<appendix id="migration">
 <title>Migrando de PHP/FI 2.0 a PHP 3.0</title>

 <sect1 id="migration-about">
  <title>Acerca de las incompatibilidades en PHP 3.0</title>
  <simpara>
   PHP 3.0 ha sido reescrito desde cero. Tiene un intérprete propio,
   que es mucho mas robusto y consistente que el de 2.0. 3.0 es también
   significativamente mas rápido, y usa menos memoria. De cualquier
   modo, algunas de estas mejoras no fueron posibles sin alterar la
   compatibilidad, tanto de sintaxis como de funcionamiento.</simpara>

  <simpara>
   Además, los desarrolladores de PHP han intentado clarificar la
   sintaxis y la semántica de PHP 3.0, y eso ha causado también algunas
   incompatibilidades. Creemos que, a la larga, estos cambios serán
   para mejor.</simpara>

  <simpara>
   Este capítulo, intentará guiarle a través de las incompatibilidades
   que encontrará si migra de PHP/FI 2.0 a PHP 3.0, además de ayudarle
   a resolverlas. No se mencionarán aquí las herramientas nuevas, hasta
   que sea necesario.</simpara>

  <simpara>
   Existe un programa que convierte automáticamente sus viejos guiones
   PHP/FI 2.0. Puede hallarlo en el subdirectorio <filename class="directory">convertor</filename> de la distribucion 3.0 de PHP
   Este programa, solo actúa en referencia a los cambios sintácticos,
   así que debería leer este capítulo detenidamente, de todos modos.</simpara></sect1>

 <sect1 id="migration-startendtags">
  <title>Tags de inicio y fin</title>

  <para>
   Probablemente lo primero que note, es que los tags de inicio y fin de
   PHP han cambiado. Las vieja forma <literal>&lt;? &gt;</literal> ha sido
   reemplazada por tres nuevas formas posibles:
   <example>
    <title>Migración: Cambio de los tags de inicio y fin</title>
    <programlisting>
&lt;? echo "Esto es codigo PHP/FI 2.0.\n"; &gt;
</programlisting></example>

   Como en la versión 2.0, PHP/FI también soporta esta variante:

   <example><title>Migración: Nuevos tags de inicio y fin, Variante 1</title>
    <programlisting>
&lt;? echo "Esto es código PHP 3.0!\n"; ?&gt;
</programlisting></example>

   Note que el tag de fin, consiste ahora en un signo de interrogación
   y un mayor-que, mientras que antes era sólo un mayor-que. Sin embargo
   si Ud. planea usar XML en su servidor, tendrá problemas con esta nueva
   variante, porque PHP tratará de ejecutar las marcas en los documentos
   XML, como código PHP. Es por esto que se han introducido las siguientes
   variantes:

   <example><title>Migración: Nuevos tags de inicio y fin, Variante 2</title>
    <programlisting>
&lt;?php echo "Esto es código PHP 3.0!\n"; ?&gt;
</programlisting></example>

   Algunas personas han tenido problemas con editores que no reconocen
   del todo los tags de instrucciones de procesamiento. Microsoft FrontPage
   es uno de esos editores, y a modo de remedio, se ha introducido también
   esta otra variante:

   <example><title>Migración: Nuevos tags de inicio y fin, Variante 3</title>
    <programlisting>
&lt;script language="php"&gt;

  echo "Esto es código PHP 3.0!\n";

&lt;/script&gt;
</programlisting></example></para></sect1>


 <sect1 id="migration-if-endif">
  <title>sintáxis de if..endif</title>

  <para>
   La manera `alternativa' de escribir la declaración if/elseif/else,
   usando if();elseif(); else; endif; no puede implementarse eficientemente
   sin agregar una gran complejidad al intérprete 3.0. Por eso la sintáxis
   ha cambiado:
   <example>
    <title>Migración: vieja sintáxis if..endif </title>
    <programlisting>
if ($foo);
    echo "sip\n";
elseif ($bar);
    echo "casi\n";
else;
    echo "nop\n";
endif;
</programlisting></example>
   <example>
    <title>Migración: nueva sitáxis if..endif (si...finsi)</title>
    <programlisting>
if ($foo):
    echo "sip\n";
elseif ($bar):
    echo "casi\n";
else:
    echo "nop\n";
endif;
</programlisting></example>

   Nótese que los punto-y-coma, han sido reemplazados por los
   los dos-puntos en todas las declaraciones, excepto en la de
   finalización (endif).</para></sect1>

 <sect1 id="migration-while">
  <title>sintáxis de while (mientras)</title>
  <para>
   Al igual que para if..endif, la sintáxis de while..endwhile
   se ha cambiado:
   <example><title>Migración: vieja sintaxis while..endwhile</title>
   <programlisting>
while ($more_to_come);
    ...
endwhile;
</programlisting></example>
   <example><title>Migración: nueva sintáxis while..endwhile</title>
   <programlisting>
while ($more_to_come):
    ...
endwhile;
</programlisting></example>
  </para>
  <warning>
   <simpara>
    Si se utiliza la sintáxis vieja de mientras...fin-mientras en
    PHP 3.0, el resultado es un bucle infinito.
   </simpara>
  </warning></sect1>

 <sect1 id="migration-expr">
  <title>Tipos de expresiones</title>
  <simpara>
   PHP/FI 2.0 usó el lado izquierdo de las expresiones para determinar
   de qué tipo debía ser el resultado. PHP 3.0 toma ambos lados en cuenta
   cuando determina el tipo de resultado, y eso puede producir resultados
   impredecibles si ejecuta guiones 2.0 en 3.0.</simpara>
  <simpara></simpara>

  <para>
   Considere este ejemplo:
   <informalexample><programlisting>
$a[0]=5;
$a[1]=7;

$key = key($a);
while ("" != $key) {
    echo "$keyn";
    next($a);
}
</programlisting></informalexample>

   En PHP/FI 2.0, esto mostraría los dos índices de $a.  En PHP
   3.0, no muestra nada.  El motivo es que en PHP 2.0, al ser el
   argumento izquierdo de tipo cadena, se comparaba cadenas, y
   puesto que ciertamente <literal>""</literal> no es igual a
   <literal>"0"</literal>, el bucle continúa.  En PHP 3.0,
   cuando se compara una cadena con un entero, se realiza una
   comparación de enteros (la cadena es convertida a entero). Esto
   es comparar entonces <literal>atoi("")</literal> que es
   <literal>0</literal>, y <literal>variablelist</literal> que tambien
   es <literal>0</literal>, y como <literal>0==0</literal>, el bucle
   no avanzará.

  </para>
  <para>
   La solución a esto es simple, reemplaze la declaración while con:
   <informalexample><programlisting>
while ((string)$key != "") {
</programlisting></informalexample></para></sect1>


 <sect1 id="migration-errors">
  <title>Cambios en los mensajes de error</title>
  <simpara>
   Los mensajes de error de PHP 3.0 son usualmente mas precisos que los
   de 2.0, pero ya no podrá ver el fragmento de código que causó el error.
   En vez de eso, se le mostrará el nombre de archivo y número de línea
   del error.
  </simpara></sect1>


 <sect1 id="migration-booleval">
  <title>Evaluación booleana por corto-circuito</title>
  <simpara>
   En PHP 3.0, la evaluación booleana es por cortocircuito. Eso significa
   que en una expresión como <literal>(1 || prueba_me())</literal>, la
   función <function>prueba_me</function> no será ejecutada ya que nada
   puede cambiar el resultado de la expresión despues del <literal>1</literal>.</simpara>
    
  <simpara>
   Si bien es éste un detalle menor de la compatibilidad, puede provocar
   inesperados efectos colaterales</simpara></sect1>


 <sect1 id="migration-truefalse">
  <title>Retorno de valores en funciones verdadero/falso</title>
  <simpara>
   La mayoria de las funciones internas han sido reescritas, asi
   que devuelven TRUE (verdadero) si hubo éxito, o FALSE (falso)
   si hubo falla, en oposición a los valores 0 y -1 de PHP/FI 2.0,
   para idénticas circunstancias. La nueva respuesta permite mas
   código lógico, como <literal>$fp = fopen("/su/fichero") or
    fail("diablos!");</literal>.  Puesto que PHP/FI 2.0 no tiene reglas
   claras acerca de lo que devuelven las funciones cuando fallan, scripts
   de este tipo deberán revisarse manualmente despues de usar el
   conversor de 2.0 a 3.0.</simpara>
  <para>
   <example>
    <title>Migración desde 2.0: Valores de retorno, codigo viejo</title>
    <programlisting>
$fp = fopen($file, "r");
if ($fp == -1);
    echo("No se pudo abrir el fichero $file para su lectura&lt;br&gt;\n");
endif;
</programlisting>
   </example>
   <example>
    <title>Migración desde 2.0: Valores de retorno, codigo nuevo</title>
    <programlisting>
$fp = @fopen($file, "r") or print("No se pudo abrir el fichero $file para su lectura&lt;br&gt;\n");
</programlisting>
   </example></para></sect1>

   
 <sect1 id="migration-other">
  <title>Otras incompatibilidades</title>

   <itemizedlist>
    <listitem><simpara>
      El modulo Apache de 3.0 no soportará versiones de Apache
      anteriores a la 1.2.  Es requisito Apache 1.2 o posterior.</simpara></listitem>

    <listitem><simpara> <function>echo</function> no soportará
    las cadenas de formato.  Use en su lugar la función
    <function>printf</function>.</simpara></listitem>

    <listitem><simpara>
      En PHP/FI 2.0, un efecto colateral en la implementación hacía que
      <literal>$foo[0]</literal> tenga el mismo efecto que
      <literal>$foo</literal>.  Esto ya no es así en PHP 3.0.</simpara></listitem>

    <listitem><simpara>
      La lectura de arreglos con <literal>$array[]</literal> ya no
      está soportada</simpara>

     <simpara>
      Esto es, no se puede recorrer un arreglo mediante un bucle que ejecute
      <literal>$data = $array[]</literal>.  Use
      <function>current</function> y <function>next</function>
      en su lugar.</simpara>
     <simpara>
      Tambien, <literal>$array1[] = $array2</literal> no agrega los
      valores de <literal>$array2</literal> a <literal>$array1</literal>,
      pero agrega <literal>$array2</literal> como la última entrada
      de <literal>$array1</literal>.  Véase tambien el soporte de
      arreglos multidimensionales.</simpara></listitem>

    <listitem>
     <simpara> <literal>"+"</literal> ya no funciona como operador
     de concatenación de cadenas, sino que convierte los argumentos,
     a números, y realiza una suma numérica. Utilize <literal>"."</literal> en su lugar.</simpara></listitem>
   </itemizedlist>

        <example>
          <title>Migración desde 2.0: concatenando cadenas</title>
          <programlisting>
echo "1" + "1";
</programlisting>

         <para> 
          En PHP 2.0 esto mostraría 11, en PHP 3.0 sería 2. Use en su
          lugar:

          <programlisting>
echo "1"."1";
</programlisting>

          <programlisting>
$a = 1;
$b = 1;
echo $a + $b;
</programlisting></para>

         <para>  
          Esto dá 2 igualmente en PHP 2.0 y 3.0.

          <programlisting>
$a = 1;
$b = 1;
echo $a.$b;
</programlisting>
          Esto dá 11 en PHP 3.0.</para>
	</example></sect1>

 </appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
