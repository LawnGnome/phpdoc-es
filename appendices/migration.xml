<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.9 $ -->
<!-- EN-Revision: 1.27 Maintainer: lboshell Status: ready -->
<appendix xml:id="migration" xmlns="http://docbook.org/ns/docbook">
 <title>Migración desde PHP/FI 2 hacia PHP 3</title>

 <section xml:id="migration.about">
  <title>Sobre las incompatibilidades en 3.0</title>
  <simpara>
   PHP 3.0 ha sido rescrito desde ceros. Posee un analizador sintáctico
   apropiado, que es mucho más robusto y consistente que el de 2.0. 3.0 es
   también significativamente mas rápido, y usa menos memoria. Sin embargo,
   algunas de estas mejoras no fueron posibles sin modificaciones de
   compatibilidad, tanto en la sintaxis como en el funcionamiento.
  </simpara>

  <simpara>
   Además, los desarrolladores de PHP han intentado limpiar tanto la
   sintaxis como la semántica de PHP en la versión 3.0, y ésto ha causado
   también algunas incompatibilidades. Creemos que, a largo plazo, estos
   cambios serán para bien.
  </simpara>

  <simpara>
   Este capítulo intentará guiarle a través de las incompatibilidades que
   puede encontrar cuando vaya desde PHP/FI 2.0 a PHP 3.0, además de
   ayudarle a resolverlas. No se mencionan aquí las nuevas características,
   a menos que sea necesario.
  </simpara>

  <simpara>
   Existe un programa que puede convertir automáticamente sus viejos scripts
   PHP/FI 2.0. Puede ser encontrado en el subdirectorio <filename
   class="directory">convertor</filename> de la distribucion 3.0 de PHP. Sin
   embargo, este programa solo detecta los cambios de sintaxis, así que
   debería leer este capítulo con cuidado, en cualquier caso.
  </simpara>
 </section>

 <section xml:id="migration.old-function">
  <title><literal>old_function</literal></title>
  <simpara>
   La sentencia <literal>old_function</literal> le permite declarar una
   función usando una sintaxis idéntica a PHP/FI2 (excepto en que debe
   reemplazar 'function' con 'old_function').
  </simpara>
  <simpara>
   Esta es una característica considerada como obsoleta, y debe ser usada
   únicamente por el programa de conversión PHP/FI2-&gt;PHP 3.
  </simpara>
  <warning>
   <para>
    Las funciones declaradas como <literal>old_function</literal> no pueden
    ser llamadas desde el código interno de PHP. Entre otras cosas, esto
    quiere decir que no puede usarlas en funciones como
    <function>usort</function>, <function>array_walk</function>, y
    <function>register_shutdown_function</function>. Puede evitar esta
    limitación escribiendo una función de envoltura (en la forma normal de
    PHP 3) para llamar a <literal>old_function</literal>.
   </para>
  </warning>
 </section>

 <section xml:id="migration.startendtags">
  <title>Etiquetas de inicio/final</title>

  <para>
   Aquello que probablemente note primero, es que las etiquetas de inicio y
   final de PHP han cambiado. Las vieja forma <literal>&lt;?  &gt;</literal>
   ha sido reemplazada por tres nuevas formas posibles:
   <example>
    <title>Migración: etiquetas viejas de inicio/fin</title>
    <programlisting role="php">
<![CDATA[
<? echo "Esto es código PHP/FI 2.0.\n"; >
]]>
    </programlisting>
   </example>
   A partir de la versión 2.0, PHP/FI también soporta esta variante:
   <example>
    <title>Migración: primer juego nuevo de etiquetas de inicio/fin</title>
    <programlisting role="php">
<![CDATA[
<? echo "¡Esto es código PHP 3.0!\n"; ?>
]]>
    </programlisting>
   </example>
   Note que la etiqueta de fin consiste ahora en un signo de interrogación y
   un caracter mayor-que, en lugar de tan sólo un mayor-que. Sin embargo, si
   planea usar XML en su servidor, tendrá problemas con la primera variante
   nueva, ya que PHP puede intentar ejecutar el marcado XML en documentos
   XML como código PHP. Es por esto que se han introducido las siguientes
   variantes:
   <example>
    <title>Migración: segundo juego de etiquetas de inicio/fin</title>
    <programlisting role="php">
<![CDATA[
<?php echo "¡Esto es código PHP 3.0!\n"; ?>
]]>
    </programlisting>
   </example>
   Algunas personas han tenido problemas con editores que no reconocen las
   etiquetas de instrucción de procesamiento después de todo. Microsoft
   FrontPage es uno de esos editores, y a modo de remedio, se ha introducido
   también esta otra variante:
   <example>
    <title>Migración: tercer juego de etiquetas de inicio/fin</title>
    <programlisting role="php">
<![CDATA[
<script language="php">

  echo "¡Esto es código PHP 3.0!\n";

</script>
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section xml:id="migration.if-endif">
  <title>Sintaxis if..endif</title>

  <para>
   El modo `alternativo' de escribir sentencias if/elseif/else, usando
   if();elseif(); else; endif; no puede implementarse de forma eficiente sin
   agregar una gran cantidad de complejidad al analizador sintáctico 3.0.
   Debido a esto, la sintaxis ha sido modificada:
   <example>
    <title>Migración: sintaxis if..endif antigua</title>
    <programlisting role="php">
<![CDATA[
if ($foo);
    echo "sip\n";
elseif ($bar);
    echo "casi\n";
else;
    echo "nop\n";
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migración: sintaxis if..endif nueva</title>
    <programlisting role="php">
<![CDATA[
if ($foo):
    echo "sip\n";
elseif ($bar):
    echo "casi\n";
else:
    echo "nop\n";
endif;
]]>
    </programlisting>
   </example>
   Note que los punto-y-coma, han sido reemplazados por los los dos-puntos
   en todas las sentencias, excepto en aquella que termina la expresión
   (endif).
  </para>
 </section>

 <section xml:id="migration.while">
  <title>Sintaxis while</title>

  <para>
   Al igual que con if..endif, la sintaxis de while..endwhile ha cambiado
   también:
   <example>
    <title>Migración: sintaxis while..endwhile antigua</title>
    <programlisting role="php">
<![CDATA[
while ($mas_en_camino);
    ...
endwhile;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migración: sintaxis while..endwhile nueva</title>
    <programlisting role="php">
<![CDATA[
while ($mas_en_camino):
    ...
endwhile;
]]>
    </programlisting>
   </example>
  </para>
  <warning>
   <simpara>
    Si usa la sintaxis antigua while..endwhile en PHP 3.0, obtendrá un ciclo
    que nunca finaliza.
   </simpara>
  </warning>
 </section>

 <section xml:id="migration.expr">
  <title>Tipos de las expresiones</title>
  <simpara>
   PHP/FI 2.0 usaba el lado izquierdo de las expresiones para determinar el
   tipo del resultado. PHP 3.0 toma ambos lados en cuenta cuando determina
   los tipos del resultado, y esto puede producir comportamientos
   impredecibles si ejecuta scripts 2.0 en 3.0.
  </simpara>
  <para>
   Considere este ejemplo:
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a[0]=5;
$a[1]=7;

$clave = key($a);
while ("" != $clave) {
    echo "$clave";
    next($a);
}
]]>
    </programlisting>
   </informalexample>

   En PHP/FI 2.0, esto mostraría los dos índices de $a.  En PHP 3.0, no
   mostraría nada. La razón es que en PHP 2.0, al ser el argumento izquierdo
   de tipo cadena, se realizaba una comparación de cadenas, y ciertamente
   <literal>""</literal> no es igual a <literal>"0"</literal>, y el ciclo
   continúa.  En PHP 3.0, cuando se compara una cadena con un entero, se
   realiza una comparación de enteros (la cadena es convertida a entero).
   Esto resulta en la comparación de <literal>atoi("")</literal> que es
   <literal>0</literal>, y <literal>lista_de_variables</literal> que también
   es <literal>0</literal>, y dado que <literal>0==0</literal>, el ciclo no
   avanzará ni una sola vez.
  </para>
  <para>
   La solución a esto es simple. Reemplace la sentencia while con:
   <informalexample>
    <programlisting role="php">
<![CDATA[
while ((string)$clave != "") {
]]>
    </programlisting>
   </informalexample>
  </para>
 </section>

 <section xml:id="migration.errors">
  <title>Los mensajes de error han cambiado</title>
  <simpara>
   Los mensajes de error de PHP 3.0 son, usualmente, más precisos que los de
   2.0, pero ya no puede ver el fragmento de código que causa el error. Sin
   embargo, se le entregará el nombre de archivo y número de línea del
   error.
  </simpara>
 </section>

 <section xml:id="migration.booleval">
  <title>Evaluación booleana de corto-circuito</title>
  <simpara>
   En PHP 3.0, la evaluación booleana es por corto-circuito. Esto significa
   que en una expresión como <literal>(1 || prueba())</literal>, la función
   <function>prueba</function> no será ejecutada ya que nada puede cambiar
   el resultado de la expresión después del <literal>1</literal>.
  </simpara>

  <simpara>
   Es éste un detalle menor de compatibilidad, pero puede provocar
   inesperados efectos colaterales.
  </simpara>
 </section>

 <section xml:id="migration.truefalse">
  <title>Valores de retorno de función &true;/&false;</title>
  <simpara>
   La mayoría de funciones internas han sido rescritas de modo que devuelvan
   &true; de tener éxito y &false; cuando fallan, en contraste a los valores
   0 y -1 de PHP/FI 2.0, respectivamente. El nuevo comportamiente permite la
   implementación de código más lógico, como <literal>$da =
   fopen("/su/archivo") or fail("¡diablos!");</literal>.  Dado que PHP/FI
   2.0 no disponía de reglas claras sobre el valor que debían devolver las
   funciones cuando fallan, la mayoría de tales scripts probablemente deban
   revisarse manualmente después de usar el programa de conversión de 2.0 a
   3.0.
  </simpara>
  <para>
   <example>
    <title>Migración desde 2.0: valores de retorno, código antiguo</title>
    <programlisting role="php">
<![CDATA[
$da = fopen($archivo, "r");
if ($da == -1);
    echo("No pudo abrirse $archivo para lectura<br />\n");
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migración desde 2.0: valores de retorno, código nuevo</title>
    <programlisting role="php">
<![CDATA[
$da = @fopen($archivo, "r") or print("No pudo abrirse $archivo para lectura<br />\n");
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section xml:id="migration.other">
  <title>Otras incompatibilidades</title>

  <itemizedlist>
   <listitem>
    <simpara>
     El módulo Apache de PHP 3.0 no soporta más versiones de Apache
     anteriores a la 1.2. Se requiere Apache 1.2 o superior.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     <function>echo</function> no soporta más una cadena de formato. Use la
     función <function>printf</function> en su lugar.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     En PHP/FI 2.0, un efecto colateral de implementación causaba que
     <literal>$foo[0]</literal> tuviera el mismo efecto que
     <literal>$foo</literal>. Esto no ocurre en PHP 3.0.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     La lectura de matrices con <literal>$matriz[]</literal> ya no es
     soportada.
    </simpara>
    <simpara>
     Esto quiere decir que no puede recorrer una matriz mediante un ciclo
     que realice <literal>$datos = $matriz[]</literal>. Use
     <function>current</function> y <function>next</function> en su lugar.
    </simpara>
    <simpara>
     Asimismo, <literal>$matriz1[] = $matriz2</literal> no adiciona los
     valores de <literal>$matriz2</literal> a <literal>$matriz1</literal>,
     sino que adiciona <literal>$matriz2</literal> como la última entrada de
     <literal>$matriz1</literal>. Consulte también el soporte de matrices
     multidimensionales.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     <literal>"+"</literal> ya no es sobrecargado como un operador de
     concatenación de cadenas, sino que convierte sus argumentos a números y
     realiza una suma numérica. Use <literal>"."</literal> en su lugar.
    </simpara>
   </listitem>
  </itemizedlist>

  <example>
   <title>Migración desde 2.0: concatenación para cadenas</title>
   <programlisting role="php">
<![CDATA[
echo "1" + "1";
]]>
   </programlisting>
   <para>
    En PHP 2.0 esto mostraría 11, en PHP 3.0 imprimiría 2. En su lugar use:
    <programlisting role="php">
<![CDATA[
echo "1"."1";
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a + $b;
]]>
    </programlisting>
   </para>
   <para>
    Esto imprimiría 2 tanto en PHP 2.0 como en 3.0.
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a.$b;
]]>
    </programlisting>
    Esto imprimirá 11 en PHP 3.0.
   </para>
  </example>
 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
