<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.6 $ -->
<!-- EN-Revision: 1.24 Maintainer: lboshell Status: ready -->
<appendix id="migration">
 <title>Migraci&oacute;n desde PHP/FI 2 hacia PHP 3</title>

 <section id="migration.about">
  <title>Sobre las incompatibilidades en 3.0</title>
  <simpara>
   PHP 3.0 ha sido rescrito desde ceros. Posee un analizador
   sint&aacute;ctico apropiado, que es mucho m&aacute;s robusto y
   consistente que el de 2.0. 3.0 es tambi&eacute;n significativamente
   mas r&aacute;pido, y usa menos memoria. Sin embargo, algunas de
   estas mejoras no fueron posibles sin modificaciones de
   compatibilidad, tanto en la sintaxis como en el funcionamiento.
  </simpara>

  <simpara>
   Adem&aacute;s, los desarrolladores de PHP han intentado limpiar
   tanto la sintaxis como la sem&aacute;ntica de PHP en la
   versi&oacute;n 3.0, y &eacute;sto ha causado tambi&eacute;n algunas
   incompatibilidades. Creemos que, a largo plazo, estos cambios
   ser&aacute;n para bien.
  </simpara>

  <simpara>
   Este cap&iacute;tulo intentar&aacute; guiarle a trav&eacute;s de
   las incompatibilidades que puede encontrar cuando vaya desde PHP/FI
   2.0 a PHP 3.0, adem&aacute;s de ayudarle a resolverlas. No se
   mencionan aqu&iacute; las nuevas caracter&iacute;sticas, a menos
   que sea necesario.
  </simpara>

  <simpara>
   Existe un programa que puede convertir autom&aacute;ticamente sus
   viejos scripts PHP/FI 2.0. Puede ser encontrado en el
   subdirectorio <filename class="directory">convertor</filename> de
   la distribucion 3.0 de PHP. Sin embargo, &eacute;ste programa solo
   detecta los cambios de sintaxis, as&iacute; que deber&iacute;a leer
   este cap&iacute;tulo con cuidado, en cualquier caso.
  </simpara>
 </section>

 <section id="migration.old-function">
  <title><literal>old_function</literal></title>
  <simpara>
La sentencia <literal>old_function</literal> le permite declarar una
funci&oacute;n usando una sintaxis id&eacute;ntica a PHP/FI2 (excepto
en que debe reemplazar 'function' con 'old_function').
  </simpara>
  <simpara>
Esta es una caracter&iacute;stica considerada como obsoleta, y debe
ser usada &uacute;nicamente por el programa de conversi&oacute;n
PHP/FI2-&gt;PHP 3.
  </simpara>
  <warning>
   <para>
Las funciones declaradas como <literal>old_function</literal> no
pueden ser llamadas desde el c&oacute;digo interno de PHP. Entre otras
cosas, esto quiere decir que no puede usarlas en funciones como
<function>usort</function>, <function>array_walk</function>,
y <function>register_shutdown_function</function>. Puede evitar esta
limitaci&oacute;n escribiendo una funci&oacute;n de envoltura (en la
forma normal de PHP 3) para llamar a <literal>old_function</literal>.
   </para>
  </warning>
 </section>
 
 <section id="migration.startendtags">
  <title>Etiquetas de inicio/final</title>

  <para>
   Aquello que probablemente note primero, es que las etiquetas de
   inicio y final de PHP han cambiado. Las vieja forma <literal>&lt;?
   &gt;</literal> ha sido reemplazada por tres nuevas formas posibles:
   <example>
    <title>Migraci&oacute;n: etiquetas viejas de inicio/fin</title>
    <programlisting role="php">
<![CDATA[
<? echo "Esto es c&oacute;digo PHP/FI 2.0.\n"; >
]]>
    </programlisting>
   </example>
A partir de la versi&oacute;n 2.0, PHP/FI tambi&eacute;n soporta esta
variante:
   <example>
    <title>Migraci&oacute;n: primer juego nuevo de etiquetas de
    inicio/fin</title>
    <programlisting role="php">
<![CDATA[
<? echo "&iexcl;Esto es c&oacute;digo PHP 3.0!\n"; ?>
]]>
    </programlisting>
   </example>
   Note que la etiqueta de fin consiste ahora en un signo de
   interrogaci&oacute;n y un caracter mayor-que, en lugar de tan
   s&oacute;lo un mayor-que. Sin embargo, si planea usar XML en su
   servidor, tendr&aacute; problemas con la primera variante nueva, ya
   que PHP puede intentar ejecutar el marcado XML en documentos XML
   como c&oacute;digo PHP. Es por esto que se han introducido las
   siguientes variantes:
   <example>
    <title>Migraci&oacute;n: segundo juego de etiquetas de
    inicio/fin</title>
    <programlisting role="php">
<![CDATA[
<?php echo "&iexcl;Esto es c&oacute;digo PHP 3.0!\n"; ?>
]]>
    </programlisting>
   </example>
   Algunas personas han tenido problemas con editores que no reconocen
   las etiquetas de instrucci&oacute;n de procesamiento despu&eacute;s
   de todo. Microsoft FrontPage es uno de esos editores, y a modo de
   remedio, se ha introducido tambi&eacute;n esta otra variante:
   <example>
    <title>Migraci&oacute;n: tercer juego de etiquetas de inicio/fin</title>
    <programlisting role="php">
<![CDATA[
<script language="php">

  echo "&iexcl;Esto es c&oacute;digo PHP 3.0!\n";

</script>
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section id="migration.if-endif">
  <title>Sintaxis if..endif</title>

  <para>
   El modo `alternativo' de escribir sentencias if/elseif/else, usando
   if();elseif(); else; endif; no puede implementarse de forma
   eficiente sin agregar una gran cantidad de complejidad al
   analizador sint&aacute;ctico 3.0. Debido a esto, la sintaxis
   ha sido modificada:
   <example>
    <title>Migraci&oacute;n: sintaxis if..endif antigua</title>
    <programlisting role="php">
<![CDATA[
if ($foo);
    echo "sip\n";
elseif ($bar);
    echo "casi\n";
else;
    echo "nop\n";
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migraci&oacute;n: sintaxis if..endif nueva</title>
    <programlisting role="php">
<![CDATA[
if ($foo):
    echo "sip\n";
elseif ($bar):
    echo "casi\n";
else:
    echo "nop\n";
endif;
]]>
    </programlisting>
   </example>
   Note que los punto-y-coma, han sido reemplazados por los los
   dos-puntos en todas las sentencias, excepto en aquella que termina
   la expresi&oacute;n (endif).
  </para>
 </section>

 <section id="migration.while">
  <title>Sintaxis while</title>

  <para>
   Al igual que con if..endif, la sintaxis de while..endwhile ha
   cambiado tambi&eacute;n:
   <example>
    <title>Migraci&oacute;n: sintaxis while..endwhile antigua</title>
    <programlisting role="php">
<![CDATA[
while ($mas_en_camino);
    ...
endwhile;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migraci&oacute;n: sintaxis while..endwhile nueva</title>
    <programlisting role="php">
<![CDATA[
while ($mas_en_camino):
    ...
endwhile;
]]>
    </programlisting>
   </example>
  </para>
  <warning>
   <simpara>
    Si usa la sintaxis antigua while..endwhile en PHP 3.0,
    obtendr&aacute; un ciclo que nunca finaliza.
   </simpara>
  </warning>
 </section>

 <section id="migration.expr">
  <title>Tipos de las expresiones</title>
  <simpara>
   PHP/FI 2.0 usaba el lado izquierdo de las expresiones para
   determinar el tipo del resultado. PHP 3.0 toma ambos lados en
   cuenta cuando determina los tipos del resultado, y esto puede
   producir comportamientos impredecibles si ejecuta scripts 2.0 en
   3.0.
  </simpara>
  <para>
   Considere este ejemplo:
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a[0]=5;
$a[1]=7;

$clave = key($a);
while ("" != $clave) {
    echo "$clave";
    next($a);
}
]]>
    </programlisting>
   </informalexample>

   En PHP/FI 2.0, esto mostrar&iacute;a los dos &iacute;ndices de $a.
   En PHP 3.0, no mostrar&iacute;a nada. La raz&oacute;n es que en PHP
   2.0, al ser el argumento izquierdo de tipo cadena, se realizaba una
   comparaci&oacute;n de cadenas, y ciertamente <literal>""</literal>
   no es igual a
   <literal>"0"</literal>, y el ciclo contin&uacute;a.  En PHP 3.0,
   cuando se compara una cadena con un entero, se realiza una
   comparaci&oacute;n de enteros (la cadena es convertida a
   entero). Esto resulta en la comparaci&oacute;n
   de <literal>atoi("")</literal> que es
   <literal>0</literal>, y <literal>lista_de_variables</literal> que
   tambi&eacute;n es <literal>0</literal>, y dado
   que <literal>0==0</literal>, el ciclo no avanzar&aacute; ni una
   sola vez.
  </para>
  <para>
   La soluci&oacute;n a esto es simple. Reemplace la sentencia while
   con:
   <informalexample>
    <programlisting role="php">
<![CDATA[
while ((string)$clave != "") {
]]>
    </programlisting>
   </informalexample>
  </para>
 </section>

 <section id="migration.errors">
  <title>Los mensajes de error han cambiado</title>
  <simpara>
   Los mensajes de error de PHP 3.0 son, usualmente, m&aacute;s
   precisos que los de 2.0, pero ya no puede ver el fragmento de
   c&oacute;digo que causa el error. Sin embargo, se le
   entregar&aacute; el nombre de archivo y n&uacute;mero de
   l&iacute;nea del error.
  </simpara>
 </section>

 <section id="migration.booleval">
  <title>Evaluaci&oacute;n booleana de corto-circuito</title>
  <simpara>
   En PHP 3.0, la evaluaci&oacute;n booleana es por
   corto-circuito. Esto significa que en una expresi&oacute;n
   como <literal>(1 || prueba())</literal>, la
   funci&oacute;n <function>prueba</function> no ser&aacute; ejecutada
   ya que nada puede cambiar el resultado de la expresi&oacute;n
   despu&eacute;s del <literal>1</literal>.
  </simpara>

  <simpara>
   Es &eacute;ste un detalle menor de compatibilidad, pero puede
   provocar inesperados efectos colaterales.
  </simpara>
 </section>

 <section id="migration.truefalse">
  <title>Valores de retorno de funci&oacute;n &true;/&false;</title>
  <simpara>
   La mayor&iacute;a de funciones internas han sido rescritas de modo
   que devuelvan &true; de tener &eacute;xito y &false; cuando fallan,
   en contraste a los valores 0 y -1 de PHP/FI 2.0,
   respectivamente. El nuevo comportamiente permite la
   implementaci&oacute;n de c&oacute;digo m&aacute;s l&oacute;gico,
   como <literal>$da = fopen("/su/archivo") or
   fail("&iexcl;diablos!");</literal>.  Dado que PHP/FI 2.0 no
   dispon&iacute;a de reglas claras sobre el valor que deb&iacute;an
   devolver las funciones cuando fallan, la mayor&iacute;a de tales
   scripts probablemente deban revisarse manualmente despu&eacute;s de
   usar el programa de conversi&oacute;n de 2.0 a 3.0.
  </simpara>
  <para>
   <example>
    <title>Migraci&oacute;n desde 2.0: valores de retorno,
    c&oacute;digo antiguo</title>
    <programlisting role="php">
<![CDATA[
$da = fopen($archivo, "r");
if ($da == -1);
    echo("No pudo abrirse $archivo para lectura<br>\n");
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migraci&oacute;n desde 2.0: valores de retorno,
    c&oacute;digo nuevo</title>
    <programlisting role="php">
<![CDATA[
$da = @fopen($archivo, "r") or print("No pudo abrirse $archivo para lectura<br>\n");
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section id="migration.other">
  <title>Otras incompatibilidades</title>

  <itemizedlist>
   <listitem>
    <simpara>
     El m&oacute;dulo Apache de PHP 3.0 no soporta m&aacute;s
     versiones de Apache anteriores a la 1.2. Se requiere Apache 1.2 o
     superior.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     <function>echo</function> no soporta m&aacute;s una cadena de
     formato. Use la funci&oacute;n <function>printf</function> en su
     lugar.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     En PHP/FI 2.0, un efecto colateral de implementaci&oacute;n
     causaba que
     <literal>$foo[0]</literal> tuviera el mismo efecto
     que <literal>$foo</literal>. Esto no ocurre en PHP 3.0.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     La lectura de matrices con <literal>$matriz[]</literal> ya no es
     soportada.
    </simpara>
    <simpara>
     Esto quiere decir que no puede recorrer una matriz mediante un
     ciclo que realice <literal>$datos = $matriz[]</literal>. Use
     <function>current</function> y <function>next</function>
     en su lugar.
    </simpara>
    <simpara>
     As&iacute; mismo, <literal>$matriz1[] = $matriz2</literal> no
     adiciona los valores de <literal>$matriz2</literal>
     a <literal>$matriz1</literal>, sino que
     adiciona <literal>$matriz2</literal> como la &uacute;ltima
     entrada de <literal>$matriz1</literal>. Consulte tambi&eacute;n
     el soporte de matrices multidimensionales.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     <literal>"+"</literal> ya no es sobrecargado como un operador de
     concatenaci&oacute;n de cadenas, sino que convierte sus
     argumentos a n&uacute;meros y realiza una suma
     num&eacute;rica. Use <literal>"."</literal> en su lugar.
    </simpara>
   </listitem>
  </itemizedlist>

  <example>
   <title>Migraci&oacute;n desde 2.0: concatenaci&oacute;n para
   cadenas</title>
   <programlisting role="php">
<![CDATA[
echo "1" + "1";
]]>
   </programlisting>
   <para> 
    En PHP 2.0 esto mostrar&iacute;a 11, en PHP 3.0 imprimir&iacute;a
    2. En su lugar use:
    <programlisting role="php">
<![CDATA[
echo "1"."1";
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a + $b;
]]>
    </programlisting>
   </para>
   <para>
    Esto imprimir&iacute;a 2 tanto en PHP 2.0 como en 3.0.
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a.$b;
]]>
    </programlisting>
    Esto imprimir&aacute; 11 en PHP 3.0.
   </para>
  </example>
 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
