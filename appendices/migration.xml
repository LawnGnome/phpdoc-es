<appendix id="migration">
 <title>Migrando de PHP/FI 2.0 a PHP 3.0</title>

 <sect1 id="migration-about">
  <title>Acerca de las incompatibilidades en PHP 3.0</title>
  <simpara>
   PHP 3.0 ha sido reescrito desde cero. Tiene un int&eacute;rprete propio,
   que es mucho mas robusto y consistente que el de 2.0. 3.0 es tambi&eacute;n
   significativamente mas r&aacute;pido, y usa menos memoria. De cualquier
   modo, algunas de estas mejoras no fueron posibles sin alterar la
   compatibilidad, tanto de sintaxis como de funcionamiento.</simpara>

  <simpara>
   Adem&aacute;s, los desarrolladores de PHP han intentado clarificar la
   sintaxis y la sem&aacute;ntica de PHP 3.0, y eso ha causado tambi&eacute;n algunas
   incompatibilidades. Creemos que, a la larga, estos cambios ser&aacute;n
   para mejor.</simpara>

  <simpara>
   Este cap&iacute;tulo, intentar&aacute; guiarle a trav&eacute;s de las incompatibilidades
   que encontrar&aacute; si migra de PHP/FI 2.0 a PHP 3.0, adem&aacute;s de ayudarle
   a resolverlas. No se mencionar&aacute;n aqu&iacute; las herramientas nuevas, hasta
   que sea necesario.</simpara>

  <simpara>
   Existe un programa que convierte autom&aacute;ticamente sus viejos guiones
   PHP/FI 2.0. Puede hallarlo en el subdirectorio <filename class="directory">convertor</filename> de la distribucion 3.0 de PHP
   Este programa, solo act&uacute;a en referencia a los cambios sint&aacute;cticos,
   as&iacute; que deber&iacute;a leer este cap&iacute;tulo detenidamente, de todos modos.</simpara></sect1>

 <sect1 id="migration-startendtags">
  <title>Tags de inicio y fin</title>

  <para>
   Probablemente lo primero que note, es que los tags de inicio y fin de
   PHP han cambiado. Las vieja forma <literal>&lt;? &gt;</literal> ha sido
   reemplazada por tres nuevas formas posibles:
   <example>
    <title>Migraci&oacute;n: Cambio de los tags de inicio y fin</title>
    <programlisting>
&lt;? echo "Esto es codigo PHP/FI 2.0.\n"; &gt;
</programlisting></example>

   Como en la versi&oacute;n 2.0, PHP/FI tambi&eacute;n soporta esta variante:

   <example><title>Migraci&oacute;n: Nuevos tags de inicio y fin, Variante 1</title>
    <programlisting>
&lt;? echo "Esto es c&oacute;digo PHP 3.0!\n"; ?&gt;
</programlisting></example>

   Note que el tag de fin, consiste ahora en un signo de interrogaci&oacute;n
   y un mayor-que, mientras que antes era s&oacute;lo un mayor-que. Sin embargo
   si Ud. planea usar XML en su servidor, tendr&aacute; problemas con esta nueva
   variante, porque PHP tratar&aacute; de ejecutar las marcas en los documentos
   XML, como c&oacute;digo PHP. Es por esto que se han introducido las siguientes
   variantes:

   <example><title>Migraci&oacute;n: Nuevos tags de inicio y fin, Variante 2</title>
    <programlisting>
&lt;?php echo "Esto es c&oacute;digo PHP 3.0!\n"; ?&gt;
</programlisting></example>

   Algunas personas han tenido problemas con editores que no reconocen
   del todo los tags de instrucciones de procesamiento. Microsoft FrontPage
   es uno de esos editores, y a modo de remedio, se ha introducido tambi&eacute;n
   esta otra variante:

   <example><title>Migraci&oacute;n: Nuevos tags de inicio y fin, Variante 3</title>
    <programlisting>
&lt;script language="php"&gt;

  echo "Esto es c&oacute;digo PHP 3.0!\n";

&lt;/script&gt;
</programlisting></example></para></sect1>


 <sect1 id="migration-if-endif">
  <title>sint&aacute;xis de if..endif</title>

  <para>
   La manera `alternativa' de escribir la declaraci&oacute;n if/elseif/else,
   usando if();elseif(); else; endif; no puede implementarse eficientemente
   sin agregar una gran complejidad al int&eacute;rprete 3.0. Por eso la sint&aacute;xis
   ha cambiado:
   <example>
    <title>Migraci&oacute;n: vieja sint&aacute;xis if..endif </title>
    <programlisting>
if ($foo);
    echo "sip\n";
elseif ($bar);
    echo "casi\n";
else;
    echo "nop\n";
endif;
</programlisting></example>
   <example>
    <title>Migraci&oacute;n: nueva sit&aacute;xis if..endif (si...finsi)</title>
    <programlisting>
if ($foo):
    echo "sip\n";
elseif ($bar):
    echo "casi\n";
else:
    echo "nop\n";
endif;
</programlisting></example>

   N&oacute;tese que los punto-y-coma, han sido reemplazados por los
   los dos-puntos en todas las declaraciones, excepto en la de
   finalizaci&oacute;n (endif).</para></sect1>

 <sect1 id="migration-while">
  <title>sint&aacute;xis de while (mientras)</title>
  <para>
   Al igual que para if..endif, la sint&aacute;xis de while..endwhile
   se ha cambiado:
   <example><title>Migraci&oacute;n: vieja sintaxis while..endwhile</title>
   <programlisting>
while ($more_to_come);
    ...
endwhile;
</programlisting></example>
   <example><title>Migraci&oacute;n: nueva sint&aacute;xis while..endwhile</title>
   <programlisting>
while ($more_to_come):
    ...
endwhile;
</programlisting></example>
  </para>
  <warning>
   <simpara>
    Si se utiliza la sint&aacute;xis vieja de mientras...fin-mientras en
    PHP 3.0, el resultado es un bucle infinito.
   </simpara>
  </warning></sect1>

 <sect1 id="migration-expr">
  <title>Tipos de expresiones</title>
  <simpara>
   PHP/FI 2.0 us&oacute; el lado izquierdo de las expresiones para determinar
   de qu&eacute; tipo deb&iacute;a ser el resultado. PHP 3.0 toma ambos lados en cuenta
   cuando determina el tipo de resultado, y eso puede producir resultados
   impredecibles si ejecuta guiones 2.0 en 3.0.</simpara>
  <simpara></simpara>

  <para>
   Considere este ejemplo:
   <informalexample><programlisting>
$a[0]=5;
$a[1]=7;

$key = key($a);
while ("" != $key) {
    echo "$keyn";
    next($a);
}
</programlisting></informalexample>

   En PHP/FI 2.0, esto mostrar&iacute;a los dos &iacute;ndices de $a.  En PHP
   3.0, no muestra nada.  El motivo es que en PHP 2.0, al ser el
   argumento izquierdo de tipo cadena, se comparaba cadenas, y
   puesto que ciertamente <literal>""</literal> no es igual a
   <literal>"0"</literal>, el bucle contin&uacute;a.  En PHP 3.0,
   cuando se compara una cadena con un entero, se realiza una
   comparaci&oacute;n de enteros (la cadena es convertida a entero). Esto
   es comparar entonces <literal>atoi("")</literal> que es
   <literal>0</literal>, y <literal>variablelist</literal> que tambien
   es <literal>0</literal>, y como <literal>0==0</literal>, el bucle
   no avanzar&aacute;.

  </para>
  <para>
   La soluci&oacute;n a esto es simple, reemplaze la declaraci&oacute;n while con:
   <informalexample><programlisting>
while ((string)$key != "") {
</programlisting></informalexample></para></sect1>


 <sect1 id="migration-errors">
  <title>Cambios en los mensajes de error</title>
  <simpara>
   Los mensajes de error de PHP 3.0 son usualmente mas precisos que los
   de 2.0, pero ya no podr&aacute; ver el fragmento de c&oacute;digo que caus&oacute; el error.
   En vez de eso, se le mostrar&aacute; el nombre de archivo y n&uacute;mero de l&iacute;nea
   del error.
  </simpara></sect1>


 <sect1 id="migration-booleval">
  <title>Evaluaci&oacute;n booleana por corto-circuito</title>
  <simpara>
   En PHP 3.0, la evaluaci&oacute;n booleana es por cortocircuito. Eso significa
   que en una expresi&oacute;n como <literal>(1 || prueba_me())</literal>, la
   funci&oacute;n <function>prueba_me</function> no ser&aacute; ejecutada ya que nada
   puede cambiar el resultado de la expresi&oacute;n despues del <literal>1</literal>.</simpara>
    
  <simpara>
   Si bien es &eacute;ste un detalle menor de la compatibilidad, puede provocar
   inesperados efectos colaterales</simpara></sect1>


 <sect1 id="migration-truefalse">
  <title>Retorno de valores en funciones verdadero/falso</title>
  <simpara>
   La mayoria de las funciones internas han sido reescritas, asi
   que devuelven TRUE (verdadero) si hubo &eacute;xito, o FALSE (falso)
   si hubo falla, en oposici&oacute;n a los valores 0 y -1 de PHP/FI 2.0,
   para id&eacute;nticas circunstancias. La nueva respuesta permite mas
   c&oacute;digo l&oacute;gico, como <literal>$fp = fopen("/su/fichero") or
    fail("diablos!");</literal>.  Puesto que PHP/FI 2.0 no tiene reglas
   claras acerca de lo que devuelven las funciones cuando fallan, scripts
   de este tipo deber&aacute;n revisarse manualmente despues de usar el
   conversor de 2.0 a 3.0.</simpara>
  <para>
   <example>
    <title>Migraci&oacute;n desde 2.0: Valores de retorno, codigo viejo</title>
    <programlisting>
$fp = fopen($file, "r");
if ($fp == -1);
    echo("No se pudo abrir el fichero $file para su lectura&lt;br&gt;\n");
endif;
</programlisting>
   </example>
   <example>
    <title>Migraci&oacute;n desde 2.0: Valores de retorno, codigo nuevo</title>
    <programlisting>
$fp = @fopen($file, "r") or print("No se pudo abrir el fichero $file para su lectura&lt;br&gt;\n");
</programlisting>
   </example></para></sect1>

   
 <sect1 id="migration-other">
  <title>Otras incompatibilidades</title>

   <itemizedlist>
    <listitem><simpara>
      El modulo Apache de 3.0 no soportar&aacute; versiones de Apache
      anteriores a la 1.2.  Es requisito Apache 1.2 o posterior.</simpara></listitem>

    <listitem><simpara> <function>echo</function> no soportar&aacute;
    las cadenas de formato.  Use en su lugar la funci&oacute;n
    <function>printf</function>.</simpara></listitem>

    <listitem><simpara>
      En PHP/FI 2.0, un efecto colateral en la implementaci&oacute;n hac&iacute;a que
      <literal>$foo[0]</literal> tenga el mismo efecto que
      <literal>$foo</literal>.  Esto ya no es as&iacute; en PHP 3.0.</simpara></listitem>

    <listitem><simpara>
      La lectura de arreglos con <literal>$array[]</literal> ya no
      est&aacute; soportada</simpara>

     <simpara>
      Esto es, no se puede recorrer un arreglo mediante un bucle que ejecute
      <literal>$data = $array[]</literal>.  Use
      <function>current</function> y <function>next</function>
      en su lugar.</simpara>
     <simpara>
      Tambien, <literal>$array1[] = $array2</literal> no agrega los
      valores de <literal>$array2</literal> a <literal>$array1</literal>,
      pero agrega <literal>$array2</literal> como la &uacute;ltima entrada
      de <literal>$array1</literal>.  V&eacute;ase tambien el soporte de
      arreglos multidimensionales.</simpara></listitem>

    <listitem>
     <simpara> <literal>"+"</literal> ya no funciona como operador
     de concatenaci&oacute;n de cadenas, sino que convierte los argumentos,
     a n&uacute;meros, y realiza una suma num&eacute;rica. Utilize <literal>"."</literal> en su lugar.</simpara></listitem>
   </itemizedlist>

        <example>
          <title>Migraci&oacute;n desde 2.0: concatenando cadenas</title>
          <programlisting>
echo "1" + "1";
</programlisting>

         <para> 
          En PHP 2.0 esto mostrar&iacute;a 11, en PHP 3.0 ser&iacute;a 2. Use en su
          lugar:

          <programlisting>
echo "1"."1";
</programlisting>

          <programlisting>
$a = 1;
$b = 1;
echo $a + $b;
</programlisting></para>

         <para>  
          Esto d&aacute; 2 igualmente en PHP 2.0 y 3.0.

          <programlisting>
$a = 1;
$b = 1;
echo $a.$b;
</programlisting>
          Esto d&aacute; 11 en PHP 3.0.</para>
	</example></sect1>

 </appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
