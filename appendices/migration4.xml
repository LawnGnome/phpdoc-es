<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.9 $ -->
<!-- EN-Revision: 1.41 Maintainer: lboshell Status: ready -->
 <appendix xml:id="migration4" xmlns="http://docbook.org/ns/docbook">
  <title>Migración de PHP 3 a PHP 4</title>

  <section xml:id='migration4.changes'>
   <title>Qué ha cambiado en PHP 4</title>
   <para>
    PHP 4 y el motor Zend integrado han mejorado considerablemente las
    capacidades y el rendimiento de PHP, pero se ha tenido mucho cuidado
    para evitar cualquier impacto negativo sobre el código existente. De
    modo que migrar su código desde PHP 3 a PHP 4 debe ser mucho más
    sencillo que migrar de PHP/FI 2 a PHP 3. Bastante código de PHP 3
    existente debe estar listo para correr sin modificaciones, pero aun así
    es importante que sepa sobre las pocas diferencias, y tome las
    precauciones necesarias para probar su código antes de cambiar las
    versiones en entornos de producción. Las siguientes líneas deben
    propocionarle algunas pistas sobre qué tipo de cosas considerar.
   </para>
  </section>

  <section xml:id="migration4.php4.with.php3">
   <title>Ejecutar PHP 3 y PHP 4 simultáneamente</title>
   <simpara>
    Sistemas operativos recientes ofrecen la posibilidad de realizar
    versionamiento y contextualización. Estas características hacen posible
    que PHP 3 y PHP 4 corran como módulos concurrentes en un servidor
    Apache.
   </simpara>
   <simpara>
    Se conoce que esta característica funciona sobre las siguientes
    plataformas:
   </simpara>
   <itemizedlist>
     <listitem><simpara>Linux con versión reciente de binutils (se ha
     probado con binutils 2.9.1.0.25) </simpara></listitem>
     <listitem><simpara>Solaris 2.5 o superior</simpara></listitem>
     <listitem><simpara>FreeBSD (se ha probado con 3.2, 4.0)</simpara></listitem>
   </itemizedlist>
   <para>
    Para habilitarlo, configure PHP 3 y PHP 4 para que usen APXS (<option
    role="configure">--with-apxs</option>) y las extensiones de enlace
    necesarias (<option role="configure">--enable-versioning</option>). Por
    lo demás, todas las instrucciones de instalación estándar se aplican.
    Por ejemplo:
    <informalexample>
     <programlisting role="shell">
<![CDATA[
$ ./configure \
  --with-apxs=/apache/bin/apxs \
  --enable-versioning \
  --with-mysql \
  --enable-track-vars
]]>
     </programlisting>
    </informalexample>
   </para>
  </section>

  <section xml:id="migration4.configuration">
   <title>Migración de Archivos de Configuración</title>
   <para>
    El archivo de configuración global, <filename>php3.ini</filename>, ha
    cambiado su nombre a &php.ini;.
   </para>
   <para>
    Para el archivo de configuración de Apache, existen unos cuantos cambios
    más. Los tipos MIME reconocidos por el módulo PHP han cambiado.
    <informalexample>
     <programlisting role="apache-conf">
<![CDATA[
application/x-httpd-php3        -->    application/x-httpd-php
application/x-httpd-php3-source -->    application/x-httpd-php-source
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Puede hacer que sus archivos de configuración trabajen con ambas
    versiones de PHP (dependiendo de cuál es la que está compilada
    actualmente con el servidor), usando la siguiente sintaxis:
    <informalexample>
     <programlisting role="apache-conf">
<![CDATA[
AddType  application/x-httpd-php3        .php3
AddType  application/x-httpd-php3-source .php3s

AddType  application/x-httpd-php         .php
AddType  application/x-httpd-php-source  .phps
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Adicionalmente, los nombres de directivas PHP para Apache han cambiado.
   </simpara>
   <para>
    A partir de PHP 4.0, existen solo cuatro directivas Apache que se
    relacionan con PHP:
    <informalexample>
     <programlisting role="apache-conf">
<![CDATA[
php_value [nombre de directiva PHP] [valor]
php_flag [nombre de directiva PHP] [On|Off]
php_admin_value [nombre de directiva PHP] [valor]
php_admin_flag [nombre de directiva PHP] [On|Off]
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Existen dos diferencias entre los valores Admin y los no-admin:
   </simpara>
   <itemizedlist>
    <listitem>
     <simpara>
      Los valores (o banderas) admin pueden aparecer solo en los archivos de
      configuración globales de Apache (p.ej., &httpd.conf;).
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Los valores (o banderas) estándar no pueden controlar ciertas
      directivas PHP, por ejemplo: &safemode; (si pudiera sobrescribir los
      parámetros del modo seguro en los archivos &htaccess;, se estropearía
      la gracia de &safemode;). En contraste, los valores Admin pueden
      modificar el valor de cualquier directiva PHP.
     </simpara>
    </listitem>
   </itemizedlist>
   <simpara>
    Para hacer el proceso de transición más sencillo, PHP 4 es distribuido
    con scripts que convierten automáticamente su configuración en archivos
    Apache y &htaccess; para que trabajen con PHP 3 y PHP 4. ¡Estos scripts
    NO convierten las líneas de tipos mime!  Tendrá que convertir éstas
    manualmente.
   </simpara>
   <para>
    Para convertir sus archivos de configuración de Apache, ejecute el
    script <filename>apconf-conv.sh</filename> (disponible en el directorio
    <filename>scripts/apache/</filename>). Por ejemplo:
    <informalexample>
     <programlisting role="shell">
<![CDATA[
~/php4/scripts/apache:#  ./apconf-conv.sh /usr/local/apache/conf/httpd.conf
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Su archivo de configuración original será guardado en httpd.conf.orig.
   </simpara>
   <para>
    Para convertir sus archivos &htaccess;, ejecute el script
    <filename>aphtaccess-conv.sh</filename> (disponible así mismo en el
    directorio <filename>scripts/apache/</filename>):
    <informalexample>
     <programlisting role="shell">
<![CDATA[
~/php4/scripts/apache:#  find / -name .htaccess -exec ./aphtaccess-conv.sh {} \;
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    De modo semejante, sus archivos &htaccess; antiguos serán guardados con
    el sufijo .orig.
   </simpara>
   <simpara>
    Los scripts de conversión requieren que 'awk' esté instalado.
   </simpara>
  </section>

  <section xml:id='migration4.parser'>
   <title>Comportamiento del analizador sintáctico</title>
   <para>
    El proceso de análisis sintáctico y la ejecución son ahora dos pasos
    completamente separados, no se procederá a la ejecución del código de
    cualquier archivo hasta que éste en su totalidad, así como todo el
    código requerido se haya analizado completa y satisfactoriamente.
   </para>
   <para>
    Uno de los nuevos requisitos introducidos con esta separación es que
    todos los archivos requeridos y de inclusión tienen que ser
    sintácticamente completos ahora. Ya no es permitida la separación de
    diferentes segmentos de una estructura de control a través de varios
    archivos. Esto quiere decir que ahora no puede iniciar un ciclo
    <literal>for</literal> o <literal>while</literal>, una sentencia
    <literal>if</literal> o un bloque <literal>switch</literal> en un
    archivo, y tener el final del ciclo, sentencias <literal>else</literal>,
    <literal>endif</literal>, <literal>case</literal> o
    <literal>break</literal> en un archivo diferente.
   </para>
   <para>
    Aun es perfectamente legal incluir código adicional al interior de
    ciclos u otras estructuras de control, únicamente las palabras claves de
    control y los corchetes correspondientes <literal>{...}</literal> tienen
    que estar en la misma unidad de compilación (archivo o cadena procesada
    por <function>eval</function>).
   </para>
   <para>
    Esto no debe generar una repercusión significativa ya que separar el
    código de esta manera debe ser considerado como muy mal estilo, en
    cualquier caso.
   </para>
   <para>
    Algo más que ya no es posible, aunque es rara veces visto en código PHP
    3, es devolver valores desde un archivo requerido. Devolver un valor
    desde un archivo de inclusión es posible aun.
   </para>
  </section>

  <section xml:id='migration4.error-reporting'>
   <title>Reporte de errores</title>

   <section xml:id='migration4.error-reporting.config'>
    <title>Cambios de configuración</title>
    <para>
     Con PHP 3 el nivel de reporte de errores estaba establecido como un
     valor numérico simple formado por la suma de los números relacionados
     con diferentes niveles de error. Algunos valores usuales eran 15 para
     reportar todos los errores y advertencias, o 7 para reportar todo
     excepto mensajes de noticias simples que indicaban mal estilo del
     código y cosas por el estilo.
    </para>
    <para>
     PHP 4 tiene un conjunto de niveles de error y advertencia mayor y viene
     con un analizador sintáctico de configuración que permite el uso de
     constantes simbólicas para determinar el comportamiento deseado.
    </para>
    <para>
     El nivel de reporte de errores debe ser ahora configurado mediante la
     deshabilitación explícita de niveles de advertencia que no desea que
     generen mensajes de error, con una sentencia lógica OR sobre la
     constante simbólica <literal>E_ALL</literal>. ¿Suena complicado?  Bien,
     digamos que usted desea que el sistema de reporte de errores le haga
     saber sobre cualquier problema excepto por las advertencias de estilo
     simples que están categorizadas por la constante simbólica
     <literal>E_NOTICE</literal>. En ese caso, colocará lo siguiente en su
     &php.ini;: <literal>error_reporting = E_ALL &amp; ~ (
     E_NOTICE)</literal>. Si desea suprimir las advertencias también, usted
     agrega la constante apropiada al interior de los paréntesis usando el
     operador binario OR '|': <literal>error_reporting= E_ALL &amp; ~ (
     E_NOTICE | E_WARNING)</literal>.
    </para>
    <warning>
     <para>
      Cuando actualice código o servidores desde PHP 3 a PHP 4, usted
      debería chequear estos parámetros y llamadas a
      <function>error_reporting</function> o puede que quiera deshabilitar
      el reporte de los nuevos tipos de error, especialmente
      <literal>E_COMPILE_ERROR</literal>. Esto puede llevar a la generación
      de documentos sin información alguna sobre qué ha pasado o en dónde
      investigar por posibles problemas.
     </para>
    </warning>
    <warning>
     <para>
      El uso de los valores antiguos 7 y 15 para establecer el reporte de
      errores es una muy mala idea ya que esto suprime algunas de las nuevas
      clases de errores presentes, incluyendo errores de la fase de análisis
      sintáctico. Esto puede producir comportamientos bastante extraños,
      debido a que posiblemente los scripts no trabajen más sin dejar de
      mostrar mensajes de error en todas partes.
     </para>
     <para>
      Esto ha producido una cantidad enorme de reportes de fallos
      irreproducibles en el pasado, en donde la gente reportaba problemas
      con el motor de scripts que eran incapaces de rastrear, cuando lo que
      sucedía en realidad era usualmente algún '}' que faltaba en un archivo
      requerido, que el analizador sintáctico no podía reportar debido a un
      sistema de reporte de errores mal configurado.
     </para>
     <para>
      Así que revisar la configuración de su reporte de errores debe ser lo
      primero que debe hacer siempre que sus scripts mueran silenciosamente.
      El motor Zend puede considerarse suficientemente maduro en la
      actualidad como para afirmar que éste no es el causante de estos
      comportamientos extraños.
     </para>
    </warning>
   </section>

   <section xml:id='migration4.error-reporting.additions'>
    <title>Mensajes de advertencia adicionales</title>
    <para>
     Una gran cantidad de código PHP 3 existente usa construcciones del
     lenguaje que deben ser consideradas como muy mal estilo ya que, aunque
     logran el efecto esperado ahora, pueden verse influenciadas por cambios
     en otros lugares del código. PHP 4 desplegará una enorme cantidad de
     mensajes de noticia en tales situaciones en donde PHP 3 no lo hacía. La
     solución simple es deshabilitar los mensajes
     <literal>E_NOTICE</literal>, pero usualmente es una buena idea arreglar
     el código en su lugar.
    </para>
    <para>
     El caso más común que produce mensajes de noticia ahora es el uso de
     constantes de cadena sin comillas como índices de matrices. Tanto PHP 3
     como PHP 4 llegarán a interpretar éstas como cadenas si no existen
     palabras clave o constantes con tales nombres, pero en donde sea que
     una constante con tal nombre haya sido definida en algún lugar del
     código, puede dañar el script. Esto puede convertirse incluso en un
     riesgo de seguridad si algún intruso logra redefinir constantes de
     cadena en forma tal que hace que sus scripts le den derechos de acceso
     que él no debía tener. Así que PHP 4 le advertirá ahora siempre que use
     constantes de cadena sin comillas, como por ejemplo en
     <literal>$_SERVER[REQUEST_METHOD]</literal>. Modificar tal expresión
     por <literal>$_SERVER['REQUEST_METHOD']</literal> hará feliz al
     analizador sintáctico y mejorará significativamente el estilo y la
     seguridad de su código.
    </para>
    <para>
     Otra cosa sobre la que PHP 4 le notificará es sobre el uso de variables
     o elementos de matrices sin inicializar.
    </para>
   </section>

  </section>

  <section xml:id='migration4.initializers'>
   <title>Inicializadores</title>
   <para>
    Las variables estáticas y los inicializadores de miembros de clase
    aceptan únicamente valores escalares, mientras que en PHP 3 aceptaban
    cualquier expresión válida. Esto es, nuevamente, debido a la separación
    entre el análisis sintáctico y la ejecución ya que el código no ha sido
    ejecutado aun cuando el analizador sintáctico ve el inicializador.
   </para>
   <para>
    Para clases, debería usar constructores para inicializar variables
    miembro en su lugar. Para variables estáticas, cosas diferentes a
    simples valores estáticos rara vez tienen sentido después de todo.
   </para>
  </section>

  <section xml:id='migration4.empty'>
   <title><literal>empty("0")</literal></title>
   <para>
    Quizás el cambio de comportamiento más controversial ha ocurrido con
    <function>empty</function>. Una cadena que contenga solo el caracter '0'
    (cero) es considerada vacía, mientras que en PHP 3 no era así.
   </para>
   <para>
    Este nuevo comportamiento tiene sentido en aplicaciones web, dado que
    todos los campos de entrada devuelven cadenas incluso si se solicitan
    valores numéricos, y dadas las capacidades de conversión automática de
    tipos de PHP. Pero, por otra parte, puede dañar su código en formas
    sutiles, causando comportamientos exóticos que son difíciles de rastrear
    si no sabe qué buscar.
   </para>
  </section>

  <section xml:id='migration4.missing'>
   <title>Funciones faltantes</title>
   <para>
    Aunque PHP 4 viene con una gran cantidad de características, funciones y
    extensiones nuevas, puede que aun encuentre funciones de la versión 3
    que hacen falta. Un número pequeño de funciones centrales han
    desaparecido ya que no funcionan con el nuevo esquema de separación de
    análisis sintáctico y ejecución que se introdujo en PHP 4 con el motor
    Zend. Otras funciones, e incluso extensiones completas, se han marcado
    obsoletas a medida que nuevas funciones y extensiones cubren las mismas
    tareas y en ocasiones en una forma más general. Algunas funciones
    simplemente no han sido portadas aun y finalmente algunas funciones o
    extensiones pueden faltar debido a conflictos de licencias.
   </para>

   <section xml:id='migration4.missing.concept'>
    <title>Funciones faltantes debido a cambios conceptuales</title>
    <para>
     Dado que PHP 4 separa ahora el análisis sintáctico de la ejecución, ya
     no es posible modificar el comportamiente del analizador sintáctico
     (embebido ahora en el motor Zend) en tiempo de ejecución, dado que el
     análisis ya ha ocurrido para entonces. De modo que la función
     <function>short_tags</function> ya no existe. Aun puede modificar el
     comportamiento del analizador sintáctico definiendo los valores
     apropiados en el archivo &php.ini;.
    </para>
    <para>
     Otra característica de PHP 3 que no es parte de PHP 4 es la interfaz de
     depuración integrada. Existen adiciones de terceros para el motor Zend
     que añaden funcionalidades similares.
    </para>
   </section>

   <section xml:id='migration4.deprecate'>
    <title>Funciones y extensiones deprecadas</title>
    <para>
     Las extensiones de bases de datos Adabas y Solid ya no existen. Larga
     vida a la extensión unificada ODBC en su lugar.
    </para>
   </section>

   <section xml:id='migration4.unset'>
    <title>Status modificado para <function>unset</function></title>
    <para>
     <function>unset</function>, aun cuando sigue estando disponible, es
     implementada ahora como una construcción del lenguaje en lugar de una
     función.
    </para>
    <para>
     Esto no tiene consecuencia alguna en el comportamiento de
     <function>unset</function>, pero realizar una prueba con "unset" usando
     <function>function_exists</function> devolverá &false; del mismo modo
     que ocurriría con otras construcciones del lenguaje que tienen
     apariencia de funciones, como <function>echo</function>.
    </para>
    <para>
     Otro cambio más práctico es que ya no es posible llamar
     <function>unset</function> indirectamente, esto es,
     <literal>$func="unset"; $func($alguna_variable)</literal> no funcionará
     más.
    </para>
   </section>
  </section>

  <section xml:id='migration4.extensions'>
   <title>Extensiones PHP 3</title>
   <para>
    Las extensiones escritas para PHP 3 no trabajarán con PHP 4, ni como
    binarios ni al nivel de fuente. No es difícil portar extensiones a PHP 4
    si tiene acceso a las fuentes originales. Una descripción detallada de
    tal proceso de migración no hace parte de este documento.
   </para>
  </section>

  <section xml:id='migration4.strings'>
   <title>Sustitución de variables en cadenas</title>
   <para>
    PHP 4 añade un nuevo mecanismo para la sustitución de variables en
    cadenas. Ahora, finalmente, puede acceder a variables miembro de objetos
    y elementos de matrices multidimensionales al interior de cadenas.
   </para>
   <para>
    Para tal efecto, necesita rodear sus variables con corchetes, colocando
    el signo de dólar inmediatamente después del corchete de apetura:
    <literal>{$...}</literal>
   </para>
   <para>
    Para embeber el valor de una variable miembro de objeto en una cadena,
    simplemente escriba <literal>"texto {$obj-&gt;miembro} texto"</literal>,
    mientras que en PHP 3 debía hacer algo como <literal>"texto
    ".$obj-&gt;miembro." texto"</literal>.
   </para>
   <para>
    Esto debería representar código más legible, aunque podría arruinar
    scripts existentes escritos para PHP 3. Pero puede encontrar fácilmente
    este tipo de problemas, revisando el código por la combinación de
    caracteres <literal>{$</literal> en su código, y reemplazándola por
    <literal>\{$</literal> con su herramienta de búsqueda-y-reemplazo
    favorita.
   </para>
  </section>

  <section xml:id='migration4.cookies'>
   <title>Cookies</title>
   <para>
    PHP 3 tenía el mal hábito de definir cookies en el orden contrario al de
    las llamadas a <function>setcookie</function> en su código. PHP 4 acabó
    con este hábito y crea las líneas de cabecera de cookies en el mismo
    orden exacto en el que usted define las cookies en el código.
   </para>
   <para>
    Esto puede dañar código existente, pero el comportamiento antiguo era
    tan extraño de entender que merecía un cambio para prevenir posteriores
    problemas en el futuro.
   </para>
  </section>

  <section xml:id='migration4.variables'>
   <title>Gestión de variables globales</title>
   <para>
    Aunque el manejo de variables globales se enfocaba en la simplicidad en
    PHP 3 y versiones tempranas de PHP 4, éste enfoque ha cambiado para ser
    más seguro. Mientras que en PHP 3 el siguiente ejemplo funcionaba bien,
    en PHP 4 debe ser unset(<literal>unset($GLOBALS["id"])</literal>);. Este
    es sólo un detalle de la gestión de variables globales. Usted debería
    usar siempre <varname>$GLOBALS</varname>, con versiones recientes de PHP
    4 está obligado a hacerlo en la mayoría de casos. Lea más sobre este
    asunto en la <link linkend="references.global">sección de referencias
    <literal>global</literal></link>.
   </para>
   <example>
    <title>Migración de variables globales</title>
    <programlisting role="php">
<![CDATA[
<?php
$id = 1;
function prueba()
{
    global $id;
    unset($id);
}
prueba();
echo($id); // Esto imprime 1 en PHP 4
?>
]]>
    </programlisting>
   </example>
  </section>

 </appendix>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
