<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.9 $ -->
<!-- EN-Revision: 1.8 Maintainer: lboshell Status: ready -->
<!-- splitted from ./index.xml, last change in rev 1.66 -->
  <chapter xml:id="security.globals" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
   <title>Uso de Register Globals</title>
   &warn.deprecated.removed-6-0-0;
   <para>
    Quizás el cambio más controversial en la historia de PHP se ha dado
    cuando la directiva <link
    linkend="ini.register-globals">register_globals</link> pasó de tener
    como valor por defecto ON al valor OFF en PHP <link
    xlink:href="&url.php.release4.2.0;">4.2.0</link>. La dependencia sobre
    esta directiva era bastante común y muchas personas nisiquiera estaban
    enteradas de que existía y asumían que ese era el modo en que PHP
    trabajaba. Esta página explicará cómo puede llegar a escribirse código
    inseguro con esta directiva pero tenga en mente que no es la directiva
    misma la que es insegura sino el uso inapropiado de ella.
   </para>
   <para>
    Cuando se encuentra activa, la directiva register_globals inyectará sus
    scripts con todo tipo de variables, como variables de peticiones
    provenientes de formularios HTML. Esto junto con el hecho de que PHP no
    requiere la inicialización de variables significa que es muy fácil
    escribir código inseguro. Fue una decisión difícil, pero la comunidad de
    PHP decidió desahibilar esta directiva por defecto. Cuando está
    habilitada, las personas usan variables sin saber con seguridad de dónde
    provienen y solo queda asumir. Las variables internas que son definidas
    en el script mismo son mezcladas con los datos enviados por los usuarios
    y al deshabilitar register_globals se modifica este comportamiento.
    Demostremos este caso con un ejemplo del uso incorrecto de
    register_globals:
   </para>
   <para>
    <example>
     <title>Ejemplo del uso inapropiado de register_globals = on</title>
     <programlisting role="php">
<![CDATA[
<?php
// definir $autorizado = true solo si el usuario ha sido autenticado

if (usuario_autenticado()) {
    $autorizado = true;
}

// Ya que no inicializamos $autorizado como false, ésta podría estar
// definida a través de register_globals, como en el caso de GET
// auth.php?autorizado=1

// ¡De modo que cualquier persona podría verse como autenticada!

if ($autorizado) {
    include "/datos/muy/importantes.php";
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Cuando register_globals = on, nuestra lógica anterior podría verse
    comprometida. Cuando la directiva está deshabilitada,
    <varname>$autorizado</varname> no puede definirse a través de
    peticiones, así que no habrá ningún problema, aunque es cierto que
    siempre es una buena práctica de programación inicializar las variables
    primero. Por ejemplo, en nuestro ejemplo anterior pudimos haber
    realizado primero algo como <literal>$authorized = false</literal>.
    Hacer esto representa que el código anterior podría funcionar con
    register_globals establecido a on u off ya que los usuarios no serían
    autorizados por omisión.
   </para>
   <para>
    Otro ejemplo es aquel de las <link
    linkend="ref.session">sesiones</link>. Cuando register_globals = on,
    podríamos usar también <varname>$nombre_usuario</varname> en nuestro
    siguiente ejemplo, pero nuevamente usted debe notar que
    <varname>$nombre_usuario</varname> puede provenir de otros medios, como
    GET (a través de la URL).
   </para>
   <para>
    <example>
     <title>Ejemplo del uso de sesiones con register_globals on u
     off</title>
     <programlisting role="php">
<![CDATA[
<?php
// No sabríamos de dónde proviene $nombre_usuario, pero sabemos que
// $_SESSION es para datos de sesión

if (isset($_SESSION['nombre_usuario'])) {

    echo "Hola <b>{$_SESSION['nombre_usuario']}</b>";

} else {

    echo "Hola <b>Invitado</b><br />";
    echo "¿Quisiera iniciar su sesión?";

}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Incluso es posible tomar medidas preventivas para advertir cuando se
    intente falsificar la información. Si usted sabe previamente con
    exactitud el lugar de donde debería provenir una variable, usted puede
    chequear si los datos enviados provienen de una fuente inadecuada.
    Aunque esto no garantiza que la información no haya sido falsificada,
    esto requiere que un atacante adivine el medio apropiado para falsificar
    la información. Si no le importa de dónde proviene la información, puede
    usar <varname>$_REQUEST</varname> ya que allí se incluye una mezcla de
    variables que provienen de datos GET, POST y COOKIE. Consulte también la
    sección del manual sobre el uso de <link
    linkend="language.variables.external">variables desde fuera de
    PHP</link>.
   </para>
   <para>
    <example>
     <title>Detección de envenenamiento simple de variables</title>
     <programlisting role="php">
<![CDATA[
<?php
if (isset($_COOKIE['COOKIE_MAGICA'])) {

    // COOKIE_MAGICA proviene de una cookie.
    // ¡Asegurese de validar los datos de la cookie!

} elseif (isset($_GET['COOKIE_MAGICA']) || isset($_POST['COOKIE_MAGICA'])) {

   mail("admin@example.com", "Posible intento de intromisión",
        $_SERVER['REMOTE_ADDR']);
   echo "Violación de seguridad, el administrador ha sido alertado.";
   exit;

} else {

   // COOKIE_MAGICA no fue definida en este REQUEST

}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Por supuesto, deshabilitar register_globals no quiere decir que su
    código vaya a ser seguro. Por cada trozo de datos que sea enviado por el
    usuario, éste debe ser chequeado en otras formas. ¡Siempre valide los
    datos de los usuarios e inicialice sus variables! Para chequear por
    variables no inicializadas, usted puede usar
    <function>error_reporting</function> para mostrar errores del nivel
    <constant>E_NOTICE</constant>.
   </para>

   <para>
    Para más información sobre la emulación del valor On u Off de
    register_globals, consulte este <link
    linkend="faq.misc.registerglobals">FAQ</link>.
   </para>

   &note.superglobals;

  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
