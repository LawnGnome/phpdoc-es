<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.9 $ -->
<!-- EN-Revision: 1.13 Maintainer: lboshell Status: ready -->
<!-- splitted from ./index.xml, last change in rev 1.66 -->
  <chapter xml:id="security.database" xmlns="http://docbook.org/ns/docbook">
   <title>Seguridad de Bases de Datos</title>

   <simpara>
    Hoy en día, las bases de datos son componentes cardinales de
    cualquier aplicación basada en web, permitiendo que los sitios web
    provean contenido dinámico. Debido a que información
    considerablemente sensible o secreta puede ser almacenada en una
    base de datos, usted debe considerar seriamente la protección de
    sus bases de datos.
   </simpara>
   <simpara>
    Para recuperar o almacenar cualquier información necesita
    conectarse a la base de datos, enviar una consulta válida, recoger
    el resultado y cerrar la conexión. Hoy en día, el lenguaje de
    consultas usado comúnmente en estas interacciones es el Lenguaje
    de Consultas Estructurado (SQL por sus siglas en inglés). Puede
    apreciar cómo un atacante puede <link
    linkend="security.database.sql-injection">intentar acometidas con
    una consulta SQL</link>.
   </simpara>
   <simpara>
    Como puede suponer, PHP no puede proteger su base de datos por sí
    solo. Las siguientes secciones están dirigidas a servir de
    introducción a los conceptos básicos de cómo acceder y manipular
    bases de datos desde scripts PHP.
   </simpara>
   <simpara>
    Mantenga en mente esta simple regla: protección en
    profundidad. Entre más acciones tome para incrementar la
    protección de su base de datos, menor será la probabilidad de que
    un atacante tenga éxito exponiendo o abusando de cualquier
    información almacenada. Un buen diseño del esquema de la base de
    datos y de la aplicación basta para lidiar con sus mayores
    temores.
   </simpara>

   <sect1 xml:id="security.database.design">
    <title>Diseño de Bases de Datos</title>
     <simpara>
      El primer paso siempre es crear la base de datos, a menos que
      desee usar una creada por alguien más. Cuando una base de datos
      es creada, ésta es asignada a un dueño, quien ejecutó la
      sentencia de creación. Usualmente, únicamente el dueño (o un
      super-usuario) puede hacer cualquier cosa con los objetos de esa
      base de datos, y para que otros usuarios puedan usarla, deben
      otorgarse privilegios.
     </simpara>
     <simpara>
      Las aplicaciones nunca deberían conectarse a la base de datos
      bajo el usuario correspondiente a su dueño, o como un
      super-usuario, ya que estos usuarios pueden, por ejemplo,
      ejecutar cualquier consulta a su antojo, modificando el esquema
      (p. ej. eliminando tablas) o borrando su contenido completo.
     </simpara>
     <simpara>
      Usted puede crear diferentes usuarios de la base de datos para
      cada aspecto de su aplicación con derechos muy limitados sobre
      los objetos de la base de datos. Tan solo deben otorgarse los
      privilegios estrictamente necesarios, y evitar que el mismo
      usuario pueda interactuar con la base de datos en diferentes
      casos de uso. Esto quiere decir que si un intruso gana acceso a
      su base de datos usando las credenciales de sus aplicaciones, él
      solo puede efectuar tantos cambios como su aplicación se lo
      permita.
     </simpara>
     <simpara>
      Es buena idea que no implemente toda la lógica del asunto en la
      aplicación web (es decir, en su script); en su lugar, hágalo en
      el esquema de la base de datos usando vistas, disparadores o
      reglas. Si el sistema evoluciona, se espera que nuevos puertos
      sean abiertos a la aplicación, y tendrá que re-implementar la
      lógica para cada cliente de la base de datos. Por sobre todo,
      los disparadores pueden ser usados para gestionar de forma
      transparente todos los campos automáticamente, lo cual con
      frecuencia provee información útil cuando se depuren problemas
      de su aplicación, o se realicen rastreos sobre transacciones
      particulares.
     </simpara>
   </sect1>

   <sect1 xml:id="security.database.connection">
    <title>Conexión con la Base de Datos</title>
    <simpara>
     Puede que desee establecer las conexiones sobre SSL para
     encriptar las comunicaciones cliente/servidor, incrementando el
     nivel de seguridad, o puede hacer uso de ssh para encriptar la
     conexión de red entre los clientes y el servidor de la base de
     datos. Si cualquiera de estos recursos es usado, entonces
     monitorear su tráfico y adquirir información sobre su base de
     datos será difícil para un atacante potencial.
    </simpara>
    <!--simpara>
Si su servidor de base de datos tiene soporte SSL nativo, considere el
uso de <link linkend="ref.openssl">funciones OpenSSL</link> en la
comunicaci&oacute;n entre PHP y la base de datos v&iacute;a SSL.
    </simpara-->
   </sect1>

   <sect1 xml:id="security.database.storage">
    <title>Modelo de Almacenamiento Encriptado</title>
    <simpara>
     SSL/SSH protege los datos que viajan desde el cliente al
     servidor, SSL/SSH no protege los datos persistentes almacenados
     en la base de datos. SSL es un protocolo sobre-el-cable.
    </simpara>
    <simpara>
     Una vez el atacante adquiere acceso directo a su base de datos
     (evitando el paso por el servidor web), los datos críticos
     almacenados pueden estar expuestos o malutilizados, a menos que
     la información esté protegida en la base de datos misma. La
     encripción de datos es una buena forma de mitigar esta amenaza,
     pero muy pocas bases de datos ofrecen este tipo de mecanismo de
     encripción de datos.
    </simpara>
    <simpara>
     La forma más sencilla de evitar este problema es crear primero su
     propio paquete de encripción, y luego utilizarlo desde sus
     scripts de PHP. PHP puede ayudarle en este sentido con varias
     extensiones, como <link linkend="ref.mcrypt">Mcrypt</link> y
     <link linkend="ref.mhash">Mhash</link>, las cuales cubren una
     amplia variedad de algoritmos de encripción. El script encripta
     los datos antes de insertarlos en la base de datos, y los
     decripta cuando los recupera. Vea las referencias para consultar
     más ejemplos de cómo opera la encripción.
    </simpara>
    <simpara>
     En el caso de datos realmente escondidos, si su representación
     original no se necesita (es decir, no debe ser desplegada), los
     resúmenes criptográficos pueden llegar a considerarse también. El
     ejemplo clásico de gestión de resúmenes criptogáficos es el
     almacenamiento de secuencias MD5 de una contraseña en una base de
     datos, en lugar de la contraseña misma. Vea también
     <function>crypt</function> y <function>md5</function>.
    </simpara>
    <example>
     <title>Uso de un campo de contraseñas encriptado</title>
     <programlisting role="php">
<![CDATA[
<?php

// almacenamiento de resumen criptográfico de la contraseña
$consulta  = sprintf("INSERT INTO usuarios(nombre,contr) VALUES('%s','%s');",
                     pg_escape_string($nombre_usuario), md5($contrasenya));
$resultado = pg_query($conexion, $consulta);


// consulta de verificación de la contraseña enviada
$consulta  = sprintf("SELECT 1 FROM usuarios WHERE nombre='%s' AND contr='%s';",
                     pg_escape_string($nombre_usuario), md5($contrasenya));
$resultado = pg_query($conexion, $consulta);

if (pg_num_rows($resultado) > 0) {
    echo '¡Bienvenido, $nombre_usuario!';
}
else {
    echo 'No pudo autenticarse a $nombre_usuario.';
}

?>
]]>
     </programlisting>
    </example>
   </sect1>

   <sect1 xml:id="security.database.sql-injection">
    <title>Inyección de SQL</title>
    <simpara>
     Muchos desarrolladores web no son conscientes de cómo pueden
     manipularse las consultas SQL, y asumen que una consulta SQL es
     un comando confiable. Esto representa que las consultas SQL
     pueden burlar los controles de acceso, y de este modo evitar los
     chequeos estándares de autenticación y autorización, y a veces
     las consultas SQL pueden incluso permitir acceso a comandos al
     nivel del sistema operativo de la máquina huésped.
    </simpara>
    <simpara>
     La Inyección Directa de Comandos SQL es una técnica en la cual un
     atacante crea o altera comandos SQL existentes para exponer datos
     escondidos, o sobrescribir datos críticos, o incluso ejecutar
     comandos del sistema peligrosos en la máquina en donde se
     encuentra la base de datos. Esto se consigue cuando la aplicación
     toma información de entrada del usuario y la combina con
     parámetros estáticos para construir una consulta SQL. Los
     siguientes ejemplos, desafortunadamente, están basados en
     historias reales.
    </simpara>
    <para>
     Debido a la falta de validación de la información de entrada y el
     establecimiento de conexiones con la base de datos desde un
     super-usuario o aquel que puede crear usuarios, el atacante
     podría crear un super-usuario en su base de datos.
     <example>
      <title>
       Paginación del conjunto de resultados ... y creación de
       super-usuarios (PostgreSQL)
      </title>
      <programlisting role="php">
<![CDATA[
<?php

$offset   = $argv[0]; // atención, ¡no se valida la entrada!
$consulta = "SELECT id, nombre FROM productos ORDER BY nombre LIMIT 20 " .
            "OFFSET $offset;";

$resultado = pg_query($conexion, $consulta);

?>
]]>
      </programlisting>
     </example>
     Los usuarios normales pulsan sobre los enlaces 'siguiente' y
     'anterior', en donde el desplazamiento
     (<varname>$offset</varname>) se encuentra codificado en la
     URL. El script espera que el valor entrante
     <varname>$offset</varname> sea un número decimal.  Sin embargo,
     qué sucede si alguien intenta un ataque añadiendo una forma
     codificada (<function>urlencode</function>) de lo siguiente en la
     URL
      <informalexample>
       <programlisting role="sql">
<![CDATA[
0;
insert into pg_shadow(usename,usesysid,usesuper,usecatupd,passwd)
    select 'crack', usesysid, 't','t','crack'
    from pg_shadow where usename='postgres';
--
]]>
       </programlisting>
      </informalexample>
     Si esto ocurriera, entonces el script le presentaría un acceso de
     superusuario al atacante. Note que <literal>0;</literal> es usado
     para ofrecer un desplazamiento válido a la consulta original y
     finalizarla.
    </para>
    <note>
     <para>
      Es una técnica común obligar al analizador sintáctico de SQL a
      que ignore el resto de la consulta escrita por el desarrollador
      mediante <literal>--</literal>, el cual es el signo de
      comentarios en SQL.
     </para>
    </note>
    <para>
     Una forma viable de adquirir contraseñas es jugar con las páginas
     de resultados de búsquedas. Lo único que necesita el atacante es
     ver si existen variables enviadas por el usuario que sean usadas
     en sentencias SQL, y que no sean tratadas apropiadamente. Estos
     filtros pueden ubicarse por lo general previos a cláusulas
     <literal>WHERE, ORDER BY, LIMIT</literal> y
     <literal>OFFSET</literal> en sentencias <literal>SELECT</literal>
     para personalizar la instrucción. Si su base de datos soporta la
     construcción <literal>UNION</literal>, el atacante puede intentar
     añadir una consulta completa a la consulta original para generar
     una lista de contraseñas desde una tabla cualquiera. El uso de
     campos encriptados de contraseñas es altamente recomendable.
     <example>
      <title>
       Listado de artículos ... y algunas contraseñas (en cualquier
       base de datos)
      </title>
      <programlisting role="php">
<![CDATA[
<?php

$consulta  = "SELECT id, nombre, insertado, tam FROM productos
                  WHERE tam = '$tam'
                  ORDER BY $orden LIMIT $limite, $offset;";
$resultado = odbc_exec($conexion, $consulta);

?>
]]>
      </programlisting>
     </example>
     La parte estática de la consulta puede combinarse con otra
     sentencia <literal>SELECT</literal> la cual revela todas las
     contraseñas:
     <informalexample>
      <programlisting role="sql">
<![CDATA[
'
union select '1', concat(uname||'-'||passwd) as name, '1971-01-01', '0' from usertable;
--
]]>
      </programlisting>
     </informalexample>
     Si esta consulta (la cual juega con <literal>'</literal> y
     <literal>--</literal>) fuera asignada a una de las variables
     usadas en <varname>$consulta</varname>, la bestia de la consulta
     habrá despertado.
    </para>
    <para>
     Las sentencias UPDATE de SQL son también susceptibles a
     ataque. Estas consultas también se encuentran amenazadas por un
     posible acotamiento y adición de una consulta completamente
     nueva. Pero en este caso el atacante puede amañar la información
     de una cláusula <literal>SET</literal>. En este caso se requiere
     contar con cierta información sobre el esquema de la base de
     datos para poder manipular la consulta satisfactoriamente. Esta
     información puede ser adquirida mediante el estudio de los
     nombres de variables de los formularios, o simplemente por fuerza
     bruta. No existen demasiadas convenciones para nombrar campos de
     contraseñas o nombres de usuario.
     <example>
     <title>
      De restablecer una contraseña ... a adquirir más privilegios
      (con cualquier servidor de base de datos)
     </title>
      <programlisting role="php">
<![CDATA[
<?php
$consulta = "UPDATE usertable SET pwd='$pwd' WHERE uid='$uid';";
?>
]]>
      </programlisting>
     </example>
     Pero un usuario malicioso envía el valor <literal>' or uid
     like'%admin%'; --</literal> como <varname>$uid</varname> para
     cambiar la contraseña del administrador, o simplemente establece
     <varname>$pwd</varname> a <literal>"hehehe', admin='yes',
     trusted=100 "</literal> (con un espacio al inicio) para adquirir
     más privilegios. En tal caso, la consulta sería manipulada:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php

// $uid == ' or uid like'%admin%'; --
$consulta = "UPDATE usertable SET pwd='...' WHERE uid='' or uid like '%admin%'; --";

// $pwd == "hehehe', admin='yes', trusted=100 "
$consulta = "UPDATE usertable SET pwd='hehehe', admin='yes', trusted=100 WHERE ...;"

?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Un horrible ejemplo de cómo puede accederse a comandos del
     nivel del sistema operativo en algunas máquinas
     anfitrionas de bases de datos.
     <example>
     <title>Ataque al sistema operativo de la máquina anfitriona de la
     base de datos (MSSQL Server)</title>
      <programlisting role="php">
<![CDATA[
<?php

$consulta  = "SELECT * FROM productos WHERE id LIKE '%$prod%'";
$resultado = mssql_query($consulta);

?>
]]>
      </programlisting>
     </example>
     Si el atacante envía el valor <literal>a%' exec
     master..xp_cmdshell 'net user test testpass /ADD' --</literal> a
     <varname>$prod</varname>, entones la <varname>$consulta</varname>
     será:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php

$consulta  = "SELECT * FROM productos
                    WHERE id LIKE '%a%'
                    exec master..xp_cmdshell 'net user test testpass /ADD'--";
$resultado = mssql_query($consulta);

?>
]]>
      </programlisting>
     </informalexample>
     MSSQL Server ejecuta sentencias SQL en el lote, incluyendo un
     comando para agregar un nuevo usuario a la base de datos de
     cuentas locales. Si esta aplicación estuviera corriendo como
     <literal>sa</literal> y el servicio MSSQLSERVER está corriendo
     con los privilegios suficientes, el atacante tendría ahora una
     cuenta con la que puede acceder a esta máquina.
    </para>
    <note>
     <para>
      Algunos de los ejemplos anteriores están atados a un servidor de
      base de datos específico. Esto no quiere decir que un ataque
      similar sea imposible con otros productos. Su base de datos
      puede ser vulnerable de forma semejante, en alguna otra manera.
     </para>
    </note>

    <sect2 xml:id="security.database.avoiding">
     <title>Técnicas de protección</title>
     <simpara>
      Usted puede argumentar con justa razón que el atacante debe
      poseer cierta cantidad de información sobre el esquema de la
      base de datos en la mayoría de ejemplos que hemos visto. Tiene
      razón, pero usted nunca sabe cuándo y cómo puede filtrarse esta
      información, y si ocurre, su base de datos estará expuesta. Si
      está usando un paquete de gestión de bases de datos de código
      abierto, o cuyo código fuente está disponible públicamente, el
      cual puede pertenecer a algún sistema de administración de
      contenido o foro, los intrusos pueden producir fácilmente una
      copia de un trozo de su código. También puede ser un riesgo de
      seguridad si es un segmento de código pobremente diseñado.
     </simpara>
     <simpara>
      Estos ataques se basan principalmente en la explotación del
      código que no ha sido escrito pensando en la seguridad. Nunca
      confíe en ningún tipo de información de entrada, especialmente
      aquella que proviene del lado del cliente, aun si lo hace desde
      una caja de selección, un campo de entrada hidden o una
      cookie. El primer ejemplo le muestra que una consulta así de
      descuidada puede causar desastres.
     </simpara>

     <itemizedlist>
      <listitem>
       <simpara>
        Nunca se conecte a la base de datos como un super-usuario o
        como el dueño de la base de datos. Use siempre usuarios
        personalizados con privilegios muy limitados.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Revise si la entrada recibida es del tipo apropiado. PHP posee
        un amplio rango de funciones de validación de datos, desde los
        más simples encontrados en <link linkend="ref.var">Funciones
        sobre variables</link> y en <link
        linkend="ref.ctype">Funciones de tipo de caracter</link>
        (p. ej. <function>is_numeric</function>,
        <function>ctype_digit</function> respectivamente) hasta el
        soporte para <link linkend="ref.pcre">Expresiones Regulares
        compatibles con Perl</link>.
       </simpara>
      </listitem>
      <listitem>
       <para>
        Si la aplicación espera alguna entrada numérica, considere la
        verificación de información con
        <function>is_numeric</function>, o modifique silenciosamente
        su tipo usando <function>settype</function>, o utilice su
        representación numérica, dada por
        <function>sprintf</function>.
        <example>
         <title>
          Una forma más segura de generar una consulta para paginado
         </title>
         <programlisting role="php">
<![CDATA[
<?php

settype($offset, 'integer');
$consulta = "SELECT id, nombre FROM productos ORDER BY nombre " .
            "LIMIT 20 OFFSET $offset;";

// note el simbolo %d en la cadena de formato, usar %s no tendría sentido
$consulta = sprintf("SELECT id, nombre FROM productos ORDER BY nombre" .
                    "LIMIT 20 OFFSET %d;", $offset);

?>
]]>
         </programlisting>
        </example>
       </para>
      </listitem>
      <listitem>
       <simpara>
        Ubique cada valor no-numérico que entrega el usuario y que sea
        pasado a la base de datos entre comillas con la función de
        escape de cadenas específica a su base de datos (p.ej.
        <function>mysql_escape_string</function>,
        <function>sql_escape_string</function>, etc.). Si no hay
        disponible un mecanismo de escape de cadenas específico a la
        BD, las funciones <function>addslashes</function> y
        <function>str_replace</function> pueden ser útiles
        (dependiendo del tipo de base de datos). Vea <link
        linkend="security.database.storage">el primer
        ejemplo</link>. Como se ve allí, agregar comillas a la parte
        estática de la consulta no es suficiente, haciéndola
        fácilmente manipulable.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        No imprima ninguna información específica sobre la base de
        datos, especialmente sobre su esquema, ya sea por razones
        justas o por equivocaciones. Vea también <link
        linkend="security.errors">Reporte de Errores</link> y <link
        linkend="ref.errorfunc">Gestión de Errores y Funciones de
        Registro</link>.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Puede usar procedimientos almacenados y cursores previamente
        definidos para abstraer el acceso a las bases de datos, de
        modo que los usuarios no tengan acceso directo a las tablas o
        vistas, aunque esta solución tiene otros impactos.
       </simpara>
      </listitem>
     </itemizedlist>

     <simpara>
      Además de estas acciones, usted puede beneficiarse del registro
      explícito de las consultas realizadas, ya sea desde su script o
      por la base de datos misma, si ésta soporta la gestión de
      registros. Por supuesto, el registro de acciones no puede
      prevenir cualquier intento peligroso, pero puede ser útil para
      rastrear cuáles aplicaciones han sido usadas para violar la
      seguridad. El registro en sí no es útil; lo es la información
      que contiene. Por lo general, es mejor contar con más detalles
      que con menos.
     </simpara>
    </sect2>
   </sect1>
  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
