<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.1 $ -->
<!-- EN-Revision: 1.1 Maintainer: lboshell Status: ready -->
<!-- splitted from ./index.xml, last change in rev 1.66 -->
  <sect1 id="security.filesystem">
   <title>Seguridad del sistema de archivos</title>
   <simpara>
    PHP est&aacute; sujeto a la seguridad misma de la mayor&iacute;a
    de sistemas de servidores en lo que a permisos sobre archivos y
    directorios se refiere. Esto le permite controlar cu&aacute;les
    archivos en el sistema de archivos pueden ser le&iacute;dos. Debe
    tenerse cuidado con aquellos archivos que tengan permisos de
    lectura globales, para asegurarse de que su contenido es seguro y
    no represente peligro el que pueda ser le&iacute;do por todos los
    usuarios con acceso al sistema de archivos.
   </simpara>
   <simpara>
    Ya que PHP fue dise&ntilde;ado para permitir acceso al nivel de
    usuarios al sistema de archivos, es completamente posible escribir
    un script PHP que le permita leer archivos del sistema como
    /etc/passwd, modificar sus conexiones tipo ethernet, enviar
    trabajos de impresi&oacute;n masivos, etc. Esto tiene algunas
    implicaciones obvias, en el sentido en que usted tiene que
    asegurarse de que los archivos desde lo que lee y hacia los que
    escribe datos, sean los correctos.
   </simpara>
   <simpara>
    Considere el siguiente script, en donde un usuario indica que
    quisiera eliminar un archivo ubicado en su directorio
    personal. Este caso asume que se trata de una situaci&oacute;n en
    donde se usa normalmente una interfaz web que se vale de PHP para
    la gesti&oacute;n de archivos, as&iacute; que el usuario de Apache
    tiene permitido eliminar archivos en los directorios personales de
    los usuarios.
   </simpara>
   <para>
    <example>
     <title>Un chequeo pobre de variables nos lleva a...</title>
     <programlisting role="php">
<![CDATA[
<?php
// eliminar un archivo del directorio personal del usuario

$nombre_usuario = $_POST['nombre_enviado_por_el_usuario'];
$directorio     = "/home/$nombre_usuario";

$archivo_a_eliminar = "$archivo_de_usuario";

unlink ("$directorio/$archivo_de_usuario");

echo "&iexcl;El archivo $archivo_a_eliminar ha sido eliminado!";
?>
]]>
     </programlisting>
    </example>
    Ya que el nombre de usuario es enviado desde un formulario de
    usuario, cualquiera puede enviar un nombre de usuario y archivo
    propiedad de otra persona, y eliminar archivos. En este caso,
    usted querr&aacute; usar otro m&eacute;todo de
    autenticaci&oacute;n. Considere lo que sucede si las variables
    enviadas son "../etc/" y "passwd". El c&oacute;digo entonces se
    ejecutar&iacute;a efectivamente como:
    <example>
     <title>... un ataque al sistema de archivos</title>
     <programlisting role="php">
<![CDATA[
<?php
// elimina un archivo de cualquier parte del disco duro al que el
// usuario de PHP tiene acceso. Si PHP tiene acceso de root:

$nombre_usuario = "../etc/";
$directorio     = "/home/../etc/";

$archivo_a_eliminar = "passwd";

unlink ("/home/../etc/passwd");

echo "&iexcl;El archivo /home/../etc/passwd ha sido eliminado!";
?>
]]>
     </programlisting>
    </example>
    Hay dos importantes medidas que usted debe tomar para prevenir
    estas situaciones.
    <itemizedlist>
     <listitem>
      <simpara>
       Otorgarle &uacute;nicamente permisos limitados al usuario web
       del binario PHP.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Chequear todas las variables que son enviadas por usuarios.
      </simpara>
     </listitem>
    </itemizedlist>
    Aqu&iacute; hay una versi&oacute;n mejorada del script:
    <example>
     <title>Un chequeo de nombres de archivos m&aacute;s
     seguro</title>
     <programlisting role="php">
<![CDATA[
<?php
// elimina un archivo de cualquier parte del disco duro al que el
// usuario de PHP tiene acceso.

$nombre_usuario = $_SERVER['REMOTE_USER']; // uso de un mecanismo de
                                           // autenticacion

$directorio = "/home/$nombre_usuario";

$archivo_a_eliminar = basename("$archivo_de_usuario"); // remover rutas
unlink ($directorio/$archivo_a_eliminar);

$fp = fopen("/home/registros/eliminacion.log","+a"); // registrar el proceso

$cadena_de_registro = "$nombre_usuario $directorio $archivo_a_eliminar";

fputs ($fp, $cadena_de_registro);
fclose($fp);

echo "&iexcl;El archivo $archivo_a_eliminar ha sido eliminado!";
?>
]]>
     </programlisting>
    </example>
    Sin embargo, incluso este caso no est&aacute; libre de
    problemas. Si su sistema de autenticaci&oacute;n le ha permitido a
    los usuarios la creaci&oacute;n de sus propios nombres en el
    sistema, y un usuario elige "../etc/", el sistema se encuenrta
    nuevamente expuesto. Por esta raz&oacute;n, puede que uster
    prefiera escribir un chequeo m&aacute;s personalizado:
    <example>
     <title>Chequeo de nombres de archivos aun m&aacute;s
     seguro</title>
     <programlisting role="php">
<![CDATA[
<?php
$nombre_usuario = $_SERVER['REMOTE_USER']; // uso de un mecanismo de
                                           // autenticacion

$directorio = "/home/$nombre_usuario";

if (!ereg('^[^./][^/]*$', $archivo_de_usuario))
     die('nombre de archivo inv&aacute;lido'); // finalizar,
                                               // no ejecutar el proceso

if (!ereg('^[^./][^/]*$', $nombre_usuario))
     die('nombre de archivo inv&aacute;lido'); // finalizar,
                                               // no ejecutar el proceso

//etc...
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Dependiendo de su sistema operativo, existe una amplia variedad de
    archivos sobre los que usted deber&iacute;a estar atento,
    incluyendo las entradas de dispositivos (/dev/ o COM1), archivos
    de configuraci&oacute;n (archivos /etc/ y los archivos .ini),
    areas conocidas de almacenamiento de datos (/home/, Mis
    Documentos), etc. Por esta raz&oacute;n, usualmente es m&aacute;s
    sencillo crear una pol&iacute;tica en donde se proh&iacute;ba toda
    transacci&oacute;n excepto por aquellas que usted permita
    expl&iacute;citamente.
   </para>
  </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
