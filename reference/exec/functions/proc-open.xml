<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.7 $ -->
<!-- EN-Revision: 1.11 Maintainer: lboshell Status: ready -->
<!-- splitted from ./en/functions/exec.xml, last change in rev 1.28 -->
  <refentry id='function.proc-open'>
   <refnamediv>
    <refname>proc_open</refname>
    <refpurpose>
     Ejecutar un comando y abrir apuntadores de archivo para
     entrada/salida
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripci&oacute;n</title>
     <methodsynopsis>
      <type>resource</type><methodname>proc_open</methodname>
      <methodparam><type>string</type><parameter>cmd</parameter></methodparam>
      <methodparam><type>array</type><parameter>espec_descriptor</parameter></methodparam>
      <methodparam><type>array</type><parameter>&amp;pipes</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>cwd</parameter></methodparam>
      <methodparam choice="opt"><type>array</type><parameter>env</parameter></methodparam>
      <methodparam choice="opt"><type>array</type><parameter>otras_opciones</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>proc_open</function> es similar a
     <function>popen</function> pero provee un grado de control mucho
     mayor sobre la ejecuci&oacute;n del
     programa. <parameter>cmd</parameter> es el comando a ser
     ejecutado por el int&eacute;rprete de
     comandos. <parameter>espec_descriptor</parameter> es una matriz
     indexada en donde la clave representa el n&uacute;mero de
     descriptor y el valor representa el modo como PHP pasar&aacute;
     ese descriptor al proceso hijo. <parameter>pipes</parameter>
     ser&aacute; definido como una matriz indexada de apuntadores a
     archivo que corresponden a los puntos de comunicaci&oacute;n con
     PHP de todo pipe que sea creado. El valor de retorno es un
     recurso que representa el proceso; usted debe liberarlo usando
     <function>proc_close</function> una vez haya terminado de usarlo.
    </para>
    <!-- TODO: Document cwd, env, other_options and when they appeared. -->
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$espec_descriptor = array(
   0 => array("pipe", "r"),  // stdin es un pipe usado por el hijo para lectura
   1 => array("pipe", "w"),  // stdout es un pipe usado por el hijo para escritura
   2 => array("file", "/tmp/error-output.txt", "a") // stderr es un archivo para escritura
);
$proceso = proc_open("php", $espec_descriptor, $pipes);
if (is_resource($proceso)) {
    // $pipes ahora luce de esta forma:
    // 0 => gestor de escritura conectado con la entrada estandar del hijo
    // 1 => gestor de lectura conectado con la salida estandar del hijo
    // Cualquier mensaje de salida de error sera adicionado a /tmp/error-output.txt

    fwrite($pipes[0], "<?php echo \"&iexcl;Hola mundo!\"; ?>");
    fclose($pipes[0]);

    while (!feof($pipes[1])) {
        echo fgets($pipes[1], 1024);
    }
    fclose($pipes[1]);
    // Es importante que cierre todos los pipes antes de llamar
    // proc_close para evitar un bloqueo muerto
    $retval = proc_close($proceso);

    echo "el comando ha devuelto $retval\n";
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     PHP 5RC2 introduce soporte pty para sistemas con ptys
     Unix98. Esto le permite a su script interactuar con aplicaciones
     que esperan estar hablando con una terminal. Una pty trabaja como
     un pipe, pero es bi-direccional, as&iacute; que no hay necesidad
     de especificar un modo de lectura/escritura. El siguiente ejemplo
     muestra c&oacute;mo usar una pty; note que no necesita tener
     todos los descriptores hablando con una pty. Note tambi&eacute;n
     que solo una pty es creada, incluso cuando pty se especifica 3
     veces. En una versi&oacute;n futura de PHP, puede que sea posible
     hacer m&aacute;s que simplemente leer y escribir a la pty.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// Crear una pseudo terminal para el proceso hijo
$espec_descriptor = array(
   0 => array("pty"),
   1 => array("pty"),
   2 => array("pty")
);
$proceso = proc_open("cvs -d:pserver:cvsread@cvs.php.net:/repository login", $espec_descriptor, $pipes);
if (is_resource($proceso)) {
   // trabaje con el recurso aqui
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Los n&uacute;meros de descriptor de archivo en
     <parameter>espec_descriptor</parameter> no est&aacute;n limitados
     a 0, 1 y 2 - usted puede especificar cualquier n&uacute;mero de
     descriptor de archivo v&aacute;lido y &eacute;ste ser&aacute;
     pasado al proceso hijo. Esto le permite a su script interoperar
     con otros scripts que corran como "co-procesos". En particular,
     esto es &uacute;til para pasar contrase&ntilde;as a programas
     como PGP, GPG y openssl en un modo m&aacute;s
     seguro. Tambi&eacute;n es &uacute;til para la lectura de
     informaci&oacute;n de status entregada por aquellos programas en
     descriptores de archivo auxiliares.
    </para>
    <note>
     <para>
      Compatibilidad con windows: Los descriptores m&aacute;s
      all&aacute; de 2 (stderr) son entregados al proceso hijo como
      gestores heredables, pero ya que la arquitectura windows no
      asocia n&uacute;meros de descriptor de archivo con gestores de
      bajo nivel, el proceso hijo no dispone (aun) de un medio para
      acceder a esos gestores. Stdin, stdout y stderr funcionan como
      es de esperar.
     </para>
    </note>
    <note>
     <para>
      Si s&oacute;lo necesita un pipe de proceso uni-direccional
      (una-v&iacute;a), use <function>popen</function> en su lugar, ya
      que es mucho m&aacute;s f&aacute;cil de usar.
     </para>
    </note>

    <para>
     Vea tambi&eacute;n <function>stream_select</function>,
     <function>exec</function>,
     <function>system</function>,
     <function>passthru</function>, <function>popen</function>,
     <function>escapeshellcmd</function>, y el <link
     linkend="language.operators.execution">operador de comilla
     invertida</link>.
    </para>

   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
