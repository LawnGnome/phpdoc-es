<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.8 $ -->
<!-- EN-Revision: 1.14 Maintainer: lboshell Status: ready -->
<!-- splitted from ./en/functions/exec.xml, last change in rev 1.28 -->
  <refentry id='function.proc-open'>
   <refnamediv>
    <refname>proc_open</refname>
    <refpurpose>
     Ejecutar un comando y abrir apuntadores de archivo para
     entrada/salida
    </refpurpose>
   </refnamediv>
   <refsect1 role="description">
    &reftitle.description;
     <methodsynopsis>
      <type>resource</type><methodname>proc_open</methodname>
      <methodparam><type>string</type><parameter>cmd</parameter></methodparam>
      <methodparam><type>array</type><parameter>espec_descriptor</parameter></methodparam>
      <methodparam><type>array</type><parameter role="reference">pipes</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>cwd</parameter></methodparam>
      <methodparam choice="opt"><type>array</type><parameter>env</parameter></methodparam>
      <methodparam choice="opt"><type>array</type><parameter>otras_opciones</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>proc_open</function> es similar a
     <function>popen</function> pero provee un grado de control mucho
     mayor sobre la ejecuci&oacute;n del programa.
    </para>
    <para>
     PHP 5 introduce soporte pty para sistemas con ptys Unix98. Esto
     le permite a su script interactuar con aplicaciones que esperan
     hablar con una terminal. Un pty trabaja como un pipe, pero es
     bi-direccional, as&iacute; que no hay necesidad de especificar un
     modo de lectura/escritura. El ejemplo presentado m&aacute;s
     adelante muestra c&oacute;mo usar un pty, note que no tiene que
     tener todos los descriptores hablando con un pty. Tambi&eacute;n
     note que solo un pty es creado, aun cuando se especifica pty 3
     veces. En una futura versi&oacute;n de PHP, puede que sea posible
     hacer m&aacute;s que solo leer y escribir en el pty.
    </para>
   </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>cmd</parameter></term>
     <listitem>
      <para>
       El comando a ejecutar
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>espec_descriptor</parameter></term>
     <listitem>
      <para>
       Una matriz indexada en donde las llaves representan el
       n&uacute;mero del descriptor y el valor representa el modo en
       que PHP pasar&aacute; el descriptor al proceso hijo. 0 es
       stdin, 1 es stdout, y 2 es stderr.
      </para>
      <para>
       Los &uacute;nicos tipos de pipe soportados son
       <literal>file</literal>, <literal>pipe</literal> y
       <literal>pty</literal>.
      </para>
      <para>
       Los n&uacute;meros de descriptor de archivo no se limitan a 0,
       1 y 2 - es posible que especifique cualquier n&uacute;mero de
       descriptor de archivo v&aacute;lido y &eacute;ste ser&aacute;
       pasado al proceso hijo. Esto le permite a su script interoperar
       con otros scripts que corren como "co-procesos". En particular,
       esto es &uacute;til para pasar frases secretas a programas como
       PGP, GPG y openssl de una forma m&aacute;s
       segura. Tambi&eacute;n es &uacute;til para leer
       informaci&oacute;n de status ofrecida por esos programas en
       descriptores de archivo auxiliares.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>pipes</parameter></term>
     <listitem>
      <para>
       Recibir&aacute; como valor una matriz indexada de apuntadores
       de archivo que corresponden a los valores en PHP de los pipes
       creados.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>cwd</parameter></term>
     <listitem>
      <para>
       El directorio de trabajo inicial para el comando. Este debe ser
       una ruta de directorio <emphasis
       role="strong">absoluta</emphasis>, o &null; si desea usar el
       valor predeterminado (el directorio de trabajo del proceso PHP
       actual)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>env</parameter></term>
     <listitem>
      <para>
       Una matriz con las variables de entorno para el comando que
       ser&aacute; ejecutado, o &null; para usar el mismo entorno que
       el proceso PHP actual
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>otras_opciones</parameter></term>
     <listitem>
      <para>
       Le permite especificar opciones adicionales. En la actualidad
       solo se reconoce <literal>suppress_errors</literal>,
       opci&oacute;n que elimina los errores generados por esta
       funci&oacute;n cuando su valor es &true;
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Devuelve un recurso que representa el proceso, el cual debe ser
   liberado usando <function>proc_close</function> cuando haya
   terminado de usarlo. En caso de error, devuelve &false;.
  </para>
 </refsect1>

 <refsect1 role="changelog">
  &reftitle.changelog;
  <para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>5.0.0.</entry>
       <entry>
        Se a&ntilde;adieron los par&aacute;metros
        <parameter>cwd</parameter>, <parameter>env</parameter> y
        <parameter>otras_opciones</parameter>. Se agreg&oacute;
        soporte para ptys Unix98.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>Un ejemplo de <function>proc_open</function></title>
    <programlisting role="php">
<![CDATA[
<?php
$espec_descriptor = array(
   0 => array("pipe", "r"),  // stdin es un pipe usado por el hijo para lectura
   1 => array("pipe", "w"),  // stdout es un pipe usado por el hijo para escritura
   2 => array("file", "/tmp/error-output.txt", "a") // stderr es un archivo para escritura
);

$cwd = '/tmp';
$env = array('una_opcion' => 'aeiou');

$proceso = proc_open('php', $espec_descriptor, $pipes, $cwd, $env);

if (is_resource($proceso)) {
    // $pipes ahora luce de esta forma:
    // 0 => gestor de escritura conectado con la entrada estandar del hijo
    // 1 => gestor de lectura conectado con la salida estandar del hijo
    // Cualquier mensaje de salida de error sera adicionado a /tmp/error-output.txt

    fwrite($pipes[0], '<?php print_r($_ENV); ?>');
    fclose($pipes[0]);

    echo stream_get_contents($pipes[1]);
    fclose($pipes[1]);

    // Es importante que cierre todos los pipes antes de llamar
    // proc_close para evitar un bloqueo muerto
    $retval = proc_close($proceso);

    echo "el comando ha devuelto $retval\n";
}
?>
]]>
      </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Array
(
    [some_option] => aeiou
    [PWD] => /tmp
    [SHLVL] => 1
    [_] => /usr/local/bin/php
)
el comando ha devuelto 0
]]>
    </screen>
   </example>
  </para>
  <para>
   <example>
    <title>Uso de ptys</title>
    <programlisting role="php">
<![CDATA[
<?php
// Crear una pseudo terminal para el proceso hijo
$espec_descriptor = array(
   0 => array("pty"),
   1 => array("pty"),
   2 => array("pty")
);
$proceso = proc_open("cvs -d:pserver:cvsread@cvs.php.net:/repository login", $espec_descriptor, $pipes);
if (is_resource($proceso)) {
   // trabaje con el recurso aqui
}
?>
]]>
    </programlisting>
   </example>
  </para>
 </refsect1>

 <refsect1 role="notes">
  &reftitle.notes;
  <note>
   <para>
    Compatibilidad con Windows: Los descriptores m&aacute;s
    all&aacute; de 2 (stderr) se ponen a disposici&oacute;n del
    proceso hijo como gestores heredables, pero ya que la arquitectura
    de Windows no asocia n&uacute;meros de descriptores de archivo con
    gestores de bajo nivel, el proceso hijo no tiene (aun) una forma
    de acceder a esos gestores. Stdin, stdout y stderr funcionan como
    es de esperarse.
   </para>
  </note>
  <note>
   <para>
    Si solo necesita un pipe de proceso uni-direccional (de una
    v&iacute;a), use <function>popen</function> en su lugar, ya que es
    mucho m&aacute;s f&aacute;cil de usar.
   </para>
  </note>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>popen</function></member>
    <member><function>exec</function></member>
    <member><function>system</function></member>
    <member><function>passthru</function></member>
    <member><function>stream_select</function></member>
    <member>El <link linkend="language.operators.execution">operador
    de comilla invertida</link></member>
   </simplelist>
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
