<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
<!-- EN-Revision: 1.37 Maintainer: lboshell Status: ready -->
<!-- splitted from ./en/functions/http.xml, last change in rev 1.2 -->
  <refentry xml:id="function.setcookie" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
   <refnamediv>
    <refname>setcookie</refname>
    <refpurpose>Enviar una cookie</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripci&oacute;n</title>
     <methodsynopsis>
      <type>bool</type><methodname>setcookie</methodname>
      <methodparam><type>string</type><parameter>nombre</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>valor</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>expirar</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>ruta</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>dominio</parameter></methodparam>
      <methodparam choice="opt"><type>bool</type><parameter>segura</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>setcookie</function> define una cookie para ser enviada
     junto con el resto de las cabeceras HTTP. Como otras cabeceras,
     las cookies deben ser enviadas <emphasis>antes</emphasis> de
     cualquier salida desde su script (esta es una restricci&oacute;n
     de protocolo). Esto requiere que coloque las llamadas a esta
     funci&oacute;n antes de cualquier salida, incluyendo las
     etiquetas <literal>&lt;html&gt;</literal> y
     <literal>&lt;head&gt;</literal> as&iacute; como cualquier espacio
     en blanco. Si existe salida antes de llamar esta funci&oacute;n,
     <function>setcookie</function> fallar&aacute; y devolver&aacute;
     &false;. Si <function>setcookie</function> se ejecuta con
     &eacute;xito, devolver&aacute; &true;. Esto no indica si el
     usuario acept&oacute; la cookie.
    </para>
    <note>
     <para>
      A partir de PHP 4, es posible usar control de b&uacute;feres
      para producir salida antes de llamar esta funci&oacute;n, con
      cierta penalizaci&oacute;n en rendimiento debido a que la salida
      al navegador es almacenada en el servidor hasta ser enviada. Es
      posible hacerlo llamando a <function>ob_start</function> y
      <function>ob_end_flush</function> en su script, o definiendo la
      directiva de configuraci&oacute;n
      <literal>output_buffering</literal> en su archivo &php.ini; o en
      los archivos de configuraci&oacute;n del servidor.
     </para>
    </note>
    <para>
     Todos los argumentos con excepci&oacute;n de
     <parameter>nombre</parameter> son opcionales. Es posible
     tambi&eacute;n reemplazar un argumento con una cadena
     vac&iacute;a (<emphasis>&quot;&quot;</emphasis>) para evitar ese
     argumento. Dado que el argumento <parameter>expirar</parameter>
     es entero, no puede saltarse con una cadena vac&iacute;a, use un
     cero (<emphasis>0</emphasis>) en su lugar. La siguiente tabla
     explica cada par&aacute;metro de la funci&oacute;n
     <function>setcookie</function>, aseg&uacute;rese de leer la
     <link xlink:href="&spec.cookies;">especificaci&oacute;n de cookies de
     Netscape</link> para conocer los detalles sobre c&oacute;mo
     funciona cada par&aacute;metro de <function>setcookie</function>
     y el documento <link xlink:href="&url.rfc;2965">RFC 2965</link> para
     m&aacute;s informaci&oacute;n sobre c&oacute;mo trabajan las
     cookies HTTP.
    </para>
    <para>
     <table>
      <title>Los par&aacute;metros de <function>setcookie</function>
      explicados</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Par&aacute;metro</entry>
         <entry>Descripci&oacute;n</entry>
         <entry>Ejemplos</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><parameter>nombre</parameter></entry>
         <entry>
          El nombre de la cookie.
         </entry>
         <entry>
          'nombre_cookie' es llamada como
          <varname>$_COOKIE['nombre_cookie']</varname>
         </entry>
        </row>
        <row>
         <entry><parameter>valor</parameter></entry>
         <entry>
          El valor de la cookie. Este valor es almacenado en el equipo
          del cliente; no almecene informaci&oacute;n sensible.
         </entry>
         <entry>
          Asumiendo que <parameter>nombre</parameter> es
          'nombre_cookie', este valor es recuperado por medio de
          <varname>$_COOKIE['nombre_cookie']</varname>
         </entry>
        </row>
        <row>
         <entry><parameter>expirar</parameter></entry>
         <entry>
          La hora en la que expira la cookie. Este valor es una marca
          de tiempo Unix as&iacute; que es el n&uacute;mero de
          segundos recorridos desde el epoch. En otras palabras, es
          probable que este valor sea definido con la funci&oacute;n
          <function>time</function> m&aacute;s el n&uacute;mero de
          segundos antes de que usted quiera que expire. O es posible
          usar <function>mktime</function>.
         </entry>
         <entry>
          <literal>time()+60*60*24*30</literal> definir&aacute; que la
          cookie expire en 30 d&iacute;as. Si no se define, la cookie
          expirar&aacute; al final de la sesi&oacute;n (cuando el
          navegador sea cerrado).
         </entry>
        </row>
        <row>
         <entry><parameter>ruta</parameter></entry>
         <entry>
          La ruta en el servidor en la que estar&aacute; disponible la
          cookie.
         </entry>
         <entry>
          Si se define como <literal>'/'</literal>, la cookie
          estar&aacute; disponible en el
          <parameter>dominio</parameter> completo. Si se define como
          <literal>'/foo/'</literal>, la cookie estar&aacute;
          disponible &uacute;nicamente al interior del directorio
          <literal>/foo/</literal> y todos sus subdirectorios en
          <parameter>dominio</parameter> como
          <literal>/foo/bar/</literal>. El valor predeterminado es el
          directorio actual en el que se define la cookie.
         </entry>
        </row>
        <row>
         <entry><parameter>dominio</parameter></entry>
         <entry>
          El dominio en el que la cookie est&aacute; disponible.
         </entry>
         <entry>
          Para lograr que la cookie est&eacute; disponible en todos
          los subdominios de example.com entonces es necesario definir
          este valor como <literal>'.example.com'</literal>. El
          caracter <literal>.</literal> no es requerido pero hace a la
          cookie compatible con m&aacute;s navegadores. Definir su
          valor como <literal>www.example.com</literal> har&aacute;
          que la cookie est&eacute; disponible &uacute;nicamente en el
          subdominio <literal>www</literal>. Refi&eacute;rase a la
          comparaci&oacute;n de sufijos en la <link
          xlink:href="&spec.cookies;">especificaci&oacute;n</link> para
          m&aacute;s detalles.
         </entry>
        </row>
        <row>
         <entry><parameter>segura</parameter></entry>
         <entry>
          Indica que la cookie deber&iacute;a ser transmitida
          &uacute;nicamente sobre una conexi&oacute;n HTTPS
          segura. Cuando su valor es &true;, la cookie ser&aacute;
          definida &uacute;nicamente si existe una conexi&oacute;n
          segura. El valor predeterminado es &false;.
         </entry>
         <entry>
          <literal>0</literal> o <literal>1</literal>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     Una vez se han definido las cookies, ellas pueden ser accesadas
     en la siguiente carga de p&aacute;gina con las matrices <link
     linkend="reserved.variables.cookies">$_COOKIE</link> o
     <varname>$HTTP_COOKIE_VARS</varname>. Note que las variables
     <link
     linkend="language.variables.superglobals">auto-globales</link>
     como <varname>$_COOKIE</varname> aparecieron en PHP <link
     xlink:href="&url.php.release4.1.0;">4.1.0</link>.
     <varname>$HTTP_COOKIE_VARS</varname> ha existido desde PHP 3. Los
     valores de cookies tambi&eacute;n existen en <link
     linkend="reserved.variables.request"> $_REQUEST</link>.
    </para>
    <note>
     <para>
      Si la directiva <link
      linkend="ini.register-globals">register_globals</link>
      est&aacute; definida como <literal>on</literal> entonces los
      valores de cookie tambi&eacute;n ser&aacute;n registrados como
      variables. En nuestros ejemplos siguientes, la variable
      <varname>$CookieDePrueba</varname> existir&aacute;. Es
      recomendable usar <varname>$_COOKIE</varname>.
     </para>
    </note>
    <para>
     Errores Comunes:
     <itemizedlist>
      <listitem>
       <simpara>
        Las cookies no ser&aacute;n visibles hasta la siguiente carga
        de una p&aacute;gina en la que debe estar disponible la
        cookie. Para probar si una cookie ha sido definida
        exitosamente, verifique la cookie en una carga de
        p&aacute;gina siguiente antes de que la cookie expire. El
        tiempo de expiraci&oacute;n es definido mediante el
        par&aacute;metro <parameter>expirar</parameter>. Una forma
        adecuada para depurar la existencia de cookies es simplemente
        llamando <literal>print_r($_COOKIE);</literal>.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Las cookies deben ser eliminadas con los mismos
        par&aacute;metros con los que son creadas. Si el argumento
        valor es una cadena vac&iacute;a, o &false;, y todos los
        dem&aacute;s argumentos coinciden con una llamada previa a
        setcookie, entonces la cookie cen el nombre especificado
        ser&aacute; eliminada del cliente remoto.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Ya que la definici&oacute;n de una cookie con un valor de
        &false; intentar&aacute; eliminar la cookie, no
        deber&iacute;an usarse valores booleanos. En su lugar, use
        <emphasis>0</emphasis> para &false; y <emphasis>1</emphasis>
        para &true;.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Los nombres de cookie pueden ser definidos como nombres de
        matrices y estar&aacute;n disponibles en sus scripts PHP como
        matrices, pero en el sistema del usuario se almacenan cookies
        separadas. Considere el uso de <function>explode</function>
        para definir una cookie con m&uacute;ltiples nombres y
        valores. No es recomendable usar
        <function>serialize</function> para este prop&oacute;sito, ya
        que puede resultar en agujeros de seguridad.
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
    <simpara>
     En PHP 3, m&uacute;ltiples llamadas a
     <function>setcookie</function> en el mismo script ser&aacute;n
     efectuadas en el orden inverso. Si se intenta eliminar una cookie
     antes de insertar otra, es necesario colocar la inserci&oacute;n
     antes de la eliminaci&oacute;n. A partir de PHP 4,
     m&uacute;ltiples llamadas a <function>setcookie</function> son
     realizadas en el orden de llamado.
    </simpara>
    <para>
     A continuaci&oacute;n se presentan algunos ejemplos sobre
     c&oacute;mo enviar cookies:
     <example>
      <title>Ejemplo de env&iacute;o de
      <function>setcookie</function></title>
      <programlisting role="php">
<![CDATA[
<?php
$valor = 'algo desde algun lugar';

setcookie("CookieDePrueba", $valor);
setcookie("CookieDePrueba", $valor, time()+3600);  /* expirar en 1 hora */
setcookie("CookieDePrueba", $valor, time()+3600, "/~rasmus/", ".example.com", 1);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Note que la porci&oacute;n del valor de la cookie ser&aacute;
     codificado (mediante urlencode) autom&aacute;ticamente cuando
     env&iacute;e la cookie, y que al ser recibida la cookie, es
     autom&aacute;ticamente decodificada y asignada a una variable con
     el mismo nombre que la cookie. Si no desea esto, puede usar
     <function>setrawcookie</function> en su lugar, si est&aacute;
     usando PHP 5. Para ver los contenidos de nuestra cookie de prueba
     en un script, simplemente use uno de los siguientes ejemplos:
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// Imprime una cookie individual
echo $_COOKIE["CookieDePrueba"];
echo $HTTP_COOKIE_VARS["CookieDePrueba"];

// Otra forma de depurar/probar es ver todas las cookies
print_r($_COOKIE);
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Al eliminar una cookie, es buena idea asegurarse de que la fecha
     de expiraci&oacute;n sea en el pasado, para activar el mecanismo
     de eliminaci&oacute;n en su navegador. Los siguientes ejemplos
     demuestran c&oacute;mo eliminar cookies enviadas en el ejemplo
     anterior:
    </para>
    <para>
     <example>
      <title>Ejemplo de eliminaci&oacute;n de
      <function>setcookie</function></title>
      <programlisting role="php">
<![CDATA[
<?php
// establecer la fecha de expiracion hace una hora
setcookie ("CookieDePrueba", "", time() - 3600);
setcookie ("CookieDePrueba", "", time() - 3600, "/~rasmus/", ".example.com", 1);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Tambi&eacute;n es posible definir cookies tipo matriz usando una
     notaci&oacute;n de matriz en el nombre de la cookie. Esto tiene
     el efecto de definir tantas cookies como elementos tenga la
     matriz, pero cuando la cookie es recibida por su script, los
     valores son todos colocados en una matriz con el nombre de la
     cookie:
    </para>
    <para>
     <example>
      <title><function>setcookie</function> y matrices</title>
      <programlisting role="php">
<![CDATA[
<?php
// definir las cookies
setcookie("cookie[tres]", "cookietres");
setcookie("cookie[dos]", "cookiedos");
setcookie("cookie[uno]", "cookieuno");

// luego de que la pagina recarga, imprimirlas
if (isset($_COOKIE['cookie'])) {
    foreach ($_COOKIE['cookie'] as $nombre => $valor) {
        echo "$nombre : $valor <br />\n";
    }
}
?>
]]>
      </programlisting>
      <para>
       lo cual imprime
      </para>
      <screen>
<![CDATA[
tres : cookietres
dos : cookiedos
uno : cookieuno
]]>
      </screen>
     </example>
    </para>
    <note>
     <para>
      Los siguientes documentos RFC pueden resultar &uacute;tiles
      tambi&eacute;n: <link xlink:href="&url.rfc;2109">RFC 2109</link> y
      <link xlink:href="&url.rfc;2965">RFC 2695</link>
     </para>
     <para>
      Puede que haya notado que el par&aacute;metro
      <parameter>expirar</parameter> recibe una marca de tiempo Unix,
      en lugar del formato de fecha <literal>Dia, DD-Mes-YYYY HH:MM:SS
      GMT</literal>, esto se debe a que PHP realiza esta
      conversi&oacute;n internamente.
     </para>
     <para>
      <parameter>expirar</parameter> es comparado con la hora del
      cliente, la cual puede diferir de la hora del servidor.
     </para>
    </note>
    <note>
     <simpara>
      Microsoft Internet Explorer 4 con el Service Pack 1 aplicado no
      maneja correctamente las cookies que tienen su par&aacute;metro
      de ruta definido.
     </simpara>
     <simpara>
      Parece que Netscape Communicator 4.05 y Microsoft Internet
      Explorer 3.x manejan las cookies incorrectamente cuando la ruta
      y hora no son definidas.
     </simpara>
    </note>
    <para>
     Vea tambi&eacute;n <function>header</function>,
     <function>setrawcookie</function> y la <link
     linkend="features.cookies">secci&oacute;n sobre cookies</link>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
