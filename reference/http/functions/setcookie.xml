<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
<!-- EN-Revision: 1.37 Maintainer: lboshell Status: ready -->
<!-- splitted from ./en/functions/http.xml, last change in rev 1.2 -->
  <refentry xml:id="function.setcookie" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
   <refnamediv>
    <refname>setcookie</refname>
    <refpurpose>Enviar una cookie</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
     <methodsynopsis>
      <type>bool</type><methodname>setcookie</methodname>
      <methodparam><type>string</type><parameter>nombre</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>valor</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>expirar</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>ruta</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>dominio</parameter></methodparam>
      <methodparam choice="opt"><type>bool</type><parameter>segura</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>setcookie</function> define una cookie para ser enviada
     junto con el resto de las cabeceras HTTP. Como otras cabeceras,
     las cookies deben ser enviadas <emphasis>antes</emphasis> de
     cualquier salida desde su script (esta es una restricción
     de protocolo). Esto requiere que coloque las llamadas a esta
     función antes de cualquier salida, incluyendo las
     etiquetas <literal>&lt;html&gt;</literal> y
     <literal>&lt;head&gt;</literal> así como cualquier espacio
     en blanco. Si existe salida antes de llamar esta función,
     <function>setcookie</function> fallará y devolver&aacute;
     &false;. Si <function>setcookie</function> se ejecuta con
     éxito, devolverá &true;. Esto no indica si el
     usuario aceptó la cookie.
    </para>
    <note>
     <para>
      A partir de PHP 4, es posible usar control de búferes
      para producir salida antes de llamar esta función, con
      cierta penalización en rendimiento debido a que la salida
      al navegador es almacenada en el servidor hasta ser enviada. Es
      posible hacerlo llamando a <function>ob_start</function> y
      <function>ob_end_flush</function> en su script, o definiendo la
      directiva de configuración
      <literal>output_buffering</literal> en su archivo &php.ini; o en
      los archivos de configuración del servidor.
     </para>
    </note>
    <para>
     Todos los argumentos con excepción de
     <parameter>nombre</parameter> son opcionales. Es posible
     también reemplazar un argumento con una cadena
     vacía (<emphasis>&quot;&quot;</emphasis>) para evitar ese
     argumento. Dado que el argumento <parameter>expirar</parameter>
     es entero, no puede saltarse con una cadena vacía, use un
     cero (<emphasis>0</emphasis>) en su lugar. La siguiente tabla
     explica cada parámetro de la función
     <function>setcookie</function>, asegúrese de leer la
     <link xlink:href="&spec.cookies;">especificación de cookies de
     Netscape</link> para conocer los detalles sobre cómo
     funciona cada parámetro de <function>setcookie</function>
     y el documento <link xlink:href="&url.rfc;2965">RFC 2965</link> para
     más información sobre c&oacute;mo trabajan las
     cookies HTTP.
    </para>
    <para>
     <table>
      <title>Los parámetros de <function>setcookie</function>
      explicados</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Parámetro</entry>
         <entry>Descripción</entry>
         <entry>Ejemplos</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><parameter>nombre</parameter></entry>
         <entry>
          El nombre de la cookie.
         </entry>
         <entry>
          'nombre_cookie' es llamada como
          <varname>$_COOKIE['nombre_cookie']</varname>
         </entry>
        </row>
        <row>
         <entry><parameter>valor</parameter></entry>
         <entry>
          El valor de la cookie. Este valor es almacenado en el equipo
          del cliente; no almecene información sensible.
         </entry>
         <entry>
          Asumiendo que <parameter>nombre</parameter> es
          'nombre_cookie', este valor es recuperado por medio de
          <varname>$_COOKIE['nombre_cookie']</varname>
         </entry>
        </row>
        <row>
         <entry><parameter>expirar</parameter></entry>
         <entry>
          La hora en la que expira la cookie. Este valor es una marca
          de tiempo Unix así que es el número de
          segundos recorridos desde el epoch. En otras palabras, es
          probable que este valor sea definido con la función
          <function>time</function> más el número de
          segundos antes de que usted quiera que expire. O es posible
          usar <function>mktime</function>.
         </entry>
         <entry>
          <literal>time()+60*60*24*30</literal> definirá que la
          cookie expire en 30 días. Si no se define, la cookie
          expirará al final de la sesión (cuando el
          navegador sea cerrado).
         </entry>
        </row>
        <row>
         <entry><parameter>ruta</parameter></entry>
         <entry>
          La ruta en el servidor en la que estará disponible la
          cookie.
         </entry>
         <entry>
          Si se define como <literal>'/'</literal>, la cookie
          estará disponible en el
          <parameter>dominio</parameter> completo. Si se define como
          <literal>'/foo/'</literal>, la cookie estará
          disponible únicamente al interior del directorio
          <literal>/foo/</literal> y todos sus subdirectorios en
          <parameter>dominio</parameter> como
          <literal>/foo/bar/</literal>. El valor predeterminado es el
          directorio actual en el que se define la cookie.
         </entry>
        </row>
        <row>
         <entry><parameter>dominio</parameter></entry>
         <entry>
          El dominio en el que la cookie está disponible.
         </entry>
         <entry>
          Para lograr que la cookie esté disponible en todos
          los subdominios de example.com entonces es necesario definir
          este valor como <literal>'.example.com'</literal>. El
          caracter <literal>.</literal> no es requerido pero hace a la
          cookie compatible con más navegadores. Definir su
          valor como <literal>www.example.com</literal> hará
          que la cookie esté disponible únicamente en el
          subdominio <literal>www</literal>. Refiérase a la
          comparación de sufijos en la <link
          xlink:href="&spec.cookies;">especificación</link> para
          más detalles.
         </entry>
        </row>
        <row>
         <entry><parameter>segura</parameter></entry>
         <entry>
          Indica que la cookie debería ser transmitida
          únicamente sobre una conexión HTTPS
          segura. Cuando su valor es &true;, la cookie será
          definida únicamente si existe una conexión
          segura. El valor predeterminado es &false;.
         </entry>
         <entry>
          <literal>0</literal> o <literal>1</literal>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     Una vez se han definido las cookies, ellas pueden ser accesadas
     en la siguiente carga de página con las matrices <link
     linkend="reserved.variables.cookies">$_COOKIE</link> o
     <varname>$HTTP_COOKIE_VARS</varname>. Note que las variables
     <link
     linkend="language.variables.superglobals">auto-globales</link>
     como <varname>$_COOKIE</varname> aparecieron en PHP <link
     xlink:href="&url.php.release4.1.0;">4.1.0</link>.
     <varname>$HTTP_COOKIE_VARS</varname> ha existido desde PHP 3. Los
     valores de cookies también existen en <link
     linkend="reserved.variables.request"> $_REQUEST</link>.
    </para>
    <note>
     <para>
      Si la directiva <link
      linkend="ini.register-globals">register_globals</link>
      está definida como <literal>on</literal> entonces los
      valores de cookie también serán registrados como
      variables. En nuestros ejemplos siguientes, la variable
      <varname>$CookieDePrueba</varname> existirá. Es
      recomendable usar <varname>$_COOKIE</varname>.
     </para>
    </note>
    <para>
     Errores Comunes:
     <itemizedlist>
      <listitem>
       <simpara>
        Las cookies no serán visibles hasta la siguiente carga
        de una página en la que debe estar disponible la
        cookie. Para probar si una cookie ha sido definida
        exitosamente, verifique la cookie en una carga de
        página siguiente antes de que la cookie expire. El
        tiempo de expiración es definido mediante el
        parámetro <parameter>expirar</parameter>. Una forma
        adecuada para depurar la existencia de cookies es simplemente
        llamando <literal>print_r($_COOKIE);</literal>.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Las cookies deben ser eliminadas con los mismos
        parámetros con los que son creadas. Si el argumento
        valor es una cadena vacía, o &false;, y todos los
        demás argumentos coinciden con una llamada previa a
        setcookie, entonces la cookie cen el nombre especificado
        será eliminada del cliente remoto.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Ya que la definición de una cookie con un valor de
        &false; intentará eliminar la cookie, no
        deberían usarse valores booleanos. En su lugar, use
        <emphasis>0</emphasis> para &false; y <emphasis>1</emphasis>
        para &true;.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Los nombres de cookie pueden ser definidos como nombres de
        matrices y estarán disponibles en sus scripts PHP como
        matrices, pero en el sistema del usuario se almacenan cookies
        separadas. Considere el uso de <function>explode</function>
        para definir una cookie con múltiples nombres y
        valores. No es recomendable usar
        <function>serialize</function> para este propósito, ya
        que puede resultar en agujeros de seguridad.
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
    <simpara>
     En PHP 3, múltiples llamadas a
     <function>setcookie</function> en el mismo script serán
     efectuadas en el orden inverso. Si se intenta eliminar una cookie
     antes de insertar otra, es necesario colocar la inserción
     antes de la eliminación. A partir de PHP 4,
     múltiples llamadas a <function>setcookie</function> son
     realizadas en el orden de llamado.
    </simpara>
    <para>
     A continuación se presentan algunos ejemplos sobre
     cómo enviar cookies:
     <example>
      <title>Ejemplo de envío de
      <function>setcookie</function></title>
      <programlisting role="php">
<![CDATA[
<?php
$valor = 'algo desde algun lugar';

setcookie("CookieDePrueba", $valor);
setcookie("CookieDePrueba", $valor, time()+3600);  /* expirar en 1 hora */
setcookie("CookieDePrueba", $valor, time()+3600, "/~rasmus/", ".example.com", 1);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Note que la porción del valor de la cookie será
     codificado (mediante urlencode) automáticamente cuando
     envíe la cookie, y que al ser recibida la cookie, es
     automáticamente decodificada y asignada a una variable con
     el mismo nombre que la cookie. Si no desea esto, puede usar
     <function>setrawcookie</function> en su lugar, si está
     usando PHP 5. Para ver los contenidos de nuestra cookie de prueba
     en un script, simplemente use uno de los siguientes ejemplos:
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// Imprime una cookie individual
echo $_COOKIE["CookieDePrueba"];
echo $HTTP_COOKIE_VARS["CookieDePrueba"];

// Otra forma de depurar/probar es ver todas las cookies
print_r($_COOKIE);
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Al eliminar una cookie, es buena idea asegurarse de que la fecha
     de expiración sea en el pasado, para activar el mecanismo
     de eliminación en su navegador. Los siguientes ejemplos
     demuestran cómo eliminar cookies enviadas en el ejemplo
     anterior:
    </para>
    <para>
     <example>
      <title>Ejemplo de eliminación de
      <function>setcookie</function></title>
      <programlisting role="php">
<![CDATA[
<?php
// establecer la fecha de expiracion hace una hora
setcookie ("CookieDePrueba", "", time() - 3600);
setcookie ("CookieDePrueba", "", time() - 3600, "/~rasmus/", ".example.com", 1);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     También es posible definir cookies tipo matriz usando una
     notación de matriz en el nombre de la cookie. Esto tiene
     el efecto de definir tantas cookies como elementos tenga la
     matriz, pero cuando la cookie es recibida por su script, los
     valores son todos colocados en una matriz con el nombre de la
     cookie:
    </para>
    <para>
     <example>
      <title><function>setcookie</function> y matrices</title>
      <programlisting role="php">
<![CDATA[
<?php
// definir las cookies
setcookie("cookie[tres]", "cookietres");
setcookie("cookie[dos]", "cookiedos");
setcookie("cookie[uno]", "cookieuno");

// luego de que la pagina recarga, imprimirlas
if (isset($_COOKIE['cookie'])) {
    foreach ($_COOKIE['cookie'] as $nombre => $valor) {
        echo "$nombre : $valor <br />\n";
    }
}
?>
]]>
      </programlisting>
      <para>
       lo cual imprime
      </para>
      <screen>
<![CDATA[
tres : cookietres
dos : cookiedos
uno : cookieuno
]]>
      </screen>
     </example>
    </para>
    <note>
     <para>
      Los siguientes documentos RFC pueden resultar útiles
      también: <link xlink:href="&url.rfc;2109">RFC 2109</link> y
      <link xlink:href="&url.rfc;2965">RFC 2695</link>
     </para>
     <para>
      Puede que haya notado que el parámetro
      <parameter>expirar</parameter> recibe una marca de tiempo Unix,
      en lugar del formato de fecha <literal>Dia, DD-Mes-YYYY HH:MM:SS
      GMT</literal>, esto se debe a que PHP realiza esta
      conversión internamente.
     </para>
     <para>
      <parameter>expirar</parameter> es comparado con la hora del
      cliente, la cual puede diferir de la hora del servidor.
     </para>
    </note>
    <note>
     <simpara>
      Microsoft Internet Explorer 4 con el Service Pack 1 aplicado no
      maneja correctamente las cookies que tienen su parámetro
      de ruta definido.
     </simpara>
     <simpara>
      Parece que Netscape Communicator 4.05 y Microsoft Internet
      Explorer 3.x manejan las cookies incorrectamente cuando la ruta
      y hora no son definidas.
     </simpara>
    </note>
    <para>
     Vea también <function>header</function>,
     <function>setrawcookie</function> y la <link
     linkend="features.cookies">sección sobre cookies</link>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
