<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.5 $ -->
<!-- EN-Revision: 1.10 Maintainer: lboshell Status: ready -->
<refentry xml:id="function.create-function" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>create_function</refname>
  <refpurpose>Crear una función anónima (estilo-lambda)</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>string</type><methodname>create_function</methodname>
   <methodparam><type>string</type><parameter>args</parameter></methodparam>
   <methodparam><type>string</type><parameter>codigo</parameter></methodparam>
  </methodsynopsis>
  <para>
   Crea una función anónima con los parámetros pasados, y devuelve un nombre
   único para ella.
  </para>
 </refsect1>
 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   Por lo general estos parámetros serán pasados como cadenas delimitadas
   por comillas sencillas. La razón para usar cadenas entre comillas
   sencillas es evitar que los nombres de variables sean interpretados, de
   otro modo, si usa comillas dobles será necesario escapar los nombres de
   variables, p.ej.  <literal>\$una_var</literal>.
   <variablelist>
    <varlistentry>
     <term><parameter>args</parameter></term>
     <listitem>
      <para>
       Los argumentos de la función.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>codigo</parameter></term>
     <listitem>
      <para>
       El código de la función.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Devuelve un nombre de función único como una cadena, o &false; en caso de
   error.
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>
     Creación de una función anónima con
     <function>create_function</function>
    </title>
    <para>
     Es posible usar esta función para (por ejemplo) crear una función con
     información obtenida en tiempo de ejecución:
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$nueva_func = create_function('$a,$b', 'return "ln($a) + ln($b) = " . log($a * $b);');
echo "Nueva función anónima: $nueva_func\n";
echo $nueva_func(2, M_E) . "\n";
// imprime
// Nueva función anónima: lambda_1
// ln(2) + ln(2.718281828459) = 1.6931471805599
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   O, quizás para tener una función de gestión general que pueda aplicar un
   conjunto de operaciones a una lista de parámetros:
  </para>
  <para>
   <example>
    <title>
     Creación de una función general de procesamiento con
     <function>create_function</function>
    </title>
    <programlisting role="php">
<![CDATA[
<?php
function procesar($var1, $var2, $f_matriz)
{
    foreach ($f_matriz as $f) {
        echo $f($var1, $var2) . "\n";
    }
}

// crear un grupo de funciones matemáticas
$f1 = 'if ($a >=0) {return "b*a^2 = ".$b*sqrt($a);} else {return false;}';
$f2 = "return \"min(b^2+a, a^2,b) = \".min(\$a*\$a+\$b,\$b*\$b+\$a);";
$f3 = 'if ($a > 0 && $b != 0) {return "ln(a)/b = ".log($a)/$b; } else { return false; }';
$f_matriz = array(
    create_function('$x,$y', 'return "operación trigonométrica: ".(sin($x) + $x*cos($y));'),
    create_function('$x,$y', 'return "una hipotenusa: ".sqrt($x*$x + $y*$y);'),
    create_function('$a,$b', $f1),
    create_function('$a,$b', $f2),
    create_function('$a,$b', $f3)
    );

echo "\nUsando la primera matriz de funciones anónimas\n";
echo "parámetros: 2.3445, M_PI\n";
procesar(2.3445, M_PI, $f_matriz);

// ahora crear un grupo de funciones de procesamiento de cadenas
$g_matriz = array(
    create_function('$b,$a', 'if (strncmp($a, $b, 3) == 0) return "¡** \"$a\" '.
    'y \"$b\"\n ** lucen igual! (mirando los 3 primeros caracteres)";'),
    create_function('$a,$b', '; return "CRCs: " . crc32($a) . " , ".crc32(b);'),
    create_function('$a,$b', '; return "similar(a,b) = " . similar_text($a, $b, &$p) . "($p%)";')
    );
echo "\nUsando la segunda matriz de funciones anónimas\n";
procesar("Twas brilling and the slithy toves", "Twas the night", $g_matriz);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Usando la primera matriz de funciones anónimas
parámetros: 2.3445, M_PI
operación trigonométrica: -1.6291725057799
una hipotenusa: 3.9199852871011
b*a^2 = 4.8103313314525
min(b^2+a, a^2,b) = 8.6382729035898
ln(a/b) = 0.27122299212594

Usando la segunda matriz de funciones anónimas
¡** "Twas the night" y "Twas brilling and the slithy toves"
 ** lucen igual! (mirando los 3 primeros caracteres)
CRCs: -725381282 , 1908338681
similar(a,b) = 11(45.833333333333%)
]]>
    </screen>
   </example>
  </para>
  <para>
   Pero quizás el uso más común para funciones estilo-lambda (anónimas) es
   crear llamadas de retorno, por ejemplo cuando se usa
   <function>array_walk</function> o <function>usort</function>
  </para>
  <para>
   <example>
    <title>Uso de funciones anónimas como llamadas de retorno</title>
    <programlisting role="php">
<![CDATA[
<?php
$av = array("el ", "un ", "ese ", "este ");
array_walk($av, create_function('&$v,$k', '$v = $v . "mango";'));
print_r($av);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Array
(
  [0] => el mango
  [1] => un mango
  [2] => ese mango
  [3] => este mango
)
]]>
    </screen>
    <para>
     una matriz de cadenas ordenadas desde la más corta a la más larga
    </para>
    <programlisting role="php">
<![CDATA[
<?php

$sv = array("corta", "mas larga", "una cadena grande", "es una cosa como una cadena");
print_r($sv);

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Array
(
    [0] => corta
    [1] => mas larga
    [2] => una cadena grande
    [3] => es una cosa como una cadena
)
]]>
    </screen>
    <para>
     ordenarla desde la más larga a la más corta
    </para>
    <programlisting role="php">
<![CDATA[
<?php

usort($sv, create_function('$a,$b','return strlen($b) - strlen($a);'));
print_r($sv);

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Array
(
    [0] => es una cosa como una cadena
    [1] => una cadena grande
    [2] => mas larga
    [3] => corta
)
]]>
    </screen>
   </example>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
