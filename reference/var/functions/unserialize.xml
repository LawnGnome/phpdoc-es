<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.8 $ -->
<!-- EN-Revision: 1.19 Maintainer: lboshell Status: ready -->
<!-- splitted from ./en/functions/var.xml, last change in rev 1.2 -->
  <refentry xml:id="function.unserialize" xmlns="http://docbook.org/ns/docbook">
   <refnamediv>
    <refname>unserialize</refname>
    <refpurpose>
      Crea un valor PHP a partir de una representación almacenada
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
     <methodsynopsis>
      <type>mixed</type><methodname>unserialize</methodname>
      <methodparam><type>string</type><parameter>cadena</parameter></methodparam>
     </methodsynopsis>
    <simpara>
     <function>unserialize</function> toma una variable sencilla
     seriada (vea <function>serialize</function>) y la convierte de
     vuelta a su valor PHP. El valor convertido es retornado, y puede
     ser un <type>boolean</type>, <type>integer</type>,
     <type>float</type>, <type>string</type>, <type>array</type> u
     <type>object</type>. En caso de que la cadena pasada no pueda ser
     procesada para revertir la seriación, se devuelve &false; y un
     error de tipo <literal>E_NOTICE</literal> es generado.
    </simpara>
    <warning>
     <para>
      &false; es devuelto tanto en el caso de un error como cuando se
      convierte el valor seriado &false;. Es posible atrapar este caso
      especial comparando <parameter>cadena</parameter> con
      <literal>serialize(false)</literal> o atrapando el error
      <literal>E_NOTICE</literal> generado.
     </para>
    </warning>
    <note>
     <title>Directiva unserialize_callback_func</title>
     <para>
      Es posible establecer una función-llamada de retorno la cual
      será llamada si una clase no definida debería ser instanciada
      durante el proceso de revertir la seriación. (para prevenir que
      se reciba un <type>object</type> incompleto
      "__PHP_Incomplete_Class".) Use su &php.ini;,
      <function>ini_set</function> o &htaccess; para definir
      'unserialize_callback_func'. Cada vez que una clase no definida
      deba ser instanciada, esta función será llamada. Para
      deshabilitar esta característica simplemente asigne un valor
      vacío a este parámetro. También note que la directiva
      unserialize_callback_func se hizo disponible en PHP 4.2.0.
     </para>
    </note>
    <para>
     Si la variable que está siendo convertida de vuelta es un objeto,
     PHP intentará llamar la función miembro
     <function>__wakeup</function> (si existe) automáticamente luego
     de haber recontruido satisfactoriamente el objeto.
     <example>
      <title>Ejemplo de unserialize_callback_func</title>
      <programlisting role="php">
<![CDATA[
<?php
$objeto_seriado='O:1:"a":1:{s:5:"valor";s:3:"100";}';

// la directiva unserialize_callback_func está disponible a partir de PHP 4.2.0
ini_set('unserialize_callback_func', 'mi_llamada_de_retorno'); // defina su callback_function

function mi_llamada_de_retorno($nombre_clase)
{
    // tan solo incluya un archivo que contenga su definición de clase

    // usted recibe $nombre_clase para determinar qué definición de
    // clase requiere
}
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      En PHP 3, los métodos no se preservan cuando se revierte un
      objeto seriado. Esa limitación fue retirada en PHP 4 ya que
      tanto las propiedades como los métodos se almacenan ahora. Por
      favor consulte la sección <link
      linkend="language.oop.serialization">Seriación de Objetos</link>
      de <link linkend="language.oop">Clases y Objetos</link> para más
      información.
     </para>
    </note>
    <para>
     <example>
      <title>Ejemplo de <function>unserialize</function></title>
      <programlisting role="php">
<![CDATA[
<?php
// Aquí usamos unserialize() para cargar los datos de sesión
// provenientes de la cadena seleccionada desde la base de datos en la
// matriz $datos_sesion. Este ejemplo complementa aquél descrito con
// serialize().

$con  = odbc_connect("bd_web", "php", "gallina");
$sent = odbc_prepare($con, "SELECT datos FROM sesiones WHERE id = ?");
$datos_sql = array ($PHP_AUTH_USER);

if (!odbc_execute($sent, &$datos_sql) || !odbc_fetch_into($sent, &$tmp)) {
    // si la ejecución del comando o la recuperación de datos falla,
    // inicializar una matriz vacía
    $datos_sesion = array();
} else {
    // ahora deberíamos tener los datos seriados en $tmp[0].
    $datos_sesion = unserialize($tmp[0]);
    if (!is_array($datos_sesion)) {
        // algo ha fallado, inicializar una matriz vacía
        $datos_sesion = array();
    }
}
?>
]]>
      </programlisting>
     </example>
    </para>
   <para>
    Vea también <function>serialize</function>.
   </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
