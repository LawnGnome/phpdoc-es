<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.7 $ -->
<!-- EN-Revision: 1.20 Maintainer: lboshell Status: ready -->
<refentry xml:id="function.sprintf" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>sprintf</refname>
  <refpurpose>Devuelve una cadena con formato</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>string</type><methodname>sprintf</methodname>
   <methodparam><type>string</type><parameter>formato</parameter></methodparam>
   <methodparam choice="opt"><type>mixed</type><parameter>args</parameter></methodparam>
   <methodparam choice="opt"><type>mixed</type><parameter>...</parameter></methodparam>
  </methodsynopsis>
  <para>
   Devuelve una cadena producida de acuerdo con la cadena de formato
   <parameter>formato</parameter>.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>formato</parameter></term>
     <listitem>
      <para>
       La cadena de formato se compone de cero o más directivas: caracteres
       ordinarios (excluyendo <literal>%</literal>) que son copiados
       directamente en el resultado, y unas <emphasis>especificaciones de
       conversión</emphasis>, cada una de las cuales produce una búsqueda
       por su propio parámetro. Esto se aplica tanto en
       <function>sprintf</function> como en <function>printf</function>.
      </para>
      <para>
       Cada especificación de conversión consiste de un signo de porcentaje
       (<literal>%</literal>), seguido por uno o más de los siguientes
       elementos, en orden:
       <orderedlist>
        <listitem>
         <simpara>
          Un <emphasis>indicador de signo</emphasis> opcional que obliga a
          que se use un determinado signo (- o +) en un número. De forma
          predeterminada, sólo el signo - es usado en un número si éste es
          negativo. Este indicador obliga a los números positivos a que
          tengan también el signo + adjunto, comportamiento que se agregó en
          PHP 4.3.0.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Un <emphasis>indicador de relleno</emphasis> opcional, que dice
          qué caracter será usado para adaptar el resultado al tamaño de
          cadena apropiado. Este puede ser un caracter de espacio, o un
          <literal>0</literal> (caracter cero). El comportamiento
          predeterminado es rellenar con espacios. Un caracter de relleno
          alternativo puede especificarse al colocar una comilla sencilla
          (<literal>'</literal>) al comienzo. Vea los ejemplos más adelante.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Un <emphasis>indicador de alineamiento</emphasis> opcional que
          dice si el resultado debe alinearse a la izquierda o a la derecha.
          El comportamiento predeterminado es alinear a la derecha; un
          caracter <literal>-</literal> en este lugar hace que la alineación
          sea a la izquierda.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Un número opcional, un <emphasis>indicador de ancho</emphasis> que
          dice cuántos caracteres (como mínimo) debe producir la conversión.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Un <emphasis>indicador de precisión</emphasis> opcional que dice
          cuántos dígitos decimales deben mostrarse para los números de
          punto flotante. Cuando se usa este indicador con una cadena, actúa
          como un punto de corte, indicando un límite máximo de caracteres
          para la cadena.
         </simpara>
        </listitem>
        <listitem>
         <para>
          Un <emphasis>indicador de tipo</emphasis> que especifica el tipo
          bajo el que deben tratarse los datos del argumento. Los posibles
          tipos son:
          <simplelist>
           <member>
            <literal>%</literal> - un caracter de porcentaje literal. No
            requiere argumento.
           </member>
           <member>
            <literal>b</literal> - el argumento es tratado como un entero,
            presentado como un número binario.
           </member>
           <member>
            <literal>c</literal> - el argumento es tratado como un entero, y
            presentado como el caracter con ese valor ASCII.
           </member>
           <member>
            <literal>d</literal> - el argumento es tratado como un entero, y
            presentado como un número decimal (con signo).
           </member>
           <member>
            <literal>e</literal> - el argumento es tratado como notación
            científica (p.ej. 1.2e+2). El especificador de precisión indica
            el número de dígitos después del punto decimal a partir de PHP
            5.2.1. En versiones anteriores, era tomado como el número de
            dígitos significativos (uno menos).
           </member>
           <member>
            <literal>u</literal> - el argumento es tratado como un entero, y
            presentado como un número decimal sin signo.
           </member>
           <member>
            <literal>f</literal> - el argumento es tratado como un flotante,
            y presentado como un número de punto flotante (teniendo en
            cuenta la localidad).
           </member>
           <member>
            <literal>F</literal> - el argumento es tratado como un flotante,
            y presentado como un número de punto flotante (no tiene en
            cuenta la localidad). Disponible desde PHP 4.3.10 y PHP 5.0.3.
           </member>
           <member>
            <literal>o</literal> - el argumento es tratado como un entero, y
            presentado como un número octal.
           </member>
           <member>
            <literal>s</literal> - el argumento es tratado y presentado como
            una cadena.
           </member>
           <member>
            <literal>x</literal> - el argumento es tratado como un entero y
            presentado como un número hexadecimal (con letras minúsculas).
           </member>
           <member>
            <literal>X</literal> - el argumento es tratado como un entero y
            presentado como un número hexadecimal (con letras mayúsculas).
           </member>
          </simplelist>
         </para>
        </listitem>
       </orderedlist>
      </para>
      <para>
       La cadena de formato soporta la numeración/intercambio de argumentos.
       He aquí un ejemplo:
       <example>
        <title>Intercambio de argumentos</title>
        <programlisting role="php">
<![CDATA[
<?php
$formato = 'Hay %d monos en el %s';
printf($formato, $num, $ubicacion);
?>
]]>
        </programlisting>
       </example>
       Esto podría imprimir, "Hay 5 monos en el árbol". Pero imagine que
       creamos una cadena de formato en un archivo separado, generalmente
       por que queremos implementar un mecanismo de internacionalización, y
       re-escribimos el código:
       <example>
        <title>Intercambio de argumentos</title>
        <programlisting role="php">
<![CDATA[
<?php
$formato = 'El %s contiene %d monos';
printf($formato, $num, $ubicacion);
?>
]]>
        </programlisting>
       </example>
       Ahora tenemos un problema. El orden de los recipientes en la cadena
       de formato no coincide con el orden de los argumentos en el código.
       Quisiéramos dejar el código tal como está, y simplemente indicar en
       la cadena de formato cuáles argumentos están siendo referidos por los
       recipientes. Entonces re-escribiríamos la cadena de formato de esta
       forma:
       <example>
        <title>Intercambio de argumentos</title>
        <programlisting role="php">
<![CDATA[
<?php
$formato = 'El %2$s contiene %1$d monos';
printf($formato, $num, $ubicacion);
?>
]]>
        </programlisting>
       </example>
       Un beneficio adicional de esto es que puede repetir los recipientes
       sin agregar más argumentos en el código. Por ejemplo:
       <example>
        <title>Intercambio de argumentos</title>
        <programlisting role="php">
<![CDATA[
<?php
$formato = 'El %2$s contiene %1$d monos.
            Se trata de un bonito %2$s lleno con %1$d monos.';
printf($formato, $num, $ubicacion);
?>
]]>
        </programlisting>
       </example>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>args</parameter></term>
     <listitem>
      <para>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>...</parameter></term>
     <listitem>
      <para>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Devuelve una cadena producida de acuerdo a la cadena de formato
   <parameter>formato</parameter>.
  </para>
 </refsect1>

 <refsect1 role="changelog">
  &reftitle.changelog;
  <para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>4.0.6</entry>
       <entry>
        Se agregó el soporte para el intercambio y la numeración de
        argumentos
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <example>
   <title><function>printf</function>: ejemplos varios</title>
   <programlisting role="php">
<![CDATA[
<?php
$n =  43951789;
$u = -43951789;
$c = 65; // el valor ASCII 65 es 'A'

// note el doble %%, esto imprime un caracter '%' literal
printf("%%b = '%b'\n", $n); // representación binaria
printf("%%c = '%c'\n", $c); // imprime el caracter ascii, igual que la función chr()
printf("%%d = '%d'\n", $n); // representación de entero estándar
printf("%%e = '%e'\n", $n); // notación científica
printf("%%u = '%u'\n", $n); // representación entera sin signo de un entero positivo
printf("%%u = '%u'\n", $u); // representación entera sin signo de un entero negativo
printf("%%f = '%f'\n", $n); // representación en punto flotante
printf("%%o = '%o'\n", $n); // representación octal
printf("%%s = '%s'\n", $n); // representación de cadena
printf("%%x = '%x'\n", $n); // representación hexadecimal (minúsculas)
printf("%%X = '%X'\n", $n); // representación hexadecimal (mayúsculas)

printf("%%+d = '%+d'\n", $n); // indicador de signo en un entero positivo
printf("%%+d = '%+d'\n", $u); // indicador de signo en un entero negativo
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
%b = '10100111101010011010101101'
%c = 'A'
%d = '43951789'
%e = '4.39518e+7'
%u = '43951789'
%u = '4251015507'
%f = '43951789.000000'
%o = '247523255'
%s = '43951789'
%x = '29ea6ad'
%X = '29EA6AD'
%+d = '+43951789'
%+d = '-43951789'
]]>
   </screen>
  </example>
  <example>
   <title><function>printf</function>: indicadores de cadena</title>
   <programlisting role="php">
<![CDATA[
<?php
$s = 'mono';
$t = 'varios monos';

printf("[%s]\n",      $s); // salida de cadena estándar
printf("[%10s]\n",    $s); // alineación a derecha con espacios
printf("[%-10s]\n",   $s); // alineación a izquierda con espacios
printf("[%010s]\n",   $s); // el relleno con ceros funciona con cadenas también
printf("[%'#10s]\n",  $s); // usar el caracter de relleno '#'
printf("[%10.10s]\n", $t); // alineación a izquierda pero con un corte de 10 caracteres
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
[mono]
[      mono]
[mono      ]
[000000mono]
[######mono]
[varios mon]
]]>
   </screen>
  </example>
  <example>
   <title><function>sprintf</function>: enteros con relleno de
   ceros</title>
   <programlisting role="php">
<![CDATA[
<?php
$fecha_iso = sprintf("%04d-%02d-%02d", $anyo, $mes, $dia);
?>
]]>
   </programlisting>
  </example>
  <example>
   <title><function>sprintf</function>: formato de valores
   monetarios</title>
   <programlisting role="php">
<![CDATA[
<?php
$dinero1 = 68.75;
$dinero2 = 54.35;
$dinero = $dinero1 + $dinero2;
// echo $dinero imprimiría "123.1";
$con_formato = sprintf("%01.2f", $dinero);
// echo $con_formato imprime "123.10"
?>
]]>
   </programlisting>
  </example>
  <example>
   <title><function>sprintf</function>: notación científica</title>
   <programlisting role="php">
<![CDATA[
<?php
$numero = 362525200;

echo sprintf("%.3e", $numero); // imprime 3.625e+8
?>
]]>
   </programlisting>
  </example>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>printf</function></member>
    <member><function>sscanf</function></member>
    <member><function>fscanf</function></member>
    <member><function>vsprintf</function></member>
    <member><function>number_format</function></member>
   </simplelist>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
