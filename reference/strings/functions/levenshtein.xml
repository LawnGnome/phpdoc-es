<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
<!-- EN-Revision: n/a Maintainer: javi Status: ready -->
<!-- splitted from ./en/functions/strings.xml, last change in rev 1.12 -->
  <refentry xml:id="function.levenshtein" xmlns="http://docbook.org/ns/docbook">
   <refnamediv>
    <refname>levenshtein</refname> 
    <refpurpose>
     Calcula la distancia Levenshtein entre dos cadenas
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripci&oacute;n</title>
     <methodsynopsis>
      <type>int</type><methodname>levenshtein</methodname>
      <methodparam><type>string</type><parameter>cadena1</parameter></methodparam>
      <methodparam><type>string</type><parameter>cadena2</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>cost_ins</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>cost_rep</parameter></methodparam>
      <methodparam><type>int</type><parameter>cost_del</parameter></methodparam>
     </methodsynopsis>
     <!-- La funci&oacute;n de callback todav&iacute;a no est&aacute; implementada, ver bug #29552
     <methodsynopsis>
      <type>int</type><methodname>levenshtein</methodname>
      <methodparam><type>string</type><parameter>cadena1</parameter></methodparam>
      <methodparam><type>string</type><parameter>cadena2</parameter></methodparam>
      <methodparam><type>callback</type><parameter>cost</parameter></methodparam>
     </methodsynopsis>
     -->
    <para>
     Esta funci&oacute;n devuelve la distancia Levenshtein entre las dos 
     cadenas indicadas, &oacute; -1 si alguna de las cadenas tiene m&aacute;s 
     de 255 caracteres.
    </para>
    <para>
     La distancia Levenshtein se define como el m&iacute;nimo n&uacute;mero de 
     caracteres que se tienen que sustituir, insertar o borrar 
     para transformar <parameter>cadena1</parameter> en 
     <parameter>cadena2</parameter>. La complejidad del algoritmo es 
     <literal>O(m*n)</literal>, donde <literal>n</literal> y 
     <literal>m</literal> son las longitudes de <parameter>cadena1</parameter> 
     y <parameter>cadena2</parameter> (por tanto, el rendimiento es bastante 
	 bueno si se la compara con el de la funci&oacute;n <function>similar_text</function>, que es O(max(n,m)**3), pero  
     a&uacute;n as&iacute; se trata de una funci&oacute;n que puede penalizar el 
	 rendimiento global del script).
    </para>
    <para>
     La forma m&aacute;s simple de utilizar la funci&oacute;n es indicar 
	 2 cadenas como par&aacute;metros y realizar el c&aacute;lculo del n&uacute;mero 
	 de operaciones de inserci&oacute;n, reemplazamiento y borrado que son necesarias 
	 para convertir la <parameter>cadena1</parameter> en la <parameter>cadena2</parameter>.
    </para>
    <para>
     Una forma alternativa de uso es la que tiene en cuenta 3 par&aacute;metros, siendo 
	 el tercer el que define el coste que tienen las operaciones de inserci&oacute;n, 
	 reemplazamiento y borrado. Esta forma es m&aacute;s gen&eacute;rica y m&aacute;s adaptativa, 
	 pero es menos eficiente.
    </para>
    <!--  La funci&oacute;n de callback todav&iacute;a no est&aacute; implementada, ver bug #29552
    <para>
     La forma m&aacute;s avanzada de utilizar la funci&oacute;n (y que todav&iacute;a no est&aacute; 
	 implementada) es la m&aacute;s gen&eacute;rica y adaptativa, pero tambi&eacute;n es la menos 
	 eficiente. Consiste en permitir la llamada a una funci&oacute;n que determine 
	 el coste de cada una de las operaciones posibles.
    </para>
    <para>
     La funci&oacute;n de callback personalizada se llamar&aacute; con los siguientes par&aacute;metros:
     <itemizedlist>
      <listitem>
       <simpara>
        operaci&oacute;n a aplicar: 'I', 'R' o 'D'
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        car&aacute;cter de la cadena 1
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        car&aacute;cter de la cadena 2
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        posici&oacute;n en la cadena 1
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        posici&oacute;n en la cadena 2
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        caracteres restantes en la cadena 1
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        caracteres restantes en la cadena 2
       </simpara>
      </listitem>
     </itemizedlist>
     La funci&oacute;n llamada tiene que devolver un entero positivo que representa el coste calculado 
	 para la operaci&oacute;n indicada. El c&aacute;lculo del coste puede realizarse con parte o todos 
	 los par&aacute;metros pasados por la funci&oacute;n <function>levenshtein</function>.
    </para>
    <para>
     La posibilidad de realizar el c&aacute;lculo de los costes en una funci&oacute;n personalizada, 
	 brinda la posibilidad de determinar el coste en funci&oacute;n de la importancia y/o diferencia 
	 entre ciertos s&iacute;mbolos, o la posibilidad de calcular el coste en funci&oacute;n del 
	 contexto en el que aparecen esos s&iacute;mbolos. El aspecto negativo del uso de funciones 
	 personalizadas, es que no se mantienen las optimizaciones realizadas a nivel de registros de 
	 CPU y de caches que se emplean en las otras 2 formas de empleo de la funci&oacute;n <function>levenshtein</function>.
    </para>
    -->
    <para>
     <example>
      <title>Ejemplo de <function>levenshtein</function></title>
      <programlisting role="php">
<![CDATA[
<?php
// Palabra escrita incorrectamente
$palabra_original = 'zanahorria';

// Array de palabras para comprobar las palabras
$palabras  = array('manzana','pina','platano','naranja',
                'rabano','zanahoria','guisante','alubia','patata');

// No se ha encontrado todavia la distancia mas corta
$distancia_mas_corta = -1;

// Recorrer $palabras para encontrar la mas corta
foreach ($palabras as $palabra_actual) {

    // Calcular la distancia entre la $palabra_original y la $palabra_actual
    $lev = levenshtein($palabra_original, $palabra_actual);

    // comprobar si son iguales (distancia 0)
    if ($lev == 0) {

        // se trata de la palabra mas proxima (de hecho, las 2 coinciden)
        $palabra_mas_cercana = $palabra_actual;
        $distancia_mas_corta = 0;

        // salir del bucle porque ya se ha encontrado una coincidencia
        break;
    }

    // si la distancia es menor que la siguiente distancia mas corta encontrada, o si 
    // si no se ha encontrado la palabra con la distancia mas corta
    if ($lev <= $distancia_mas_corta || $distancia_mas_corta < 0) {
        // establece la palabra mas cercana y la distancia mas corta
        $palabra_mas_cercana  = $palabra_actual;
        $distancia_mas_corta = $lev;
    }
}

echo "Palabra introducida: $palabra_original\n";
if ($distancia_mas_corta == 0) {
    echo "Se ha encontrado una coincidencia exacta: $palabra_mas_cercana\n";
} else {
    echo "Quiso decir: $palabra_mas_cercana?\n";
}

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Palabra introducida: zanahorria 
Quiso decir: zanahoria?
]]>
      </screen>
     </example>
    </para>
    <para>
     Vea tambi&eacute;n <function>soundex</function>, <function>similar_text</function> y 
     <function>metaphone</function>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
