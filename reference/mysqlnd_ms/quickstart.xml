<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 325466 Maintainer: seros Status: ready -->
<!-- Reviewed: no -->

<chapter xml:id="mysqlnd-ms.quickstart" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Inicio rápido y Ejemplos</title>
 <para>
  El complemento de equilibrio de carga y replicación de mysqlnd es fácilde usar.
  Esta guía rápida demostrará los casos de uso típicos, y proporcionará consejos sobre cómo
  empezar.
 </para>
 <para>
  Se recomienda leer las secciones de referencia además de la guía
  rápida. Ésta intenta evitar tratar con conceptos teóricos
  y limitaciones. En su lugar, enlazará con las secciones de referencia. Es seguro
  comenzar con l guía rápida. Sin embargo, antes de usar el complemento en entornos de objetivos
  críticos, le animamos a que lea adicionalmente la información de fondo de las
  secciones de referencia.
 </para>
 <para>
  El enfoque es usar mysqlnd_ms de PECL para trabajar con agrupaciones de MySQL asíncronos,
  a saber, la replicación MySQL. Generalmente hablando, un agrupamiento asíncrono es más
  difícil de usar que uno sincrónico. Por lo tanto, los usuario de, por ejemplo, el Agrupamiento de MySQL,
  encontrarán más información de la necesaria.
 </para>
 <section xml:id="mysqlnd-ms.quickstart.configuration">
  <title>Puesta en marcha</title>
  <para>
   El complemento está implementado como una extensión de PHP. Vea también las
   <link linkend="mysqlnd-ms.installation">instrucciones de instalación</link> para
   instalar la extenxión
   <link xlink:href="&url.pecl.package;mysqlnd_ms">PECL/mysqlnd_ms</link>.
  </para>
  <para>
   Compile o configure la extensión (API) de MySQL de PHP (<link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link>,
   <link linkend="ref.mysql">mysql</link>) que planee usar con soporte
   para la biblioteca <link linkend="book.mysqlnd">mysqlnd</link>. PECL/mysqlnd_ms
   es un complemento para la biblioteca mysqlnd. Para utilizar el complemento con cualqier extensión
   de MySQL de PHP, la extensión ha de utilizar la biblioteca mysqlnd.
  </para>
  <para>
   Después carque la extensión en PHP y active el complemento en el fichero de
   confuguración de PHP usantdo la directiva de configuración llamada
   <link linkend="ini.mysqlnd-ms.enable">mysqlnd_ms.enable</link>.
  </para>
  <para>
   <example>
    <title>Habilitar el complemento (php.ini)</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_ms.enable=1
mysqlnd_ms.ini_file=/ruta/al/complemetno_mysqlnd_ms.ini
]]>
    </programlisting>
   </example>
  </para>
  <para>
   El complemento utiliza su propio fichero de configuración. Use la directiva
   de configuración de PHP
   <link linkend="ini.mysqlnd-ms.ini-file">mysqlnd_ms.ini_file</link>
   para establecer la ruta completa al fichero de configuración específico del complemento.
   Es fichero debe ser legible por PHP (p.ej., el usuario del servidor web).
  </para>
  <para>
   Cree un fichero de configuración específico del complemento. Guarde el fichero en la ruta
   establecida por la directiva de configuración de PHP
   <link linkend="ini.mysqlnd-ms.ini-file">mysqlnd_ms.ini_file</link>.
  </para>
  <para>
   El <link linkend="mysqlnd-ms.plugin-ini-json">fichero de configuración</link> de los complementos
   están basados en <acronym>JSON</acronym>. Está dividido en una o más secciones.
   Cada sección tiene un nombre, por ejemplo, <literal>myapp</literal>. Cada sección
   contiene su propio conjunto de ajustes de configuración.
  </para>
  <para>
   Una sección debe lista, como mínimo, el servidor maestro de replicación de MySQL y establecer
   una lista de esclavos. El complemento soporta únicamente un servidor maestro por sección.
   La configuración de replicación de MySQL de maestros múltiples aún no está totalemnte soportada.
   Use el ajuste de configuración
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.master">master</link>
   para establecer el nombre del anfitrión y el puerto o socket de servidor maestro de MySQL.
   Los servidores esclavos de MySQL se configuran usando la
   palabra clave
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.slave">slave</link>.
  </para>
  <para>
   <example>
    <title>Fichero de configuración mínima específico del complemento (mysqlnd_ms_plugin.ini)</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": [

        ]
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Es necesario configurar una lista de servidores esclaves de MySQL, aunque puede
   contener una lista vacía. Se recomienda que siempre se configure al
   menos un servidor esclavo.
  </para>
  <para>
   Las listas de servidores pueden usar la <link linkend="mysqlnd-ms.plugin-ini-json.server-list-syntax">
   sintaxis anónima o no anónima</link>. Las listas no
   anónimas incluyen sobrenombres para los servidores, tales como <literal>master_0</literal>
   para el maestro del ejemplo de arriba. E the master in the above example. La guía rápida utiliza la
   sintaxis no anónima más prolija.
  </para>
  <para>
   <example>
    <title>Sonfiguración mínima recomendada del complemento específico (mysqlnd_ms_plugin.ini)</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Si al menos
   existen dos servidores en total, el complemento puede empezar a equilibrar la carga e intercambia
   conexiones. El intercambio de conexiones no siempre es transparente y puede ocasionar
   problemas en ciertos casos. Las secciones de referencia sobre
   <link linkend="mysqlnd-ms.pooling">intercambio y almacenamiento de conexiones</link>,
   <link linkend="mysqlnd-ms.transaction">manejo de transacciones</link>,
   <link linkend="mysqlnd-ms.failover">tolerancia a fallos</link>
   <link linkend="mysqlnd-ms.loadbalancing">equilibrio de carga</link> y
   <link linkend="mysqlnd-ms.rwsplit">división de lectura-escritura</link> proporcionan
   más detalles.more details. Un obstáculo potencial está descrito después en esta guía.
  </para>
  <para>
   Es responsabilidad de la aplicación el manejar los problemas potenciales causados
   por el intercambio de conexiones, configurando un servidor maestro con al menos un servidor
   esclavo, el cual permite el intercambio para trabajar, por lo tanto, con los problemas relacionados que pueda encontrar.
  </para>
  <para>
   Los servidores maestros y esclavos de MySQL que se configuren no necesitan
   ser parte de la configuración de replicación de MySQL. Para propósitos de pruebas se puede usar un único
   servidor MySQL y hacerle saber al complemento que se trata de un servidor maestro y eclavo,
   como se muestra abajo. Esto podría de ayuda para detectar muchos problemas potenciales con
   los intercambios de conexión. Sin embargo, tal configuración no tendrá tendencia a los problemas
   causados por la demora de replicación.
  </para>
  <para>
   <example>
    <title>Usar un servidor como maestro y esclavo (¡solamente pruebas!)</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.usage">
  <title>Ejecutar sentencias</title>
  <para>
   El complemento se puede usar con cualquier extensión de MySQL para PHP
   (<link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.mysql">mysql</link>, y
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link>) que esté
   compilada para utilizar la biblioteca <link linkend="book.mysqlnd">mysqlnd</link>.
   PECL/mysqlnd_ms se acopla a la biblioteca <link linkend="book.mysqlnd">mysqlnd</link>.
   No cambia la API o el comportamiento de estas extensiones.
  </para>
  <para>
   Siempre que se esté abriendo una conexión a MySQL, el complemento compara el valor del
   parámetro host de la llamada de conexión con los nombres de las secciones
   del fichero de configuración específico del complemento. Si, por ejemplo, el
   fichero de configuración específico del complemento tiene una sección <literal>myapp</literal> , entonces
   la sección debería ser referenciada para abrir una conexión a MySQL para el
   host <literal>myapp</literal>
  </para>
  <para>
   <example>
    <title>Fichero de configuración específico del complemento (mysqlnd_ms_plugin.ini)</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Abrir una conexión con equilibrio de carga</title>
    <programlisting role="php">
<![CDATA[
<?php
/* El equilibrio de carga sigue las reglas de la sección "myapp" del fichero de configuración de complementos */
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
$pdo = new PDO('mysql:host=myapp;dbname=base_datos', 'nombre_usuario', 'contraseña');
$mysql = mysql_connect("myapp", "nombre_usuario", "contraseña");
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Los ejemplos de conexión de arriba tendrán equilibrio de carga.
   El complemento enviará sentencias de solo escritura al servidor esclavo de MySQL con la
   IP <literal>192.168.2.27</literal> y escuchará el puerto <literal>3306</literal>
   para la conexión cliente de MySQL. Todas las demás sentencias serán dirigidas al
   servidor maestro de MySQL que se ejecuta en el anfitrión <literal>localhost</literal>. Si se ejecuta en sistemas
   operativos similaes a Unix, el maestro sobre <literal>localhost</literal> aceptará
   conexiones cliente de MySQL en el socket de dominio Unix <literal>/tmp/mysql.sock</literal>,
   mientras que TCP/IP es el puerto predeterminado en Windows.
   El complemento usará el nombre de usuario <literal>nombre_usuario</literal> y la contraseña
   <literal>contraseña</literal> para conectarse a cualquier servidor de MySQL listado en
   la sección <literal>myapp</literal> del fichero de configuración de complementos. Una vez
   realizada la conexión, el complemento seleccionará <literal>base_datos</literal> como el esquema
   actual.
  </para>
  <para>
   El nombre de usuario, la contraseña y el nombre del esquema son tomados de las llamadas a la
   API de conexión y usados por todos los servidores. En otras palabras: se debe usar los mismos
   nombre de usuario y contraseña para cada servidor MySQL listado en una sección del fichero de configuración
   del comlemento. No es una limitación general. A partir de PECL/mysqlnd_ms 1.1.0,
   es posible establecer
   <link linkend="mysqlnd-ms.plugin-ini-json.server-config-keywords">nombre_usuario</link> y
   <link linkend="mysqlnd-ms.plugin-ini-json.server-config-keywords">contraseña</link> para cualquier servidor del
   fichero de configuración de complementos, para usarlos en lugar de las credenciales pasadas
   a la llamada a la API.
  </para>
  <para>
   El complemento no cambia la API para ejecutar sentencias.
   La <link linkend="mysqlnd-ms.rwsplit">división de lectura-escritura</link>
   se desarrolla aparte. El siguiente ejemplo asumen que no existe
   una demora de replicación significante entre el maestro y el esclavo.
  </para>
  <para>
   <example>
    <title>Ejecutar sentencias</title>
    <programlisting role="php">
<![CDATA[
<?php
/* El equilibrio de carga sigue las reglas de la sección "myapp" del fichero de configuración de complementos */
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (mysqli_connect_errno())
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Las sentencias se ejcutarán en el maestro */
if (!$mysqli->query("DROP TABLE IF EXISTS test")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
if (!$mysqli->query("CREATE TABLE test(id INT)")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
if (!$mysqli->query("INSERT INTO test(id) VALUES (1)")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* solo lectura: la sentencia se ejecutará en un esclavo */
if (!($resultado = $mysqli->query("SELECT id FROM test")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $fila = $resultado->fetch_assoc();
 $resultado->close();
 printf("El esclavó devolvió el ID = '%s'\n", $fila['id'];
}
$mysqli->close();
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
El esclavó devolvió el ID = '1'
]]>
    </screen>
   </example>
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.connectionpooling">
  <title>Estado de la conexión</title>
  <para>
   El complemento cambia la semántica de un gestor de conexión de MySQL para PHP.
   Un gestor de conexión representa una caché de conexiones, en lugar de una
   única conexión de red cliente-servidor de MySQL. La caché de conexión consiste
   en una conexión maestra, y opcionalmente cualquier número de conexiones esclavas.
  </para>
  <para>
   Cada conexión de la caché de conexiones tiene su propio estado. Por ejemplo,
   las variables de usuario de SQL, las tablas temporales y las transacciones son parte del estado.
   Para una lista completa de los elementos que pertenece al estado de una conexión, véanse
   los conceptos de la documentación de
   <link linkend="mysqlnd-ms.pooling">almacenamiento e intercambio de conexiones</link>.
   Si el complemento decide intercambias conexiones para equilibrar la carga, a la
   aplicación se le podría otorgar una conexión que tuviera un estado diferente.
   Las aplicaciones deben considerar esto.
  </para>
  <para>
   <example>
    <title>Configuración del complemento con un esclavo y un maestro</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Obstáculo: estado de conexión y variables de usuario de SQL</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Conexión 1, la conexión vincula una variable de usuario de SQL, por lo que no se ejecuta ningún SELECT en el maestro */
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Conexión 2, se ejecuta en el esclavo a causa de SELECT */
if (!($resultado = $mysqli->query("SELECT @myrole AS _role"))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $fila = $resultado->fetch_assoc();
 $resultado->close();
 printf("@myrole = '%s'\n", $fila['_role']);
}
$mysqli->close();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
@myrole = ''
]]>
    </screen>
   </example>
  </para>
  <para>
   El ejemplo abre una conexión con equilibrio de carga y ejecuta dos sentencias.
   La primera sentencia <literal>SET @myrole='master'</literal> no comienza
   con la cadena <literal>SELECT</literal>. Por lo tanto, el complemento no
   la reconoce como una consulta de solo lectura que se ejecutará en un esclavo. El
   ejecuta la sentencia en una conexión al maestro. La sentencia
   establece una variable de usuario de SQL que está vinculada a la conexión con el maestro. El
   estado de la conexión maestra ha sido cambiado.
  </para>
  <para>
   La siguiente sentencia es <literal>SELECT @myrole AS _role</literal>.
   El complemento la reconoce como una consulta de solo lectura y la envía al
   esclavo. La sentencia se ejecuta en una conexión al esclavo. Esta
   segunda conexión no tiene ninguna variable de usuario de SQL vinculada a ella.
   Tiene un estado diferente a la primera conexión al maestro.
   La variable de usuario de SQL no está establecida. El script de ejemplo imprime
   <literal>@myrole = ''</literal>.
  </para>
  <para>
   Es responsabilidad del desarrollador de la apliación ocuparse
   del estado de la conexión. El complemento no monitoriza todas
   las actividades de cambio de estado. La monitorización de todos los casos posibles
   sería una tarea intensiva de la CPU, si pudiera ser realizada.
  </para>
  <para>
   Los obstáculos se pueden evitar fácilmente usando sugerencias SQL.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.sqlhints">
  <title>Sugerencias SQL</title>
  <para>
   Las sugerencias SQL pueden forzar a una consulta a elegir un servidor específico de la caché de conexiones.
   Proporcionan al complemento una sugerencia para utilizar un servidor indicado, el cual puede resolver
   problemas causados por intercambios de conexión y estados de conexión.
  </para>
  <para>
   Las sugerencias SQL son comentarios que siguen el estándar. Ya que
   los comentarios SQL están soportados para que sean ignorados por sistemas de procesamiento SQL,
   no interfieren con otros programas como el Servidor MySQL, el Proxy MySQL,
   o un cortafuegos.
  </para>
  <para>
   El complemento soporta tres sugerencias SQL:
   La sugerencia <constant>MYSQLND_MS_MASTER_SWITCH</constant> hace que el complemento ejecute una sentencia
   en el servidor, <constant>MYSQLND_MS_SLAVE_SWITCH</constant> fuerza el uso
   del esclavo, y <constant>MYSQLND_MS_MASTER_SWITCH</constant> ejecutará una
   sentencia en el mismo servidor que se utilizó con la sentencia anterior.
  </para>
  <para>
   El complemento escanea el inicio de una sentencia para la existencia de una sugerencia
   SQL. Las sentencias SQL solo son reconocidas si aparecen al inicio de
   la sentencia.
  </para>
  <para>
   <example>
    <title>Configuración del complemento con un esclavo y un maestro</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
    </example>
  </para>
  <para>
   <example>
    <title>Sugerencias SQL para evitar el intercambio de conexión</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (mysqli_connect_errno())
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Conexión 1, la conexión vincula una variable de usuario de SQL, por lo que no se ejecuta ningún SELECT en el maestro */
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Conexión 1, se ejecuta en el maestro debido a la sugerencia SQL */
if (!($resultado = $mysqli->query(sprintf("/*%s*/SELECT @myrole AS _role", MYSQLND_MS_LAST_USED_SWITCH)))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $fila = $resultado->fetch_assoc();
 $resultado->close();
 printf("@myrole = '%s'\n", $fila['_role']);
}
$mysqli->close();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
@myrole = 'master'
]]>
    </screen>
   </example>
  </para>
  <para>
   En el ejemplo de arriba, el uso de <constant>MYSQLND_MS_LAST_USED_SWITCH</constant> evita
   el intercambio de sesión desde el maestro al esclavo al ejecutar la sentencia
   <literal>SELECT</literal>.
  </para>
  <para>
   Las sugerencias SQL también se pueden usar para ejecutar sentencias <literal>SELECT</literal>
   en el servidor maestro de MySQL. Esto puede ser requerido si los servidores esclavos de MySQL
   están normalmente detrás del maestro, pero no se necesitan datos actuales del grupo.
  </para>
  <para>
   En la versión 1.2.0, el concepto de nivel de servidio ha sido introducido para dirigir
   casos en los que no son necesarios datos actuales. El uso de un nivel de servicio requiere menos atención
   y elimina la necesidad de usar sugerencias SQL para este caso de uso. Se puede encontrar más
   información más abajo en la sección de nivel de servicio y consitencia.
  </para>
  <para>
   <example>
    <title>Fighting replication lag</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Forzar el uso del maestro, el maestro siempre tiene datos recientes y actuales */
if (!$mysqli->query(sprintf("/*%s*/SELECT critical_data FROM important_table", MYSQLND_MS_MASTER_SWITCH))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Un caso de uso puede incluir la creación de tablas en un esclavo.
   Si no se proporciona una sugenrencia SQL, el complemento enviará las sentencias
   <literal>CREATE</literal> y <literal>INSERT</literal> al maestro. Utilice la
   sugerencia SQL <constant>MYSQLND_MS_SLAVE_SWITCH</constant> si quiere
   ejecutar tales sentencias en un esclavo, por ejemplo, para construir tablas de
   informes temporales.
  </para>
  <para>
   <example>
    <title>Creación de una tabla en un esclavo</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Forzar el uso del esclavo */
if (!$mysqli->query(sprintf("/*%s*/CREATE TABLE informes_esclavo(id INT)", MYSQLND_MS_SLAVE_SWITCH))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
/* Continuar usando esta conexión esclava en particular */
if (!$mysqli->query(sprintf("/*%s*/INSERT INTO informes_esclavo(id) VALUES (1), (2), (3)", MYSQLND_MS_LAST_USED_SWITCH))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
/* ¡No usar MYSQLND_MS_SLAVE_SWITCH ya que permitiría el intercambio con otro esclavo! */
if ($resultado = $mysqli->query(sprintf("/*%s*/SELECT COUNT(*) AS _num FROM informes_esclavo", MYSQLND_MS_LAST_USED_SWITCH))) {
  $fila = $resultado->fetch_assoc();
  $resultado->close();
  printf("Hay %d filas en la tabla 'informes_esclavo'", $fila['_num']);
} else {
  printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
$mysqli->close();
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   La sugerencia SQL <constant>MYSQLND_MS_LAST_USED</constant> prohíbe el intercambio de una
   conexión, y fuerza el uso de la conexión usada anteriormente.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.transactions">
  <title>Transacciones</title>
  <para>
   La versión actual del complemento no es segura con transacciones de forma predeterminada,
   ya que no consideran las transacciones. Las transacciones SQL son
   unidades de trabajo para ser ejecutadas en un único servidor.
   El complemento no sabe cuando la unidad de trabajo comienza y cuando finaliza.
   Por consiguiente, el complemento puede decidir intercambiar conexiones en mitad
   de una transacción.
  </para>
  <para>
   Se pueden usar sugerencias SQL para evitar esta limitación. De forma alternativa,
   se puede activar la monitorización de llamadas a la API de trasacciones. En el último caso,
   de deben usar llamadas a la API solamente para controlar transacciones. Véase más abajo.
  </para>
  <para>
   <example>
    <title>Configuración del complemento con un esclavo y un maestro</title>
    <programlisting role="ini">
<![CDATA[
[myapp]
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Usar sugerencias SQL para transacciones</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* No es un SELECT, se usará el maestro */
if (!$mysqli->query("START TRANSACTION")) {
 /* Por favor, use un manejo de errores mejor en su código */
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* ¡Evitar el intercambio de conexión! */
if (!$mysqli->query(sprintf("/*%s*/INSERT INTO test(id) VALUES (1)", MYSQLND_MS_LAST_USED_SWITCH)))) {
 /* Por favor, realice el ROLLBACK apropiado en su código, y no use simplemente die */
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if ($resultado = $mysqli->query(sprintf("/*%s*/SELECT COUNT(*) AS _num FROM test", MYSQLND_MS_LAST_USED_SWITCH)))) {
  $fila = $resultado->fetch_assoc();
  $resultado->close();
  if ($fila['_num'] > 1000) {
   if (!$mysqli->query(sprintf("/*%s*/INSERT INTO events(task) VALUES ('cleanup')", MYSQLND_MS_LAST_USED_SWITCH)))) {
     die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
   }
  }
} else {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query(sprintf("/*%s*/UPDATE log SET last_update = NOW()", MYSQLND_MS_LAST_USED_SWITCH)))) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query(sprintf("/*%s*/COMMIT", MYSQLND_MS_LAST_USED_SWITCH)))) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

$mysqli->close();
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Desde PHP 5.4.0, la biblioteca <literal>mysqlnd</literal> permite al
   complemento monitorizar el estado del modo <literal>autocommit</literal>, si
   el modo está establecido por llamadas a la API en lugar de usar sentencias SQL como
   <literal>SET AUTOCOMMIT=0</literal>. Esto hace posible que el complemento
   considere las transacciones.
  </para>
  <para>
   Si se está utlizando PHP 5.4.0 o superior, cuando las llamadas a la API que habilitan el modo <literal>autocommit</literal>,
   y cuando se establece la opción de configuración del complemento
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.trx-stickiness">trx_stickiness=master</link>,
   el complemento puede deshabilitar automáticamente el equilibrio de carga y el intercambio de conexiones
   para transacciones SQL. Con esta configuración, el complemento detiene el equilibrio de carga
   si <literal>autocommit</literal> está deshabilitado, y por lo tanto dirige todas las setnecias al
   maestro. Esto evita el intercambio de conexiones en mitad de
   una transacción. Una vez que <literal>autocommit</literal> es rehabilitado, el complemento
   inicia de nuevo las sentencias de equilibro de carga.
  </para>
  <para>
   <example>
    <title>Equilibrio de carga que considera transacciones: el ajuste trx_stickiness</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "trx_stickiness": "master"
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Consideración de transacciones</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Deshabilitar autocommit, el complemento ejecutará todas las sentencias en el maestro */
$mysqli->autocommit(FALSE);

if (!$mysqli->query("INSERT INTO test(id) VALUES (1)")) {
 /* Por favor, realice el ROLLBACK apropiado en su código, y no use simplemente die */
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if ($resultado = $mysqli->query("SELECT COUNT(*) AS _num FROM test")) {
  $fila = $resultado->fetch_assoc();
  $resultado->close();
  if ($fila['_num'] > 1000) {
   if (!$mysqli->query("INSERT INTO events(task) VALUES ('cleanup')")) {
     die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
   }
  }
} else {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query("UPDATE log SET last_update = NOW()")) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->commit()) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* El complemento asume que la transacción ha finalizado e inicia el equilibrio de carga de nuevo */
$mysqli->autocommit(TRUE);
$mysqli->close();
?>
]]>
    </programlisting>
   </example>
  </para>
  <note>
   <title>Requerimiento de versión</title>
   <para>
    La opción de configuración del complemento
    <link linkend="ini.mysqlnd-ms-plugin-config-v2.trx-stickiness">trx_stickiness=master</link>
    requiere PHP 5.4.0 o superior.
   </para>
  </note>
 </section>
 <section xml:id="mysqlnd-ms.quickstart.qos-consistency">
  <title>Nivel de servicios y consistencia</title>
  <note>
   <title>Requerimiento de versión</title>
   <para>
    Los niveles de servicios han sido introducidos en la versión 1.2.0-alpha de PECL mysqlnd_ms.
    <function>mysqlnd_ms_set_qos</function>
    está disponible con PHP 5.4.0 o superior.
   </para>
  </note>
  <para>
   Las diferentes soluciones de agrupación de MySQL ofrecen diferentes niveles de
   servicios y consistencia de datos para sus usuarios. Un grupo de replicación de MySQL asíncrono
   ofrece consistencia eventual de forma predeterminada. Una lectura ejecutada en un esclavo asíncrono
   puede devolver los datos actuales, antiguos, o ningún dato, dependiendo de si el esclavo
   ha repetido todos los conjuntos de cambios del maestro.
  </para>
  <para>
   Las aplicaciones que utilizan un grupo de replicación de MySQL necesitan ser diseñadas para funcionar
   correctamente con datos consistentes eventuales. En algunos casos, sin embargo, los datos antiguos
   no son aceptables. En estos casos solamente ciertos accesos a esclavos o incluso a un maestro son
   permitidos para realizar la calidad del servicio requerida del grupo.
  </para>
  <para>
   A partir de PECL mysqlnd_ms 1.2.0, el complemento es capaz de seleccionar
   nodos de replicación de MySQL automáticamente que realizan consistencia de sesiones o
   consistencia fuerte. La consistencia de sesiones significa que un cliente puede leer sus escrituras.
   Otros clientes pueden ver o no la escritura del cliente. La consistencia fuerte significa
   que todos los clientes verán todas las escrituras del cliente.
  </para>
  <para>
   <example>
    <title>Consistencia de sesión: leer sus escrituras</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Solicitud de consistencia de sesión</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* división de lecutura-escritura: se usa el maestro */
if (!$mysqli->query("INSERT INTO orders(order_id, item) VALUES (1, 'christmas tree, 1.8m')")) {
  /* Por favor, use un manejo de errores mejor en su código */
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Solicitud de consistencia de sesión: leer sus escrituras */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* El complemento selecciona un nodo que posee los cambios, aquí: maestro */
if (!$resultado = $mysqli->query("SELECT item FROM orders WHERE order_id = 1"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

var_dump($resultado->fetch_assoc());

/* Volver a la consistencia eventual: se permiten datos antiguos */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* El complemento seleccina cualquier esclavo, se permiten datos antiguos */
if (!$resultado = $mysqli->query("SELECT item, price FROM specials"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Los niveles de servicios se pueden establecer en el fichero de configuración de complementos y en tiempo de ejecución
   usando <function>mysqlnd_ms_set_qos</function>.
   En el ejemplo, la función se utsa para forzar la
   consistencia de sesión (leer sus escrituras) para todas las sentencia futuras hasta próximo aviso.
   La sentencia <literal>SELECT</literal> de la tabla <literal>orders</literal>
   se ejecuta en un maestro para asegurarse de que las escrituras anteriores puedan ser vistas por el cliente.
   La lógica de la división de lectura-escritura-write ha sido adaptada para satisfacer el nivel de servicios.
  </para>
  <para>
   Después de que una aplicación haya leído sus cambios desde la tabla <literal>orders</literal>,
   vuelve al nivel de servicios predeterminado, que es la consistencia eventual. Ésta
   no pone restricciones al elegir un nodo para la ejecución de sentencias.
   Por lo tanto, la sentencia <literal>SELECT</literal> de la tabla <literal>specials</literal>
   se ejecuta en un esclavo.
  </para>
  <para>
   La nueva funcionalidad sustituye el uso de sugerencias SQL y la opción
   de configuración <literal>master_on_write</literal>. En muchos casos,
   <function>mysqlnd_ms_set_qos</function> es más fácil de usar, más potente y
   mejora la portabilidad.
  </para>
  <para>
   <example>
    <title>Edad máxima/demora del esclavo</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "failover" : "master"
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Limitar la demora del esclavo</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Demora de la lectura desde los esclavos de no más de cuatro segundos */
$ret = mysqlnd_ms_set_qos($mysqli,
         MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL,
         MYSQLND_MS_QOS_OPTION_AGE, 4);

if (!$ret)
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* El comlemento elige cualquier esclavo, el cual puede o no tener los cambios */
if (!$resultado = $mysqli->query("SELECT item, price FROM daytrade"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));


/* Volver a lo predeterminado: usar todos los esclavos y maestros permitidos */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   El nivel de servicio de consistencia eventual se puede usar con un parámetro
   opcional para establecer la demora máxima de los esclavos elegidos. Si se establece,
   el complemento comprueba <literal>SHOW SLAVE STATUS</literal> para todos
   los esclavos configurados. En el caso del ejemplo, solamente los esclavos
   para los que <literal>Slave_IO_Running=Yes</literal>,
   <literal>Slave_SQL_Running=Yes</literal> y
   <literal>Seconds_Behind_Master &lt;= 4</literal>
   sean verdaderos, son tenidos en cuenta para la ejecución de la sentencia
   <literal>SELECT item, price FROM daytrade</literal>.
  </para>
  <para>
   La comprobacion de <literal>SHOW SLAVE STATUS</literal> se realiza de maenra transparente desde
   la perspectiva de las aplicaciones. Los errores, si los hubiera, son reportados como
   advertencias. No se establecerá ningún error en el gestor de conexión. Incluso si todas
   las sentencias SQL <literal>SHOW SLAVE STATUS</literal> ejecutadas por el
   complemento fallan, la ejecución de las sentencias del usuario no se detienen, dado
   que la toleracia a fallos del maestro está habilitada. Por lo tanto, no se requieren cambios en la aplicación.
  </para>
  <note>
   <title>Operaciones caras y lentas</title>
   <para>
    La comprobación de <literal>SHOW SLAVE STATUS</literal> para todos los esclavos añade carga adicional
    a la aplicación. Es una operaciónto the application. Es una operación en segundo plano cara y lenta.
    Intente minimizar su uso. Desafortunadamente, un grupo de replicación MySQL
    no proporciona a los clientes la posibilidad de solicitar una lista de candidatos
    desde una instancia central.
    En consecuencia, no hay disponible una manera más eficiente de comprobar la demora de los esclavos.
   </para>
   <para>
    Por favor, observe las limitaciones y propiedades de <literal>SHOW SLAVE STATUS</literal>
    tal y como están explicadas en el manual de referencia de MySQL.
   </para>
  </note>
  <para>
   Para evitar que mysqlnd_ms emita una advertencia si se pudieron encontrar esclavos 
   que demoren no menos que el número de segundos definido detrás del maestro,
   es necesario habilitar la tolerancia a fallos del maestro en el fichero de configuración de complementos.
   Si no se puedieron encontrar esclavos y la tolerancia a fallos está habilitada, el complemento
   elige un maestro para ejecutar la setencia.
  </para>
  <para>
   Si no se puedieron encontrar esclavos y la tolerancia a fallos está deshabilitada, el complemento emite
   una advertencia, no ejecuta la sentencia y establece un error
   sobre la conexión.
  </para>
  <para>
   <example>
    <title>La tolerancia a fallos no está establecida</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>No hay esclavos dentro del límite de tiempo</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Demora de la lectura desde los esclavos de no más de cuatro segundos */
$ret = mysqlnd_ms_set_qos($mysqli,
         MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL,
         MYSQLND_MS_QOS_OPTION_AGE, 4);

if (!$ret)
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* El comlemento elige cualquier esclavo, el cual puede o no tener los cambios */
if (!$resultado = $mysqli->query("SELECT item, price FROM daytrade"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));


/* Volver a lo predeterminado: usar todos los esclavos y maestros permitidos */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
PHP Warning:  mysqli::query(): (mysqlnd_ms) Couldn't find the appropriate slave connection. 0 slaves to choose from. Something is wrong in %s on line %d
PHP Warning:  mysqli::query(): (mysqlnd_ms) No connection selected by the last filter in %s on line %d
[2000] (mysqlnd_ms) No connection selected by the last filter
]]>
    </screen>
   </example>
  </para>
  <note>
   <title>El funcionamiento de la lógica de la tolerancia a fallos está en progreso</title>
   <para>
    Los detalles de la lógica de la tolerancia a fallos pueden cambiar en versiones futuras.
   </para>
  </note>
 </section>
 <section xml:id="mysqlnd-ms.quickstart.gtid">
  <title>IDs de transacción globales</title>
  <note>
   <title>Requerimientos de versión</title>
   <para>
    Se ha introducido una inyección del ID de transacción global en el lado del cliente en la versión 1.2.0-alpha de mysqlnd_ms.
    La característica no es necesario para agrupaciones síncronas, tales como Agrupación MySQL.
    Utilícela con agrupaciones asíncronas tales como la replicación MySQL clásica.
   </para>
   <para>
    A partir de MySQL 5.6.5-m8, el servidor MySQL introduce los identificadores de transacción globales internos.
    La característica del ID de transacción globa interno está soportada por PECL/mysqlnd_ms 1.3.0-alpha o
    posterior.
   </para>
  </note>
  <para>
   PECL/mysqlnd_ms puede usar tanto su propia emulación del ID de transacción global como la
   característica del ID de transacción glbal interna de MySQL 5.6.5-m8 o posterior. Desde una perspectiva del
   desarrolador, los enfoques del lado del cliente y del lado del servidor ofrecen las mismas características en cuanto
   a los niveles de servicios proporcionados por PECL/mysqlnd_ms. Las diferencias
   son tratadas en la <link linkend="mysqlnd-ms.gtid">sección conceptos</link>.
  </para>
  <para>
   La guía rápida primero demuestra el uso de la emulación del ID de transación global en el lado del cliente
   interna a PECL/mysqlnd_ms antes de mostrar cómo usar su homólogo en el lado del servidor.
   El orden asegura que la idea subyacente se trata primero.
  </para>
  <para>
   <emphasis role="bold">La idea y la emulación en el lado del cliente</emphasis>
  </para>
  <para>
   En su forma más básica, un ID de Transacción Global (GTID de sus siglas en inglés) es un contador de una tabla del
   maestro. El contador se incrementa siempre que se consigne una transacción en el maestro.
   Los esclavos replican la tabla. El contador sirve para dos propósitos. En caso de un
   fallo del maestro, ayuda al administrador de la base de datos a identificar al esclavo que fue promovido
   más recientemente al nuevo maestro. El esclavo más reciente es aquel con el
   valor de contador más alto. Las aplicaciones pueden usar el ID de transacción global para buscar
   los esclavos que ya han replicado ciertas escrituras (identificados por un ID de transacción
   global).
  </para>
  <para>
   PECL/mysqlnd_ms puede inyectar SQL para cada transacción consignada para incrementar un contador GTID.
   El ID creado es accesible por la aplicación para identificar una operación de escritura
   de aplicaciones. Esto habilita al complemento para proporcionar el nivel de servicio de consistencia de sesiones
   (leer sus escrituras) mediante no solamente consultar los maestros, sino también a los esclavos que ya han
   replicado el cambio. La carga de lectura se le quita al maestro.
  </para>
  <para>
   La emulación del ID de transacciones global en el lado del cliente tiene algunas limitaciones. Por favor,
   lea la <link linkend="mysqlnd-ms.gtid">sección de concetos</link>
   detenidamente para comprender completamente los principios y las ideas
   subyacentes antes de usarla en entornos de producción. No es necesario un conocimiento
   profundo para continuar con la guía rápida.
  </para>
  <para>
   Primero, cree una tabla contador en su servidor maestro e inserte un registro en ella.
   El complemento no asiste en la creación de la tabla.
   Los administradores de la base de datos deben asegurarse de que existe. Dependiendo del modo de reporte
   de errores, el complemento ignorará de forma silenciosa la ausencia de la tabla o abandonará.
  </para>
  <para>
   <example>
    <title>Crear una tabla contador en el maestro</title>
    <programlisting role="sql">
<![CDATA[
CREATE TABLE `trx` (
  `trx_id` int(11) DEFAULT NULL,
  `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=latin1
INSERT INTO `trx`(`trx_id`) VALUES (1);
]]>
    </programlisting>
   </example>
  </para>
  <para>
   En el fichero de configuración de complementos establezca el SQL para actualizar la
   tabla del ID de transacción global usando <literal>on_commit</literal>
   en la sección <literal>global_transaction_id_injection</literal>.
   Asegúrese de que el nombre de la tabla usado para la sentencia <literal>UPDATE</literal>
   está completamente cualificado. En el ejemplo,
   <literal>test.trx</literal> se usa para referirse a la tabla <literal>trx</literal>
   del esquema (base de datos) <literal>test</literal>. Use la tabla que se creó en
   el paso anterior. Es importante establecer el nombre de la tabla completamente cualificado
   ya que la conexión donde se realiza la inyección puede usar una base de datos predeterminada
   diferente. Asegúrese de que al usuario que abra la conexión
   se le permita ejecutar la sentencia <literal>UPDATE</literal>.
  </para>
  <para>
   Habilite el reporte de errores que pudieran ocurrir cuando mysqlnd_ms realice inyecciones
   de ID de transacciones global.
  </para>
  <para>
   <example>
    <title>Configuración del complemento: SQL para la inyección GTID en el lado del cliente</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "report_error":true
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Inyección transparente del ID de transacción global</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* modo autoconsigna, transacción en el maestro, GTID debe ser incrementado */
if (!$mysqli->query("DROP TABLE IF EXISTS test"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* modo autoconsigna, transacción en el maestro, GTID debe ser incrementado */
if (!$mysqli->query("CREATE TABLE test(id INT)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* modo autoconsigna, transacción en el maestro, GTID debe ser incrementado */
if (!$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* modo autoconsigna, lectura en el esclavo, sin incremento */
if (!($resultado = $mysqli->query("SELECT id FROM test")))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

var_dump($resultado->fetch_assoc());
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(1) {
  ["id"]=>
  string(1) "1"
}
]]>
    </screen>
   </example>
  </para>
  <para>
   El ejemplo ejecuta tres sentencias en el modo autoconsigna en el maestro, causando
   tres transacciones en el maestro. Para cada sentencia, el complemento
   inyectará el <literal>UPDATE</literal> configurado de forma transparente antes de ejecutar
   las sentencias SQL del usuario. Cuando finaliza el script, el contador de ID
   de transacciones global en el maestro ha sido incrementado en tres.
  </para>
  <para>
   La cuarta sentencia SQL ejecutada en el ejemplo, un <literal>SELECT</literal>,
   no desencadena un incremento. Solamente las transaccionies (escrituras) ejecutadas en un maestro
   incrementarán el contador GTID.
  </para>
  <note>
   <title>SQL para ID de transacciones global: ¡se busca una solución eficiente!</title>
   <para>
    El SQL usado para la emulación del ID de transacciones global es ineficiente.
    Está optimizado para la trasnparencia, no para el rendimiento. No lo use para entornos de
    producción. Por favor, ayude a encontrar una solución eficiente para su inclusión en el manual.
    Apreciamos su aportación.
   </para>
  </note>
  <para>
   <example>
    <title>Configuración del complemento: SQL para obtener el GTID</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "fetch_last_gtid" : "SELECT MAX(trx_id) FROM test.trx",
            "report_error":true
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Obtener el GTID después de la ejecución</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* modo autoconsigna, transacción en el maestro, GTID debe ser incrementado */
if (!$mysqli->query("DROP TABLE IF EXISTS test"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

printf("GTID después de la transacción %s\n", mysqlnd_ms_get_last_gtid($mysqli));

/* modo autoconsigna, transacción en el maestro, GTID debe ser incrementado */
if (!$mysqli->query("CREATE TABLE test(id INT)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

printf("GTID after transaction %s\n", mysqlnd_ms_get_last_gtid($mysqli));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
GTID después de la transacción 7
GTID después de la transacción 8
]]>
    </screen>
   </example>
  </para>
  <para>
   Las aplicaciones pueden preguntar a PECL mysqlnd_ms por un ID de transacción global que
   pertenezca a la última operación de escritura realizada por la aplicación.
   La función <function>mysqlnd_ms_get_last_gtid</function> devuelve el
   GTID obtenido cuando se ejecuta la sentencia SQL desde la
   entrada <literal>fetch_last_gtid</literal> de la sección
   <literal>global_transaction_id_injection</literal> del
   fichero de configuración de complementos. La función puede ser invocada
   después de que el GTID haya sido incrementado.
  </para>
  <para>
   Se aconseja que las aplicaciones no ejecuten la sentencia
   SQL por sí mismas ya que aumenta el riesgo de que accidentalmente ocasione un incremento
   implícito de GTID. También, si se usa la función, es más fácil migrar
   una aplicación desde una sentencia SQL para obtener un ID de transacción a otra,
   por ejemplo, si ningún servidor MySQL incluye el soporte interno para ID de transacciones global.
  </para>
  <para>
   La guía rápida muestra una sentencia SQL que devolverá un GTID igual o mayor
   que el creado por la sentencia anterior. Éste es exactamente el GTID creado
   por la sentencia anteiror si ningún cliente ha incrementado el GTID en el
   tiempo transcurrido entre la ejecución de la sentencia y el <literal>SELECT</literal>
   para obtener el GTID. De otro modo, será mayor.
  </para>
  <para>
   <example>
    <title>Configuración del complemento: Comprobar un cierto GTID</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "fetch_last_gtid" : "SELECT MAX(trx_id) FROM test.trx",
            "check_for_gtid" : "SELECT trx_id FROM test.trx WHERE trx_id >= #GTID",
            "report_error":true
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Nivel de servicio de consistencia de sesión y GTID combinados</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* modo autoconsigna, transacción en el maestro, GTID debe ser incrementado */
if (!$mysqli->query("DROP TABLE IF EXISTS test") ||
    !$mysqli->query("CREATE TABLE test(id INT)") ||
    !$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* GTID es un identificador para la última escritura */
$gtid = mysqlnd_ms_get_last_gtid($mysqli);

/* Consistencia de sesión (lectura de sus escrituras): intentar leer de los esclavos, no sólo del maestro */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION, MYSQLND_MS_QOS_OPTION_GTID, $gtid)) {
  die(sprintf("[006] [%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Ejecutar en el maestro o en el esclavo que ha replicado el INSERT */
if (!($resultado = $mysqli->query("SELECT id FROM test"))) {
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

var_dump($resultado->fetch_assoc());
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Un GTID devuelto por <function>mysqlnd_ms_get_last_gtid</function>
   se puede usar como una opción para el nivel de servicio de consistencia de sesión.
   La consistencia de sesión proporciona la lectura de sus escrituras. La consistencia de sesión
   puede ser solicitada llamando a
   <function>mysqlnd_ms_set_qos</function>.
   En el ejemplo, el complemento ejecutará la sentencia <literal>SELECT</literal>
   en el maestro o en un esclavo que ya ha repliacdo
   el <literal>INSERT</literal> anterior.
  </para>
  <para>
   PECL mysqlnd_ms comprobará de forma transparente cada esclavo configurado si
   si ha replicado el <literal>INSERT</literal> mediante la comprobación de la tabla
   GTID de esclavos. La comprobación se realiza ejecutando la sentencia SQL establecida con la
   opción <literal>check_for_gtid</literal> de la
   sección <literal>global_transaction_id_injection</literal> del
   fichero de configuración de complementos. Por favor, observe que este es un procedimiento
   lento y caro. Las aplicaciones debería intentar usarlo poco y únicamente
   si la carga de lectura en el maestro se convierte en alta.
  </para>
  <para>
   <emphasis role="bold">Uso de la característica del ID de transacción global en el lado del servidor</emphasis>
  </para>
  <para>
   Desde MySQL 5.6.5-m8, el sistema de Replicación MySQL introduce los IDs de transacción
   global. Los identificadores de transacción son generados automáticamente y
   mantenidos por el servidor. Los usuarios no necesitan ocuparse de mantenerlos.
   No hay necesidad de configurar ninguna tabla de antemano, o de configurar
   <literal>on_commit</literal>. Ya no es necesaria la emulación en el lado del cliente.
  </para>
  <para>
   Los clientes puede seguir usando los identificadores de transacciones globales para conseguir
   consistencia de sesión al leer desde esclavos de Replicación MySQL. El algorítmo
   funciona como está descrito arriba. Se deben configurar diferentes sentencias SQL para
   <literal>fetch_last_gtid</literal> y <literal>check_for_gtid</literal>.
   Las sentencias se proporcionan abajo. Por favor, observe que MySQL 5.6.5-m8 es una versión en
   desarrollo. Los detalles de la implementación del servidor pueden cambiar en el futuro y requerir
   adoptar las sentencias SQL mostradas.
  </para>
  <para>
   Al utilizar la siguiente configuración, cualquier funcionalidad descrita arriba puede
   usarse junto con la característica del ID de transacciones global en el lado del servidor.
   <function>mysqlnd_ms_get_last_gtid</function> y <function>mysqlnd_ms_set_qos</function>
   siguen funcionando como se describió arriba. La única diferencia es que el servidor
   no utiliza un número de secuenca simple, sino una cadena que contiene un identificador de servidor
   y un número de secuencia. Por lo tanto, los usuarios no pueden obtener fáciltmente un orden desde los GTIDs
   devueltos por <function>mysqlnd_ms_get_last_gtid</function>.
  </para>
  <para>
   <example>
    <title>Configuración de complemento: usar la característica GTID interna de MySQL 5.6.5-m8</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "fetch_last_gtid" : "SELECT @@GLOBAL.GTID_DONE AS trx_id FROM DUAL",
            "check_for_gtid" : "SELECT GTID_SUBSET('#GTID', @@GLOBAL.GTID_DONE) AS trx_id FROM DUAL",
            "report_error":true
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
 </section>
 <section xml:id="mysqlnd-ms.quickstart.cache">
  <title>Integración de caché</title>
  <note>
   <title>Requerimientos de versión y dependencias</title>
   <para>
    La integración de caché está disponible a partir de PECL/mysqlnd_ms 1.3.0-beta (bajo desarrollo).
    <link linkend="book.mysqlnd-qc">PECL/mysqlnd_qc 1.1.0</link> (bajo desarrollo)
    o posterior se usa como una caché. Se debe instalar
    ambos complementos. PECL/mysqlnd_ms debe ser compilado para admitir la característica de la caché.
    Es obligatorio usar PHP 5.4.0 o posterior.
   </para>
  </note>
  <para>
   Los agrupamientos de bases de datos pueden proporcionar diferentes niveles de consistencia. A partir de
   PECL/mysqlnd_ms 1.2.0 es posible notificar al complemento para que cosidere solamente
   nodos del agrupamiento que puedan proporcionar el nivel de consistencia requerido. Por ejemplo,
   si se usa la Replicación MySQL con su consistencia eventual a lo ancho del
   agrupamiento, es posible solicitar consistencia de sesión (lectura de sus escrituras)
   en cualquier momento usando <function>mysqlnd_ms_set_quos</function>. Por favor, vea también la
   introducción de
   <link linkend="mysqlnd-ms.quickstart.qos-consistency">nivel de servicio y consistencia</link>.
  </para>
  <para>
   <example>
    <title>Resumen: calidad del servicio para solicitar la lectura de sus escrituras</title>
    <programlisting role="php">
     /* Solicitud de consistencia de sesión: lectura de sus escrituras */
     if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION))
     die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
    </programlisting>
   </example>
  </para>
  <para>
   Asumiendo que a PECL/mysqlnd se le ha indicado explícitamente que proporcione un nivel de consistencia
   no mayor que la consistencia eventual, es posible reemplazar un acceso de lectura de un nodo de
   la base de datos por una caché en el lado del cliente usando el tiempo de vida (TTL) como
   estrategia de invalidación. El nodo de la base de datos y la caché pueden o no servir
   datos actuales, ya que esto es lo que la consistencia eventul define.
  </para>
  <para>
   El reemplazo de un acceso de lectura de de un nodo de la base de datos por un acceso a la caché local
   puede mejorar el redimiento general y disminuir la carga de la base de datos. Si la entrada de la caché
   es reutilizado por otro cliente que no sea el que creó dicha entrada,
   se guarada un acceso a la base de datos y así se disminuye la carga de la base de datos. Además,
   el rendimiento del sistema se puede mejorar si la computación y la entrega
   de una consulta a la base de datos es más baja que un acceso a la caché local.
  </para>
  <para>
   <example>
    <title>Configuración del complemento: sin entradas especiales para la caché</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Almacenar en caché una petición de un servidor</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

if (!$mysqli->query("DROP TABLE IF EXISTS test") ||
    !$mysqli->query("CREATE TABLE test(id INT)") ||
    !$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Explícitamente permite la consistencia eventual y el almacenamiento en caché (TTL <= 60 segundos) */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL, MYSQLND_MS_QOS_OPTION_CACHE, 60)) {
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Para que este ejemplo funcione, debemos esperar a que el esclavo se ponga al día. Estilo de fuerza bruta. */
$intentos = 0;
do {
  /* comprobar si el esclavo posee la tabla */
  if ($resultado = $mysqli->query("SELECT id FROM test")) {
    break;
  } else if ($mysqli->errno) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
  }
  /* esperar a que el esclavo se ponga al día */
  usleep(200000);
} while ($intentos++ < 10);

/* La consulta ha sido ejecutada en un esclavo, el resultado está en la caché */
assert($resultado);
var_dump($resultado->fetch_assoc());

/* Servido desde la caché */
$resultado = $mysqli->query("SELECT id FROM test");
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   El ejemplo muestra cómo usar la caché. Primero, se ha de establecer
   la calidad del servicio a consistencia eventual y explícitamente permitir el almacenamiento en caché.
   Esto se lleva a cabo llamando a <function>mysqlnd_ms_set_qos</function>.
   Luego, el conjunto de resultados de cada sentencia de solo lectura se almacena en la caché hasta un
   máximo de segundos según lo permitido por <function>mysqlnd_ms_set_qos</function>.
  </para>
  <para>
   El TTL real es menor o igual al valor establecido
   con <function>mysqlnd_ms_set_qos</function>. El valor pasado a la función
   establece la edad máxima (en segundos) de los datos proporcionados. Para calcular
   el valor real del TTL, se comprueba la demora de replicación de un servidor y se resta
   del valor dado. Si, por ejemplo, la edad máxima es de 60 segundos y
   el esclavo notifica una demora de 10 segundos, el TTL resultante es de 50 segundos.
   El TTL se calcula de forma individual para cada consulta de la caché.
  </para>
  <para>
   <example>
    <title>Lectura de sus escrituras y almacenamiento en caché combinados</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

if (!$mysqli->query("DROP TABLE IF EXISTS test") ||
    !$mysqli->query("CREATE TABLE test(id INT)") ||
    !$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Explícitamente permite la consistencia eventual y el almacenamiento en caché (TTL <= 60 segundos) */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL, MYSQLND_MS_QOS_OPTION_CACHE, 60)) {
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Para que este ejemplo funcione, debemos esperar a que el esclavo se ponga al día. Estilo de fuerza bruta. */
$intentos = 0;
do {
  /* comprobar si el esclavo posee la tabla */
  if ($resultado = $mysqli->query("SELECT id FROM test")) {
    break;
  } else if ($mysqli->errno) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
  }
  /* esperar a que el esclavo se ponga al día */
  usleep(200000);
} while ($intentos++ < 10);

assert($resultado);

/* La consulta ha sido ejecutada en un esclavo, el resultado está en la caché */
var_dump($resultado->fetch_assoc());

/* Servido desde la caché */
if (!($resultado = $mysqli->query("SELECT id FROM test")))
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
var_dump($resultado->fetch_assoc());

/* Actualización en el maestro */
if (!$mysqli->query("UPDATE test SET id = 2"))
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Lectura de sus escrituras */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION)) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Obtener los últimos datos */
if (!($resultado = $mysqli->query("SELECT id FROM test")))
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
var_dump($resultado->fetch_assoc());
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   La calidad del servicio se puede cambiar en cualquier momento para evitar el uso de la caché.
   Si fuera necesario, se podría cambiar la lectura de sus escrituras (consistencia de sesión). En este caso,
   la caché no se usará y se leerán datos actuales.
  </para>
 </section>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
