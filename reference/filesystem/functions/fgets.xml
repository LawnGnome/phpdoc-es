<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.4 $ -->
<!-- EN-Revision: 1.16 Maintainer: lboshell Status: ready -->
<!-- splitted from ./en/functions/filesystem.xml, last change in rev 1.2 -->
  <refentry id="function.fgets">
   <refnamediv>
    <refname>fgets</refname>
    <refpurpose>Obtiene una línea desde el apuntador de
    archivo</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
     <methodsynopsis>
      <type>string</type><methodname>fgets</methodname>
      <methodparam><type>resource</type><parameter>gestor</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>longitud</parameter></methodparam>
     </methodsynopsis>
    <para>
     Devuelve una cadena de hasta <parameter>longitud</parameter> - 1
     bytes leídos desde el archivo apuntado por
     <parameter>gestor</parameter>. La lectura termina cuando se han
     leído <parameter>longitud</parameter> - 1 bytes, se alcanza un
     salto de línea (el cual se incluye en el valor devuelto), o en
     EOF (lo que ocurra primero). Si no se especifica una longitud, la
     función seguirá leyendo desde la secuencia hasta que llegue al
     final de línea.
    </para>
    <para>
     Si ocurre un error, devuelve &false;.
    </para>
    <para>
     Errores comunes:
    </para>
    <simpara>
     Aquellos acostumbrados a la semántica de
     <function>fgets</function> en 'C', debe notar la diferencia en el
     modo en que <literal>EOF</literal> es devuelto.
    </simpara>

    &fs.validfp.all;

    <para>
     A continuación se presenta un ejemplo simple:
     <example>
      <title>Lectura de un archivo línea a línea</title>
      <programlisting role="php">
<![CDATA[
<?php
$gestor = @fopen("/tmp/archivo_entrada.txt", "r");
if ($gestor) {
    while (!feof($gestor)) {
        $bufer = fgets($gestor, 4096);
        echo $bufer;
    }
    fclose ($gestor);
}
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <simpara>
      El parámetro <parameter>longitud</parameter> se hizo opcional en
      PHP 4.2.0. Hasta PHP 4.3.0, al ser omitido, se asume 1024 como
      la longitud de línea. Si la mayoría de líneas en el archivo
      superan los 8KB, es más eficiente en términos de recursos
      espicificar la longitud máxima de línea en su script.
     </simpara>
    </note>
    <note>
     <simpara>
      Esta función es segura con material binario desde PHP 4.3. Las
      versiones anteriores no contaban con esta característica.
     </simpara>
    </note>
    &note.line-endings;
    <para>
     Vea también <function>fgetss</function>
     <function>fread</function>, <function>fgetc</function>,
     <function>stream_get_line</function>, <function>fopen</function>,
     <function>popen</function>, <function>fsockopen</function>, y
     <function>stream_set_timeout</function>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
