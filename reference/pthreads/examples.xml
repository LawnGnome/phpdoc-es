<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 327532 Maintainer: seros Status: ready -->
<!-- Reviewed: no -->
<chapter xml:id="pthreads.tutorials" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 &reftitle.examples;
 
 <section role="examples">
  <para>Este ejemplo de HolaMundo demuestra lo sencillo que es definir y ejecutar subprocesos (hilos) en aplicaciones de PHP</para>
  <example>
   <title>Ejemplo de Hola Mundo</title>
   <programlisting role="php">
<![CDATA[
<?php
class HolaMundo extends Thread {
    public function __construct($mundo) {
       $this->mundo = $mundo;
    }

    public function run() {
        return sprintf("Hola %s", $this->mundo);
    }
}

$hilo = new HolaMundo("Mundo");

if ($hilo->start()) {
    printf("El hilo #%lu dice: %s\n", $hilo->getThreadId(), $hilo->join());
}
?>
]]>
   </programlisting>
  </example>
 </section>
 
 <section role="examples">
  <para>
   El propósito de PHP es generar contenido, y el tener el subprocesamiento en la "caja de herramientas"
   provee de más contenido. Pero el contenido es un tema relativo. Por esta
   razón, es necesario un buen control sobre cuándo a un subproceso se le permite ejecutarse,
   o, de hecho, es forzado a esperar.
  </para>
  <para>
   Por ejemplo, un motor de metabúsquedas podría realizar lo siguiente:
  </para>
  <orderedlist>
   <listitem>
    <para>
     Inicializar una búsquda con un orgien principal de datos
    </para>
   </listitem>
   <listitem>
    <para>
     Registrar los resultados del uso de la API para análisis de estadísticas
    </para>
   </listitem>
   <listitem>
    <para>
     Almacenar en caché los resultados para limitar el uso externo de la API
    </para>
   </listitem>
   <listitem>
    <para>
     Consultar las bases de datos locales para generar contenido de página (búsquedas recientes, etc.)
    </para>
   </listitem>
   <listitem>
    <para>
     Registrar los resultados del uso de la base de datos local, del de HTTP, del de la caché
     y, posiblemente, recurrir a un origen secundario y volver al paso 2;
    </para>
   </listitem>
   <listitem>
    <para>
     Generar contenido (HTML) desde los resultados de la API, xml/json, etc.
    </para>
   </listitem>
   <listitem>
    <para>
     Enviar el contenido al cliente
    </para>
   </listitem>
  </orderedlist>
  <para>
   En un diseño multisubprocesado, la tarea 2 delegada de un subproceso no tiene posibilidad de ejecutarse
   hsata que el subproceso 1 haya devuelto un resultado.
  </para>
  <para>
   En un diseño extermo, donde cada tarea tiene asignado un subproceso, los subprocesos 2,3,4,5,
   e incluso el 6, pueden ser ejecutados concurrentemente, aunque todos dependen de que el subproceso 1
   devuelva contenido.
  </para>
  <para>
   pthreads incluye una forma fácil de sincronizar cuándo a los subprocesos se les permite
   ejecutarse, o ser forzados a esperar, para permitir un subprocesamiento flexible y potente
   si está siendo usado por un motor de búsqueda o por la administración (esto es, trabajos cron).
  </para>
  <example>
   <title>Sincronización</title>
   <programlisting role="php">
<![CDATA[
<?php
class Tarea1 extends Thread {
    public function __construct($parámetros) {
        $this->parámetros = $parámetros;
    }
  
    /* ... */
  
    public function run() {

       /* posiblemente, administrar algo aquí, quizás buscar en cachés locales, comprobar si el cliente es googlebot, etc. */
       if ($this->asegurarDisponibilidad()) {
           $this->notify();
           return $this->conjuntoResultados();
       }
    }
}
 
class Tarea2 extends Thread {
    public function __construct($tarea1, $parámetros) {
        $this->tarea1 = $tarea1;
        $this->parámetros = $parámetros;
    }
  
    /* ... */
  
    public function run(){
    $tarea1 = Thread::getThread($this->tarea1);
        if ($tarea1->wait()) {
            $this->crearRegistros();
        }
    }
}
 
$tareas    = array();
$tareas[0] = new Tarea1($_POST);
$tareas[1] = new Tarea2($tareas[0]->getThreadId(), $_POST);
/* ... */
 
foreach ($tareas as $id => $tarea) {
    $tarea->start();
}
 
/* ... */
?>
]]>
   </programlisting>
  </example>
  <para>
   Al utilizar el mecanismo de espera/notificación ('wait/notify') incluido en pthreads, se oculta
   la complejidad de usar Variables de Mutex y de Condición para sincronizar subprocesos, simplifica mucho
   la legibilidad y, más importante, la sostenibilidad de una idea o implementación.
  </para>
 </section>
 
 <section role="examples">
  <para>
   pthreads permite el acceso directo a (un subconjunto de) estas características.
   El programador debería tener cuidado al destruir gestores de Variables de Mutex y
   de Condición que ya no sean necesarios para la lógica.
  </para>
  <para>
   Las Variables de Mutex y de Condición no son destruidas en representación del programador
   como otros recursos de PHP, ya que esto limitaría su utilidad al contexto
   de multisubprocesamiento en entornos SAPI.
  </para>
  <para>
   Son almacenadas y repartidos fácilmente ya que están representadas como números de tipo long.
   Las Variables de Mutex y de Condición persisten una vez asignadas, hasta que se destruyan
   explícitamente.
  </para>
  <example>
   <title>Variables de Mutex y de Condición</title>
   <programlisting role="php">
<![CDATA[
<?php
/* ... */
if (Cond::broadcast($finalizado)) {
    Cond::destroy($finalizado);
    Mutex::destroy($señales);
}
?>
]]>
   </programlisting>
  </example>
  <para>
   El trozo de código de arriba muestra un script de PHP que envía su propagación (broadcast) final
   a los subprocesos que haya creado, y limpia la Variable de Condición que creó y usó para
   dicha propagación. Otros subprocesos que estaban esperando una señal sobre $finalizado estaban
   usando $señales (espearar una señal siempre requiere una Mutex) y, ya que la
   Variable de condición ya no es válida, la Mutex acompañante también es destruida.
  </para>
  <para>
   <warning>
    <para>
     Antes de que el programador intente usar Variables de Condición debería tener
     experiencia en los "Despertares Falsos" que deja margen la especificación de
     Subprocesos de Posix sobre la que está construida pthreads.
    </para>
    <para>
     Una breve explicación del problema es como sigue:
    </para>
    <para>
     Una llamada a Cond::wait podría devolver antes de que la Variable de Condición reciba una
     señal legítima como resultado de otro contexto que llame a Cond::signal
     o a Cond::broadcast. Debido a este comportamiento, una llamada para esperar una
     señal o una Variable de Condición debería comprobar una afirmación (usualmente un valor
     booleano) sobre la devolución desde la llamada a Cond::wait. Esto elimina el
     riesgo de Despertares Falsos.
    </para>
   </warning>
  </para>
 </section>
 
 <section role="examples">
  <title>Miembros de subprocesos</title>
  <para>
   Los miembros de un subproceso pueden ser de cualquier tipo que admita la serialización de
   PHP, incluyendo clases declaradas por el programador.
  </para>
  <para>
   En el caso donde un subproceso contenga miembros que son de un tipo declarado por el programador
   (clase), éste debe incluir la declaración usando el método mágico
   Thread::__prepare.
  </para>
  <para>
   El método Thread::__prepare es ejecutado por pthreads en el contexto recién creado,
   antes de que dicho contexto ejecute Thread::run. Esto lleva a la deserialización
   correcta del tipo declarado por el programador en el nuevo contexto.
  </para>
  <example>
   <programlisting role="php">
<![CDATA[
<?php
class EjemploSubproceso extends Thread {
    public function __prepare(){
        require_once("/ruta/a/inc.php");
    }

    public function __construct($miTipo){
        $this->miTipo = $miTipo;
    }

    public function run(){
        if (method_exists($this->miTipo, "miMétodo")) {
    
        }
   }
}

require_once("/ruta/a/inc.php");
/* ... */

$mi = new Inc();
/* ... */

$ejemplo = new EjemploSubproceso($mi);
if ($ejemplo->start()) {
    /* ... */
}
?>
]]>
   </programlisting>
  </example>
  <para>
   En el ejemplo de arriba, /ruta/a/inc.php declara una clase, como definida por el
   programador. Éste incluye la declaración en el ámbito global
   antes de pasar una instancia del objeto a una instancia de EjemploSubproceso.
   La instancia de EjemploSubproceso puede manipular el objeto y ejecutar
   funciones de miembros que tengan incluida la declaración mediante __prepare.
  </para>
 </section>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
