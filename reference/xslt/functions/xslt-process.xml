<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 327484 Maintainer: seros Status: ready -->
<!-- Reviewed: no -->
<refentry xml:id="function.xslt-process" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>xslt_process</refname>
  <refpurpose>Realizar una transformación <acronym>XSLT</acronym></refpurpose>
 </refnamediv>
 
 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>mixed</type><methodname>xslt_process</methodname>
   <methodparam><type>resource</type><parameter>xh</parameter></methodparam>
   <methodparam><type>string</type><parameter>xmlcontainer</parameter></methodparam>
   <methodparam><type>string</type><parameter>xslcontainer</parameter></methodparam>
   <methodparam choice="opt"><type>string</type><parameter>resultcontainer</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter>arguments</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter>parameters</parameter></methodparam>
  </methodsynopsis>
  <para>
   La función <function>xslt_process</function> es crucial para la extensión
   <acronym>XSLT</acronym>. Permite realizar una transformación <acronym>XSLT</acronym> empleando
   casi cualquier tipo de origen de entrada - los contenedores. Esto se realiza
   a través del uso de búferes de argumentos -- un concepto tomado del procesador
   de <acronym>XSLT</acronym> <productname>Sablotron</productname> (actualmente el único procesador de <acronym>XSLT</acronym> que admite esta extensión).
   El valor predeterminado para los contenedores de entrada es un nombre de fichero que
   'contiene' el documento a procesar.
  </para>
 </refsect1>
 
 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    &xslt.parameter.xh;
    <varlistentry>
     <term><parameter>xmlcontainer</parameter></term>
     <listitem>
      <para>
       La ruta al fichero <acronym>XML</acronym> o el parámetro de sustitución para
       el argumento <acronym>XML</acronym>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>xslcontainer</parameter></term>
     <listitem>
      <para>
       La ruta al fichero <acronym>XSL</acronym> o el parámetro de sustitución para
       el argumento <acronym>XML</acronym>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>resultcontainer</parameter></term>
     <listitem>
      <para>
       El valor predeterminado apara el contenedor resultante es un nombre de fichero para
       el documento transformado. Si el contenedor resultante no se especifica - es decir, &null;
       - se devuelve el resultado.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>arguments</parameter></term>
     <listitem>
      <para>
       En vez de especificar ficheros para los argumentos <acronym>XML</acronym> y <acronym>XSLT</acronym> de la función
       <function>xslt_process</function>, se pueden especificar &quot;parámetros de sustitución de argumentos&quot; que serán
       sustituidos por los valores dados en el array <parameter>arguments</parameter>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>parameters</parameter></term>
     <listitem>
      <para>
       Un array para cualquier parámetro del más alto nivel que será pasado al documento
       XSLT. Se puede acceder a estos parámetros dentro de los ficheros XSL
       empleando la instrucción <literal>&lt;xsl:param name=&quot;nombre_parámetro&quot;&gt;</literal>.
       Los parámetros deben estar codificados en UTF-8 y sus valores interpretados
       como string por el procesador <productname>Sablotron</productname>.
       En otras palabras, no se pueden pasar <literal>conjuntos de nodos</literal> como parámetros al
       documento <acronym>XSLT</acronym>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  <para>
   Los contenedores también se pueden establecer mediante el array
   <parameter>arguments</parameter> (véase más abajo).
  </para>
 </refsect1>
 
 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   &return.success; Si no se especifica el contenedor resultante - es decir,
   &null; - se devuelve el resultado.
  </para>
 </refsect1>
 
 <refsect1 role="changelog">
  &reftitle.changelog;
  <para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>4.0.6</entry>
       <entry>
        Esta función ya no toma string de XML en
        <parameter>xmlcontainer</parameter> o
        <parameter>xslcontainer</parameter>. Pasar un string que contiene XML
        a cualquiera de estos parámetros resultará en un error de segmentación en
        versiones de Sablotron hasta e incluyendo la 0.95.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </refsect1>
 
 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   El tipo de transformación más sencilla con la función
   <function>xslt_process</function> es la transformación de un
   fichero <acronym>XML</acronym> con un fichero <acronym>XSLT</acronym>, colocando el resultado
   en un tercer fichero que contiene el nuevo documento <acronym>XML</acronym> (o HTML).
   Hacer esto con <productname>Sablotron</productname> es realmente sencillo...
  </para>
  <example>
   <title>Usar <function>xslt_process</function> para transformar un fichero <acronym>XML</acronym>
    y un fichero <acronym>XSL</acronym> en un nuveo fichero <acronym>XML</acronym></title>
   <programlisting role="php">
<![CDATA[
<?php

// Asignar un nuevo procesador de XSLT
$xh = xslt_create();

// Procesar el documento
if (xslt_process($xh, 'muestra.xml', 'muestra.xsl', 'resultado.xml')) {
    echo "ÉXITO, muestra.xml se transformó mediante muestra.xsl en resultado.xml";
    echo ", resultado.xml contiene lo siguiente:\n<br />\n";
    echo "<pre>\n";
    readfile('resultado.xml');
    echo "</pre>\n";
} else {
    echo "Lo sentimos, muestra.xml no se pudo transformar mediante muestra.xsl en";
    echo " resultado.xml; la razón es: " . xslt_error($xh) . ", y el";
    echo " código de error es " . xslt_errno($xh);
}

xslt_free($xh);

?>
]]>
   </programlisting>
  </example>
  <para>
   Aunque esta es una gran funcionalidad, muchas veces, especialmente en un entorno web, se querrá
   imprimir el resultado directamente. Por lo tanto, si se omite el tercer argumento de
   la función <function>xslt_process</function> (o se proporciona un valor NULL para dicho argumento),
   automáticamente devolverá el valor de la transformación <acronym>XSLT</acronym>, en lugar de escribirla
   en un fichero...
  </para>
  <para>
   <example>
    <title>Usar <function>xslt_process</function> para transformar un fichero <acronym>XML</acronym>
     y un fichero <acronym>XSL</acronym> a una variable que contiene los datos XML resultantes</title>
    <programlisting role="php">
<![CDATA[
<?php

// Asignar un nuevo procesador de XSLT
$xh = xslt_create();

// Procesar el documento, devolviendo el resultado en la variable $resultado
$resultado = xslt_process($xh, 'muestra.xml', 'muestra.xsl');
if ($resultado) {
    echo "ÉXITO, muestra.xml se transformó mediante muestra.xsl en la variable";
    echo " \$result; la variable \$resultado continene lo siguiente:\n<br />\n";
    echo "<pre>\n";
    echo $resultado;
    echo "</pre>\n";
} else {
    echo "Lo sentimos, muestra.xml no se pudo transformar mediante muestra.xsl en";
    echo " la variable \$resultado; la razón es: " . xslt_error($xh);
    echo " y el código de error es " . xslt_errno($xh);
}

xslt_free($xh);

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Los dos casos anteriores son los más sencillos que existen para usar transformaciones XSLT,
   y me atrevo a decir que son los casos más comunes; sin embargo, algunas veces se obtiene el código <acronym>XML</acronym> y
   <acronym>XSLT</acronym> desde fuentes externas, como una base de datos o un socket. En estos casos se tendrán
   los datos <acronym>XML</acronym> y/o <acronym>XSLT</acronym> en una variable -- por lo que en aplicaciones de producción la sobrecarga de depositar
   dichos datos a un fichero podría ser excesiva. Aquí es cuando la sintaxis de &quot;argumentos&quot; de <acronym>XSLT</acronym> viene al
   rescate. En vez de pasar ficheros a los argumentos <acronym>XML</acronym> y <acronym>XSLT</acronym> de la función
   <function>xslt_process</function>, se pueden especificar &quot;parámetros de sustitución de argumentos&quot;, los cuales son sustituidos
   por los valores dados en el array de argumentos (5º parámetro de la función <function>xslt_process</function>).
   El siguiente es un ejemplo de tranformación de <acronym>XML</acronym> y <acronym>XSLT</acronym> en una variable de resultado sin
   emplear ningún fichero.
  </para>
  <para>
   <example>
    <title>Usar <function>xslt_process</function> para transformar una variable que contiene datos <acronym>XML</acronym>
     y una variable que contiene datos <acronym>XSL</acronym> en una variable que contiene los datos <acronym>XML</acronym> resultantes</title>
    <programlisting role="php">
<![CDATA[
<?php
// $xml y $xsl contienen los datos XML y XSL

$argumentos = array(
     '/_xml' => $xml,
     '/_xsl' => $xsl
);

// Allocate a new XSLT processor
$xh = xslt_create();

// Procesar el documento
$resultado = xslt_process($xh, 'arg:/_xml', 'arg:/_xsl', NULL, $argumentos);
if ($resultado) {
    echo "ÉXITO, muestra.xml se transformó mediante muestra.xsl en la variable";
    echo " \$result; la variable \$resultado continene lo siguiente:\n<br />\n";
    echo "<pre>\n";
    echo $resultado;
    echo "</pre>\n";
} else {
    echo "Lo sentimos, muestra.xml no se pudo transformar mediante muestra.xsl en";
    echo " la variable \$resultado; la razón es: " . xslt_error($xh);
    echo " y el código de error es " . xslt_errno($xh);
}
xslt_free($xh);
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Pasar variables de PHP a ficheros XSL</title>
    <programlisting role="php">
<![CDATA[
<?php

// String XML
$xml = '<?xml version="1.0"?>
<para>
 change me
</para>';

// String XSL
$xsl = '
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="html" encoding="ISO-8859-1" indent="no"
 omit-xml-declaration="yes"  media-type="text/html"/>
 <xsl:param name="mivar"/>
 <xsl:param name="minodo"/>
 <xsl:template match="/">
Mi variable de PHP : <xsl:value-of select="$mivar"/><br />
Mi conjunto de nodos : <xsl:value-of select="$minodo"/>
 </xsl:template>
</xsl:stylesheet>';


$xh = xslt_create();

// el segundo parámetro será interpretado como un string
$parámetros = array (
  'mivar' => 'test',
  'minodo' => '<foo>bar</foo>'
);

$argumentos = array (
  '/_xml' => $xml,
  '/_xsl' => $xsl
);

echo xslt_process($xh, 'arg:/_xml', 'arg:/_xsl', NULL, $argumentos, $parámetros);

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Mi variable de PHP : test<br>
Mi conjunto de nodos : &lt;foo&gt;bar&lt;/foo&gt;
]]>
    </screen>
   </example>
  </para>
 </refsect1>
 
 <refsect1 role="notes">
  &reftitle.notes;
  &note.xslt.windows;
 </refsect1>
 
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
