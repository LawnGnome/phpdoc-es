<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.8 $ -->
<!-- EN-Revision: 1.17 Maintainer: lboshell Status: ready -->
<!-- splitted from ./en/functions/array.xml, last change in rev 1.11 -->
  <refentry id="function.array-multisort">
   <refnamediv>
    <refname>array_multisort</refname>
    <refpurpose>Ordena m&uacute;ltiples matrices, o matrices
    multi-dimensionales</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripci&oacute;n</title>
    <methodsynopsis>
     <type>bool</type><methodname>array_multisort</methodname>
     <methodparam><type>array</type><parameter>matriz1</parameter></methodparam>
     <methodparam choice="opt"><type>mixed</type><parameter>arg</parameter></methodparam>
     <methodparam choice="opt"><type>mixed</type><parameter>...</parameter></methodparam>
     <methodparam choice="opt"><type>array</type><parameter>...</parameter></methodparam>
     <!-- Parameters don't need to be passed by reference -->
    </methodsynopsis>
    <para>
     &return.success;
    </para>
    <para>
     <function>array_multisort</function> puede usarse para ordenar
     varias matrices al tiempo, o una matriz multi-dimensional por una
     o m&aacute;s dimensiones.
    </para>
    <para>
     Las llaves asociativas (<type>string</type>) son conservadas,
     aunque las llaves num&eacute;ricas son re-indexadas.
    </para>
    <para>
     Las matrices de entrada son tratadas como columnas de una tabla
     que deber&aacute; ser ordenada por filas - de forma similar a la
     funcionalidad de una sentencia SQL ORDER BY. La primera matriz es
     considerada la primaria para el ordenamiento. Las filas (valores)
     en esa matriz que sean comparadas como iguales son ordenadas por
     la siguiente matriz de entrada, y as&iacute; sucesivamente.
    </para>
    <para>
     La estructura de argumentos de esta funci&oacute;n es un poco
     inusual, pero flexible. El primer argumento debe ser una
     matriz. Subsecuentemente, cada argumento puede ser o una matriz o
     una bandera de ordenamiento de las siguientes.
    </para>
    <para>
     Banderas de orientaci&oacute;n del ordenamiento:
     <itemizedlist>
      <listitem>
       <simpara><constant>SORT_ASC</constant> - Ordenar ascendentemente</simpara>
      </listitem>
      <listitem>
       <simpara><constant>SORT_DESC</constant> - Ordenar descendentemente</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Banderas de tipo de ordenamiento
     <itemizedlist>
      <listitem>
       <simpara><constant>SORT_REGULAR</constant> - Comparar elementos
       normalmente</simpara>
      </listitem>
      <listitem>
       <simpara><constant>SORT_NUMERIC</constant> - Comparar elementos
       num&eacute;ricamente</simpara>
      </listitem>
      <listitem>
       <simpara><constant>SORT_STRING</constant> - Comparar elementos como
       cadenas</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     No pueden especificarse dos banderas de ordenamiento del mismo
     tipo luego de cada matriz. Las banderas de ordenamiento
     especificadas a continuaci&oacute;n de un argumento matriz se
     aplican s&oacute;lo a esa matriz - estos valores son
     restablecidos de vuelta a <constant>SORT_ASC</constant> y
     <constant>SORT_REGULAR</constant> antes de cada nuevo argumento
     matriz.
    </para>

    <para>
     <example>
      <title>Ordenamiento de varias matrices</title>
      <programlisting role="php">
<![CDATA[
<?php
$matriz1 = array("10", 100, 100, "a");
$matriz2 = array(1, 3, "2", 1);
array_multisort($matriz1, $matriz2);

var_dump($matriz1);
var_dump($matriz2);
?>
]]>
      </programlisting>
      <para>
       En este ejemplo, despu&eacute;s del ordenamiento, la primera
       matriz contendr&aacute; los valores 10, "a", 100, 100. La
       segunda matriz contendr&aacute; 1, 1, "2", 3. Las entradas en
       la segunda matriz que correspond&iacute;an a las entradas
       id&eacute;nticas de la primera matriz (100 y 100) fueron
       ordenadas tambi&eacute;n.
      </para>
      <screen>
<![CDATA[
array(4) {
  [0]=> string(2) "10"
  [1]=> string(1) "a"
  [2]=> int(100)
  [3]=> int(100)
}
array(4) {
  [0]=> int(1)
  [1]=> int(1)
  [2]=> string(1) "2"
  [3]=> int(3)
}
]]>
      </screen>
     </example>
    </para>

    <para>
     <example>
      <title>Ordenamiento de una matriz multi-dimensional</title>
      <programlisting role="php">
<![CDATA[
<?php
$matriz = array(
       array("10", 11, 100, 100, "a"),
       array(   1,  2, "2",   3,   1)
      );
array_multisort($matriz[0], SORT_ASC, SORT_STRING,
                $matriz[1], SORT_NUMERIC, SORT_DESC);
var_dump($matriz);
?>
]]>
      </programlisting>
      <para>
       En este ejemplo, despu&eacute;s del ordenamiento, la primera
       matriz se transformará a 10, 100, 100, 11, "a" (fue ordenada
       como cadenas en orden ascendente), y la segunda tendr&aacute;
       1, 3, "2", 2, 1 (ordenada como n&uacute;meros, en orden
       descendiente).
      </para>
      <screen>
<![CDATA[
array(2) {
  [0]=> array(5) {
    [0]=> string(2) "10"
    [1]=> int(100)
    [2]=> int(100)
    [3]=> int(11)
    [4]=> string(1) "a"
  }
  [1]=> array(5) {
    [0]=> int(1)
    [1]=> int(3)
    [2]=> string(1) "2"
    [3]=> int(2)
    [4]=> int(1)
  }
}
]]>
      </screen>
     </example>
    </para>

    <para>
     <example>
      <title>Ordenamiento de resultados de una base de datos</title>
      <para>
       Para este ejemplo, cada elemento en la matriz
       <varname>datos</varname> representa una fila en una tabla. Este
       tipo de conjunto de datos es t&iacute;pico de los registros en
       una base de datos.
      </para>
      <para>
       Datos de ejemplo:
      </para>
      <screen>
<![CDATA[
volumen| edicion
-------+--------
    67 |       2
    86 |       1
    85 |       6
    98 |       2
    86 |       6
    67 |       7
]]>
      </screen>
      <para>
       Las datos como una matriz, llamada
       <varname>datos</varname>. &Eacute;sta se obtendr&iacute;a
       usualmente, por ejemplo, mediante un ciclo con
       <function>mysql_fetch_assoc</function>.
      </para>
      <programlisting role="php">
<![CDATA[
<?php
$datos[] = array('volumen' => 67, 'edicion' => 2);
$datos[] = array('volumen' => 86, 'edicion' => 1);
$datos[] = array('volumen' => 85, 'edicion' => 6);
$datos[] = array('volumen' => 98, 'edicion' => 2);
$datos[] = array('volumen' => 86, 'edicion' => 6);
$datos[] = array('volumen' => 67, 'edicion' => 7);
?>
]]>
      </programlisting>
      <para>
       En este ejemplo, ordenaremos por <varname>volumen</varname>
       descendientemente, y por <varname>edicion</varname>
       ascendentemente.
      </para>
      <para>
       Tenemos una matriz de filas, pero
       <function>array_multisort</function> requiere una matriz de
       columnas, as&iacute; que usamos el c&oacute;digo a
       continuaci&oacute;n para obtener las columnas, y luego realizar
       el ordenamiento.
      </para>
      <programlisting role="php">
<![CDATA[
<?php
// Obtener una lista de columnas
foreach ($datos as $llave => $fila) {
    $volumen[$llave]  = $fila['volumen'];
    $edicion[$llave] = $fila['edicion'];
}
// Ordenar los datos con volumen descendiente, edicion ascendiente
// Agregar $datos como el ultimo parametro, para ordenar por la llave comun
array_multisort($volumen, SORT_DESC, $edicion, SORT_ASC, $datos);
?>
]]>
      </programlisting>
      <para>
       El conjunto de datos est&aacute; ordenado ahora, y
       lucir&aacute; de este modo:
      </para>
      <screen>
<![CDATA[
volumen| edicion
-------+--------
    98 |       2
    86 |       1
    86 |       6
    85 |       6
    67 |       2
    67 |       7
]]>
      </screen>
     </example>
    </para>

    <para>
     <example>
      <title>Ordenamiento insensible a
      may&uacute;sculas/min&uacute;sculas</title>
      <para>
       Tanto <constant>SORT_STRING</constant> como
       <constant>SORT_REGULAR</constant> son sensibles a
       may&uacute;sculas/min&uacute;sculas, las cadenas que comienzan
       con una letra may&uacute;scula vendr&aacute;n antes que las
       cadenas con una letra min&uacute;scula.
      </para>
      <para>
       Para realizar una b&uacute;squeda insensible a
       min&uacute;sculas y may&uacute;sculas, aseg&uacute;rese de que
       el orden sea determinado por una copia en min&uacute;sculas de
       la matriz original.
      </para>
      <programlisting role="php">
<![CDATA[
<?php
$matriz = array('Alpha', 'atomico', 'Beta', 'banco');
$matriz_minusculas = array_map('strtolower', $matriz);

array_multisort($matriz_minusculas, SORT_ASC, SORT_STRING, $matriz);

print_r($matriz);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array
(
    [0] => Alpha
    [1] => atomico
    [2] => banco
    [3] => Beta
)
]]>
      </screen>
     </example>
    </para>

   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
