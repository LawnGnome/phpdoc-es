<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 337115 Maintainer: seros Status: ready -->
<!-- Reviewed: no -->

<book xml:id="mongodb.persistence" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <titleabbrev>Persistencia de datos</titleabbrev>
 <title>Serialización y deserialización de variables de PHP en MongoDB</title>
 
 <article xml:id="mongodb.persistence.article">
  <titleabbrev>Persistencia de datos</titleabbrev>
  <title>Serialización y deserialización de variables de PHP en MongoDB</title>
  
  <para>
   Este documento trata sobre los métodos de cómo las estructuras compuestas (documentos,
   arrays, objetos) se hacen persistentes a través de los controladores y de cómo son llevadas
   de vuelta a PHP.
  </para>
  
  <section>
   <title>Serialización a BSON</title>
   
   <section>
    <title>Arrays</title>
    
    <para>
     Si un array es un <emphasis>array compacto</emphasis>, esto es, las claves empiezan
     en 0 y están en secuencia sin huecos: <emphasis>array BSON</emphasis>. 
    </para>
    
    <para>
     Si el array no es compacto, esto es, tiene claves asociativas (string), las
     claves no comienzan en 0, o cuando hay huecos: <emphasis>objeto
     BSON</emphasis>
    </para>
    
    <para>
     Un documento del más alto nivel (raíz), <emphasis>siempre</emphasis> se serializa como un
     documento BSON.
    </para>
    
    <section>
     <title>Ejemplos</title>
     
     <para>
      Los siguientes arrays se serializan como arrays BSON:
     </para>
     
     <programlisting>
      [ 8, 5, 2, 3 ] => [ 8, 5, 2, 3 ]
      [ 0 => 4, 1 => 9 ] => [ 4, 9 ]
     </programlisting>
     
     <para>
      Estos se serializan como documentos BSON:
     </para>
     
     <programlisting>
      [ 0 => 1, 2 => 8, 3 => 12 ] => { "0" : 1, "2" : 8, "3" : 12 }
      [ "foo" => 42 ] => { "foo" : 42 }
      [ 1 => 9, 0 => 10 ] => { "1" : 9, "0" : 10 }
     </programlisting>
     
     <para>
      Observe que los cinco ejemplos son <emphasis>fragmentos</emphasis> de un documento
      completo que representan solamente <emphasis>un</emphasis> valor dentro de un
      documento.
     </para>
     
    </section>
   </section>
   
   <section>
    <title>Objetos</title>
    
    <para>
     Si un objeto es de la clase <classname>stdClass</classname> se serializa
     como un <emphasis>documento BSON</emphasis>.
    </para>
    
    <para>
     Si un objeto es de una clase admitida que implementa
     <classname>MongoDB\BSON\Tipo</classname>, se utiliza la lógica de
     serialización BSON para un tipo específico.
     Las instancias de <classname>MongoDB\BSON\Tipo</classname> (excluyendo
     <classname>MongoDB\BSON\Serializable</classname> solo podrían ser serializadas
     como un valor de campo de documento. Intentar serializar tales objetos como un
     documento raíz lanzará una
     <classname>MongoDB\Driver\Exception\UnexpectedValueException</classname>
    </para>
    
    <para>
     Si un objeto se de una clase desconocida que implementa la
     interfaz <classname>MongoDB\BSON\Tipo</classname>, lanza una
     <classname>MongoDB\Driver\Exception\UnexpectedValueException</classname>
    </para>
    
    <para>
     Si un objeto es de cualquier otra clase que no implemente ninguna interfaz
     especial, se serializa como un <emphasis>documento BSON</emphasis>. Se mantienen solo
     las propiedades <emphasis>public</emphasis> y se ignoran
     las propiedades <emphasis>protected</emphasis> y
     <emphasis>private</emphasis>.
    </para>
    
    <para>
     Si un objeto es de una clase que implementa la
     interfaz <classname>MongoDB\BSON\Serializable</classname>, se llama a
     <methodname>bsonSerialize</methodname> y se utiliza el array u objeto
     <classname>stdClass</classname> devuelto para serilizarlo como un documento BSON o
     array. El tipo BSON será determinado como sigue:
    </para>
    
    <para>
     <orderedlist>
      <listitem>
       <para>Los documentos raíz deben ser serializados como un documento
        BSON.
       </para>
      </listitem>
      <listitem>
       <para>Los objetos <classname>MongoDB\BSON\Persistable</classname> deben ser
        serializados como un documento BSON.
       </para>
      </listitem>
      <listitem>
       <para>Si <methodname>bsonSerialize</methodname> devuelve un array
        compacto, se serializa como un array BSON.
       </para>
      </listitem>
      <listitem>
       <para>Si <methodname>bsonSerialize</methodname> devuelve un array
        no compacto o un objeto <classname>stdClass</classname>, se serializa como un documento
        BSON.
       </para>
      </listitem>
      <listitem>
       <para>Si <methodname>bsonSerialize</methodname> no devuelve un
        array u objeto <classname>stdClass</classname>, se lanza una
        excepción de tipo
        <classname>MongoDB\Driver\Exception\UnexpectedValueException</classname>.
       </para>
      </listitem>
     </orderedlist>
    </para>
    
    <para>
     Si un objeto es de una clase que implementa la
     interfaz <classname>MongoDB\BSON\Persistable</classname> (lo que implica que
     <classname>MongoDB\BSON\Serializable</classname> obtiene las propiedades
     de una forma similar a los párrafos anteriores, aunque
     <emphasis>también</emphasis> añade una propiedad adicional
     <property>__pclass</property> como un valor Binary, con subtipo
     <literal>0x80</literal> y datos soportando el nombre de la clase completamente cualificado
     del objeto que se está serializando.
    </para>
    
    <para>
     La propiedad <property>__pclass</property> se añade al array u
     objeto devuelto por <methodname>bsonSerialize</methodname>, lo que significa
     que se sobrescribirá cualquier clave/propiedad <property>__pclass</property> en el
     valor devuelto de <methodname>bsonSerialize</methodname>. Para evitar
     este funcionamiento y establecer un valor de <property>__pclass</property>
     propio, <emphasis>no</emphasis> se debe implementar
     <classname>MongoDB\BSON\Persistable</classname> y, en su lugar, se deería
     implementar <classname>MongoDB\BSON\Serializable</classname> directamente.
    </para>
    
    <section>
     <title>Ejemplos</title>
     
     <programlisting>
      stdClass {
      public $foo = 42;
      } => { "foo" : 42 }
      
      MiClase {
      public $foo = 42;
      protected $prot = "wine";
      private $fpr = "cheese";
      } => { "foo" : 42 }
      
      OtraClase1 implements MongoDB\BSON\Serializable {
      public $foo = 42;
      protected $prot = "wine";
      private $fpr = "cheese";
      function bsonSerialize() {
      return [ 'foo' => $this->foo, 'prot' => $this->prot ];
      }
      } => { "foo" : 42, "prot" : "wine" }
      
      OtraClase2 implements MongoDB\BSON\Serializable {
      public $foo = 42;
      function bsonSerialize() {
      return $this;
      }
      } => MongoDB\Driver\Exception\UnexpectedValueException("bsonSerialize() did not return an array or stdClass")
      
      OtraClase3 implements MongoDB\BSON\Serializable {
      private $elementos = [ 'foo', 'bar' ];
      function bsonSerialize() {
      return $this->elementos;
      }
      } => { "0" : "foo", "1" : "bar" }
      
      ClaseContenedora implements MongoDB\BSON\Serializable {
      public $cosas = OtraClase4 implements MongoDB\BSON\Serializable {
      private $elementos = [ 0 => 'foo', 2 => 'bar' ];
      function bsonSerialize() {
      return $this->elementos;
      }
      }
      function bsonSerialize() {
      return [ 'cosas' => $this->cosas ];
      }
      } => { "cosas" : { "0" : "foo", "2" : "bar" } }
      
      ClaseContenedora implements MongoDB\BSON\Serializable {
      public $cosas = OtraClase5 implements MongoDB\BSON\Serializable {
      private $elementos = [ 0 => 'foo', 2 => 'bar' ];
      function bsonSerialize() {
      return array_values($this->elementos);
      }
      }
      function bsonSerialize() {
      return [ 'cosas' => $this->cosas ];
      }
      } => { "cosas" : [ "foo", "bar" ] }
      
      ClaseContenedora implements MongoDB\BSON\Serializable {
      public $cosas = OtraClase6 implements MongoDB\BSON\Serializable {
      private $elementos = [ 'foo', 'bar' ];
      function bsonSerialize() {
      return (object) $this->elementos;
      }
      }
      function bsonSerialize() {
      return [ 'cosas' => $this->cosas ];
      }
      } => { "cosas" : { "0" : "foo", "1" : "bar" } }
      
      UpperClass implements MongoDB\BSON\Persistable {
      public $foo = 42;
      protected $prot = "wine";
      private $fpr = "cheese";
      function bsonSerialize() {
      return [ 'foo' => $this->foo, 'prot' => $this->prot ];
      }
      } => { "foo" : 42, "prot" : "wine", "__pclass" : { "$type" : "80", "$binary" : "VXBwZXJDbGFzcw==" } }
     </programlisting>
    </section>
   </section>
  </section>
  
  <section>
   <title>Deserialización desde BSON</title>
   
   <para>
    Para tipos compuestos, existen tres tipos de datos:
   </para>
   
   <para>
    <variablelist>
     <varlistentry>
      <term>root</term>
      <listitem>
       <para>
        se refiere al documento BSON de más alto nivel <emphasis>solamente</emphasis>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>document</term>
      <listitem>
       <para>
        se refiere a docuemtnos BSON embebidos <emphasis>solamente</emphasis>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>array</term>
      <listitem>
       <para>
        se refiere a un array BSON
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   
   <para>
    Cada uno de estos tres tipos de datos se pueden hacer corresponder con diferentes tipos de PHP.
    Los posibles valores de correspondencia son:
   </para>
   
   <para>
    <variablelist>
     <varlistentry>
      <term><emphasis>no establecido</emphasis> o <type>NULL</type> (es el
       predeterminado)</term>
      <listitem>
       <para>
        <itemizedlist>
         <listitem>
          <para>
           Un array BSON será deserializado como un <type>array</type> de PHP.
          </para>
         </listitem>
         <listitem>
          <para>
           Un documento BSON (raíz o embebido) sin una
           propiedad <property>__pclass</property>
           <footnote xml:id="mongodb.pclass">
            <para>
             Una propiedad __pclass solamente se considera que existe si
             existe una propiedad con ese nombre, y es un valor Binary,
             y el subtipo del valor Binary es 0x80. Si no se da alguna de
             estas tres condiciones, la propiedad __pclass no existe y
             debería ser tratada como otra propiedad normal.
            </para>
           </footnote>
           se convierte en un objeto <classname>stdClass</classname> de PHP, con cada
           clave de documento BSON establecida a propiedad <classname>stdClass</classname>
           pública.
          </para>
         </listitem>
         <listitem>
          <para>
           Un documento BSON (raíz o embebido) con una
           propiedad <property>__pclass</property> <footnoteref linkend="mongodb.pclass"/> se convierte en un objeto de PHP del
           nombre de la clase definida por la propiedad
           <property>__pclass</property>.
          </para>
          <para>
           Si la clase con nombre implementa la
           intefaz <classname>MongoDB\BSON\Persistable</classname>, las
           propiedades del documento BSON, incluyendo la
           propiedad <property>__pclass</property>, son enviadas como un array
           asociativo a la función <methodname>bsonUnserialize</methodname> para
           inicializar la propiedades del objeto.
          </para>
          <para>
           Si la clase con nombre no existe o no implementa la
           interfaz <classname>MongoDB\BSON\Persistable</classname>,
           se empleará <classname>stdClass</classname> y cada clave del documento
           BSON (incluyendo <property>__pclass</property>) será establecida a una
           propiedad <classname>stdClass</classname> pública.
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><literal>"array"</literal></term>
      <listitem>
       <para>
        Convierte un array BSON o documento BSON en un array de PHP. No habrá
        ningún tratamiento especial de una propiedad <property>__pclass</property> <footnoteref linkend="mongodb.pclass"/>,
        aunque se podría establecer como un elemento del array devuelto si estaba
        presente el el documento BSON.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><literal>"object"</literal> o <literal>"stdClass"</literal></term>
      <listitem>
       <para>
        Convierte un array BSON o documento BSON a un
        objeto <classname>stdClass</classname>. No habrá ningún tratamiento
        especial de una propiedad <property>__pclass</property> <footnoteref linkend="mongodb.pclass"/>, aunque se podría
        establecer como propiedad pública del objeto devuelto si estaba presente
        en el documento BSON.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term>cualquier otro string</term>
      <listitem>
       <para>
        Define el nombre de la clase a la que debe ser deserializado el array BSON
        u objeto BSON. Para objetos BSON que incluyan
        propiedades <property>__pclass</property>, esta clase tomará
        prioridad.
       </para>
       
       <para>
        Si la clase citada no existe, no es concreta (esto es, es
        abstracta o es una interfaz), o no implementa
        <classname>MongoDB\BSON\Unserializable</classname>, se lanzará
        una excepción
        <classname>MongoDB\Driver\Exception\InvalidArgumentException</classname>.
       </para>
       
       <para>
        Si el objeto BSON posee una propiedad <property>__pclass</property> y
        esa clase existe e implementa
        <classname>MongoDB\BSON\Persistable</classname>, sustituirá a la
        clase proporcionada en el mapa de tipo.
       </para>
       
       <para>
        Las propiedades del documento BSON, <emphasis>incluyendo</emphasis>
        la propiedad <property>__pclass</property> si existiera, será enviada
        como un array asociativo a la
        función <methodname>bsonUnserialize</methodname> para inicializar las
        propiedades del objeto.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   
   <section xml:id="mongodb.persistence.typemaps">
    <title>TypeMaps</title>
    
    <para>
     TypeMaps se puede establecer a través del
     método <methodname>MongoDB\Driver\Cursor::setTypeMap</methodname> en un
     objeto <classname>MongoDB\Driver\Cursor</classname> o del
     argumento <literal>$typeMap</literal> de
     <function>MongoDB\BSON\toPHP</function>. Cada una de las tres
     clases (<emphasis>root</emphasis>, <emphasis>document</emphasis> and
     <emphasis>array</emphasis>) se pueden establecer individualmente.
    </para>
    
    <para>
     Si el valor del mapa es <type>NULL</type>, significa lo mismo que
     el valor <emphasis>predeterminado</emphasis> para ese elemento.
    </para>
   </section>
   
   <section>
    <title>Ejemplo</title>
    
    <para>
     Estos ejemplos utilizan las siguientes clases:
    </para>
    
    <para>
     <variablelist>
      <varlistentry>
       <term>MiClase</term>
       <listitem>
        <para>
         la cual <emphasis>no</emphasis> implementa ninguna interfaz
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>TuClase</term>
       <listitem>
        <para>
         que implementa <classname>MongoDB\BSON\Unserializable</classname>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>NuestraClase</term>
       <listitem>
        <para>
         que implementa <classname>MongoDB\BSON\Persistable</classname>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>SuClase</term>
       <listitem>
        <para>
         que extiende NuestraClase
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    
    <para>
     El método <methodname>bsonUnserialize</methodname> de TuClase,
     NuestraClase, SuClase recorre el array y establece las propiedades
     sin modificaciones. <emphasis>También</emphasis> establece la propiedad
     <literal>$no_serializada</literal> a <literal>true</literal>:
     
     <programlisting>
      function bsonUnserialize( array $mapa )
      {
      foreach ( $mapa as $clave => $valor )
      {
      $this->$clave = $valor;
      }
      $this->no_serializada = true;
      }
     </programlisting>
    </para>
    
    <para>
     <programlisting>
      /* typemap: [] (all defaults) */
      { "foo": "yes", "bar" : false }
      -> stdClass { $foo => 'yes', $bar => false }
      
      { "foo": "no", "array" : [ 5, 6 ] }
      -> stdClass { $foo => 'no', $array => [ 5, 6 ] }
      
      { "foo": "no", "obj" : { "embedded" : 3.14 } }
      -> stdClass { $foo => 'no', $obj => stdClass { $embedded => 3.14 } }
      
      { "foo": "yes", "__pclass": "MiClase" }
      -> stdClass { $foo => 'yes', $__pclass => 'MiClase' }
      
      { "foo": "yes", "__pclass": { "$type" : "80", "$binary" : "MiClase" } }
      -> stdClass { $foo => 'yes', $__pclass => Binary(0x80, 'MiClase') }
      
      { "foo": "yes", "__pclass": { "$type" : "80", "$binary" : "TuClase") }
      -> stdClass { $foo => 'yes', $__pclass => Binary(0x80, 'TuClase') }
      
      { "foo": "yes", "__pclass": { "$type" : "80", "$binary" : "NuestraClase") }
      -> NuestraClase { $foo => 'yes', $__pclass => Binary(0x80, 'NuestraClase'), $no_serializada => true }
      
      { "foo": "yes", "__pclass": { "$type" : "44", "$binary" : "TuClase") }
      -> stdClass { $foo => 'yes', $__pclass => Binary(0x44, 'TuClase') }
     </programlisting>
    </para>
    
    <para>
     <programlisting>
      /* typemap: [ "root" => "MissingClass" ] */
      { "foo": "yes" }
      -> MongoDB\Driver\Exception\InvalidArgumentException("MissingClass does not exist")
      
      /* typemap: [ "root" => "MiClase" ] */
      { "foo": "yes", "__pclass" : { "$type": "80", "$binary": "MiClase" } }
      -> MongoDB\Driver\Exception\InvalidArgumentException("MiClase no implementa la interfaz Unserializable")
      
      /* typemap: [ "root" => "MongoDB\BSON\Unserializable" ] */
      { "foo": "yes" }
      -> MongoDB\Driver\Exception\InvalidArgumentException("Unserializable is not a concrete class")
      
      /* typemap: [ "root" => "TuClase" ] */
      { "foo": "yes", "__pclass" : { "$type": "80", "$binary": "MongoDB\BSON\Unserializable" } }
      -> TuClase { $foo => "yes", $__pclass => Binary(0x80, "MongoDB\BSON\Unserializable"), $no_serializada => true }
      
      /* typemap: [ "root" => "TuClase" ] */
      { "foo": "yes", "__pclass" : { "$type": "80", "$binary": "MiClase" } }
      -> TuClase { $foo => "yes", $__pclass => Binary(0x80, "MiClase"), $no_serializada => true }
      
      /* typemap: [ "root" => "TuClase" ] */
      { "foo": "yes", "__pclass" : { "$type": "80", "$binary": "NuestraClase" } }
      -> NuestraClase { $foo => "yes", $__pclass => Binary(0x80, "NuestraClase"), $no_serializada => true }
      
      /* typemap: [ "root" => "TuClase" ] */
      { "foo": "yes", "__pclass" : { "$type": "80", "$binary": "SuClase" } }
      -> SuClase { $foo => "yes", $__pclass => Binary(0x80, "SuClase"), $no_serializada => true }
      
      /* typemap: [ "root" => "NuestraClase" ] */
      { foo: "yes", "__pclass" : { "$type": "80", "$binary": "SuClase" } }
      -> SuClase { $foo => "yes", $__pclass => Binary(0x80, "SuClase"), $no_serializada => true }
     </programlisting>
    </para>
    
    <para>
     <programlisting>
      /* typemap: [ 'root' => 'TuClase' ] */
      { foo: "yes", "__pclass" : { "$type": "80", "$binary": "TuClase" } }
      -> TuClase { $foo => 'yes', $__pclass => Binary(0x80, 'TuClase'), $no_serializada => true }
     </programlisting>
    </para>
    
    <para>
     <programlisting>
      /* typemap: [ 'root' => 'array', 'document' => 'array' ] */
      { "foo": "yes", "bar" : false }
      -> [ "foo" => "yes", "bar" => false ]
      
      { "foo": "no", "array" : [ 5, 6 ] }
      -> [ "foo" => "no", "array" => [ 5, 6 ] ]
      
      { "foo": "no", "obj" : { "embedded" : 3.14 } }
      -> [ "foo" => "no", "obj" => [ "embedded => 3.14 ] ]
      
      { "foo": "yes", "__pclass": "MiClase" }
      -> [ "foo" => "yes", "__pclass" => "MiClase" ]
      
      { "foo": "yes", "__pclass" : { "$type": "80", "$binary": "MiClase" } }
      -> [ "foo" => "yes", "__pclass" => Binary(0x80, "MiClase") ]
      
      { "foo": "yes", "__pclass" : { "$type": "80", "$binary": "NuestraClase" } }
      -> [ "foo" => "yes", "__pclass" => Binary(0x80, "NuestraClase") ]
     </programlisting>
    </para>
    
    <para>
     <programlisting>
      /* typemap: [ 'root' => 'object', 'document' => 'object' ] */
      { "foo": "yes", "__pclass": { "$type": "80", "$binary": "MiClase" } }
      -> stdClass { $foo => "yes", "__pclass" => Binary(0x80, "MiClase") }
     </programlisting>
    </para>
    
   </section>
  </section>
  
 </article>
</book>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
