<?xml version="1.0" encoding="iso-8859-1"?>
 <reference xml:id="ref.xml" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Funciones de int&eacute;rprete XML</title>
  <titleabbrev>XML</titleabbrev>

  <partintro>
   <section xml:id="xml.partintro">
    <title>Introducci&oacute;n</title>
    <section xml:id="xml.intro">
     <title>Acerca de XML</title>
     <para>
      XML (eXtensible Markup Language) es un formato de informaci&oacute;n
      para el intercambio de documentos estructurado en la "Web"
      Es un est&aacute;ndar definido por el consorcio de la 
      "World Wide Web" (W3C).  Se puede encontrar
      informaci&oacute;n sobre XML y tecnolog&iacute;s relacionadas en
      <link xlink:href="&url.xml;">&url.xml;</link>.
     </para>
    </section>
    <section xml:id="xml.install">
     <title>Instalaci&oacute;n</title>
     <para>
      Esta extensi&oacute;n usa <productname>expat</productname>, que se puede
      encontrar en <link xlink:href="&url.expat;">&url.expat;</link>.  El 
      Makefile que viene con expat no crea una biblioteca por defecto,
      se puede usar esta regla de make para eso:
      <programlisting role="makefile">
libexpat.a: $(OBJS)
	ar -rc $@ $(OBJS)
	ranlib $@
      </programlisting>
      Se puede conseguir un paquete RPM de expat en  <link
      xlink:href="&url.expat.rpm;">&url.expat.rpm;</link>.
     </para>
     <para>
      Nota que si se usa Apache-1.3.7 o posterior, ya tienes
      la biblioteca requerida expat.  Simplemente, configura PHP usando
      <option role="configure">--with-xml</option> (sin ninguna
      ruta adicional) y usar&aacute; autom&aacute;ticamente la biblioteca
      expat incluida en Apache.
     </para>
     <para>
      En UNIX, ejecuta <command>configure</command> con la opci&oacute;n
      <option role="configure">--with-xml</option>.  La
      biblioteca <productname>expat</productname> deber&iacute;a ser instalada
      en alg&uacute;n lugar donde el compilador pueda encontrarlo.
      Si se compila PHP como un m&oacute;dulo para Apache 1.3.9 o posterior,
      PHP autom&aacute;ticamente usar&aacute; la biblioteca integrada
      <productname>expat</productname> de Apache. Puede necesitar establecer
      <envar>CPPFLAGS</envar> y <envar>LDFLAGS</envar> en su
      entorno antes de ejecutar "configure" si se ha instalado
      expat en alg&uacute;n lugar ex&oacute;tico.
     </para>
     <para>
      Compila PHP.  <emphasis>&iexcl;Ta-tam!</emphasis> Ya deber&iacute;a estar.
     </para>
    </section>

    <section xml:id="xml.about">
     <title>Sobre Esta Extensi&oacute;n</title>
     <para>
      Esta extensi&oacute;n de PHP implementa soporte para
      <productname>expat</productname> de James Clarkin en PHP.
      Este conjunto de herramientas permite interpretar, pero no
      validar, documentos XML.  Soporta tres 
      <link linkend="xml.encoding">codificaciones de caracteres</link>
      fuente, tambi&eacute;n proporcionados por PHP: 
      <literal>US-ASCII</literal>, <literal>ISO-8859-1</literal> y 
      <literal>UTF-8</literal>.  <literal>UTF-16</literal> no est&aacute;
      soportado.
     </para>
     <para>
      Esta extensi&oacute;n permite <link 
      linkend="function.xml-parser-create">crear int&eacute;rpretes de XML</link>
      y definir entonces <emphasis>gestores</emphasis> para diferentes 
      eventos XML. Cada int&eacute;rprete XML tiene tambi&eacute;n unos
      cuantos <link linkend="function.xml-parser-set-option">
      par&aacute;metros</link> que se pueden ajustar.
     </para>
     <para>
      Los gestores de eventos XML definidos son:
      <table>
       <title>Gestores de XML soportados</title>
       <tgroup cols="2">
	<thead>
	 <row>
	  <entry>Funci&oacute;n PHP para establecer gestor</entry>
	  <entry>Descripci&oacute;n del evento</entry>
	 </row>
	</thead>
	<tbody>
	 <row>
	  <entry><function>xml_set_element_handler</function></entry>
	  <entry>
	   Los eventos de elemento ("element") se producen cuando el
         int&eacute;rprete XML encuentra etiquetas de comienzo o
         fin.  Hay gestores separados para etiquetas de comienzo y
         etiquetas de fin.
	  </entry>
	 </row>
	 <row>
	  <entry>
	   <function>xml_set_character_data_handler</function>
	  </entry>
	  <entry>
	   La informaci&oacute;n de caracteres es, por definici&oacute;n, todo el
         contenido no "marcado" de los documentos XML, incluidos
         los espacios en blanco entre etiquetas.  Nota que el
	   int&eacute;rprete XML no a&ntilde;ade o elimina ning&uacute;n
         espacio en blanco, depende de la aplicaci&oacute;n (de ti) 
         decidir si el espacio en blanco es significativo.
	  </entry>
	 </row>
	 <row>
	  <entry>
	   <function>xml_set_processing_instruction_handler</function>
	  </entry>
	  <entry>
 	   Los programadores de PHP deber&iacute;an estar ya familiarizados
         con las instrucciones de procesado (PI).  &lt;?php ?&gt; es
         una instrucci&oacute;n de procesado, donde 
         <replaceable>php</replaceable> se denomina el "objetivo de procesado".
	   El manejo de &eacute;stos es espec&iacute;fico a cada
	   aplicaci&oacute;n, salvo que todos los objetivos PI que comienzan
	   con "XML" est&aacute;n reservados.
	  </entry>
	 </row>
	 <row>
	  <entry><function>xml_set_default_handler</function></entry>
	  <entry>
	   Todo lo que no va a otro gestor, va al gestor por defecto.
	   Se tendr&aacute;n en el gestor por defecto cosas como las declaraciones
	   de tipos de documento y XML.
	  </entry>
	 </row>
	 <row>
	  <entry>
	   <function>xml_set_unparsed_entity_decl_handler</function>
	  </entry>
	  <entry>
	   Este gestor se llamar&aacute; para la declaraci&oacute;n
	   de una entidad no analizada (NDATA).
	  </entry>
	 </row>
	 <row>
	  <entry>
	   <function>xml_set_notation_decl_handler</function>
	  </entry>
	  <entry>
	   Este gestor se llama para la declaraci&oacute;n de una anotaci&oacute;n.
	  </entry>
	 </row>
	 <row>
	  <entry>
	   <function>xml_set_external_entity_ref_handler</function>
	  </entry>
	  <entry>
	   Este gestor se llama cuando el int&eacute;rprete XML encuentra una
	   referencia a una entidad general interpretada externa.  Puede ser
	   una referencia a un archivo o URL, por ejemplo.  Ver <link
	   linkend="example.xml-external-entity">el ejemplo de entidad externa
	   </link> para demostraci&oacute;n.
	  </entry>
	 </row>
	</tbody>
       </tgroup>
      </table>
     </para>
    </section>

    <section xml:id="xml.case-folding">
     <title>Case Folding</title>
     <para>
      Las funciones manejadoras de elementos pueden tomar sus nombres
      de elementos "<glossterm>case-folded</glossterm>". Case-folding 
      se define en el est&aacute;ndar XML como "un proceso aplicado a una
      secuencia de caracteres, en el cual aquellos identificados como
      sin-may&uacute;sculas son reemplazados por sus equivalentes en may&uacute;sculas".
      En otras palabras, cuando se trata de XML, case-folding simplemente
      significa poner en may&uacute;sculas.
     </para>
     <para>
      Por defecto, todos los nombres de elementos que se pasan a las
      funciones gestoras estan "pasados a may&uacute;sculas". Esta conducta
      puede ser observada y controlada por el analizador XML con las
      funciones
      <function>xml_parser_get_option</function> y
      <function>xml_parser_set_option</function>,
      respectivamente.
     </para>
    </section>

    <section xml:id="xml.error-codes">
     <title>C&oacute;digos de Error</title>
     <para>
      Las siguientes constantes se definen para c&oacute;digos de error
      XML (como los devuelve <function>xml_parse</function>):
      <simplelist>
       <member>XML_ERROR_NONE</member>
       <member>XML_ERROR_NO_MEMORY</member>
       <member>XML_ERROR_SYNTAX</member>
       <member>XML_ERROR_NO_ELEMENTS</member>
       <member>XML_ERROR_INVALID_TOKEN</member>
       <member>XML_ERROR_UNCLOSED_TOKEN</member>
       <member>XML_ERROR_PARTIAL_CHAR</member>
       <member>XML_ERROR_TAG_MISMATCH</member>
       <member>XML_ERROR_DUPLICATE_ATTRIBUTE</member>
       <member>XML_ERROR_JUNK_AFTER_DOC_ELEMENT</member>
       <member>XML_ERROR_PARAM_ENTITY_REF</member>
       <member>XML_ERROR_UNDEFINED_ENTITY</member>
       <member>XML_ERROR_RECURSIVE_ENTITY_REF</member>
       <member>XML_ERROR_ASYNC_ENTITY</member>
       <member>XML_ERROR_BAD_CHAR_REF</member>
       <member>XML_ERROR_BINARY_ENTITY_REF</member>
       <member>XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF</member>
       <member>XML_ERROR_MISPLACED_XML_PI</member>
       <member>XML_ERROR_UNKNOWN_ENCODING</member>
       <member>XML_ERROR_INCORRECT_ENCODING</member>
       <member>XML_ERROR_UNCLOSED_CDATA_SECTION</member>
       <member>XML_ERROR_EXTERNAL_ENTITY_HANDLING</member>
      </simplelist>
     </para>
    </section>
    <section xml:id="xml.encoding">
     <title>Codificaci&oacute;n de caracteres</title>
     <para>
      La extension XML de PHP soporta el conjunto de caracteres <link
      xlink:href="&url.unicode;">Unicode</link> a trav&eacute;s de
      diferentes <glossterm>codificaciones de caracteres</glossterm>.  
      Hay dos tipos de codificaciones de caracteres, <glossterm>
      coficaci&oacute;n de fuente</glossterm> y <glossterm>
      codificaci&oacute;n de destino</glossterm>.
      La representaci&oacute;n interna de PHP del documento est&aacute;
      siempre codificada con <literal>UTF-8</literal>.
     </para>
     <para>
      La codificaci&oacute;n de fuente se hace cuando un documento XML es
      <link linkend="function.xml-parse">interpretado</link>.  Al <link
      linkend="function.xml-parser-create">crear un int&eacute;rprete XML
      </link>, se puede especificar una codificaci&oacute;n de fuente
      (esta codificaci&oacute;n no se puede cambiar m&aacute; tarde
      durante el tiempo de vida del int&eacute;rprete XML).  Las
      codificaciones de fuente soportadas son <literal>ISO-8859-1</literal>,
      <literal>US-ASCII</literal> y <literal>UTF-8</literal>.  Las
      dos primeras son codificaciones de byte-&uacute;nico, lo que significa
      que cada car&aacute;cter se representa por un solo byte.
      <literal>UTF-8</literal> puede codificar caracteres compuestos por
      un n&uacute;mero variable de bits (hasta 21) en de uno a cuatro 
      bytes.  La codificaci&oacute;n fuente por defecto usada por PHP es
      <literal>ISO-8859-1</literal>.
     </para>
     <para>
      La codificaci&oacute;n de destino se hace cuando PHP pasa datos
      a las funciones gestoras XML.  Cuando se crea un int&eacute;rprete
      XML, la codificaci&oacute;n de destino se crea igual a la 
      codificaci&oacute;n de fuente, pero se puede cambiar en cualquier
      momento. La codificaci&oacute;n de destino afectar&aacute; a
      la informaci&oacute;n de los caracteres as&iacute; como a los nombres
      de las etiquetas y a los objetivos de instrucciones de procesado.
     </para>
     <para>
      Si el int&eacute;rprete XML encuentra caracteres fuera del rango
      que su codificaci&oacute;n de fuente es capaz de representar,
      devolver&aacute; un error.  
     </para>
     <para>
      Si PHP encuentra caracteres en el documento XML interpretado que
      no pueden ser representados en la codificaci&oacute;n de destino
      elegida, los caracteres problema ser&aacute;n "degradados".
      Actualmente, esto significa que tales caracteres se reemplazan por
      un signo de interrogaci&oacute;n.
     </para>
    </section>
   </section>

   <section xml:id="xml.examples">
    <title>Algunos Ejemplos</title>
    <para>
     Aqu&iacute; hay algunos ejemplos de archivos de comandos PHP 
     que interpretan documentos XML.
    </para>
    <section xml:id="example.xml-structure">
     <title>Ejemplos de Estructuras de Elementos XML</title>
     <para>
      Este primer ejemplo muestra la estructura del elemento inicio en
      un documento con indentaci&oacute;n.
      <example>
       <title>Muestra la Estructura del Elemento XML</title>
       <programlisting role="php">
$file = "data.xml";
$depth = array();

function startElement($parser, $name, $attrs) {
    global $depth;
    for ($i = 0; $i &lt; $depth[$parser]; $i++) {
        print "  ";
    }
    print "$name\n";
    $depth[$parser]++;
}

function endElement($parser, $name) {
    global $depth;
    $depth[$parser]--;
}

$xml_parser = xml_parser_create();
xml_set_element_handler($xml_parser, "startElement", "endElement");
if (!($fp = fopen($file, "r"))) {
    die("could not open XML input");
}

while ($data = fread($fp, 4096)) {
    if (!xml_parse($xml_parser, $data, feof($fp))) {
        die(sprintf("XML error: %s at line %d",
                    xml_error_string(xml_get_error_code($xml_parser)),
                    xml_get_current_line_number($xml_parser)));
    }
}
xml_parser_free($xml_parser);
       </programlisting>
      </example>
     </para>
    </section>

    <section xml:id="example.xml-map-tags">
     <title>Ejemplo de Mapeo de Etiquetas XML</title>
     <para>
      <example>
       <title>Traduciendo XML a HTML</title>
       <para>
        Este ejemplo transforma etiquetas de un documento XML directamente
        a etiquetas HTML. Los elementos no encontrados en el "array de
        traducci&oacute;n ("map array") son ignorados. Por supuesto, este
        ejemplo solamente funcionar&aacute; con un tipo de documentos XML
	espec&iacute;fico.
	<programlisting role="php">
$file = "data.xml";
$map_array = array(
    "BOLD"     => "B",
    "EMPHASIS" => "I",
    "LITERAL"  => "TT"
);

function startElement($parser, $name, $attrs) {
    global $map_array;
    if ($htmltag = $map_array[$name]) {
        print "&lt;$htmltag>";
    }
}

function endElement($parser, $name) {
    global $map_array;
    if ($htmltag = $map_array[$name]) {
        print "&lt;/$htmltag>";
    }
}

function characterData($parser, $data) {
    print $data;
}

$xml_parser = xml_parser_create();
// usa case-folding para que estemos seguros de encontrar la etiqueta
// en $map_array
xml_parser_set_option($xml_parser, XML_OPTION_CASE_FOLDING, true);
xml_set_element_handler($xml_parser, "startElement", "endElement");
xml_set_character_data_handler($xml_parser, "characterData");
if (!($fp = fopen($file, "r"))) {
    die("could not open XML input");
}

while ($data = fread($fp, 4096)) {
    if (!xml_parse($xml_parser, $data, feof($fp))) {
        die(sprintf("XML error: %s at line %d",
                    xml_error_string(xml_get_error_code($xml_parser)),
                    xml_get_current_line_number($xml_parser)));
    }
}
xml_parser_free($xml_parser);
	</programlisting>
       </para>
      </example>
     </para>
    </section>

    <section xml:id="example.xml-external-entity">
     <title>Ejemplo de Entidad Externa XML</title>
     <para>
      Este ejemplo resalta el c&oacute;digo XML. Ilustra c&oacute;mo
      usar un gestor de referencia de entidades extenas para incluir
      y analizar otros documentos, as&iacute; como cu&uacute;ntos PIs pueden
      ser procesados, y un modo de determinar "confianza" para PIs que
      contienen c&oacute;digo.
     </para>
     <para>
      Los documentos XML que se pueden usar en este ejemplo se encuentran
      bajo el ejemplo (<filename>xmltest.xml</filename> y
      <filename>xmltest2.xml</filename>.)
     </para>
     <para>
      <example>
       <title>Ejemplo de Entidades Externas</title>
       <programlisting role="php">
$file = "xmltest.xml";

function trustedFile($file) {
    // solamente conf&iacute;a en archivos locales que nos pertenezcan
    if (!eregi("^([a-z]+)://", $file) 
        &amp;&amp; fileowner($file) == getmyuid()) {
            return true;
    }
    return false;
}

function startElement($parser, $name, $attribs) {
    print "&amp;lt;&lt;font color=\"#0000cc\"&gt;$name&lt;/font&gt;";
    if (sizeof($attribs)) {
        while (list($k, $v) = each($attribs)) {
            print " &lt;font color=\"#009900\"&gt;$k&lt;/font&gt;=\"&lt;font 
                   color=\"#990000\"&gt;$v&lt;/font&gt;\"";
        }
    }
    print "&amp;gt;";
}

function endElement($parser, $name) {
    print "&amp;lt;/&lt;font color=\"#0000cc\"&gt;$name&lt;/font&gt;&amp;gt;";
}

function characterData($parser, $data) {
    print "&lt;b&gt;$data&lt;/b&gt;";
}

function PIHandler($parser, $target, $data) {
    switch (strtolower($target)) {
        case "php":
            global $parser_file;
            // Si el documento analizado es "de confianza", diremos
            // que es seguro ejecutar c&oacute;digo PHP en su interior.
            // Si no, en vez de ello mostrar&aacute; el c&oacute;digo.
            if (trustedFile($parser_file[$parser])) {
                eval($data);
            } else {
                printf("Untrusted PHP code: &lt;i&gt;%s&lt;/i&gt;", 
                        htmlspecialchars($data));
            }
            break;
    }
}

function defaultHandler($parser, $data) {
    if (substr($data, 0, 1) == "&amp;" &amp;&amp; substr($data, -1, 1) == ";") {
        printf('&lt;font color="#aa00aa"&gt;%s&lt;/font&gt;', 
                htmlspecialchars($data));
    } else {
        printf('&lt;font size="-1"&gt;%s&lt;/font&gt;', 
                htmlspecialchars($data));
    }
}

function externalEntityRefHandler($parser, $openEntityNames, $base, $systemId,
                                  $publicId) {
    if ($systemId) {
        if (!list($parser, $fp) = new_xml_parser($systemId)) {
            printf("Could not open entity %s at %s\n", $openEntityNames,
                   $systemId);
            return false;
        }
        while ($data = fread($fp, 4096)) {
            if (!xml_parse($parser, $data, feof($fp))) {
                printf("XML error: %s at line %d while parsing entity %s\n",
                       xml_error_string(xml_get_error_code($parser)),
                       xml_get_current_line_number($parser), $openEntityNames);
                xml_parser_free($parser);
                return false;
            }
        }
        xml_parser_free($parser);
        return true;
    }
    return false;
}

function new_xml_parser($file) {
    global $parser_file;

    $xml_parser = xml_parser_create();
    xml_parser_set_option($xml_parser, XML_OPTION_CASE_FOLDING, 1);
    xml_set_element_handler($xml_parser, "startElement", "endElement");
    xml_set_character_data_handler($xml_parser, "characterData");
    xml_set_processing_instruction_handler($xml_parser, "PIHandler");
    xml_set_default_handler($xml_parser, "defaultHandler");
    xml_set_external_entity_ref_handler($xml_parser, "externalEntityRefHandler");
    
    if (!($fp = @fopen($file, "r"))) {
        return false;
    }
    if (!is_array($parser_file)) {
        settype($parser_file, "array");
    }
    $parser_file[$xml_parser] = $file;
    return array($xml_parser, $fp);
}

if (!(list($xml_parser, $fp) = new_xml_parser($file))) {
    die("could not open XML input");
}

print "&lt;pre&gt;";
while ($data = fread($fp, 4096)) {
    if (!xml_parse($xml_parser, $data, feof($fp))) {
        die(sprintf("XML error: %s at line %d\n",
                    xml_error_string(xml_get_error_code($xml_parser)),
                    xml_get_current_line_number($xml_parser)));
    }
}
print "&lt;/pre&gt;";
print "parse complete\n";
xml_parser_free($xml_parser);

?>
       </programlisting>
      </example>
     </para>
     <para xml:id="example.xml-xmltest.xml">
      <example>
       <title>xmltest.xml</title>
       <programlisting role="xml">
&lt;?xml version='1.0'?>
&lt;!DOCTYPE chapter SYSTEM "/just/a/test.dtd" [
&lt;!ENTITY plainEntity "FOO entity">
&lt;!ENTITY systemEntity SYSTEM "xmltest2.xml">
]>
&lt;chapter>
 &lt;TITLE>Title &amp;plainEntity;&lt;/TITLE>
 &lt;para>
  &lt;informaltable>
   &lt;tgroup cols="3">
    &lt;tbody>
     &lt;row>&lt;entry>a1&lt;/entry>&lt;entry morerows="1">b1&lt;/entry>&lt;entry>c1&lt;/entry>&lt;/row>
     &lt;row>&lt;entry>a2&lt;/entry>&lt;entry>c2&lt;/entry>&lt;/row>
     &lt;row>&lt;entry>a3&lt;/entry>&lt;entry>b3&lt;/entry>&lt;entry>c3&lt;/entry>&lt;/row>
    &lt;/tbody>
   &lt;/tgroup>
  &lt;/informaltable>
 &lt;/para>
 &amp;systemEntity;
 &lt;sect1 xml:id="about">
  &lt;title>About this Document&lt;/title>
  &lt;para>
   &lt;!-- this is a comment -->
   &lt;?php print 'Hi!  This is PHP version '.phpversion(); ?>
  &lt;/para>
 &lt;/sect1>
&lt;/chapter>
       </programlisting>
      </example>
     </para>
     <para xml:id="example.xml-xmltest2.xml">
      Este archivo se incluye desde <filename>xmltest.xml</filename>:
      <example>
       <title>xmltest2.xml</title>
       <programlisting role="xml">
&lt;?xml version="1.0"?>
&lt;!DOCTYPE foo [
&lt;!ENTITY testEnt "test entity">
]>
&lt;foo>
   &lt;element attrib="value"/>
   &amp;testEnt;
   &lt;?php print "This is some more PHP code being executed."; ?>
&lt;/foo>
       </programlisting>
      </example>
     </para>
    </section>
   </section>
  </partintro>

&reference.xml.entities.functions;

 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->

