<?xml version="1.0" encoding="utf-8"?>

<!-- $Revision$ -->
<!-- EN-Revision: 319495 Maintainer: chuso Status: ready -->
<!-- Reviewed: no -->
<refentry xml:id="mongocollection.update" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <refnamediv>
  <refname>MongoCollection::update</refname>
  <refpurpose>Actualizar registros basándose en los criterios proporcionados</refpurpose>
 </refnamediv>
 
 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <modifier>public</modifier> <type>bool|array</type><methodname>MongoCollection::update</methodname>
   <methodparam><type>array</type><parameter>criteria</parameter></methodparam>
   <methodparam><type>array</type><parameter>newobj</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter>options</parameter><initializer>array()</initializer></methodparam>
  </methodsynopsis>
 </refsect1>
 
 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <parameter>criteria</parameter>
     </term>
     <listitem>
      <para>
       Descripción de los objetos a actualizar.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <parameter>newobj</parameter>
     </term>
     <listitem>
      <para>
       El objeto con el que actualizar los registros que cumplan las condiciones.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <parameter>options</parameter>
     </term>
     <listitem>
      <para>
       Este parámetro es un array asociativo de la forma
       <literal>array("optionname" => &lt;boolean&gt;, ...)</literal>. Las opciones
       soportadas actualmente son:
       <itemizedlist>
        <listitem>
         <para>
          <literal>"upsert"</literal>
         </para>
         <para>
          Si ningún documento cumplira las condiciones de $criteria, se crearía un nuevo documento
          a partir de $criteria y $newobj (revise más abajo el ejemplo de upsert).
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>"multiple"</literal>
         </para>
         <para>
          Todos los documentos que cumplan las condiciones de $criteria se actualizarán.
          <function>MongoCollection::update</function> tiene exactamente el comportamiento
          contrario que <function>MongoCollection::remove</function>: de forma predeterminada, 
          actualiza sólo un documento, no todos los que cumplan las condiciones. <emphasis>Se
          recomienda especificar siempre se si deben actualizar múltiples
          documentos o un único documento</emphasis>, ya que el comportamiento predeterminado de
          la base de datos podría cambiar en el futuro.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>"safe"</literal>
         </para>
         <para>
          Puede ser un booleano o un entero, por omisión &false;. Si &false;, el programa
          continua su ejecución sin esperar respuesta por parte de la base de datos.
          Si &true;, el programa esperará la respuesta de la base de datos y emitira una
          excepcion <classname>MongoCursorException</classname> si la inserción
          no tuviera éxito.
         </para>
         <para>
          Si se estuvieran utilizando réplicas, y el maestro cambiara, al usar "safe"
          se provocaría que el driver desconectaría del maestro, emitiría una excepción,
          y en la siguiente operación se tratría de encontrar un nuevo maestro (su aplicación
          debe decidir si reintentará realizar de nuevo la operación sobre un nuevo
          maestro).
         </para>
         <para>
          Si <emphasis>no</emphasis> utiliza "safe" con conjuntos de réplicas y el maestro
          cambia, no habrá forma de que el driver conozca el cambio. En este caso, continuará
          la ejecución y la escritura, silenciosamente, fallará.
         </para>
         <para>
          Si <literal>safe</literal> fuera un entero, replicará la actualización a ese
          número de máquinas antes de notificar un éxito (o lanzaría una excepción
          si al replicar se excediera el tiempo de espera; consulte wtimeout). Sobreescribe
          la variable w asignada a la colección.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>"fsync"</literal>
         </para>
         <para>
          Booleano, por omisión &false;. Obliga a que la actualización se sincronice en disco
          antes de notificar éxito. Si &true;, se realiza de manera implícita una actuaización segura (safe)
          y sobrescribirá el ajuste <literal>safe</literal> a &false;.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>"timeout"</literal>
         </para>
         <para>
          Entero, por omisión <literal>MongoCursor::$timeout</literal>. Si
          "safe" está habilitado, este valor indica por cuánto tiempo (en milisegundos)
          esperará el cliente la respuesta de la base de datos. Si la base de datos no respondiera
          en ese periodo de tiempo, se lanzaría una excepción de tipo
          <classname>MongoCursorTimeoutException</classname>.
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>
 
 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Si <parameter>safe</parameter> está habilitado, devuelve un array con el
   estado de la actualización. En cualquier otro caso, devuelve un booleano indicando si
   el array no estaba vacío (un array vacío no se insertará). Los campos de
   este array están descritos en la documentación de
   <function>MongoCollection::insert</function>.
  </para>
 </refsect1>
 
 <refsect1 role="errors">
  &reftitle.errors;
  <para>
   Lanza <classname>MongoCursorException</classname> si la opción "safe" estuviera
   habilitada y la actualización fallara.
  </para>
  <para>
   Lanza <classname>MongoCursorTimeoutException</classname> si la opción "safe" 
   estuviera habilitada y a la operación llevara más de
   <varname>MongoCursor::$timeout</varname> milisegundos completarse. No detiene el
   proceso en el servidor; es sólo un tiempo de espera en el lado del cliente.
  </para>
 </refsect1>
 
 <refsect1 role="changelog">
  &reftitle.changelog;
  <para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>1.0.1</entry>
       <entry>
        Cambiado el parámetro "opciones" de un booleano a un array. Antes de 1.0.1, el segundo
        parámetro era un booleano opcional cuyo valor indicaba si era o no upsert.
       </entry>
      </row>
      <row>
       <entry>1.0.5</entry>
       <entry>
        Añadida la opción "safe".
       </entry>
      </row>
      <row>
       <entry>1.0.9</entry>
       <entry>
        Añadido soporte para pasar enteros a la opción "safe" (antes sólo aceptaba
        booleanos) y añadida la opción "fsync".
       </entry>
      </row>
      <row>
       <entry>1.0.9</entry>
       <entry>
        Cambiado el tipo devuelto por un array que contiene información del
        error si se utiliza la opción "safe", de otro modo es un booleano como
        antes.
       </entry>
      </row>
      <row>
       <entry>1.0.11</entry>
       <entry>
        Si "safe" está habilitado y hay un error que no sea en el maestro, se desconecta.
       </entry>
      </row>
      <row>
       <entry>1.2.0</entry>
       <entry>
        Añadida la opción "timeout".
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </refsect1>
 
 <refsect1 role="examples">
  &reftitle.examples;
  <example>
   <title><function>MongoCollection::update</function></title>
   <para>
    Añadiendo el campo dirección a un documento
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$c->insert(array("nombre" => "Pedro", "apellido" => "Ruiz" ));
$nuevosdatos = array('$set' => array("direccion" => "Calle Juan, 1"));
$c->update(array("nombre" => "Pedro"), $nuevosdatos);

var_dump($c->findOne(array("nombre" => "Pedro")));

?>
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
array(4) {
  ["_id"]=>
  object(MongoId)#6 (0) {
  }
  ["nombre"]=>
  string(3) "Pedro"
  ["apellido"]=>
  string(5) "Ruiz"
  ["direccion"]=>
  string(12) "Calle Juan, 1"
}
]]>
   </screen>
  </example>
  <example>
   <title>Ejemplo de <function>MongoCollection::update</function> con upsert</title>
   <para>
    Los upserts pueden simplificar el código, ya que con una sóla línea podemos crear el objeto si éste
    no existiera, o actualizarlo si existiera.
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$c->drop();
$c->update(array("uri" => "/fotos_verano"), array('$inc' => array("accesos" => 1)), array("upsert" => true));
var_dump($c->findOne());

?>
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
array(3) {
  ["_id"]=>
  object(MongoId)#9 (0) {
  }
  ["uri"]=>
  string(12) "/fotos_verano"
  ["accesos"]=>
  int(1)
}
]]>
   </screen>
   <para>
    Si <literal>newobj</literal> no contuviera operadores $, upsert podría crear a partir de
    él un nuevo documento. Esto coincide con el comportamiento normal de una actualización:
    si no se usaran operadores $, se sobrescribiría todo el
    documento.
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$c->update(array("nombre" => "juan"), array("usuario" => "juan12", "fechaAlta" => new MongoDate()), 
    array("upsert" => true));

?>
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
array(3) {
  ["_id"]=>
  object(MongoId)#10 (0) {
  }
  ["usuario"]=>
  string(6) "juan312"
  ["fechaAlta"]=>
  object(MongoDate)#4 (0) {
  }
}
]]>
   </screen>
  </example>
  <example>
   <title>Ejemplo de múltiples <function>MongoCollection::update</function></title>
   <para>
    De forma predeterminada, <function>MongoCollection::update</function> sólo 
    actualizará el primer documento que encuentre que cumpla las condiciones de $criteria. Si fuera
    necesario, mediante la opción "multiple" podremos sobrescribir este comportamiento.
   </para>
   <para>
    Este ejemplo añade un campo "regalo" a cada persona cuyo cumpleaños sea
    el próximo día.
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$hoy = array('$gt' => new MongoDate(), '$lt' => new MongoDate(strtotime("+1 day")));
$gente->update(array("cumpleaños" => $hoy), array('$set' => array('regalo' => $surprise)), array("multiple" => true));

?>
]]>
   </programlisting>
  </example>
 </refsect1>
 
 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   La <link linkend="mongo.updates">documentación de PHP sobre actualizaciones</link> y la
   <link xlink:href="&url.mongodb.dochub.update;">documentacion en MongoDB</link>.
  </para>
 </refsect1>
 
</refentry>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
--> 
