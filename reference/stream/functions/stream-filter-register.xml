<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.5 $ -->
<!-- EN-Revision: 1.8 Maintainer: lboshell Status: ready -->
  <refentry id="function.stream-filter-register">
   <refnamediv>
    <refname>stream_filter_register</refname>
    <refpurpose>
     Registrar un filtro de secuencia implementado como una clase PHP
     derivada de <literal>php_user_filter</literal>
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripci&oacute;n</title>
    <methodsynopsis>
     <type>bool</type><methodname>stream_filter_register</methodname>
     <methodparam><type>string</type><parameter>nombre_filtro</parameter></methodparam>
     <methodparam><type>string</type><parameter>nombre_clase</parameter></methodparam>
    </methodsynopsis>
    <para>
     <function>stream_filter_register</function> le permite
     implementar su propio filtro en cualquier secuencia registrada
     utilizada con todas los otras funciones de sistema de archivos
     (tales
     como <function>fopen</function>, <function>fread</function>
     etc.).
    </para>
    <para>
     Para implementar un filtro, necesita definir una clase como una
     extensi&oacute;n de <literal>php_user_filter</literal> con un
     n&uacute;mero de funciones miembro, tal y como se define
     m&aacute;s adelante. Cuando realice operaciones de
     lectura/escritura en la secuencia a la que se ha adjuntado su
     filtro, PHP pasar&aacute; los datos a trav&eacute;s de su filtro
     (y cualquier otro filtre adjunto a esa secuencia) de modo que los
     datos puedan ser modificados como lo desee. Debe implementar los
     m&eacute;todos exactamente como se describe m&aacute;s adelante -
     hacerlo de otra forma llevar&aacute; a comportamientos
     indefenidos.
    </para>
    <para>
     <function>stream_filter_register</function> devolver&aacute;
     &false; si <parameter>nombre_filtro</parameter> ya se encuentra
     definido.
    </para>

    <methodsynopsis>
     <type>int</type><methodname>filter</methodname>
     <methodparam><type>resource</type><parameter>entrada</parameter></methodparam>
     <methodparam><type>resource</type><parameter>salida</parameter></methodparam>
     <methodparam><type>int</type><parameter>&amp;consumido</parameter></methodparam>
     <methodparam><type>bool</type><parameter>cerrando</parameter></methodparam>
    </methodsynopsis>
    <para>
     Este m&eacute;todo es llamado siempre que se lean o escriban
     datos desde y hacia la secuencia adjunta (tal y como sucede
     con <function>fread</function>
     o <function>fwrite</function>). <parameter>entrada</parameter> es
     un recurso que apunta a una <literal>brigada de
     paquetes</literal> que contiene uno o m&aacute;s objetos de
     tipo <literal>paquete</literal> que contienen datos a ser
     filtrados. <parameter>salida</parameter> es un recurso que apunta
     a una segunda <literal>brigada de paquetes</literal> en la que
     deben ser colocados sus paquetes modificados.
     <parameter>consumido</parameter>, que debe
     declararse <emphasis>siempre</emphasis> por referencia, debe ser
     incrementado de acuerdo a la longitud de los datos que su filtro
     lee y altera. En la mayor&iacute;a de casos esto quiere decir que
     usted incrementa <parameter>consumido</parameter> en
     $paquete->datalen para cada $paquete. Si la secuencia est&aacute;
     en el proceso de ser cerrada (y por lo tanto este es el
     &uacute;ltimo paso por la cadena de filtros), el
     par&aacute;metro <parameter>cerrando</parameter> ser&aacute;
     definido como &true;. El
     m&eacute;todo <methodname>filter</methodname> debe devolver uno
     de tres valores cuando complete su ejecuci&oacute;n.
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Valor de Retorno</entry>
         <entry>Significado</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><constant>PSFS_PASS_ON</constant></entry>
         <entry>
          El filtro fue procesado satisfactoriamente con los datos
          disponibles en la <literal>brigada de
          paquetes</literal> <parameter>salida</parameter>.
         </entry>
        </row>
        <row>
         <entry><constant>PSFS_FEED_ME</constant></entry>
         <entry>
          El filtro fue procesado satisfactoriamente, sin embargo, no
          hab&iacute;an datos disponibles para devolver. Se requieren
          m&aacute;s datos desde la secuencia o desde el filtro
          anterior.
         </entry>
        </row>
        <row>
         <entry><constant>PSFS_ERR_FATAL</constant> (predeterminado)</entry>
         <entry>
          El filtro experiment&oacute; un error irrecuperable y no
          puede continuar.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>

    <methodsynopsis>
     <type>void</type><methodname>onCreate</methodname>
     <void/>
    </methodsynopsis>
    <simpara>
     Este m&eacute;todo es llamado durante la instanciaci&oacute;n del
     objeto clase del filtro. Si su filtro ubica o inicializa
     cualquier otro tipo de recursos (como un b&uacute;fer),
     &eacute;ste es el lugar para hacerlo. Su implementaci&oacute;n de
     este m&eacute;todo deber&iacute;a devolver &false; en caso de
     fallo, o &true; si tiene &eacute;xito.
    </simpara>
    <simpara>
     Cuando su filtro es instanciado por primera vez,
     y <literal>su_filtro-&gt;onCreate()</literal> es llamado, se
     colocar&aacute;n a su disposici&oacute;n un n&uacute;mero de
     propiedades, como lo muestra la siguiente tabla.
    </simpara>
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Propiedad</entry>
         <entry>Contenidos</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>ClaseFiltro-&gt;filtername</literal></entry>
         <entry>
          Una cadena que contiene el nombre con el que fue instanciado
          el filtro. Los filtros pueden ser registrados bajo
          m&uacute;ltiples nombres o bajo comodines. Use &eacute;sta
          propiedad para determinar el nombre que fue usado.
         </entry>
        </row>
        <row>
         <entry><literal>ClaseFiltro-&gt;params</literal></entry>
         <entry>
          Los contenidos del
          par&aacute;metro <parameter>parametros</parameter> pasado
          a <function>stream_filter_append</function>
          o <function>stream_filter_prepend</function>.
         </entry> 
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>

    <methodsynopsis>
     <type>void</type><methodname>onClose</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Este m&eacute;todo es llamado cuando se realiza la
     destrucci&oacute;n del filtro (por lo general, esto ocurre
     tambi&eacute;n durante la destrucci&oacute;n de la secuencia), y
     es ejecutado <emphasis>despu&eacute;s</emphasis> de que el
     m&eacute;todo <literal>flush</literal> es llamado. Si se ubicaron
     o inicializaron recursos durante <literal>onCreate</literal>,
     &eacute;ste ser&iacute;a el momento para destruirlos o
     desecharlos.
    </para>

    <para>
     El siguiente ejemplo implementa un filtro
     llamado <literal>strtoupper</literal> en la
     secuencia <literal>foo-bar.txt</literal>, el cual convierte a
     may&uacute;sculas todos los caracteres alfab&eacute;ticos
     escritos hacia/leidos desde esa secuencia.
     <example> 
      <title>Filtro para convertir los caracteres a may&uacute;sculas
      en la secuencia foo-bar.txt</title>
      <programlisting role="php">
<![CDATA[
<?php

/* Definicion de nuestra clase de filtro */
class strtoupper_filter extends php_user_filter {
  function filter($entrada, $salida, &$consumido, $cerrando)
  {
    while ($paquete = stream_bucket_make_writeable($entrada)) {
      $paquete->data = strtoupper($paquete->data);
      $consumido += $paquete->datalen;
      stream_bucket_append($salida, $paquete);
    }
    return PSFS_PASS_ON;
  }
} 

/* Registrar nuestro filtro con PHP */
stream_filter_register("strtoupper", "strtoupper_filter")
    or die("Fall&oacute; el registro del filtro");

$da = fopen("foo-bar.txt", "w");

/* Adjuntar el filtro registrado a la secuencia que acabamos de abrir */
stream_filter_append($da, "strtoupper");

fwrite($da, "Linea1\n");
fwrite($da, "Palabra - 2\n");
fwrite($da, "Tan sencillo como 123\n");

fclose($da);

/* Leer los contenidos de vuelta
 */
readfile("foo-bar.txt");

?>
]]>
      </programlisting>
      <para>
       Salida
      </para>
      <screen>
<![CDATA[
LINEA1
PALABRA - 2
TAN SENCILLO COMO 123
]]>
      </screen>
     </example>
    </para>
    <para>
     <example>
      <title>Registro de una clase gen&eacute;rica de filtro para que
      coincida con m&uacute;ltiples nombres de filtro.</title>
      <programlisting role="php">
<![CDATA[
<?php

/* Definicion de nuestra clase de filtro */
class filtro_cadena extends php_user_filter {
  var $modo;

  function filter($entrada, $salida, &$consumido, $cerrando)
  {
    while ($paquete = stream_bucket_make_writeable($entrada)) {
      if ($this->modo == 1) {
        $paquete->data = strtoupper($paquete->data);
      } elseif ($this->modo == 0) {
        $paquete->data = strtolower($paquete->data);
      }

      $consumido += $paquete->datalen;
      stream_bucket_append($salida, $paquete);
    }
    return PSFS_PASS_ON;
  }

  function onCreate()
  {
    if ($this->filtername == 'str.toupper') {
      $this->modo = 1;
    } elseif ($this->filtername == 'str.tolower') {
      $this->modo = 0;
    } else {
      /* Se ha pedido otro filtro str.* , reportar un fallo de modo
       * que PHP continue buscando */
      return false;
    }

    return true;
  }
} 

/* Registrar nuestro filtro con PHP */
stream_filter_register("str.*", "filtro_cadena")
    or die("Fall&oacute; el registro del filtro");

$da = fopen("foo-bar.txt", "w");

/* Adjuntar el filtro registrado a la secuencia recien
 * abierta. Alternativamente, aqui podemos enlazar str.tolower */
stream_filter_append($da, "str.toupper");

fwrite($da, "Linea1\n");
fwrite($da, "Palabra - 2\n");
fwrite($da, "Tan sencillo como 123\n");

fclose($da);

/* Leer los contenidos de vuelta
 */
readfile("foo-bar.txt");

/* Salida
 * ------

LINEA1
PALABRA - 2
TAN SENCILLO COMO 123

 */

?>
]]>
      </programlisting>
     </example>
    </para>

    <simpara>
     Vea tambi&eacute;n:
     <function>stream_wrapper_register</function>,
     <function>stream_filter_prepend</function>, y
     <function>stream_filter_append</function>
    </simpara>
   </refsect1>
  </refentry>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
