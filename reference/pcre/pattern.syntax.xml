<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.11 $ -->
<!-- EN-Revision: 1.15 Maintainer: lboshell Status: ready -->
<!-- splitted from ./en/functions/pcre.xml, last change in rev 1.2 -->
  <refentry xml:id="reference.pcre.pattern.syntax" xmlns="http://docbook.org/ns/docbook">
   <refnamediv>
    <refname>Sintaxis de los Patrones</refname>
    <refpurpose>Describe la sintaxis de expresiones regulares
    PCRE</refpurpose>
   </refnamediv>

   <refsect1>
    <title>Descripción</title>
    <simpara>
     La biblioteca PCRE es un conjunto de funciones que implementa
     comparaciones con patrones de expresiones regulares usando usando la
     misma sintaxis y semántica de Perl 5, con tan solo unas pocas
     diferencias (ver más adelante). La implementación actual corresponde a
     Perl 5.005.
    </simpara>
   </refsect1>

   <refsect1>
    <title>Diferencias con Perl</title>
    <para>
     Las diferencias descritas aquí existen con respecto a Perl 5.005.
    <orderedlist>
     <listitem>
      <simpara>
       Por defecto, un caracter de espacio en blanco es cualquier caracter
       que reconozca la función isspace() de la biblioteca C, aunque es
       posible compilar PCRE con tablas alternativas de tipos de caracteres.
       Normalmente, isspace() coincide con el espacio, la alimentación de
       página, la nueva línea, el retorno de carro, el tabulador horizontal
       y el tabulador vertical. Perl 5 ya no incluye el tabulador vertical
       en su conjunto de caracteres de espacio en blanco. La secuencia de
       escape \v que permaneció durante mucho tiempo en la documentación de
       Perl nunca fue reconocida en realidad. Sin embargo, el caracter mismo
       era tratado como espacio en blanco por lo menos hasta 5.002. En 5.004
       y 5.005 no coincide con \s.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       PCRE no permite cuantificadores de repetición en aserciones hacia
       adelante. Perl las permite, pero no quieren decir lo que
       probablemente piense. Por ejemplo, (?!a){3} no quiere decir que los
       siguientes tres caracteres no sean "a". Simplemente indica que el
       siguiente caracter no sea "a" tres veces.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Los sub-patrones de captura que aparecen al interior de aserciones
       negativas hacia adelante son contados, pero sus entradas en el vector
       de desplazamientos no son definidas. Perl define sus variables
       numéricas a partir de cualquiera de tales patrones que coinciden
       antes que la aserción falle en coincidir algo (y por lo tanto tiene
       éxito), pero solo si la aserción negativa hacia adelante contiene una
       sola rama.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Aunque los caracteres de cero binario son soportados en la cadena de
       asunto, no son permitidos en una cadena de patrón porque éstas son
       pasadas como un cadena normal de C, terminada en cero. La secuencia
       de escape "\x00" puede ser usada en el patrón para representar el
       cero binario.
      </simpara>
      </listitem>
      <listitem>
      <simpara>
       Las siguientes secuencias de escape de Perl no son soportadas: \l,
       \u, \L, \U. De hecho, estas son implementadas por el mecanismo de
       gestión general de cadenas de Perl y no son parte de su motor de
       comparación de patrones.
      </simpara>
      </listitem>
      <listitem>
      <simpara>
       La aserción \G de Perl no es soportada, ya que no es relevante para
       las coincidencias sencillas de patrones.
      </simpara>
      </listitem>
      <listitem>
      <simpara>
       Obviamente, PCRE no soporta la construcción (?{código}).
      </simpara>
      </listitem>
      <listitem>
      <simpara>
       En la actualidad hay algunas peculiaridades en Perl 5.005_02 con
       respecto a los grupos de cadenas capturadas cuando parte de un patrón
       se repite. Por ejemplo, al coincidir "aba" con el patrón /^(a(b)?)+$/
       se define $2 como "b", pero al coincidir "aabbaa" con /^(aa(bb)?)+$/
       deja $2 sin definir. Sin embargo, si el patrón se modifica a
       /^(aa(b(b))?)+$/ entonces $2 (y $3) se definen.

       En Perl 5.004 se define $2 en ambos casos, y también ocurre en PCRE.
       Si en el futuro Perl se adapta a un estilo consistente que sea
       diferente, PCRE puede cambiar para ajustarse.
      </simpara>
      </listitem>
      <listitem>
      <simpara>
       Otra discrepancia aun no resuelta consiste en que, en Perl 5.005_02,
       el patrón /^(a)?(?(1)a|b)+$/ coincide con la cadena "a", pero en PCRE
       no. Sin embargo, tanto en Perl como en PCRE /^(a)?a/ coincide con
       "a", dejando $1 sin definir.
      </simpara>
      </listitem>
      <listitem>
      <para>
       PCRE ofrece algunas extensiones a las capacidades de expresiones
       regulares de Perl:
        <orderedlist>
         <listitem>
          <simpara>
           Aunque las aserciones hacia atrás deben coincidir con cadenas de
           longitud fija, cada rama alternativa de una aserción hacia atrás
           puede coincidir con una longitud diferente de cadena. Perl 5.005
           requiere que todas ellas tengan la misma longitud.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Si <link
          linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
          se define y <link
          linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
          no, el meta-caracter $ sólo coincide al final absoluto de la
          cadena.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Si se define <link
          linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link>, una
          barra invertida seguida de una letra sin significado especial
          provoca un error.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Si se define <link
          linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link>,
          la ambición de los cuantificadores de repetición es invertida, es
          decir, no son ambiciosos por defecto, pero si son seguidos de un
          signo de interrogación, sí lo serán.
         </simpara>
        </listitem>
       </orderedlist>
      </para>
     </listitem>
    </orderedlist>
   </para>
   </refsect1>

   <refsect1 xml:id="regexp.reference">
    <title>Detalles de las Expresiones Regulares</title>
     <refsect2 xml:id="regexp.introduction">
      <title>Introducción</title>
      <para>
       La sintaxis y semántica de las expresiones regulares soportadas por
       PCRE se describe a continuación. Las expresiones reglurares son
       descritas en la documentación de Perl y en varios libros más, algunos
       de los cuales contienen numerosos ejemplos. El libro "Mastering
       Regular Expressions" de Jeffrey Friedl, publicado por O'Reilly (ISBN
       1-56592-257-3), las cubre con gran detalle. El propósito de la
       presente descripción es el de servir como documentación de
       referencia.
    </para>
    <para>
     Una expresión regular es un patrón que es comparado contra una cadena
     de asunto, de izquierda a derecha. La mayoría de caracteres se
     representan a ellos mismos en un patrón, y coinciden con el caracter
     correspondiente en el asunto. Como ejemplo trivial, el patrón
     <literal>The quick brown fox</literal> coincide con una porción de la
     cadena de asunto que sea idéntica al patrón dado.
    </para>
    </refsect2>
    <refsect2 xml:id="regexp.reference.meta">
     <title>Meta-caracteres</title>
     <para>
      El poder de las expresiones regulares proviene de la habilidad de
      incluir alternativas y repeticiones en el patrón. Estos recursos son
      codificados en el patrón mediante el uso de
      <emphasis>meta-caracteres</emphasis>, los cuales no se representan a
      ellos mismos, en su lugar, son interpretados de una forma especial.
    </para>
    <para>
     Hay dos conjuntos diferentes de meta-caracteres: aquellos que son
     reconocidos en cualquier parte dentro del patrón excepto entre
     corchetes cuadrados, y aquellos que son reconocidos entre corchetes
     cuadrados. Por fuera de tales corchetes, los meta-caracteres son los
     siguientes:
      <variablelist>
       <varlistentry>
        <term><emphasis>\</emphasis></term>
        <listitem><simpara>caracter de escape general con varios
        usos</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>^</emphasis></term>
        <listitem><simpara>aserción de inicio de la cadena de asunto (o
        línea, en modo multilínea)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>$</emphasis></term>
        <listitem><simpara>aserción de fin de la cadena de asunto (o línea,
        en modo multilínea)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>.</emphasis></term>
        <listitem><simpara>coincide con cualquier caracter excepto la nueva
        línea (por defecto)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>[</emphasis></term>
        <listitem><simpara>inicia la definición de clases de
        caracteres</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>]</emphasis></term>
        <listitem><simpara>fin de la definición de clases de
        caracteres</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>|</emphasis></term>
        <listitem><simpara>inicio de rama alternativa</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>(</emphasis></term>
        <listitem><simpara>inicio de sub-patrón</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>)</emphasis></term>
        <listitem><simpara>fin de sub-patrón</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>?</emphasis></term>
        <listitem><simpara>extiende el significado de (, también es el
        cuantificador 0 ó 1 también es el cuantificador de
        mínimo</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>*</emphasis></term>
        <listitem><simpara>cuantificador cero o más</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>+</emphasis></term>
        <listitem><simpara>cuantificador uno o más</simpara>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>{</emphasis></term>
        <listitem><simpara>cuantificador de inicio de valores
        mínimo/máximo</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>}</emphasis></term>
        <listitem><simpara>cuantificador de final de valores
        mínimo/máximo</simpara></listitem>
       </varlistentry>
      </variablelist>

      Un segmento de un patrón que se encuentre entre corchetes cuadrados es
      llamado una "clase de caracteres". En una clase de caracteres, los
      únicos meta-caracteres son:

      <variablelist>
       <varlistentry>
        <term><emphasis>\</emphasis></term>
        <listitem><simpara>caracter general de escape</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>^</emphasis></term>
        <listitem><simpara>niega la clase, pero sólo si se trata del primer
        caracter</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>-</emphasis></term>
        <listitem><simpara>indica un rango de
        caracteres</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>]</emphasis></term>
        <listitem><simpara>finaliza la clase de
        caracteres</simpara></listitem>
       </varlistentry>
      </variablelist>

      Las secciones siguientes describen el uso de cada uno de los
      meta-caracteres.
     </para>
    </refsect2>
   <refsect2 xml:id="regexp.reference.backslash">
    <title>Barra Invertida</title>
    <para>
     El caracter de barra invertida tiene varios usos. Primero, si es
     seguido por un caracter no-alfanumérico, remueve cualquier significado
     que el caracter pueda tener. Este uso de la barra invertida como un
     caracter de escape se aplica tanto dentro como fuera de las clases de
     caracteres.
    </para>
    <para>
     Por ejemplo, si desea crear una coincidencia con un caracter "*", debe
     escribir "\*" en el patrón. Esto es aplicable bien sea que el caracter
     siguiente hubiese sido interpretado como un meta-caracter o no, así que
     siempre es seguro preceder un caracter no-alfanumérico con "\" para
     indicar que se representa a él mismo. En particular, si desea crear una
     coincidencia con una barra invertida, escriba "\\".
    </para>
     <note>
      <para>
       Las <link linkend="language.types.string.syntax">cadenas</link> de
       PHP entre comillas sencillas y dobles tienen un significado especial
       para la barra invertida. Por lo tanto si \ debe ser coincidente con
       una expresión regular \\, entonces debe usarse "\\\\" o '\\\\' en
       código PHP.
      </para>
     </note>
    <para>
     Si un patrón es compilado con la opción <link
     linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>, los
     espacios en blanco del patrón (fuera de una clase de caracteres) y los
     caracteres entre un "#", fuera de una clase de caracteres, y el
     siguiente salto de línea son ignorados. Una barra invertida de escape
     puede ser usada para incluir un espacio en blanco o un caracter "#"
     como parte del patrón.
    </para>
    <para>
     Un segundo uso de la barra invertida ofrece una forma de codificar
     caracteres no-imprimibles en los patrones de una forma visible. No hay
     restricciones sobre la apariencia de los caracteres no-imprimibles,
     aparte del cero binario que finaliza un patrón, pero cuando un patrón
     está siendo preparado mediante la edición de texto, usualmente es más
     fácil usar una de las siguientes secuencias de escape en lugar de los
     caracteres binarios que representan:
    </para>
    <para>
      <variablelist>
       <varlistentry>
        <term><emphasis>\a</emphasis></term>
        <listitem><simpara>alarma, esto es, el caracter BEL (hexadecimal
        07)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\cx</emphasis></term>
        <listitem><simpara>"control-x", en donde x es cualquier
        caracter</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\e</emphasis></term>
        <listitem><simpara>escape (hexadecimal 1B)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\f</emphasis></term>
        <listitem><simpara>alimentación de página (hexadecimal
        0C)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\n</emphasis></term>
        <listitem><simpara>nueva línea (hexadecimal 0A)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\r</emphasis></term>
        <listitem><simpara>retorno de carro (hexadecimal
        0D)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\t</emphasis></term>
        <listitem><simpara>tabulador (hexadecimal 09)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\xhh</emphasis></term>
        <listitem><simpara>caracter con código hexadecimal
        hh</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\ddd</emphasis></term>
        <listitem><simpara>caracter con código octal ddd, o referencia hacia
        atrás</simpara></listitem>
       </varlistentry>
      </variablelist>
     </para>
    <para>
     El efecto preciso de "<literal>\cx</literal>" es como sigue: si
     "<literal>x</literal>" es una letra minúscula, ésta es convertida a
     mayúscula. Entonces el sexto bit del caracter (40 en hexadecimal) es
     invertido. Por lo tanto, "<literal>\cz</literal>" se convierte en 1A en
     hexadecimal, pero "<literal>\c{</literal>" se convierte en 3B en
     hexadecimal, mientras que "<literal>\c;</literal>" se convierte en 7B
     en hexadecimal.
    </para>
    <para>
     Después de "<literal>\x</literal>", son leidos hasta dos dígitos
     hexadecimales (las letras pueden ser mayúsculas o minúsculas). En
     <emphasis>modo UTF-8</emphasis>, "<literal>\x{...}</literal>" es
     permitido, en donde el contenido entre corchetes es una cadena de
     dígitos hexadecimales. Es interpretado como un caracter UTF-8 cuyo
     número de código es el número hexadecimal dado. La secuencia de escape
     hexadecimal original, <literal>\xhh</literal>, coincide con un caracter
     UTF-8 de dos bytes si el valor es mayor que 127.
    </para>
    <para>
     Después de "<literal>\0</literal>", son leídos hasta dos dígitos
     octales más. En ambos casos, si hay menos de dos dígitos, se usarán
     sólo los que estén presentes. Por lo tanto, la secuencia
     "<literal>\0\x\07</literal>" especifica dos ceros binarios seguidos de
     un caracter BEL. Asegúrese de indicar dos dígitos después del cero
     inicial si el caracter que sigue es en sí un dígito octal.
    </para>
    <para>
     La gestión de una barra invertida seguida por un dígito diferente de
     cero es complicada. Por fuera de una clase de caracteres, PCRE lee el
     dígito y cualquier otro que le siga como un número decimal. Si el
     número es menor que diez, o si han habido al menos tantos paréntesis
     izquierdos de captura en la expresión, entonces la secuencia entera es
     tomada como una <emphasis>referencia</emphasis> <emphasis>hacia
     atrás</emphasis>. Una descripción de cómo trabaja esto es presentada
     más adelante, tras la discusión sobre sub-patrones con paréntesis.
    </para>
    <para>
     Al interior de una clase de caracteres, o si el número decimal es mayor
     que 9 y no han habido tantos sub-patrones de captura, PCRE lee de nuevo
     hasta tres dígitos octales que sigan a la barra invertida, y genera un
     byte sencillo a partir de los ocho bits menos significativos del valor.
     Cualquier dígito subsiguiente se representa a él mismo. Por ejemplo:
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\040</emphasis></term>
       <listitem><simpara>es otro modo de escribir un
       espacio</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\40</emphasis></term>
       <listitem>
        <simpara>
         es lo mismo, siempre que haya menos de cuarenta sub-patrones de
         captura previos
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\7</emphasis></term>
       <listitem><simpara>siempre es una referencia hacia
       atrás</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\11</emphasis></term>
       <listitem>
        <simpara>
         puede ser una referencia hacia atrás, u otra forma de escribir un
         tabulador
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\011</emphasis></term>
       <listitem><simpara>siempre es un tabulador</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\0113</emphasis></term>
       <listitem><simpara>es un tabulador seguido del caracter
       "3"</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\113</emphasis></term>
       <listitem>
        <simpara>
         es el caracter con el código octal 113 (ya que no puede haber más
         de 99 referencias hacia atrás)
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\377</emphasis></term>
       <listitem><simpara>es un byte que consiste completamente de bits
       1</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\81</emphasis></term>
       <listitem>
        <simpara>
         puede ser una referencia hacia atrás, o un cero binario seguido por
         los caracteres "8" y "1"
        </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Note que los valores octales del 100 o números más grandes no deben
     iniciar con un cero, ya que no se leen más de tres dígitos octales.
    </para>
    <para>
     Todas las secuencias que definen el valor de un byte sencillo pueden
     ser usadas tanto dentro como fuera de las clases de caracteres.
     Adicionalmente, la secuencia "<literal>\b</literal>" es interpretada
     como el caracter backspace (hexadecimal 08) al interior de una clase de
     caracteres. Por fuera de una clase de caracteres tiene un significado
     diferente (ver más adelante).
    </para>
    <para>
     El tercer uso de la barra invertida es para especificar tipos genéricos
     de caracteres:
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\d</emphasis></term>
       <listitem><simpara>cualquier dígito decimal</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\D</emphasis></term>
       <listitem><simpara>cualquier caracter que no sea un dígito
       decimal</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\s</emphasis></term>
       <listitem><simpara>cualquier caracter de espacio en
       blanco</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\S</emphasis></term>
       <listitem><simpara>cualquier caracter que no sea un espacio en
       blanco</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\w</emphasis></term>
       <listitem><simpara>cualquier caracter de
       "palabra"</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\W</emphasis></term>
       <listitem><simpara>cualquier caracter que no sea de
       "palabra"</simpara></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Cada pareja de las secuencias de escape divide el conjunto global de
     caracteres en dos grupos separados. Cualquier caracter dado coincide
     con uno, y sólo uno, de cada pareja.
    </para>
    <para>
     Un caracter de "palabra" es cualquier letra o dígito, o el caracter de
     subrayado, esto quiere decir, cualquier caracter que pueda ser parte de
     una "<literal>palabra</literal>" en Perl. La definición de letras y
     dígitos es controlada por las tablas de caracteres de PCRE, y puede
     variar si se están efectuando coincidencias específicas a localidades.
     Por ejemplo, en la localidad "fr" (Francia), algunos códigos de
     caracteres mayores a 128 son usados para letras con acentos, y éstas
     coinciden con <literal>\w</literal>.
    </para>
    <para>
     Estas secuencias de tipos de caracter pueden aparecer tanto dentro como
     fuera de las clases de caracteres. Cada una coincide con un caracter
     del tipo apropiado. Si el punto de coincidencia actual es el final de
     la cadena de asunto, todas las secuencias fallan, ya que no hay
     caracteres a coincidir.
    </para>
    <para>
     El cuarto uso de la barra invertida es para ciertas aserciones simples.
     Una aserción especifica una condición que tiene que cumplirse en un
     punto particular de una coincidencia, sin consumir caracter alguno de
     la cadena de asunto. El uso de sub-patrones para aserciones más
     complicadas se describe más adelante. Las aserciones de barra invertida
     son
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\b</emphasis></term>
       <listitem><simpara>límite de palabra</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\B</emphasis></term>
       <listitem><simpara>no-límite de palabra</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\A</emphasis></term>
       <listitem><simpara>inicio de la cadena de asunto (independiente del
       modo multilínea)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\Z</emphasis></term>
       <listitem>
        <simpara>
         fin de la cadena de asunto o una nueva línea al final
         (independiente del modo multilínea)
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\z</emphasis></term>
       <listitem><simpara>fin de la cadena de asunto (independiente del modo
       multilínea)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\G</emphasis></term>
       <listitem><simpara>primera posición de coincidencia en el
       asunto</simpara></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Estas aserciones no pueden aparecer dentro de clases de caracteres
     (pero note que "<literal>\b</literal>" tiene un significado diferente,
     el cual es el caracter backspace, dentro de una clase de caracteres).
    </para>
    <para>
     Un límite de palabra es una posición en la cadena de asunto en donde el
     caracter actual y el anterior no coinciden ambos con
     <literal>\w</literal> o <literal>\W</literal> (es decir, uno coincide
     con <literal>\w</literal> y el otro coincide con
     <literal>\W</literal>), o se puede tratar del principio o el final de
     la cadena, si el primer o último caracter coincide con
     <literal>\w</literal>, respectivamente.
    </para>
    <para>
     Las aserciones <literal>\A</literal>, <literal>\Z</literal>, y
     <literal>\z</literal> se diferencian de los caracteres tradicionales
     circunflejo y dólar (descritos más adelante) en que las primeras sólo
     coinciden al inicio y final absolutos de la cadena de asunto,
     independientemente de las opciones definidas. No son influenciadas por
     las opciones <link
     linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link> o
     <link
     linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>.
     La diferencia entre <literal>\Z</literal> y <literal>\z</literal> es
     que <literal>\Z</literal> coincide antes de una nueva línea que sea el
     último caracter de la cadena como también al final de la cadena,
     mientas que <literal>\z</literal> sólo coincide al final.
     </para>
     <para>
      La aserción <literal>\G</literal> es cierta únicamente cuando la
      posición de coincidencia actual está en el punto de inicio de la
      coincidencia, como se especifica por el argumento
      <parameter>desplazamiento</parameter> de
      <function>preg_match</function>. Difiere de <literal>\A</literal>
      cuando el valor de <parameter>desplazamiento</parameter> es diferente
      de cero. Se encuentra disponible desde PHP 4.3.3.
     </para>

     <para>
      Es posible usar <literal>\Q</literal> y <literal>\E</literal> para
      ignorar meta-caracteres de expresiones regulares en el patrón desde
      PHP 4.3.3. Por ejemplo: <literal>\w+\Q.$.\E$</literal> coincidirá con
      uno o más caracteres de palabra, seguido por los literales
      <literal>.$.</literal> y anclado al final de la cadena.
     </para>

    </refsect2>

    <refsect2 xml:id="regexp.reference.unicode">
     <title>Propiedades de caracter Unicode</title>
     <para>
      A partir de PHP 4.4.0 y 5.1.0 se encuentran disponibles tres
      secuencias de escape adicionales para comparar tipos de caracter
      genéricos cuando el <emphasis>modo UTF-8</emphasis> es seleccionado.
      Éstos son:
     </para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\p{xx}</emphasis></term>
       <listitem><simpara>un caracter con la propiedad
       xx</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\P{xx}</emphasis></term>
       <listitem><simpara>un caracter sin la propiedad
       xx</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\X</emphasis></term>
       <listitem><simpara>una secuencia Unicode
       extendida</simpara></listitem>
      </varlistentry>
     </variablelist>
     <para>
      Los nombres de propiedad representados por <literal>xx</literal> en la
      lista anterior están limitados a las propiedades de categoría general
      Unicode. Cada caracter tiene exactamente una propiedad de aquéllas,
      especificada por una abreviación de dos letras. Para compatibilidad
      con Perl, es posible especificar la negación incluyendo un circunflejo
      entre el corchete de apertura y el nombre de propiedad. Por ejemplo,
      <literal>\p{^Lu}</literal> es lo mismo que <literal>\P{Lu}</literal>.
     </para>
     <para>
      Si solo una letra es especificada con <literal>\p</literal> o
      <literal>\P</literal>, ella incluye todas las propiedades que
      comienzan con esa letra. En este caso, en la ausencia de la negación,
      los corchetes en la secuencia de escape son opcionales; los siguientes
      dos ejemplos tienen el mismo efecto:
     </para>
     <literallayout>
      \p{L}
      \pL
     </literallayout>
     <table>
      <title>Códigos de propiedad soportados</title>
      <tgroup cols="2">
       <tbody>
        <row><entry><literal>C</literal></entry><entry>Otro</entry></row>
        <row><entry><literal>Cc</literal></entry><entry>Control</entry></row>
        <row><entry><literal>Cf</literal></entry><entry>Formato</entry></row>
        <row><entry><literal>Cn</literal></entry><entry>Sin asignar</entry></row>
        <row><entry><literal>Co</literal></entry><entry>Uso privado</entry></row>
        <row rowsep="1"><entry><literal>Cs</literal></entry><entry>Sustituto</entry></row>
        <row><entry><literal>L</literal></entry><entry>Letra</entry></row>
        <row><entry><literal>Ll</literal></entry><entry>Letra minúscula</entry></row>
        <row><entry><literal>Lm</literal></entry><entry>Letra modificadora</entry></row>
        <row><entry><literal>Lo</literal></entry><entry>Otra letra</entry></row>
        <row><entry><literal>Lt</literal></entry><entry>Letra de título</entry></row>
        <row
        rowsep="1"><entry><literal>Lu</literal></entry><entry>Letra mayúscula</entry></row>
        <row><entry><literal>M</literal></entry><entry>Marca</entry></row>
        <row><entry><literal>Mc</literal></entry><entry>Marca de espacio</entry></row>
        <row><entry><literal>Me</literal></entry><entry>Marca de clausura</entry></row>
        <row
        rowsep="1"><entry><literal>Mn</literal></entry><entry>Marca
        diferente de espacio</entry></row>
        <row><entry><literal>N</literal></entry><entry>Número</entry></row>
        <row><entry><literal>Nd</literal></entry><entry>Número decimal</entry></row>
        <row><entry><literal>Nl</literal></entry><entry>Número de letra</entry></row>
        <row
        rowsep="1"><entry><literal>No</literal></entry><entry>Otro número</entry></row>
        <row><entry><literal>P</literal></entry><entry>Puntuación</entry></row>
        <row><entry><literal>Pc</literal></entry><entry>Puntuación conector</entry></row>
        <row><entry><literal>Pd</literal></entry><entry>Puntuación
        de raya</entry></row>
        <row><entry><literal>Pe</literal></entry><entry>Putuación de cierre</entry></row>
        <row><entry><literal>Pf</literal></entry><entry>Puntuación final</entry></row>
        <row><entry><literal>Pi</literal></entry><entry>Puntuación inicial</entry></row>
        <row><entry><literal>Po</literal></entry><entry>Otra puntuación</entry></row>
        <row
        rowsep="1"><entry><literal>Ps</literal></entry><entry>Puntuación
        de apertura</entry></row>
        <row><entry><literal>S</literal></entry><entry>Símbolo</entry></row>
        <row><entry><literal>Sc</literal></entry><entry>Símbolo de moneda</entry></row>
        <row><entry><literal>Sk</literal></entry><entry>Símbolo modificador</entry></row>
        <row><entry><literal>Sm</literal></entry><entry>Símbolo matemático</entry></row>
        <row
        rowsep="1"><entry><literal>So</literal></entry><entry>Otro símbolo</entry></row>
        <row><entry><literal>Z</literal></entry><entry>Separador</entry></row>
        <row><entry><literal>Zl</literal></entry><entry>Separador de línea</entry></row>
        <row><entry><literal>Zp</literal></entry><entry>Separador de párrafo</entry></row>
        <row><entry><literal>Zs</literal></entry><entry>Separador de espacio</entry></row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Propiedades extendidas como "Greek" o "InMusicalSymbols" no son
      soportadas por PCRE.
     </para>
     <para>
      Especificar coincidencias no sensibles a mayúsculas/minúsculas no
      afecta estas secuencias de escape. Por ejemplo,
      <literal>\p{Lu}</literal> siempre coincide únicamente con letras
      mayúsculas.
     </para>
     <para>
      El escape <literal>\X</literal> coincide con cualquier número de
      caracteres Unicode que formen una secuencia Unicode extendida.
      <literal>\X</literal> es equivalente a <literal>(?>\PM\pM*)</literal>.
     </para>
     <para>
      Es decir, coincide con un caracter sin la propiedad "marca", seguido
      de cero o más caracteres con la propiedad "marca", y trata la
      secuencia como un grupo atómico (vea más adelante). Los caracteres con
      la propiedad "marca" usualmente son acentos que afectan el caracter
      precedente.
     </para>
     <para>
      Encontrar coincidencias por propiedades Unicode no es rápido, ya que
      PCRE tiene que buscar una estructura que contiene datos para más de
      quince-mil caracteres. Por ello es que las secuencias de escape
      tradicionales como <literal>\d</literal> y <literal>\w</literal> no
      usan propiedades Unicode en PCRE.
     </para>
    </refsect2>

    <refsect2 xml:id="regexp.reference.circudollar">
     <title>El circunflejo y el dólar</title>
     <para>
      Por fuera de una clase de caracteres, en el modo predeterminado de
      coincidencia, el caracter circunflejo es una aserción que sólo es
      verdadera si el punto de coincidencia actual es el inicio de la cadena
      de asunto. Al interior de una clase de caracteres, el circunflejo
      tiene un significado completamente distinto (ver más adelante).
     </para>
     <para>
      El circunflejo no necesita ser el primer caracter del patrón si se
      involucra un número de alternativas, pero debe ser la primer cosa en
      cada alternativa en la que aparezca si se espera que el patrón
      coincida con esa rama.  Si todas las alternativas posibles empiezan
      con un circunflejo, esto es, si el patrón está limitado a coincidir
      sólo con en el inicio del asunto, se dice que es un patrón "anclado".
      (También hay otras construcciones que pueden hacer que un patrón sea
      anclado.)
     </para>
     <para>
      Un caracter de dólar es una aserción que es verdadera sólo si el punto
      de coincidencia actual se encuentra al final de la cadena de asunto, o
      inmediatamente antes de un caracter de nueva línea que sea el último
      caracter en la cadena (por defecto). El dólar no necesita ser el
      último caracter del patrón si hay varias alternativas involucradas,
      pero debe ser el último elemento en cada rama en la que aparezca. El
      dólar no tiene un significado especial en una clase de caracteres.
     </para>
     <para>
      El significado del dólar puede ser modificado para que coincida sólo
      al final absoluto de la cadena, definiendo la opción <link
      linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
      en tiempo de compilación o a la hora de efectuar la comparación. Esto
      no afecta a la aserción \Z.
     </para>
     <para>
      Los significados de los caracteres circunflejo y dólar son modificados
      si la opción <link
      linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link> es
      definida. Cuando éste es el caso, estos caracteres coinciden
      inmediatamente antes e inmediatamente después de un caracter "\n"
      interno, respectivamente, además de coincidir con el inicio y el final
      de la cadena de asunto. Por ejemplo, el patrón /^abc$/ coincide con la
      cadena de asunto "def\nabc" en modo multilínea, pero no en otro caso.
      Consecuentemente, los patrones que son anclados en modo de línea
      sencilla ya que todas las ramas empiezan con "^" no son anclados en
      modo multilínea. La opción <link
      linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
      es ignorada si <link
      linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link> es
      definido.
     </para>
     <para>
      Tenga en cuenta que las secuencias \A, \Z y \z pueden ser usadas para
      coincidir con el inicio y el final del asunto en ambos modos, y si
      todas las ramas de un patrón comienzan con \A, el patrón siempre es
      anclado, independientemente de si <link
      linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link> es
      definido o no.
     </para>
    </refsect2>

    <refsect2 xml:id="regexp.reference.dot">
     <title>Punto</title>
     <para>
      Por fuera de una clase de caracteres, un punto en el patrón coincide
      con cualquier caracter del asunto, incluyendo caracteres
      no-imprimibles, pero no el salto de línea (por defecto). Si la opción
      <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> es
      definida, entonces los puntos coinciden con los saltos de línea
      también. El manejo del punto es completamente independiente del uso
      del circunflejo y el dólar, dado que la única relación entre ellos es
      que ambos casos involucran caracteres de nueva línea. El punto no
      tiene un significado especial dentro de una clase de caracteres.
     </para>
     <para>
      Es posible usar <emphasis>\C</emphasis> para coincidir con un byte
      sencillo. Tiene sentido en <emphasis>modo UTF-8</emphasis> en donde el
      punto coincide con el caracter completo que puede consistir de
      múltiples bytes.
     </para>
    </refsect2>

    <refsect2 xml:id="regexp.reference.squarebrackets">
     <title>Corchetes cuadrados</title>
     <para>
      Un corchete cuadrado de apertura inicia una clase de caracteres,
      terminada por un corchete cuadrado de cierre. Un corchete cuadrado de
      cierre por sí solo no es especial. Si un corchete cuadrado de cierre
      es requerido como un miembro de la clase, debería ser el primer
      caracter de datos en la clase (después de un circunflejo inicial, si
      está presente) o escapado con una barra invertida.
     </para>
     <para>
      Una clase de caracteres coincide con un caracter único en el asunto;
      el caracter debe estar en el conjunto de los caracteres definidos por
      la clase, a menos que el primer caracter en la clase sea un
      circunflejo, en cuyo caso el caracter del asunto no debe estar en el
      conjunto definido por la clase. Si un circunflejo es necesitado
      realmente como un miembro de la clase, asegúrese de que no sea el
      primer caracter, o escápelo con una barra invertida.
     </para>
     <para>
      Por ejemplo, la clase de caracteres [aeiou] coincide con cualquier
      vocal minúscula, mientras que [^aeiou] coincide con cualquier caracter
      que no sea una vocal minúscula.  Note que un circunflejo es una
      notación conveniente para especificar los caracteres que están en la
      clase enumerando aquellos que no lo están. No es una aserción: aun
      consume un caracter de la cadena de asunto, y falla si el apuntador
      actual está al final de la cadena.
     </para>
     <para>
      Cuando se recurre a las comparaciones insensibles a mayúsculas y
      minúsculas, cualquier letra en una clase representa ambas versiones,
      por ejemplo, un patrón insensible a mayúsculas y minúsculas [aeiou]
      coincide tanto con "A" como con "a", y un patrón insensible a
      mayúsculas y minúsculas [^aeiou] no coincide con "A", mientras que una
      versión sensible lo haría.
     </para>
     <para>
      El caracter de nueva línea nunca es tratado de un modo especial entra
      las clases de caracteres, independientemente de los valores de las
      opciones <link
      linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> o <link
      linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>. Una
      clase como [^a] siempre coincidirá con una nueva línea.
     </para>
     <para>
      El caracter menos (guión) puede ser usado para especificar un rango de
      caracteres en una clase de caracteres. Por ejemplo, [d-m] coincide con
      cualquier letra entre d y m, ambas inclusive. Si un caracter menos es
      requerido en una clase, debe ser escapado con una barra invertida, o
      aparecer en una posición en donde no pueda ser interpretado como
      indicador de rango, normalmente como primer o último caracter de la
      clase.
     </para>
     <para>
      No es posible tener el caracter literal "]" como el caracter final de
      un rango.  Un patrón como [W-]46] es interpretado como una clase de
      dos caracteres ("W" y "-") seguida por la cadena literal "46]", así
      que coincidiría con "W46]" o "-46]". Sin embargo, si el caracter "]"
      es escapado con una barra invertida, éste es interpretado como el
      final del rango, así que [W-\]46] es interpretado como una clase única
      que contiene un rango seguido por dos caracteres diferentes. La
      representación octal o hexadecimal de "]" puede ser usada también para
      finalizar un rango.
     </para>
     <para>
      Los rangos trabajan en el orden de la secuencia ASCII. Pueden ser
      usados también para caracteres especificados numéricamente, por
      ejemplo [\000-\037]. Si un rango que incluye letras es usado cuando es
      definida la comparación insensible a mayúsculas y minúsculas, el rango
      coincide las letras en cualquiera de los casos. Por ejemplo, [W-c] es
      equivalente a [][\^_`wxyzabc], efectuando la coincidencia insensible a
      mayúsculas y minúsculas, y si las tablas de caracteres para la
      localidad "fr" están en uso, entonces [\xc8-\xcb] coincide con los
      caracteres E acentuados en ambos casos.
     </para>
     <para>
      Los tipos de caracteres \d, \D, \s, \S, \w, y \W también pueden
      aparecer en una clase de caracteres, y añaden los caracteres que ellos
      representan a la clase.  Por ejemplo, [\dABCDEF] coincide con
      cualquier dígito hexadecimal. Un circunflejo puede ser
      convenientemente usado con los tipos de caracter en mayúscula para
      especificar un conjunto más restringido de caracteres que el de una
      comparación con tipo en minúscula. Por ejemplo, la clase [^\W_]
      coincide con cualquier letra o dígito, pero no con el signo de
      subrayado.
     </para>
     <para>
      Todos los caracteres no-alfanuméricos diferentes a \, -, ^ (al
      comienzo) y el caracter ] de cierre no tienen un significado especial
      en una clase de caracteres, pero no hace daño que se encuentren
      escapados..
     </para>
    </refsect2>

    <refsect2 xml:id="regexp.reference.verticalbar">
     <title>Barra vertical</title>
     <para>
      Los caracteres de barra vertical son usados para separar patrones
      alternativos. Por ejemplo, el patrón
      <literal>gilbert|sullivan</literal> coincide o bien con "gilbert" o
      con "sullivan". Puede usarse cualquier número de alternativas, y se
      permiten alternativas vacías (que coinciden con la cadena vacía). El
      proceso de comparación prueba con cada alternativa de izquierda a
      derecha, y la primera que tenga éxito es usada. Si las alternativas
      están al interior de un sub-patrón (definido más adelante), el "éxito"
      quiere decir que coincida con el resto del patrón principal como
      también con la alternativa en el sub-patrón.
     </para>
    </refsect2>

    <refsect2 xml:id="regexp.reference.internal-options">
     <title>Definición de opciones internas</title>
     <para>
      Los valores de <link
      linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link>, <link
      linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>,
      <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>,
      <link linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link>,
      <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link>, y
      <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>
      pueden ser modificados desde el interior del patrón por una secuencia
      de letras de opciones de Perl encerradas entre "(?" y ")".  Las letras
      de opciones son:

      <table>
       <title>Letras de opciones internas</title>
       <tgroup cols="2">
        <tbody>
         <row>
          <entry><literal>i</literal></entry>
          <entry>para <link
          linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link></entry>
         </row>
         <row>
          <entry><literal>m</literal></entry>
          <entry>para <link
          linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link></entry>
         </row>
         <row>
          <entry><literal>s</literal></entry>
          <entry>para <link
          linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link></entry>
         </row>
         <row>
          <entry><literal>x</literal></entry>
          <entry>para <link
          linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link></entry>
         </row>
         <row>
          <entry><literal>U</literal></entry>
          <entry>para <link
          linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link></entry>
         </row>
         <row>
          <entry><literal>X</literal></entry>
          <entry>para <link
          linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link></entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </para>
     <para>
      Por ejemplo, (?im) define una comparación insensible a mayúsculas y
      minúsculas y en modo multilínea. También es posible eliminar estas
      opciones precediendo las letras con un guión, así como se permite
      también una combinación de activaciones y desactivaciones como
      (?im-sx), la cual define <link
      linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link> y
      <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
      al mismo tiempo que desactiva <link
      linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> y <link
      linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>. Si
      una letra aparece antes y después del guión, la opción será
      desactivada.
     </para>
     <para>
      Cuando un cambio de opción ocurre en el nivel superior (es decir, no
      al interior de los paréntesis de sub-patrones), el cambio se aplica al
      resto del patrón a seguir. Así que <literal>/ab(?i)c/</literal>
      coincide únicamente con "abc" y "abC". Este comportamiento ha cambiado
      en PCRE 4.0, el cual es distribuido desde PHP 4.3.3. Antes de aquellas
      versiones, <literal>/ab(?i)c/</literal> actuaría como
      <literal>/abc/i</literal> (p.ej. coincidiendo "ABC" y "aBc").
     </para>
     <para>
      Si un cambio de opción sucede dentro de un sub-patrón, el efecto es
      diferente. Este es un cambio respecto a la conducta de Perl 5.005. Un
      cambio de opción dentro de un sub-patrón afecta sólo a la parte del
      sub-patrón que lo sigue, de modo que

        <literal>(a(?i)b)c</literal>

      coincide con abc y aBc y ninguna otra cadena (asumiendo que no se está
      usando <link
      linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link>). De
      esta forma, las opciones pueden definirse para tener diferentes
      significados en diferente partes del patrón. Cualquier cambio
      realizado en una alternativa ciertamente se aplica a ramas
      subsecuentes al interior del mismo sub-patrón. Por ejemplo,

        <literal>(a(?i)b|c)</literal>

      coincide con "ab", "aB", "c", y "C", aun cuando al coincidir con "C",
      la primera rama es abandonada antes de definir la opción. Esto es
      porque los efectos de definir de opciones ocurren en tiempo de
      compilación. De otro modo, ocurriría un comportamiento muy extraño.
     </para>
     <para>
      Las opciones específicas de PCRE <link
      linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link> y
      <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link>
      pueden ser modificadas del mismo modo que las opciones compatibles con
      Perl usando los caracteres U y X respectivamente. La opción bandera
      (?X) es especial en el sentido en que siempre debe ocurrir antes que
      cualquier otra característica adicional que active en el patrón,
      incluso cuando es definida en el nivel superior. Su mejor ubicación es
      el inicio.
     </para>
    </refsect2>

    <refsect2 xml:id="regexp.reference.subpatterns">
     <title>Sub-patrones</title>
     <para>
      Los sub-patrones son delimitados por paréntesis, y pueden estar
      anidados. Marcar parte de un patrón como un sub-patrón logra dos
      cosas:
    </para>
    <para>
     1. Ubica un conjunto de alternativas. Por ejemplo, el patrón

       <literal>cat(aract|erpillar|)</literal>

     coincide con una de las palabras "cat", "cataract", o "caterpillar".
     Sin los paréntesis, coincidiría con "cataract", "erpillar" o la cadena
     vacía.
    </para>
    <para>
     2. Define el sub-patrón como un sub-patrón de captura (como se definió
     anteriormente). Cuando el patrón completo coincida, esa porción de la
     cadena de asunto que coincidió con el sub-patrón es devuelta al origen
     mediante el argumento <emphasis>ovector</emphasis> de
     <function>pcre_exec</function>. Los paréntesis de apertura son contados
     de izquierda a derecha (empezando desde 1) para obtener los números de
     los sub-patrones de captura.
    </para>
    <para>
     Por ejemplo, si la cadena "the red king" es comparada contra el patrón

       <literal>the ((red|white) (king|queen))</literal>

     las sub-cadenas capturadas son "red king", "red", y "king", y son
     numeradas como 1, 2 y 3.
    </para>
    <para>
     El hecho de que los simples paréntesis realicen dos funciones no
     siempre es útil. Con frecuencia se presenta el caso en el que un
     sub-patrón de agrupamiento es requerido sin necesidad de una captura.
     Si un paréntesis de apertura es seguido por "?:", el sub-patrón no
     realiza ninguna captura, y no es contado cuando se compute el número de
     sub-patrones subsiguientes capturados. Por ejemplo, si la cadena "the
     white queen" es comparada con el patrón

       <literal>the ((?:red|white) (king|queen))</literal>

     las sub-cadenas capturadas son "white queen" y "queen", y son numeradas
     como 1 y 2. El número máximo de sub-cadenas capturadas es de 99, y el
     número máximo de todos los sub-patrones, de captura o no, es de 200.
    </para>
    <para>
     Como un atajo conveniente, si cualquiera de las opciones se requiere al
     inicio de un sub-patrón que no sea de captura, las letras de las
     opciones pueden aparecer entre los caracteres "?" y ":". Por lo tanto,
     los dos patrones
    </para>

    <literallayout>
       (?i:saturday|sunday)
       (?:(?i)saturday|sunday)
    </literallayout>

    <para>
     coinciden con exactamente el mismo conjunto de cadenas. Dado que las
     ramas alternativas son probadas de izquierda a derecha, y las opciones
     no son reestablecidas hasta el final del sub-patrón, una definición de
     opción en una rama afecta las ramas subsecuentes, así que los patrones
     anteriores coinciden con "SUNDAY", al igual que con "Saturday".
     </para>

     <para>
      Es posible nombrer el sub-patrón con
      <literal>(?P&lt;nombre&gt;patron)</literal> a partir de PHP 4.3.3. En
      ese caso, las matrices con coincidencias contendrán el resultado
      indexado por la cadena junto con el resultado indexado por un número.
     </para>
    </refsect2>

    <refsect2 xml:id="regexp.reference.repetition">
     <title>Repetición</title>
     <para>
      La repetición es especificada por cuantificadores, los cuales pueden
      ir tras cualquiera de los siguientes elementos:
      <itemizedlist>
       <listitem><simpara>un caracter sencillo, posiblemente
       escapado</simpara></listitem>
       <listitem><simpara>el meta-caracter .</simpara></listitem>
       <listitem><simpara>una clase de caracteres</simpara></listitem>
       <listitem><simpara>una referencia hacia atrás (vea la siguiente
       sección)</simpara></listitem>
       <listitem><simpara>un sub-patrón entre paréntesis (a menos que se
       trate de una aserción - vea más adelante)</simpara></listitem>
      </itemizedlist>
    </para>
    <para>
     El cuantificador general de repetición indica un número mínimo y un
     número máximo de coincidencias permitidas, dando los dos números entre
     corchetes ondulados (llaves), separados por una coma. Los números deben
     ser menores a 65536, y el primero debe ser menor o igual al segundo.
     Por ejemplo:

       <literal>z{2,4}</literal>

     coincide con "zz", "zzz", o "zzzz". Una llave de cierre por sí sola no
     es un caracter especial. Si el segundo número es omitido, pero aparece
     la coma, entonces no hay límite superior; si el segundo número y la
     coma son omitidos ambos, el cuantificador indica el número exacto de
     repeticiones requeridas. Por lo tanto

       <literal>[aeiou]{3,}</literal>

     coincide con al menos 3 vocales sucesivas, pero podría coincidir con
     muchas más, mientras que

       <literal>\d{8}</literal>

     coincide con exactamente ocho dígitos. Una llave de apertura que
     aparezca en una posición en donde no se permite un cuantificador, o una
     que no coincida con la sintaxis de un cuantificador, es tomada como un
     caracter literal. Por ejemplo, {,6} no es un cuantificador, sino una
     cadena literal de cuatro caracteres.
    </para>
    <para>
     Se permite el uso del cuantificador {0}, lo que provoca que la
     expresión se comporte como si el elemento anterior y el cuantificador
     no estuvieran presentes.
    </para>
    <para>
     Por conveniencia (y compatibilidad histórica) los tres cuantificadores
     más comunes tienen abreviaciones de un solo caracter:
     <table>
      <title>Cuantificadores de caracter-único</title>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry><literal>*</literal></entry>
         <entry>equivalente a <literal>{0,}</literal></entry>
        </row>
        <row>
         <entry><literal>+</literal></entry>
         <entry>equivalente a <literal>{1,}</literal></entry>
        </row>
        <row>
         <entry><literal>?</literal></entry>
         <entry>equivalente a <literal>{0,1}</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     Es posible construir ciclos infinitos mediante un sub-patrón que no
     pueda coincidar con ningún caracter con un cuantificador que no tenga
     límite superior, por ejemplo:

       <literal>(a?)*</literal>
    </para>
    <para>
     Las primeras versiones de Perl y PCRE solían producir un error en
     tiempo de compilación para tales patrones. Sin embargo, dado que
     existen casos en donde esto puede ser útil, tales patrones son
     aceptados ahora, pero si cualquier repetición del sub-patrón no
     coincide realmente con ningún caracter, el ciclo es interrumpido a la
     fuerza.
    </para>
    <para>
     Por omisión, los cuantificadores son "ambiciosos", lo que quiere decir,
     coinciden con tanto material como les es posible (hasta el número
     máximo de veces permitido), sin provocar que el resto del patrón falle.
     El ejemplo clásico en el que esto causa problema es a la hora de crear
     coincidencias con comentarios en programas en C. Éstos aparecen entre
     las secuencias /* y */ y, al interior de la secuencia, los caracteres
     * y / pueden aparecer individualmente. Un intento por coincidir
     comentarios en C al aplicar el patrón

       <literal>/\*.*\*/</literal>

     sobre la cadena

       <literal>/* primer comentario */ no comentado /* segundo
       comentario */</literal>


     falla, ya que coincide con la cadena entera debido a la ambición del
     elemento .*
    </para>
    <para>
     Sin embargo, si un cuantificador es seguido por un signo de
     interrogación, entonces deja de ser ambicioso, y en su lugar coincide
     el mínimo número de veces posibles, de tal suerte que el patrón

       <literal>/\*.*?\*/</literal>

     hace lo correcto con los comentarios en C. El significado de los varios
     cuantificadores no se modifica en otro modo, tan sólo el número
     preferido de coincidencias. No confunda este uso del signo de
     interrogación con su uso como un cuantificador por sí solo. Debido a
     que tiene dos usos, a veces puede aparecer dos veces seguidas, como en

       <literal>\d??\d</literal>

     caso que coincide con un dígito de ser posible, pero puede coincidir
     con dos si ese el único modo en que el resto del patrón coincida.
    </para>
    <para>
     Si se encuentra definida la opción <link
     linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link> (la
     cual no está disponible en Perl) entonces los cuantificadores no son
     ambiciosos por defecto, pero cada uno por separado puede serlo cuando a
     continuación de ellos se encuentra un signo de interrogación. En otras
     palabras, invierte el comportamiento predeterminada.
    </para>
    <para>
     Los cuantificadores seguidos por <literal>+</literal> son "posesivos".
     Ellos consumen tantos caracteres como es posible y no regresan para
     coincidir con el resto del patrón. Por lo tanto
     <literal>.*abc</literal> coincide con "aabc" pero
     <literal>.*+abc</literal> no ya que <literal>.*+</literal> consume la
     cadena completa. Los cuantificadores posesivos pueden ser usados para
     incrementar la rapidez de procesamiento desde PHP 4.3.3.
    </para>
    <para>
     Cuando un sub-patrón entre paréntesis es cuantificado con un número
     mínimo de repeticiones superior a 1 o con un límite máximo, se necesita
     mayor almacenamiento para el patrón compilado, en proporción al tamaño
     del mínimo o del máximo.
    </para>
    <para>
     Si un patrón empieza con .* o .{0,} y la opción <link
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>
     (equivalente a /s en Perl) es definida, permitiendo de esa forma que .
     coincida con nuevas líneas, entonces el patrón es anclado
     implícitamente, ya que cualquier cosa a continuación será comparada
     contra cada posición de caracter en la cadena de asunto, así que no hay
     razones para reintentar la coincidencia en su totalidad en cualquier
     posición luego de la primera. PCRE trata tales patrones como si
     estuvieran precedidos por \A. En los casos donde se conoce que la
     cadena de asunto no contiene nuevas líneas, vale la pena definir <link
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> cuando el
     patrón comienza con .* para obtener esta optimización, o
     alternativamente usar ^ para indicar el anclamiento explícitamente.
    </para>
    <para>
     Cuando un sub-patrón de captura es repetido, el valor capturado es la
     sub-cadena que coincidió con la iteración final. Por ejemplo, luego de
     que

       <literal>(tweedle[dume]{3}\s*)+</literal>

     ha coincidido con "tweedledum tweedledee" el valor de la sub-cadena
     capturada es "tweedledee". Sin embargo, si hay sub-patrones de captura
     anidados, los valores capturados correspondientes pueden haber sido
     definidos en las iteraciones anteriores. Por ejemplo, después de que

       <literal>/(a|(b))+/</literal>

     coincide con "aba", el valor de la segunda sub-cadena capturada es "b".
     </para>
    </refsect2>

    <refsect2 xml:id="regexp.reference.back-references">
     <title>Referencias hacia atrás</title>
     <para>
     Por fuera de una clase de caracteres, una barra invertida seguida por
     un digito mayor que cero (y posiblemente más dígitos) es una referencia
     hacia atrás a un sub-patrón de captura anterior (es decir, a su
     izquierda) en el patrón, siempre y cuando existan tantos paréntesis
     izquierdos de captura.
    </para>
    <para>
     Sin embargo, si el número decimal a continuación de la barra invertida
     es menor que diez, siempre es tomado como una referencia hacia atrás, y
     causa un error sólo si no hay los suficientes paréntesis izquierdos de
     captura en todo el patrón. En otras palabras, los paréntesis que son
     referidos no necesitan estar a la izquierda de la referencia para
     números menores que diez.  Vea la sección anterior titulada "Barra
     invertida" para más detalles sobre el manejo de los dígitos que siguen
     a una barra invertida.
    </para>
    <para>
     Una referencia hacia atrás coincide con cualquier cosa que haya
     coincidido realmente con el sub-patrón de captura en la cadena de
     asunto actual, en lugar de hacerlo con cualquier cosa que coincida con
     el sub-patrón mismo. De modo que el patrón

       <literal>(sens|respons)e and \1ibility</literal>

     coincide con "sense and sensibility" y "response and responsibility",
     pero no "sense and responsibility". Si se está aplicando una
     comparación sensible a mayúsculas y minúsculas al momento de la
     referencia hacia atrás, entonces la distinción de las letras es
     importante. Por ejemplo,

       <literal>((?i)rah)\s+\1</literal>

     coincide con "rah rah" y "RAH RAH", pero no "RAH rah", incluso cuando
     el sub-patrón de captura original fue comparado de forma insensible a
     mayúsculas y minúsculas.
    </para>
    <para>
     Puede haber más de una referencia hacia atrás hacia el mismo
     sub-patrón. Si un sub-patrón no ha sido usado realmente en una
     coincidencia particular, entonces cualquier referencia hacia atrás
     hacia aquél siempre falla. Por ejemplo, el patrón

       <literal>(a|(bc))\2</literal>

     siempre falla si comienza coincidiendo con "a" en lugar de "bc". Ya que
     puede haber hasta 99 referencias hacia atrás, todos los dígitos que
     siguen a la barra invertida son tomados como parte de un potencial
     número de referencia hacia atrás. Si el patrón continúa con un caracter
     de dígito, entonces debe ser usado algún delimitador para terminar la
     referencia hacia atrás. Si la opción <link
     linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link> es
     definida, este puede ser el espacio en blanco. De otro modo, un
     comentario vacío puede ser usado.
    </para>
    <para>
     Una referencia hacia atrás que ocurra dentro del paréntesis al cual
     hace referencia falla cuando el sub-patrón es usado por primera vez,
     así que, por ejemplo, (a\1) nunca crea coincidencias. Sin embargo,
     tales referencia pueden ser útiles al interior de sub-patrones
     repetidos. Por ejemplo, el patrón

       <literal>(a|b\1)+</literal>

     coincide con cualquier número de "a"s y también con "aba", "ababaa"
     etc. Para cada iteración del sub-patrón, la referencia hacia atrás
     coincide con la cadena de caracteres correspondiente a la iteración
     anterior. Para que esto funcione, el patrón debe ser tal que la primera
     iteración no necesite coincidir con la referencia hacia atrás. Esto
     puede lograrse usando alternaciones, como en el ejemplo anterior, o por
     medio de un cuantificador con un mínimo de cero.
     </para>
    </refsect2>

    <refsect2 xml:id="regexp.reference.assertions">
     <title>Aserciones</title>
     <para>
      Una aserción es una prueba sobre los caracteres a continuación o antes
      del punto actual de coincidencia que no consume caracteres en
      realidad. Las aserciones simples codificadas como \b, \B, \A, \Z, \z,
      ^ y $ son descritas anteriormente. Las aserciones más complicadas son
      codificadas como sub-patrones. Hay dos tipos: aquellas que trabajan
      con material más adelante de la posición actual en la cadena de asunto
      y aquellas que lo hacen con material hacia atrás.
    </para>
    <para>
     Un sub-patrón de aserción es comparado del modo usual, excepto que no
     causa que el punto actual de coincidencia cambie. Las aserciones hacia
     adelante comienzan con (?= en el caso de aserciones positivas y (?!
     para las negativas. Por ejemplo,

       <literal>\w+(?=;)</literal>

     coincide con una palabra seguida por un punto-y-coma. pero no incluye
     el punto-y-coma en la coincidencia, y

       <literal>foo(?!bar)</literal>

     coincide con cualquier ocurrencia de "foo" que no sea seguida por
     "bar". Note que el patrón, en apariencia semejante,

       <literal>(?!foo)bar</literal>

     no encuentra una ocurrencia de "bar" que sea precedida por algo
     diferente de "foo"; encuentra cualquier ocurrencia de "bar", ya que la
     aserción (?!foo) es siempre verdadera cuando los siguientes tres
     caracteres son "bar". Una aserción hacia atrás es necesaria para
     conseguir este efecto.
    </para>
    <para>
     Las aserciones hacia atrás comienzan con (?&lt;= para las aserciones
     positivas y (?&lt;!  para las negativas. Por ejemplo,

       <literal>(?&lt;!foo)bar</literal>

     encuentra una ocurrencia de "bar" que no es precedida por "foo".  Los
     contenidos de una aserción hacia atrás son restringidos de tal forma
     que todas las cadenas con las que coinciden deben tener una longitud
     fija. Sin embargo, si hay varias alternativas, no todas tienen que
     tener la misma longitud. Por lo tanto

       <literal>(?&lt;=bullock|donkey)</literal>

     se permite, pero

       <literal>(?&lt;!dogs?|cats?)</literal>

     genera un error en tiempo de compilación. Las ramas que coinciden con
     cadenas de diferentes longitudes son permitidas sólo en el nivel
     superior de la aserción hacia atrás. Ésta es una extensión en
     comparación con Perl 5.005, en donde se requiere que todas las ramas
     coincidan con la misma longitud de cadena. Una aserción como

       <literal>(?&lt;=ab(c|de))</literal>

     no es permitida, ya que su rama única de nivel superior puede coincidir
     con dos longitudes diferentes, pero es aceptable si se reescribe para
     usar dos ramas de nivel superior:

       <literal>(?&lt;=abc|abde)</literal>

     La implementación de las aserciones hacia atrás consiste en, para cada
     alternativa, mover temporalmente la posición actual hacia atrás en el
     ancho fijo e intentar la coincidencia. Si no hay suficientes caracteres
     antes de la posición actual, la coincidencia está destinada a fallar.
     Las aserciones hacia atrás, en unión con los sub-patrones de una sola
     aplicación, pueden ser particularmente útiles para las coincidencias al
     final de cadenas; un ejemplo es dado al final de la sección sobre
     sub-patrones de una aplicación.
    </para>
    <para>
     Varias aserciones (de cualquier tipo) pueden ocurrir en sucesión. Por
     ejemplo,

       <literal>(?&lt;=\d{3})(?&lt;!999)foo</literal>

     coincide con "foo" precedido de tres dígitos que no sean "999". Note
     que cada una de las aserciones es aplicada independientemente en el
     mismo punto en la cadena de asunto. Primero hay un chequeo para que los
     tres caracteres previos sean todos dígitos, luego hay un chequeo para
     que los mismos caracteres no sean "999". Este patrón no coincide con
     "foo" precedido de seis caracteres, en donde los primeros son dígitos y
     los últimos tres no son "999". Por ejemplo, no coincide con
     "123abcfoo". Un patrón para conseguir eso es

       <literal>(?&lt;=\d{3}...)(?&lt;!999)foo</literal>
    </para>
    <para>
     En este caso la primera aserción revisa los seis caracteres anteriores,
     y chequea que los tres primeros sean dígitos, y luego la segunda
     aserción chequea que los tres caracteres anteriores no sean "999".
    </para>
    <para>
     Las aserciones puede ser anidadas en cualquier combinación. Por
     ejemplo,

       <literal>(?&lt;=(?&lt;!foo)bar)baz</literal>

     coincide con una ocurrencia de "baz" que sea precedida por "bar", la
     cual a su vez no sea precedida por "foo", mientras que

       <literal>(?&lt;=\d{3}...(?&lt;!999))foo</literal>

     es otro patrón que coincide con "foo" precedido por tres dígitos y tres
     caracteres cualquiera que no sean "999".
    </para>
    <para>
     Los sub-patrones de aserción no son sub-patrones de captura, y no
     pueden ser repetidos, ya que no tiene sentido afirmar la misma cosa
     varias veces. Si una aserción de cualquier tipo contiene sub-patrones
     de captura en su interior, éstos son contados con el propósito de
     numerar los sub-patrones de captura en todo el patrón. Sin embargo, la
     captura de subcadenas solo se lleva a cabo en las aserciones positivas,
     porque no tiene sentido para las negativas.
    </para>
    <para>
     Las aserciones cuentan para el máximo de 200 sub-patrones entre
     paréntesis.
     </para>
    </refsect2>

    <refsect2 xml:id="regexp.reference.onlyonce">
     <title>Sub-patrones de una sola aplicación</title>
     <para>
      Tanto con las repeticiones máximas como en las mínimas, el hecho de
      que falle de lo que se encuentra a continuación causa por lo general
      que el item repetido sea re-evaluado para ver si un número diferente
      de repeticiones permite que el resto del patrón coincida. A veces es
      útil prevenir esto, ya sea cambiando la naturaleza de la coincidencia,
      o causando que falle antes de cuando ocurriría de otra forma, cuando
      el creador del patrón sabe que no tiene sentido continuar.
    </para>
    <para>
     Considere, por ejemplo, el patrón \d+foo cuando se aplica a la línea de
     asunto

       <literal>123456bar</literal>
    </para>
    <para>
     Después de coincidir con los seis dígitos y fallar al comparar con
     "foo", la acción normal del motor es intentar otra vez con sólo cinco
     dígitos para coincidir con \d+, y luego con cuatro, y así
     sucesivamente, antes de fallar por completo. Los sub-patrones de una
     aplicación ofrecen el medio de especificar que una vez una porción del
     patrón ha coincidido, no debe ser re-evaluada en esta manera, así que
     el motor se rendiría inmediamente al fallar su intento por coincidir
     con "foo" la primera vez. La notación es otra forma especial de
     paréntesis, iniciado con (?&gt; como en este ejemplo:

       <literal>(?&gt;\d+)bar</literal>
    </para>
    <para>
     Este tipo de paréntesis "bloquea" la parte del patrón que contiene una
     vez ha coincidido, y se previene que un fallo más al interior del
     patrón retroceda al punto original. El retroceso hacia elementos
     previos funciona normalmente, después de todo.
    </para>
    <para>
     Una descripción alternativa es que un sub-patrón de este tipo coincide
     con la cadena de carecteres que un patrón independiente idéntico
     coincidiría, si estuviera anclado en el punto actual de la cadena de
     asunto.
    </para>
    <para>
     Los sub-patrones de una sola aplicación no son sub-patrones de captura.
     Los casos simples como el ejemplo anterior pueden verse como una
     repetición máxima que debe tragar todo lo que pueda. Así que, mientras
     que tanto \d+ como \d?  están preparados para ajustar el número de
     dígitos con los que coinciden para hacer que el resto del patrón
     coincida, (?&gt;\d+) puede coincidir sólo con un secuencia enteramente
     de dígitos.
    </para>
    <para>
     Esta construcción puede, por supuesto, contener sub-patrones
     arbitrariamente complicados, y pueden estar anidados.
    </para>
    <para>
     Los sub-patrones de una aplicación pueden ser usados en unión con
     aserciones hacia atrás para especificar coincidencias eficientes al
     final de la cadena de asunto.  Considere un patrón sencillo como

       <literal>abcd$</literal>

     cuando se aplica a una cadena larga con la cual no coincide. Dado que
     la comparación se realiza de izquierda a derecha, PCRE buscará cada "a"
     en el asunto y luego verá si lo que sigue coincide con el resto del
     patrón. Si el patrón se especifica como

       <literal>^.*abcd$</literal>

     entonces el segmento .* inicial coincide con la cadena entera primero,
     pero cuando esto falle (ya que no habrá una "a" a continuación),
     retrocede para coincidir con todo menos el último caracter, luego con
     todo excepto los dos últimos y así sucesivamente. Una vez más, la
     búsqueda de "a" cubre la cadena completa, de derecha a izquierda, así
     que no hemos mejorado. Sin embargo, si el patrón se escribiese como

       <literal>^(?&gt;.*)(?&lt;=abcd)</literal>

     entonces no hay retroceso para el elemento .*; sólo puede coincidir con
     la cadena entera. La aserción hacia atrás subsiguiente realiza una
     prueba única sobre los últimos cuatro caracteres. Si falla, la
     coincidencia falla inmediatamente. Para cadena largas, este enfoque
     representa una diferencia significativa en el tiempo de procesamiento.
    </para>
    <para>
     Cuando un patrón contiene una repetición ilimitada al interior de un
     sub-patrón que puede ser por sí mismo repetido un número ilimitado de
     veces, el uso de un sub-patrón de una aplicación es la única forma de
     evitar algunas coincidencias fallidas que consumen ciertamente un
     tiempo muy largo. El patrón

       <literal>(\D+|&lt;\d+>)*[!?]</literal>

     coincide con un número ilimitado de subcadenas que consisten ya sea de
     no-dígitos, o dígitos entre &lt;>, seguidos por ! o ?. Cuando coincida,
     se ejecuta rápido. Sin embargo, si se aplica sobre

       <literal>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</literal>

     toma un largo tiempo antes de reportar el fallo. Esto es porque la
     cadena puede ser dividida entre las dos repeticiones en un gran número
     de formas, y todas deben ser probadas. (El ejemplo usó [!?] en lugar de
     un caracter sencillo al final, ya que tanto PCRE como Perl cuentan con
     una optimización que permite reportar fallos rápidamente cuando un
     caracter sencillo es usado. Recuerdan el último caracter simple que es
     requerido para una coincidencia, y falla tempranamente si no está
     presente en la cadena.) Si el patrón es modificado a

       <literal>((?>\D+)|&lt;\d+>)*[!?]</literal>

     las secuencias de no-dígitos no pueden ser interrumpidas, y la falla
     ocurre rápidamente.
     </para>
    </refsect2>

    <refsect2 xml:id="regexp.reference.conditional">
     <title>Sub-patrones condicionales</title>
     <para>
      Es posible hacer que el proceso de comparación obedezca a un
      sub-patrón condicionalmente o que elija entre dos sub-patrones
      alternativos, dependiendo del resultado de una aserción, o de si un
      sub-patrón de captura previo coincidió o no. Las dos formas posibles
      de sub-patrones condicionales son:
    </para>

    <literallayout>
       (?(condición)patrón-si)
       (?(condición)patrón-si|patrón-no)
    </literallayout>
    <para>
     Si la condición es satisfecha, el patrón-si es usado; de otra forma el
     patrón-no es usado (si está presente). Si hay más de dos alternativas
     en el sub-patrón, se produce un error en tiempo de compilación.
    </para>
    <para>
     Hay dos clases de condición. Si el texto entre los paréntesis consiste
     de una secuencia de dígitos, entonces la condición es satisfecha si el
     sub-patrón de captura de ese número ha sido coincidido previamente.
     Consideremos el siguiente patrón, el cual contiene espacios en blanco
     sin significado para hacerlo más legible (asumiendo la opción <link
     linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>) y lo
     dividimos en tres partes para facilitar su discusión:

       <literal>( \( )?    [^()]+    (?(1) \) )</literal>
    </para>
    <para>
     La primera parte coincide con un paréntesis de apertura opcional, y si
     ese caracter está presente, lo define como la primera subcadena
     capturada. La segunda parte coincide con uno o más caracteres que no
     sean paréntesis. La tercera parte es un sub-patrón condicional que
     examina si el primer conjunto de paréntesis coincidió o no. Si lo hizo,
     es decir, si el asunto comenzó con un paréntesis de apertura, la
     condición es cierta, así que el patrón-si es ejecutado y un paréntesis
     de cierre es requerido. De otro modo, ya que no existe un patrón-no, el
     sub-patrón coincide con nada. En otras palabras, este patrón coincide
     con una secuencia de no-paréntesis, opcionalmente entre paréntesis.
    </para>
    <para>
     Si la condición es la cadena <literal>(R)</literal>, es satisfecha si
     se ha hecho una llamada recursiva al patrón o sub-partón. En el "nivel
     superior", la condición es falsa.
    </para>
    <para>
     Si la condición no es una secuencia de dígitos o (R), debe ser una
     aserción.  Ésta puede ser una aserción positiva o negativa hacia
     adelante o hacia atrás. Considere este patrón, el cual contiene una vez
     más espacios en blanco sin significado, y con las dos alternativas en
     la siguiente línea:
    </para>

    <literallayout>
       (?(?=[^a-z]*[a-z])
       \d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )
    </literallayout>
    <para>
     La condición es una aserción positiva hacia adelante que coincide con
     una secuencia opcional de no-letras seguida por una letra. En otras
     palabras, examina la presencia de al menos una letra en el asunto. Si
     se encuentra una letra, el asunto es comparado contra la primera
     alternativa; de otra forma lo es con la segunda. Este patrón coincide
     con cadenas en una de las dos formas dd-aaa-dd o dd-dd-dd, en donde aaa
     son letras y dd son dígitos.
     </para>
    </refsect2>

    <refsect2 xml:id="regexp.reference.comments">
     <title>Comentarios</title>
     <para>
      La secuencia (?# marca el inicio de un comentario el cual continúa
      hasta el siguiente paréntesis de cierre. Los paréntesis anidados no
      son permitidos. Los caracteres que forman un comentario no hacen parte
      del patrón de coincidencia en ningún caso.
    </para>
    <para>
     Si la opción <link
     linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link> es
     definida, un caracter # no escapado por fuera de una clase de
     caracteres crea un comentario que continúa hasta el próximo caracter de
     nueva línea en el patrón.
     </para>
    </refsect2>

    <refsect2 xml:id="regexp.reference.recursive">
     <title>Patrones recursivos</title>
     <para>
      Considere el problema de coincidir con una cadena entre paréntesis,
      permitiendo un número ilimitado de paréntesis anidados. Sin el uso de
      recursiones, lo mejor que puede lograrse es usar un patrón que
      coincida hasta un número límite de profundidad en el anidamiento. No
      es posible manejar una profundidad arbitraria de anidamiento. Perl 5.6
      contiene una característica experimental que permite que las
      expresiones regulares sean recursivas (entre otras cosas). El elemento
      especial (?R) está disponible para el caso específico de recursión.
      Este patrón de PCRE resuelve el problema de los paréntesis (asumiendo
      que la opción <link
      linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link> es
      definida, de modo que los espacios en blanco sean ignorados):

       <literal>\( ( (?>[^()]+) | (?R) )* \)</literal>
    </para>
    <para>
     Primero coincide con un paréntesis de apertura. Luego coincide con
     cualquier número de subcadenas, que pueden ser o bien una secuencia de
     no-paréntesis, o una coincidencia recursiva del patrón mismo (es decir,
     una subcadena correctamente envuelta por paréntesis). Finalmente hay un
     paréntesis de cierre.
    </para>
    <para>
     Este patrón de ejemplo en particular contiene repeticiones anidadas
     ilimitadas, así que el uso de un sub-patrón de una aplicación para la
     comparación de cadenas de no-paréntesis es importante cuando se aplica
     el patrón a cadenas que no coinciden. Por ejemplo, cuando se aplica a

       <literal>(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</literal>

     descubre una "no coincidencia" rápidamente. Sin embargo, si un
     sub-patrón de una aplicación no es usado, la comparación es ejecutada
     por un tiempo muy largo realmente ya que hay muchas formas diferentes
     en las que las repeticiones + y * pueden moldear el asunto, y todas
     deben ser probadas antes que pueda reportarse el fallo.
    </para>
    <para>
     Los valores establecidos para cualquier sub-patrón de captura son
     aquellos del nivel de recursión más externo en el que esté definido el
     valor del sub-patrón. Si el patrón anterior fuera comparado contra

       <literal>(ab(cd)ef)</literal>

     el valor para los paréntesis de captura es "ef", el cual es el último
     valor tomado del nivel superior. Si se agregan paréntesis adicionales,
     produciendo

       <literal>\( ( ( (?>[^()]+) | (?R) )* ) \)</literal>

     entonces la cadena que capturan es "ab(cd)ef", los contenidos de los
     paréntesis del nivel superior. Si hay más de 15 paréntesis de captura
     en un patrón, PCRE tiene que obtener memoria extra para almacenar datos
     durante una recursión, cosa que logra usando pcre_malloc, y la libera
     más adelante mediante pcre_free. Si no se puede obtener memoria, guarda
     datos únicamente para los primeros 15 paréntesis de captura, dado que
     no hay forma de producir un error de memoria-insuficiente desde el
     interior de una recursión.
     </para>

     <para>
      A partir de PHP 4.3.3, <literal>(?1)</literal>,
      <literal>(?2)</literal> y demás pueden usarse para sub-patrones
      recursivos también. Asimismo es posible usar sub-patrones con nombre:
      <literal>(?P>foo)</literal>.
     </para>
     <para>
      Si la sintaxis para una referencia de sub-patrón recursivo (ya sea por
      número o por nombre) es usada por fuera de los paréntesis a los que
      hace referencia, opera como una subrutina en un lenguaje de
      programación. Un ejemplo anterior anotaba que el patrón
      <literal>(sens|respons)e and \1ibility</literal> coincide con "sense
      and sensibility" y "response and responsibility", pero no con "sense
      and responsibility". Si en su lugar se usa el patrón
      <literal>(sens|respons)e and (?1)ibility</literal>, entonces
      efectivamente coincide con "sense and responsibility" al igual que con
      las otras dos cadenas. Sin embargo, tales referencias deben seguir al
      sub-patrón al que hacer referencia.
     </para>

     <para>
      La máxima longitud de una cadena de asunto es el número positivo más
      grande que una variable entera puede almacenar. Sin embargo, PCRE usa
      recursión para manejar sub-patrones y repetición indefinida. Esto
      quiere decir que el espacio de pila disponible puede limitar el tamaño
      de una cadena de asunto que puede resultar procesada por ciertos
      patrones.
     </para>

    </refsect2>

    <refsect2 xml:id="regexp.reference.performances">
     <title>Rendimientos</title>
     <para>
      Ciertos elementos que pueden aparecer entre los patrones son más
      eficientes que otros. Es más eficiente usar una clase de caracteres
      como [aeiou] que un conjunto de alternativas tal como (a|e|i|o|u). En
      general, la contrucción más simple que ofrezca el comportamiento
      requerido es usualmente la más eficiente. El libro de Jeffrey Friedl
      contiene una cantidad considerable de comentarios sobre la
      optimización de expresiones regulares para un rendimiento eficiente.
    </para>
    <para>
     Cuando un patrón empieza con .* y la opción <link
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> está
     definida, el patrón es anclado implícitamente por PCRE, ya que sólo
     puede coincidir al inicio de la cadena de asunto. Sin embargo, si <link
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> no es
     definido, PCRE no puede hacer esta optimización, ya que el
     meta-caracter . no coincide entonces con una nueva línea y si la cadena
     de asunto contiene nuevas líneas, el patrón podría coincidir desde el
     caracter inmediatamente siguiente a una de ellas en vez del inicio
     absoluto. Por ejemplo, el patrón

       <literal>(.*) second</literal>

     coincide con el asunto "first\nand second" (en donde \n representa un
     caracter de nueva línea) con la primera subcadena capturada que sea
     "and". Para conseguirlo, PCRE tiene que reintentar la coincidencia
     comenzando en cada nueva línea del asunto.
    </para>
    <para>
     Si está usando un patrón así con cadenas de asunto que no contienen
     nuevas líneas, el mejor rendimiento se obtiene definiendo <link
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> o
     iniciando el patrón con ^.* para indicar un anclamiento explícito. Esto
     le ahorra a PCRE tener que examinar toda la cadena de entrada buscando
     nuevas líneas para empezar de nuevo.
    </para>
    <para>
     Tenga cuidado con los patrones que contienen repeticiones anidadas
     ilimitadas. Éstos pueden tomar un tiempo de ejecución muy largo cuando
     se aplican sobre una cadena que no coincide. Considere el fragmento de
     patrón

       <literal>(a+)*</literal>
    </para>
    <para>
     Éste puede coincidir con "aaaa" en 33 maneras diferentes, y este número
     crece muy rápidamente a medida que la cadena se hace más larga. (La
     repetición * puede coincidir 0, 1, 2, 3, o 4 veces, y por cada uno de
     esos casos diferentes a 0, las repeticiones + pueden coincidir un
     número diferente de veces.)  Cuando el resto del patrón es de tal forma
     que la coincidencia completa está destinada a fallar, PCRE en principio
     intenta cada variación posible, y esto puede tomar un tiempo
     extremadamente largo.
    </para>
    <para>
     Una optimización atrapa algunos de los casos más simples tales como

       <literal>(a+)*b</literal>

     en donde un caracter literal se encuentra a continuación. Antes de
     embarcarse en el procedimiento estándar de comparación, PCRE chequea
     que haya una letra "b" más adelante en la cadena de asunto, y si no lo
     hay, falla la coincidencia inmediatamente. Sin embargo, cuando no hay
     un literal a continuación, esta optimización no puede ser usada. Puede
     apreciar la diferencia al comparar el comportamiento de

       <literal>(a+)*\d</literal>

     con el patrón anterior. El primero produce un fallo casi
     instantáneamente cuando se aplica a una línea completa de caracteres
     "a", mientras que el segundo toma un tiempo apreciable con cadenas más
     largas de aproximadamente 20 caracteres.
     </para>
    </refsect2>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
