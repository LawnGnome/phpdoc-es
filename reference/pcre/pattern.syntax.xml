<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 290376 $ -->
<!-- splitted from ./en/functions/pcre.xml, last change in rev 1.2 -->
<!-- EN-Revision: 290376 Maintainer: seros Status: partial -->
<chapter xml:id="reference.pcre.pattern.syntax" xmlns="http://docbook.org/ns/docbook">
 <title>Sintaxis de Patrón</title>
 <titleabbrev>Sintaxis de expresiones regulares de PCRE</titleabbrev>

    <section xml:id="regexp.introduction">
     <title>Introducción</title>
     <para>
      La sintaxis y semántica de las expresiones regulares
      soportadas por PCRE están descritas más adelante. Las expresiones regulares
      también están descritas en la documentación de Perl y en otros
      libros, algunos de los cuales tienen abundantes ejemplos. El libro de Jeffrey
      Friedl "Mastering  Regular  Expressions", publicado por
      O'Reilly  (ISBN 1-56592-257-3), las cubre en gran detalle.
      La descripción aquí dada está prevista como documentación de referencia.
     </para>
     <para>
      Una expresión regular es un patrón que se compara con una
      cadena objetivo de izquierda a derecha. La mayoría de los caracteres se
      representan a sí mismos en un patrón, y coinciden con el carácter
      correspondiente en el sujeto. Como ejemplo trivial, el patrón
      <literal>The quick brown fox</literal>
      coincide con una porción de una cadena objetivo que es idéntica a dicho patrón.  
     </para>
    </section>
    <section xml:id="regexp.reference.meta">
     <title>Meta-caracteres</title>
     <para>     
      El poder de las expresiones regulares viene por la
      capacidad de incluir alternativas y repeticiones en el
      patrón. Éstos están codificadoes en el patrón por el uso de
      <emphasis>meta-caracteres</emphasis>, los cuales no se representan a sí mismos,
      sino que son interpretados de una forma especial.
     </para>
     <para>
      Hay dos conjuntos diferentes de meta-caracteres: aquéllos que
      son reconocidos en cualquier lugar de un patrón excepto dentro de
      corchetes, y aquéllos que son reconocidos dentro de corchetes.
      Fuera de corchetes, los meta-caracteres son los siguientes:
      <variablelist>
       <varlistentry>
        <term><emphasis>\</emphasis></term>
        <listitem><simpara>carácter de escape general con varios usos</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>^</emphasis></term>
        <listitem><simpara>declaración de inicio de sujeto (o línea, en modo multi-línea)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>$</emphasis></term>
        <listitem><simpara>declaración de fin de sujeto (o línea, en modo multi-línea)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>.</emphasis></term>
        <listitem><simpara>coincide con cualquier carácter excepto con nueva línea (por defecto)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>[</emphasis></term>
        <listitem><simpara>inicio de la definición de la clase carácter</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>]</emphasis></term>
        <listitem><simpara>fin de la definición de la clase carácter</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>|</emphasis></term>
        <listitem><simpara>inicio de rama alternativa</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>(</emphasis></term>
        <listitem><simpara>inicio de sub-patrón</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>)</emphasis></term>
        <listitem><simpara>fin de sub-patrón</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>?</emphasis></term>
        <listitem><simpara>extiende el significado de (, también cuantificador 0 ó 1, también cuantificador minimizador</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>*</emphasis></term>
        <listitem><simpara>cuantificador 0 o más</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>+</emphasis></term>
        <listitem><simpara>cuantificador 1 o más</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>{</emphasis></term>
        <listitem><simpara>inicio de cuantificador mín/máx</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>}</emphasis></term>
        <listitem><simpara>fin de cuantificador mín/máx</simpara></listitem>
       </varlistentry>
      </variablelist>

      La parte de un patrón que está entre corchetes se llama una
      "clase carácter". En una clase carácter los únicos meta-caracteres son:

      <variablelist>
       <varlistentry>
        <term><emphasis>\</emphasis></term>
        <listitem><simpara>carácter de escape general</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>^</emphasis></term>
        <listitem><simpara>niega la clase, pero sólo si coincide el primer carácter</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>-</emphasis></term>
        <listitem><simpara>define el ámbito de caracteres</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>]</emphasis></term>
        <listitem><simpara>finaliza la clase carácter</simpara></listitem>
       </varlistentry>
      </variablelist>

      Las siguientes secciones describen el uso de cada
      meta-carácter.
     </para>
    </section>

    <section xml:id="regexp.reference.backslash">
     <title>Barra invertida</title>
     <para>
      El carácter barra invertida tiene varios usos. El primero es que si está
      seguido de un carácter no alfanumérico, toma cualquier
      significado especial que el carácter pueda tener. Este uso de
      la barra invertida como carácter de escape se aplica tanto dentro como fuera de
      las clases carácter.
     </para>
     <para>
      Por ejemplo, si quiere coincidir un carácter "*", escriba
      "\*" en el patrón. Esto se aplica aunque el
      siguiente carácter pudiera ser interpretado como un
      meta-carácter, por lo que es mejor asegurarse de preceder un carácter no alfanumérico
      con "\" para especificar que éste se representa a sí mismo. En
      particular, si quiere coincidir una barra invertida, escriba "\\".
     </para>
     <note>
      <para>
       Las <link linkend="language.types.string.syntax">cadenas</link> PHP entre comillas
       simples y dobles tienen un significado especial para la barra invertida.
       Así, si \ ha de ser coincidido con una expresión
       regular \\, entonces se debe usar "\\\\" o '\\\\' en código PHP.
      </para>
     </note>
     <para>
      Si un patrón es compilado con la opción
      <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>,
      los espacios en blanco en el patrón (distinto de una clase carácter) y los
      caracteres entre un "#" fuera de una clase carácter y el siguiente carácter nueva
      línea se ignoran. Una barra invertida de escape se puede usar para incluir un
      carácter espacio en blanco o "#" como parte del patrón.
     </para>
     <para>
      Un segundo uso de la barra invertida proporciona una manera de codificar
      caracteres no imprimibles en patrones de una forma visible. No hay
      restricciones en la aparición de los caracteres no imprimibles,
      excepto para el cero binario el cual finaliza en patrón,
      pero cuando un patrón está siendo preparado para edición de texto, normalmente
      es más fácil usar una de las siguientes secuencias de escape
      en vez del carácter binario que representa:
     </para>
     <para>
      <variablelist>
       <varlistentry>
        <term><emphasis>\a</emphasis></term>
        <listitem><simpara>alarma, es decir, el carácter BEL (07 hex)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\cx</emphasis></term>
        <listitem><simpara>"control-x", donde x es cualquier carácter</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\e</emphasis></term>
        <listitem><simpara>escape (1B hex)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\f</emphasis></term>
        <listitem><simpara>salto de página (0C hex)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\n</emphasis></term>
        <listitem><simpara>nueva línea (0A hex)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\r</emphasis></term>
        <listitem><simpara>retorno de carro (0D hex)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\t</emphasis></term>
        <listitem><simpara>tabulador (09 hex)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\xhh</emphasis></term>
        <listitem><simpara>carácter con el código hexadecimal hh</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\ddd</emphasis></term>
        <listitem><simpara>carácter con el código octal ddd, o retro-referencia</simpara></listitem>
       </varlistentry>
      </variablelist>
     </para>
    <para>
     El efecto exacto de "<literal>\cx</literal>" es como sigue: 
     si "<literal>x</literal>" es una letra minúscula, ésta se convierte
     a mayúscula. Después se invierte el bit 6 del carácter (40 hex). 
     Así, "<literal>\cz</literal>" se convierte en 1A hex, pero
     "<literal>\c{</literal>" se convierte en 3B hex, mientras que "<literal>\c;</literal>"
     se conviente en 7B hex.
    </para>
    <para>
     Después de "<literal>\x</literal>", se leen hasta dos dígitos
     hexadecimales (las letras pueden ser tanto mayúsculas como minúsculas).
     En <emphasis>modo UTF-8</emphasis>, "<literal>\x{...}</literal>" se
     permite, donde el contenido entre las llaves es una cadena de dígitos
     hexadecimales. Esto se interpreta como un carácter UTF-8 cuyo número de código es
     el dado por el número hexadecimal. La secuencia de escape hexadecimal original,
     <literal>\xhh</literal>, conincide con un carácter UTF-8 de dos bytes si el valor
     es mayor que 127.
    </para>
    <para>
     Después de "<literal>\0</literal>", se leen hasta dos dígitos octales más.
     En cualquier caso, si hay menos de dos dígitos, sólo se usan
     aquéllos que están presentes. Así, la secuencia "<literal>\0\x\07</literal>" 
     especifica dos ceros binarios seguidos de un carácter BEL. Asegúrese de
     proporcionar dos dígitos después del cero inicial si el carácter
     que sigue es también un dígito octal.
    </para>
    <para>
     El manejo de una barra invertida seguida de un dígito distinto de 0
     es complicado. Fuera de una clase carácter, PCRE lee este dígito,
     así como cualesquiera dígitos siguientes, como un número decimal. Si el número
     es menor que 10, o si ha habido al menos tantas
     capturas previas anteriores en la expresión, la
     secuencia entera es tomada como una <emphasis>retro-referencia</emphasis>. Una descripción
     de cómo funciona esto se da más adelante, seguido de una discusión
     sobre sub-patrones entre paréntesis.
    </para>
    <para>
     Dentro de una clase carácter, o si el número decimal es
     mayor que 9 y no han habido tantos sub-patrones capturados,
     PCRE relee hasta tres dígitos octales siguientes a la
     barra invertida, y genera un sólo byte de los
     8 bits menos significativos del valor. Cualesquiera dígitos subsiguientes
     se representan a sí mismos. Por ejemplo:
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\040</emphasis></term>
       <listitem><simpara>es otra manera de escribir un espacio</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\40</emphasis></term>
       <listitem>
        <simpara>
         es lo mismo, siempre que haya menos de 40
         sub-patrones de captura previos
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\7</emphasis></term>
       <listitem><simpara>es siempre una retro-referencia</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\11</emphasis></term>
       <listitem>
        <simpara>
         puede ser una retro-refenrencia, u otra manera de
         escribir una tabulación
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\011</emphasis></term>
       <listitem><simpara>es siempre una tabulación</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\0113</emphasis></term>
       <listitem><simpara>es una tabulación seguida del carácter "3"</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\113</emphasis></term>
       <listitem>
        <simpara>
         es el carácter con el código octal 113 (ya que no
         puede haber más de 99 retro-referencias)
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\377</emphasis></term>
       <listitem><simpara>es un byte consistente en bits 1 enteramente</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\81</emphasis></term>
       <listitem>
        <simpara>
         es tanto una retro-referencia como un cero binario
         seguido de los caracteres "8" y "1"
        </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Observe que los valores octales 100 y mayores no deben de ser
     precedidos por un cero inicial, ya que nunca se leen más de tres
     dígitos octales.
    </para>
    <para>
     Todas las secuencias que definen un valor de byte único se pueden
     usar tanto dentro como fuera de las clases carácter. Además,
     dentro de una clase carácter, la secuencia "<literal>\b</literal>"
     se interpreta como el carácter retroceso (08 hex). Fuera de una clase
     carácter tiene diferentes significados (véase más abajo).
    </para>
    <para>
     El tercer uso de la barra invertida es parar especificar tipos
     de caracteres genéricos:
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\d</emphasis></term>
       <listitem><simpara>cualquier dígito decimal</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\D</emphasis></term>
       <listitem><simpara>cualquier carácter que no es un dígito decimal</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\h</emphasis></term>
       <listitem><simpara>cualquier carácter espacio en blanco horizontal
       (desde PHP 5.2.4)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\H</emphasis></term>
       <listitem><simpara>cualquier carácter que no es un carácter espacio en blanco horizontal
       (desde PHP 5.2.4)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\s</emphasis></term>
       <listitem><simpara>cualquier carácter espacio en blanco</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\S</emphasis></term>
       <listitem><simpara>cualquier carácter que no es un carácter espacio en blanco</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\v</emphasis></term>
       <listitem><simpara>cualquier carácter espacio en blanco vertical
       (desde PHP 5.2.4)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\V</emphasis></term>
       <listitem><simpara>cualquier carácter que no es un carácter espacio en blanco vertical
       (desde PHP 5.2.4)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\w</emphasis></term>
       <listitem><simpara>cualquier carácter "palabra"</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\W</emphasis></term>
       <listitem><simpara>cualquier carácter que no es "palabra"</simpara></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Cada par de sencuencias de escape divide el conjunto completo de
     caracteres en dos conjuntos separados. Cualquier carácter dado
     concide con uno, y sólo uno, de cada par.
    </para>
    <para>
     Un carácter "palabra" es cualquier letra o dígito o en carácter
     subrayado, es decir, cualquier carácter que pueda ser parte de una
     "<emphasis>palabra</emphasis>" Perl. La definición de letras y dígitos está
     controlada por las tablas de caracteres de PCRE, y pueden variar si 
     tiene lugar la comparación de localizaciones específicas. Por ejemplo,
     en la localización "fr" (Francés), algunos códigos de caracteres
     mayores que 128 se usan para letras acentuadas,
     y éstos se comparan por <literal>\w</literal>.
    </para>
    <para>
     Estas secuencias de tipo de caracteres puede aparecer tanto dentro como
     fuera de las clases carácter. Cada una coincide con un carácter del
     typo apropiado. Si el punto de coincidencia actual está
     al final de la cadena objetivo, todas ellas fallarán, ya que no
     hay caracteres a comparar.
    </para>
    <para>
     El cuarto uso de la barra invertida es para ciertas declaraciones
     simples. Una declaración especifica una condición que se debe encontrar
     en un punto particular de una comparación, sin consumir ningún
     carácter de la cadena objetivo. El uso de sub-patrones
     para declaraciones más complicadas se describe después. Las
     declaraciones de la barra invertida son
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\b</emphasis></term>
       <listitem><simpara>límite de palabra</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\B</emphasis></term>
       <listitem><simpara>distinto a límite de palabra</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\A</emphasis></term>
       <listitem><simpara>comienzo del sujeto
       (independientemente del modo multi-linea)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\Z</emphasis></term>
       <listitem>
        <simpara>
         fin del sujeto o nueva línea al final (independientemente del
         modo multi-linea)
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\z</emphasis></term>
       <listitem><simpara>final del sujeto (independientemente del modo multi-line)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\G</emphasis></term>
       <listitem><simpara>primera posición de coincidencia del sujeto</simpara></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Estas declaraciones pueden no aparecer en clases carácter (pero
     observe que "<literal>\b</literal>" tiene un significado diferente, a saber, el carácter
     retroceso, dentro de una clase carácter).
    </para>
    <para>
     Un límite de palabra es una posición en la cadena objetivo donde
     es carácter actual y el carácter previo no coinciden con
     <literal>\w</literal> o <literal>\W</literal> (es decir, uno coincide con
     <literal>\w</literal> y el otro coincice con
     <literal>\W</literal>), o el inicio o final de la cadena si el primero o último
     caracteres coinciden con <literal>\w</literal>, respectivamente.
    </para>
    <para>
     Las declaraciones <literal>\A</literal>, <literal>\Z</literal>, y
     <literal>\z</literal> difieren de de los tradicionales
     circumflejo y dólar (descritos después) de modo que siempre
     coinciden con el inicio y final absolutos de la cadena objetivo,
     sin importar las opciones que se apliquen. No le afectan las opciones
     <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link> o
     <link linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>.
     La diferencia entre <literal>\Z</literal> y
     <literal>\z</literal> es que <literal>\Z</literal> coincide antes de una
     nueva línea que es el último carácter de la cadena, además de al final de
     la cadena, mientras que <literal>\z</literal> coincide sólo con el final.
     </para>
     <para>
      La declaración <literal>\G</literal> es verdadera sólo cuando la posición
      de coincidencia actual está al principio del punto de coincidencia, tal como se especifica
      en el argumento <parameter>índice</parameter> de
      <function>preg_match</function>. Difiere de <literal>\A</literal>
      cuando el valor de <parameter>índice</parameter> no es cero.
      Está disponible a partir de PHP 4.3.3.
     </para>
     
     <para>
      <literal>\Q</literal> y <literal>\E</literal> se pueden usar para ignorar
      meta-caracteres de expresiones regulares desde PHP 4.3.3. Por ejemplo:
      <literal>\w+\Q.$.\E$</literal> coincidirá con uno o más caracteres palabra,
      seguidos por los literales <literal>.$.</literal> y anclados al final de
      la cadena.
     </para>
     
     <para>
      <literal>\K</literal> se puede usar para reiniciar el inicio de comparación desde
      PHP 5.2.4. Por ejemplo, el patrón <literal>foo\Kbar</literal> coincide con
      "foobar", pero informa de que ha coincidido con "bar". El uso de
      <literal>\K</literal> no interfiere con el parámetro de las cadenas
      capturadas. Por ejemplo, cuando el patrón <literal>(foo)\Kbar</literal>
      coincide con "foobar", la primera sub-cadena está establecida aún a "foo".
     </para>
     
    </section>
 
    <section xml:id="regexp.reference.unicode">
     <title>Propiedades de los caracteres Unicode</title>
     <para>
      A partir de PHP 4.4.0 y 5.1.0, están disponibles
      tres secuencias de escape adicionales para comparar tipos de caracteres genéricos
      cuando el <emphasis>modo UTF-8</emphasis> está seleccionado. Son:
     </para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\p{xx}</emphasis></term>
       <listitem><simpara>un carácter con la propiedad xx</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\P{xx}</emphasis></term>
       <listitem><simpara>un carácter sin la propiedad xx</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\X</emphasis></term>
       <listitem><simpara>una secuencia Unicode extendida</simpara></listitem>
      </varlistentry>
     </variablelist>
     <para>
      Los nombres de las propiedades representadas arriba por <literal>xx</literal> están limitadas
      a las propiedades de la categoría general de Unicode. Cada carácter tiene exactamente una
      propiedad, especificada por una abreviatura de dos letras. Por compatibilidad con
      Perl, la negación se puede especificar incluyendo un acento circunflejo entre la
      llave de apertura y el nombre de la propiedad. Por ejemplo, <literal>\p{^Lu}</literal> 
      es lo mismo que <literal>\P{Lu}</literal>.
     </para>
     <para>
      Si sólo se especifica una letra con <literal>\p</literal> o 
      <literal>\P</literal>, se incluyen todas las propiedades que comienzan con esa
      letra. En este caso, en la ausencia de negación, las llaves en la
      secuencia de escape son opcionales; estos dos ejemplos tienen el mismo efecto:
     </para>
     <literallayout>
      \p{L}
      \pL
     </literallayout>
     <table>
      <title>Códigos de propiedades soportados</title>
      <tgroup cols="2">
       <tbody>
        <row><entry><literal>C</literal></entry><entry>Otro</entry></row>
        <row><entry><literal>Cc</literal></entry><entry>Control</entry></row>
        <row><entry><literal>Cf</literal></entry><entry>Formato</entry></row>
        <row><entry><literal>Cn</literal></entry><entry>Sin asignar</entry></row>
        <row><entry><literal>Co</literal></entry><entry>Uso privado</entry></row>
        <row rowsep="1"><entry><literal>Cs</literal></entry><entry>Sustituto</entry></row>
        <row><entry><literal>L</literal></entry><entry>Letra</entry></row>
        <row><entry><literal>Ll</literal></entry><entry>Letra minúscula</entry></row>
        <row><entry><literal>Lm</literal></entry><entry>Letra modificadora</entry></row>
        <row><entry><literal>Lo</literal></entry><entry>Otra letra</entry></row>
        <row><entry><literal>Lt</literal></entry><entry>Letra de título</entry></row>
        <row rowsep="1"><entry><literal>Lu</literal></entry><entry>Letra mayúscula</entry></row>
        <row><entry><literal>M</literal></entry><entry>Marca</entry></row>
        <row><entry><literal>Mc</literal></entry><entry>Marca de espacio</entry></row>
        <row><entry><literal>Me</literal></entry><entry>Marca adjunta</entry></row>
        <row rowsep="1"><entry><literal>Mn</literal></entry><entry>Marca de no-espacio</entry></row>
        <row><entry><literal>N</literal></entry><entry>Número</entry></row>
        <row><entry><literal>Nd</literal></entry><entry>Número decimal</entry></row>
        <row><entry><literal>Nl</literal></entry><entry>Número letra</entry></row>
        <row rowsep="1"><entry><literal>No</literal></entry><entry>Otro número</entry></row>
        <row><entry><literal>P</literal></entry><entry>Puntuación</entry></row>
        <row><entry><literal>Pc</literal></entry><entry>Puntuación de conexión</entry></row>
        <row><entry><literal>Pd</literal></entry><entry>Puntuación guión</entry></row>
        <row><entry><literal>Pe</literal></entry><entry>Puntuación de cierre</entry></row>
        <row><entry><literal>Pf</literal></entry><entry>Puntuación final</entry></row>
        <row><entry><literal>Pi</literal></entry><entry>Puntuación inicial</entry></row>
        <row><entry><literal>Po</literal></entry><entry>Otra puntuación</entry></row>
        <row rowsep="1"><entry><literal>Ps</literal></entry><entry>Puntuación de apertura</entry></row>
        <row><entry><literal>S</literal></entry><entry>Símbolo</entry></row>
        <row><entry><literal>Sc</literal></entry><entry>Símbolo de moneda</entry></row>
        <row><entry><literal>Sk</literal></entry><entry>Símbolo modificador</entry></row>
        <row><entry><literal>Sm</literal></entry><entry>Símbolo matemático</entry></row>
        <row rowsep="1"><entry><literal>So</literal></entry><entry>Otro símbolo</entry></row>
        <row><entry><literal>Z</literal></entry><entry>Separador</entry></row>
        <row><entry><literal>Zl</literal></entry><entry>Separador de línea</entry></row>
        <row><entry><literal>Zp</literal></entry><entry>Separador de párrafo</entry></row>
        <row><entry><literal>Zs</literal></entry><entry>Separador de espacio</entry></row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Las propiedades extendidas tales como "Greek" o "InMusicalSymbols" no están
      soportadas por PCRE.
     </para>
     <para>
      El especificar sin coincidir mayúsculas-minúsculas no afecta a estas secuencias de escape.
      Por ejemplo, <literal>\p{Lu}</literal> siempre coincide con letras mayúsculas.
     </para>
     <para>
      El escape <literal>\X</literal> coincide con cualquier número de caracteres Unicode
      que forman un secuencia Unicode extendida. <literal>\X</literal> es equivalente
      a <literal>(?>\PM\pM*)</literal>.
     </para>
     <para>
      Es decir, coincide con un carácter sin propiedad "marca", seguido
      por cero o más caracteres sin la propiedad "marca", y trata la
      secuencia como un grupo atómico (véase más adelante). Los caracteres con la propiedad
      "marca" son típicamente acentos que afectan al carácter precedente.
     </para>
     <para>
      La comparación de caracteres por propiedades Unicode no es rápida, porque PCRE ha
      de buscar una estructura que contiene datos por más de quince mil
      caracteres. Es por esto por lo que las secuencias de escape tradicionales tales como
      <literal>\d</literal> y <literal>\w</literal> no usan propiedades Unicode
      en PCRE.
     </para>
    </section>

    <section xml:id="regexp.reference.circudollar">
     <title>Circunflejo y dólar</title>
     <para>
      Fuera de una clase carácter, en el modo de comparación por defecto, el
      carácter circunflejo (<literal>^</literal>) es una declaración que
      es verdadera sólo si el punto de coincidencia actual está en el inicio de
      de la cadena objetivo. Dentro de una clase carácter, circunflejo (<literal>^</literal>)
      tiene un significado totalmente diferente (véase más adelante).
     </para>
     <para>
      Circunflejo (<literal>^</literal>) no necesita ser el primer carácter
      del patroón si están implicadas un número de alternativas, pero
      debería ser la primera cosa en cada alternativa en la que aparece
      si el patrón es comparado siempre con esa rama. Si todas las posibles
      alternativas comienzan con un circunflejo (<literal>^</literal>), es decir,
      si el patrón es obligado a coincidir sólo con el comienzo de la cadena objetivo,
      se dice que el patrón está "anclado". (También hay otras
      contrucciones que pueden causar que un patrón esté anclado.)
     </para>
     <para>
      Un carácter dólar (<literal>$</literal>) es una declaración la cual es
      &true; sólo si el punto actual de coincidencia está al final de la cadena
      objetivo, o inmediatamente antes de un carácter de nueva línea que es el último
      carácter en la cadena (por defecto). Dólar (<literal>$</literal>)
      no necesita ser el último carácter del patrón si están implicadas un número de
      alternativas, pero debería ser el último ítem en cualquier rama
      en el que aparezca. Dólar no tiene un significado especial en una
      clase carácter.
     </para>
     <para>
      El significado de dólar se puede cambiar y así sólo coincida
      con el final absoluto de la cadena, estableciendo la opción
      <link linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
      en tiempo de compilación o comparación. Esto no afecta a la declaración \Z.
     </para>
     <para>
      El significado de los caracteres circunflejo y dólar se
      cambia si la opción
      <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
      es establecida. Cuando este es el caso, conciden inmediatemente después e
      inmediatamente antes que un carácter "\n" interno, respectivamente, además
      de coincidir al principio y final de la cadena objetivo. Por ejemplo, el
      patrón /^abc$/ coincide con la cadena objetivo "def\nabc" en el modo multi-línea,
      y no en otros. Consecuentemente, los patrones que están anclados en el modo
      de una sóla línea por causa del inicio de todas las ramas con "^" no están anclados en
      el modo multi-línea. La opción
      <link linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
      es ignorada si
      <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link> está
      establecido.
     </para>
     <para>
      Observe que las secuencias \A, \Z, y \z se pueden usar para coincidir
      el inicio y final de la cadena objetivo en ambos modod, y si todas
      las ramas de un patrón comienzan con \A siempre es anclado,
      sin tener en cuenta si <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>  
      este establecido o no.
     </para>
    </section>

    <section xml:id="regexp.reference.dot">
     <title>Punto</title>
     <para>
     Fuera de una clase carácter, un punto en el patrón coincide con
     un carácter en el sujeto, incluyendo un carácter no imprimible,
     pero no (por defecto) una nueva línea. Si la opción
     <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> 
     está establecida, entonces los puntos coinciden con nuevas líneas tambíen. El
     manejo del punto es totalmente independiente del manejo de
     circunflejo y dólar, la única relación existente es que todos
     implican caracteres de nueva línea. El punto no tiene un significado especial
     en una clase carácter.
     </para>
     <para>
      <emphasis>\C</emphasis> se puede usar para comparar un único byte. Tiene sentido
      en <emphasis>modo UTF-8</emphasis> donde el punto coincide con el carácter
      entero el cual puede consistir en múltiples bytes.
     </para>
    </section>

    <section xml:id="regexp.reference.squarebrackets">
     <title>Corchetes</title>
     <para>
      Un corchete de apertura introduce una clase carácter,
      finalizada por un corchete de cierre. Un corchete de
      cierre por sí solo no es especial. Si se requiere
      un corchete de cierre como un miembro de la clase, éste debería ser
      el primer carácter de datos en la clase (después de un circunflejo
      inicial, si está presente) o escapado con una barra invertida.
     </para>
     <para>
      Una clase carácter coincide con un sólo carácter en el sujeto;
      el carácter debe estar en el conjunto de caracteres definido por
      la clase, a menos que el primer carácter en la clase sea un
      circunflejo, en cuyo caso el carácter sujeto no debe de estar en
      el conjunto definido por la clase. Si un circunflejo es requerido
      en realidad como un miembro de la clase, asegúrese de que no sea el
      primer carácter, o escápelo con una barra invertida.
     </para>
     <para>
      Por ejemplo, la clase carácter [aeiou] coincide con cualquier vocal
      minúscula, mientras que [^aeiou] con cualquier carácter que no sea
      una vocal minúscula. Observe que un circunflejo es sólo una
      notación conveniente para especificar los caracteres que están en
      la clase enumerando los que no están. Si no es una
      declaración: aún consume un carácter de la cadena objetivo,
      y falla si el punto actual está al final de la
      cadena.
     </para>
     <para>
      Cuando está establecido el no coincidir mayúsculas-minúculas, cualquier letra
      en una clase representa tanto su versión en mayúsculas como
      minusculas, así, por ejemplo, una clase insensible [aeiou] coincidice con "A"
      así como con "a", y una clase insensible [^aeiou] no coincide con
      "A", mientras que una versión sensible a mayúsculas-minúsculas lo haría.
     </para>
     <para>
      El carácter nueva línea nunca es tratado de ninguna manera especial en
      las clases carácter, sin importar el establecimiento de la opción <link
       linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> 
      o <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>.
      Una clase tal como [^a] siempre coincidirá con una nueva línea.
     </para>
     <para>
      El carácter menos (guión) se puede usar para especificar un ámbito
      de caracteres en una clase carácter. Por ejemplo, [d-m]
      coincide con cualquier letra entre d y m, inclusive. Si un carácter
      menos se requiere en una clase, se debe escapar con una
      barra invertida o aparecer en una posición donde no pueda ser
      interpretado como indicador de ámbito, típicamente como el primer o último
      carácter en una clase.
     </para>
     <para>
      No es posible tener un carácter literal "]" como el
      carácter final de un rango. Un patrón tal como [W-]46] es
      interpretado como una clase de dos caracteres ("W" y "-")
      seguido de una cadena literal "46]", por lo que coincidiría con "W46]" o
      "-46]". Sin embargo, si el "]" es escapado con una barra invertida
      es interpretado como el final del ámbito, así [W-\]46] es
      interpretado como un clase individual que contiene un ámbito seguido de dos
      caracteres aparte. La representación octal o hexadecimal
      de "]" también se puede usar al final del ámbito.
     </para>
     <para>
      Los ámbitos operan en la secuencia de colación de ASCII. También se pueden
      usar para caracteres especificados numéricamente, por ejemplo
      [\000-\037]. Si un ámbito que incluye letras es usado cuando
      se establece la no coincidencia de mayúsculas-minúsculas, coincide con las
      letras en cualquier caso. Por ejemplo, [W-c] es equivalente a
      [][\^_`wxyzabc], coincido insensiblemente, y si las tablas
      de caracteres para la localización "fr" están siendo usadas, [\xc8-\xcb] coincide
      con caracteres E acentudos en ambos casos.
     </para>
     <para>
      Los tipos de caracteres \d, \D, \s, \S, \w,  y  \W  también pueden
      aparecer en la clase carácter, y añaden lo caracteres que
      ellos representan a la clase. Por ejemplo, [\dABCDEF] coincide con cualquier
      dígito hexadecimal. Un circunflejo se puede usar convenientemente
      con los tipo de caracteres en mayúsculas para especificar un
      conjunto de caracteres más restrictivo que el tipo de coincidencia en minúscula.
      por ejemplo, la clase [^\W_] coincide con cualquier letra o dígito,
      excepto con el subrayado.
     </para>
     <para>
      Todos los caracteres no alfanumérico distintos de \,  -,  ^  (al
      comienzo) y el ] finalizador no son especiales en una clase
      carácter, pero no es perjudicial si son escapados. El patrón
      terminador es siempre especial y debe ser escapado cuando se usa
      dentro de una expresión.
     </para>
    </section>

    <section xml:id="regexp.reference.verticalbar">
     <title>Barra vertical</title>
     <para>
     Los caracteres barra vertical se usan para serparar patrones
     alternativos. Por ejemplo, el patrón
      <literal>gilbert|sullivan</literal>
     coincide tanto con "gilbert" como con "sullivan". Pueden aparecer
     cualquier número de alternativas, y se permite una alternativa vacía
     (coincidienco con la cadena vacía). El proceso de comparación intenta
     cada alternativa sucesivamente, de izquierda a derecha, y la primera
     que tenga éxito se usa. Si las alternativas están dentro de un
     sub-patrón (definido más adelante), "tener éxito" significa coincidir con el
     resto del patrón principal así como con la alternativa en el
     sub-patrón.
     </para>
    </section>

    <section xml:id="regexp.reference.internal-options">
     <title>Ajuste de opciones internas</title>
     <para>
      Los ajustes de <link linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link>, 
      <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>,  
      <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>,
      <link linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link>,
      <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link>,
      <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>
      y PCRE_DUPNAMES se pueden cambiar desde dentro de un patrón por
      una secuencia de letras de opciones de Perl encerradas entre "(?" y
      ")". Las letras de opciones son:

      <table>
       <title>Letras de opciones internas</title>
       <tgroup cols="2">
        <tbody>
         <row>
          <entry><literal>i</literal></entry>
          <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link></entry>
         </row>
         <row>
          <entry><literal>m</literal></entry>
          <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link></entry>
         </row>
         <row>
          <entry><literal>s</literal></entry>
          <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link></entry>
         </row>
         <row>
          <entry><literal>x</literal></entry>
          <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link></entry>
         </row>
         <row>
          <entry><literal>U</literal></entry>
          <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link></entry>
         </row>
         <row>
          <entry><literal>X</literal></entry>
          <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link></entry>
         </row>
         <row>
          <entry><literal>J</literal></entry>
          <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_INFO_JCHANGED</link></entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </para>
     <para>
      Por ejemplo, (?im) establece la coincidencia deinsensibilidad de mayúsculas-minúsculas,
      multilínea. También es posible eliminar estas opciones predediendo la letra
      con un guión, y un establecimiento y eliminación combinados como
      (?im-sx), el cual establece <link
       linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link> y
      <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
      mientras que elimina <link
       linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> y
      <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>,
      también está permitido. Si una letra apareca tanto antes como después del
      guión, la opción es eliminada.
     </para>
     <para>
      Cuando un cambio de opción sucede en el nivel más alto (es decir, no dentro
      de sub-patrones entre paréntesis), el cambio de aplica al resto del
      patrón que sigue. Así, <literal>/ab(?i)c/</literal> coincide sólo con "abc"
      y "abC". Este comportamiento ha sido cambiado en PCRE 4.0, el cual está incluído
      desde PHP 4.3.3. Antes de estas versiones, <literal>/ab(?i)c/</literal> se
      ejecutaría como <literal>/abc/i</literal> (p.ej. coincidiendo con "ABC" y "aBc").
     </para>
     <para>
      Si un cambio de opción sucede dentro de un sub-patrón, el efecto
      es diferente. Esto es un cambio de comportamiento en Perl 5.005.
      Un cambio de opción dentro de un sub-patroón afecta sólo a aquella parte
      del sub-patrón que le sigue, por lo que

        <literal>(a(?i)b)c</literal>

      coincide con  abc  and  aBc  y ninguna otra cadena (asumiendo <link
       linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link> no es
      usado). Por medio de esto, las opciones pueden ser producidas para tener diferentes ajustes en
      diferentes partes del patrón. Cualquier cambio hecho en un alternativa
      sigue en ramas subsiguientes dentro del mismo sub-patrón. Por
      ejemplo,

        <literal>(a(?i)b|c)</literal>

      coincide con "ab", "aB", "c", and "C", incluso cuando al coincidir
      "C" la primera rama es abandonada después de establecer la opción.
      Esto es porque los efectos del establecimiento de opciones ocurren en
      tiempo de compilación. De otro modo habría algunos comportamiento extraños.
     </para>
     <para>
      Las opciones específicas de PCRE <link 
      linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link> y  
      <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link> se pueden
      cambiar de la misma forma que las opciones compatibles con Perl
      usando los caracteres U y X respectivamente. La bandera
      de ajuste (?X) es especial ya que debe siempre producirse antes
      de que se active cualquier otra característica en el patrón,
      incluso si está en el más alto nivil. Lo mejor es ponerlo al principio.
     </para>
    </section>

    <section xml:id="regexp.reference.subpatterns">
     <title>Sub-patrones</title>
     <para>
     Los sub-patrones están delimitados por paréntesis,
     los cuales pueden estar anidados. Marcar parte de un patrón como un sub-patrón
     hace dos cosas:
    </para>
    <para>
     1. Localiza un conjunto de alternativas. Por ejemplo, el
     patrón

       <literal>cat(aract|erpillar|)</literal>

     coincide con una de las palabras "cat",  "cataract",  o  "caterpillar".
     Son los paréntesis, coincidiría con "cataract",
     "erpillar" o la cadena vacía.
    </para>
    <para>
     2. Establece el sub-patrón como un sub-patrón de captura  (como
     se definió antes). Cuando el patrón completo coincide, esa porción
     de la cadena objetivo que coincidió con el sub-patrón es
     devuelta la llamador mediante el argumento  <emphasis>ovector</emphasis>
     argument de
     <function>pcre_exec</function>. Los paréntesis de apertura se cuentan
     de izquierda a derecha (comenzando por 1) para obtener el número de los
     sub-patrones de captura.
    </para>
    <para>
     Por ejemplo, si la cadena "the red king" se compara con
     el patrón

       <literal>the ((red|white) (king|queen))</literal>

     las cadenas capturadasson "red king", "red",  y  "king",
     y son numeradas como 1, 2, y 3.
    </para>
    <para>
     El hecho de que los simples paréntesis lleven a cabo dos funciones no es
     siempre útil. on frecuencia se presenta el caso en el que un
     sub-patrón de agrupamiento se requiere sin la necesidad de una captura. Si un
     paréntesis de apertura es seguido por "?:", el sub-patrón no
     realiza ninguna captura, y no es contado cuando se computa el
     número de cualquier sub-patrón de captura subsiguiente. Por ejemplo,
     si la cadena "the  white  queen" se compara con el
     patrón

       <literal>the ((?:red|white) (king|queen))</literal>

     las sub-cadenas capturadas son "white queen" y "queen", y
     son numeradas como 1 y 2. El número máximo de sub-cadenas capturadas
     es de 99, y el número máximo de todos los sub-patrones,
     tanto de captura como de no captura, es de 200.
    </para>
    <para>
     Como atajo conveniente, si se necesita cualquier establecimeinto
     de opciones al inicio de un sup-patrón de no captura, las
     letras de opcioes pueden aparecen entre el "?" y ":". Así
     lo dos patrones
    </para>

    <literallayout>
       (?i:saturday|sunday)
       (?:(?i)saturday|sunday)
    </literallayout>

    <para>
     coinciden exactamente con el mismo conjunto de cadenas. Dado que las ramas
     alternativas son probadas de izquierda a derecha, y las opciones no
     se reinician hasta que se alcance el final del sub-patrón, el establecimiento
     de una opción en una rama afecta a las ramas siguientes, por lo que
     los patrones de arriba coincidenc tanto con "SUNDAY" como con "Saturday".
     </para>
     
     <para>
      Es posible nombrar a los sub-patrones con
      <literal>(?P&lt;nombre&gt;patrón)</literal> desde PHP 4.3.3. Así, las matrices
      con coincidencias contendrán la coincidencia indexada por la cadena al lado de la 
      coincidencia indexada por un número.
     </para>
    </section>

    <section xml:id="regexp.reference.repetition">
     <title>Repetition</title>
     <para>
     Repetition is specified by quantifiers, which can follow any
     of the following items:

      <itemizedlist>
       <listitem><simpara>a single character, possibly escaped</simpara></listitem>
       <listitem><simpara>the . metacharacter</simpara></listitem>
       <listitem><simpara>a character class</simpara></listitem>
       <listitem><simpara>a back reference (see next section)</simpara></listitem>
       <listitem><simpara>a parenthesized subpattern (unless it is  an  assertion  -
     see below)</simpara></listitem>
      </itemizedlist>
    </para>
    <para>
     The general repetition quantifier specifies  a  minimum  and
     maximum  number  of  permitted  matches,  by  giving the two
     numbers in curly brackets (braces), separated  by  a  comma.
     The  numbers  must be less than 65536, and the first must be
     less than or equal to the second. For example:

       <literal>z{2,4}</literal>

     matches "zz", "zzz", or "zzzz". A closing brace on  its  own
     is not a special character. If the second number is omitted,
     but the comma is present, there is no upper  limit;  if  the
     second number and the comma are both omitted, the quantifier
     specifies an exact number of required matches. Thus

       <literal>[aeiou]{3,}</literal>

     matches at least 3 successive vowels,  but  may  match  many
     more, while

       <literal>\d{8}</literal>

     matches exactly 8 digits.  An  opening  curly  bracket  that
     appears  in a position where a quantifier is not allowed, or
     one that does not match the syntax of a quantifier, is taken
     as  a literal character. For example, {,6} is not a quantifier,
     but a literal string of four characters.
    </para>
    <para>
     The quantifier {0} is permitted, causing the  expression  to
     behave  as  if the previous item and the quantifier were not
     present.
    </para>
    <para>
     For convenience (and  historical  compatibility)  the  three
     most common quantifiers have single-character abbreviations:

     <table>
      <title>Single-character quantifiers</title>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry><literal>*</literal></entry>
         <entry>equivalent to <literal>{0,}</literal></entry>
        </row>
        <row>
         <entry><literal>+</literal></entry>
         <entry>equivalent to <literal>{1,}</literal></entry>
        </row>
        <row>
         <entry><literal>?</literal></entry>
         <entry>equivalent to <literal>{0,1}</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     It is possible to construct infinite loops  by  following  a
     subpattern  that  can  match no characters with a quantifier
     that has no upper limit, for example:

       <literal>(a?)*</literal>
    </para>
    <para>
     Earlier versions of Perl and PCRE used to give an  error  at
     compile  time  for such patterns. However, because there are
     cases where this  can  be  useful,  such  patterns  are  now
     accepted,  but  if  any repetition of the subpattern does in
     fact match no characters, the loop is forcibly broken.
    </para>
    <para>
     By default, the quantifiers  are  "greedy",  that  is,  they
     match  as much as possible (up to the maximum number of permitted
     times), without causing the rest of  the  pattern  to
     fail. The classic example of where this gives problems is in
     trying to match comments in C programs. These appear between
     the  sequences /* and */ and within the sequence, individual
     * and / characters may appear. An attempt to  match  C  comments
     by applying the pattern

       <literal>/\*.*\*/</literal>

     to the string

       <literal>/* first comment */  not comment  /* second comment */</literal>

     fails, because it matches  the  entire  string  due  to  the
     greediness of the .*  item.
    </para>
    <para>
     However, if a quantifier is followed  by  a  question  mark,
     then it ceases to be greedy, and instead matches the minimum
     number of times possible, so the pattern

       <literal>/\*.*?\*/</literal>

     does the right thing with the C comments. The meaning of the
     various  quantifiers is not otherwise changed, just the preferred
     number of matches.  Do not confuse this use of
     question  mark  with  its  use as a quantifier in its own right.
     Because it has two uses, it can sometimes appear doubled, as
     in

       <literal>\d??\d</literal>

     which matches one digit by preference, but can match two  if
     that is the only way the rest of the pattern matches.
    </para>
    <para>
     If the <link linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link>  
     option is set (an option which  is  not
     available  in  Perl)  then the quantifiers are not greedy by
     default, but individual ones can be made greedy by following
     them  with  a  question mark. In other words, it inverts the
     default behaviour.
    </para>
    <para>
     Quantifiers followed by <literal>+</literal> are "possessive". They eat
     as many characters as possible and don't return to match the rest of the
     pattern. Thus <literal>.*abc</literal> matches "aabc" but
     <literal>.*+abc</literal> doesn't because <literal>.*+</literal> eats the
     whole string. Possessive quantifiers can be used to speed up processing 
     since PHP 4.3.3.
    </para>
    <para>
     When a parenthesized subpattern is quantified with a minimum
     repeat  count  that is greater than 1 or with a limited maximum,
     more store is required for the  compiled  pattern,  in
     proportion to the size of the minimum or maximum.
    </para>
    <para>
     If a pattern starts with .* or  .{0,}  and  the  <link 
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> 
     option (equivalent to Perl's /s) is set, thus allowing the .
     to match newlines, then the pattern is implicitly  anchored,
     because whatever follows will be tried against every character
     position in the subject string, so there is no point  in
     retrying  the overall match at any position after the first.
     PCRE treats such a pattern as though it were preceded by \A.
     In  cases where it is known that the subject string contains
     no newlines, it is worth setting <link 
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>  when  the  
     pattern begins with .* in order to
     obtain this optimization, or
     alternatively using ^ to indicate anchoring explicitly.
    </para>
    <para>
     When a capturing subpattern is repeated, the value  captured
     is the substring that matched the final iteration. For example, after

       <literal>(tweedle[dume]{3}\s*)+</literal>

     has matched "tweedledum tweedledee" the value  of  the  captured
     substring  is  "tweedledee".  However,  if  there are
     nested capturing  subpatterns,  the  corresponding  captured
     values  may  have been set in previous iterations. For example,
     after
     
       <literal>/(a|(b))+/</literal>

     matches "aba" the value of the second captured substring  is
     "b".
     </para>
    </section>

    <section xml:id="regexp.reference.back-references">
     <title>Back references</title>
     <para>
     Outside a character class, a backslash followed by  a  digit
     greater  than  0  (and  possibly  further  digits) is a back
     reference to a capturing subpattern  earlier  (i.e.  to  its
     left)  in  the  pattern,  provided there have been that many
     previous capturing left parentheses.
    </para>
    <para>
     However, if the decimal number following  the  backslash  is
     less  than  10,  it is always taken as a back reference, and
     causes an error only if there are not  that  many  capturing
     left  parentheses in the entire pattern. In other words, the
     parentheses that are referenced need not be to the  left  of
     the  reference  for  numbers  less  than 10. See the section
     entitled "Backslash" above for further details of  the  handling
     of digits following a backslash.
    </para>
    <para>
     A back reference matches whatever actually matched the  capturing
     subpattern in the current subject string, rather than
     anything matching the subpattern itself. So the pattern

       <literal>(sens|respons)e and \1ibility</literal>

     matches "sense and sensibility" and "response and  responsibility",
     but  not  "sense  and  responsibility". If case-sensitive (caseful)
     matching is in force at the time of the back reference, then
     the case of letters is relevant. For example,

       <literal>((?i)rah)\s+\1</literal>

     matches "rah rah" and "RAH RAH", but  not  "RAH  rah",  even
     though  the  original  capturing subpattern is matched
     case-insensitively (caselessly).
    </para>
    <para>
     There may be more than one back reference to the  same  subpattern.
     If  a  subpattern  has not actually been used in a
     particular match, then any  back  references  to  it  always
     fail. For example, the pattern

       <literal>(a|(bc))\2</literal>

     always fails if it starts to match  "a"  rather  than  "bc".
     Because  there  may  be up to 99 back references, all digits
     following the backslash are taken as  part  of  a  potential
     back reference number. If the pattern continues with a digit
     character, then some delimiter must be used to terminate the
     back reference. If the <link 
     linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>  option 
     is set, this can be whitespace.  Otherwise an empty comment can be used.
    </para>
    <para>
     A back reference that occurs inside the parentheses to which
     it  refers  fails when the subpattern is first used, so, for
     example, (a\1) never matches.  However, such references  can
     be useful inside repeated subpatterns. For example, the pattern

       <literal>(a|b\1)+</literal>

     matches any number of "a"s and also "aba", "ababba" etc.  At
     each iteration of the subpattern, the back reference matches
     the character string corresponding to  the  previous  iteration.
     In order for this to work, the pattern must be such
     that the first iteration does not need  to  match  the  back
     reference.  This  can  be  done using alternation, as in the
     example above, or by a quantifier with a minimum of zero.
     </para>
     
     <para>
      Back references to the named subpatterns can be achieved by
      <literal>(?P=name)</literal> or, since PHP 5.2.4, also by
      <literal>\k&lt;name&gt;</literal>, <literal>\k'name'</literal>,
      <literal>\k{name}</literal> or <literal>\g{name}</literal>.
     </para>
    </section>

    <section xml:id="regexp.reference.assertions">
     <title>Assertions</title>
     <para>
     An assertion is  a  test  on  the  characters  following  or
     preceding  the current matching point that does not actually
     consume any characters. The simple assertions coded  as  \b,
     \B,  \A,  \Z,  \z, ^ and $ are described above. More complicated
     assertions are coded as  subpatterns.  There  are  two
     kinds:  those that <emphasis>look ahead</emphasis> of the current position in the
     subject string, and those that <emphasis>look behind</emphasis> it.
    </para>
    <para>
     An assertion subpattern is matched in the normal way, except
     that  it  does not cause the current matching position to be
     changed. <emphasis>Lookahead</emphasis> assertions start with  (?=  for  positive
     assertions and (?! for negative assertions. For example,

       <literal>\w+(?=;)</literal>

     matches a word followed by a semicolon, but does not include
     the semicolon in the match, and

       <literal>foo(?!bar)</literal>

     matches any occurrence of "foo"  that  is  not  followed  by
     "bar". Note that the apparently similar pattern

       <literal>(?!foo)bar</literal>

     does not find an occurrence of "bar"  that  is  preceded  by
     something other than "foo"; it finds any occurrence of "bar"
     whatsoever, because the assertion  (?!foo)  is  always  &true;
     when  the  next  three  characters  are  "bar". A lookbehind
     assertion is needed to achieve this effect.
    </para>
    <para>
     <emphasis>Lookbehind</emphasis> assertions start with (?&lt;=  for  positive  assertions
     and (?&lt;! for negative assertions. For example,

       <literal>(?&lt;!foo)bar</literal>

     does find an occurrence of "bar" that  is  not  preceded  by
     "foo". The contents of a lookbehind assertion are restricted
     such that all the strings  it  matches  must  have  a  fixed
     length.  However, if there are several alternatives, they do
     not all have to have the same fixed length. Thus

       <literal>(?&lt;=bullock|donkey)</literal>

     is permitted, but

       <literal>(?&lt;!dogs?|cats?)</literal>

     causes an error at compile time. Branches  that  match  different
     length strings are permitted only at the top level of
     a lookbehind assertion. This is an extension  compared  with
     Perl  5.005,  which  requires all branches to match the same
     length of string. An assertion such as

       <literal>(?&lt;=ab(c|de))</literal>

     is not permitted, because its single  top-level  branch  can
     match two different lengths, but it is acceptable if rewritten
     to use two top-level branches:

       <literal>(?&lt;=abc|abde)</literal>

     The implementation of lookbehind  assertions  is,  for  each
     alternative,  to  temporarily move the current position back
     by the fixed width and then  try  to  match.  If  there  are
     insufficient  characters  before  the  current position, the
     match is deemed to fail.  Lookbehinds  in  conjunction  with
     once-only  subpatterns can be particularly useful for matching
     at the ends of strings; an example is given at  the  end
     of the section on once-only subpatterns.
    </para>
    <para>
     Several assertions (of any sort) may  occur  in  succession.
     For example,

       <literal>(?&lt;=\d{3})(?&lt;!999)foo</literal>

     matches "foo" preceded by three digits that are  not  "999".
     Notice  that each of the assertions is applied independently
     at the same point in the subject string. First  there  is  a
     check  that  the  previous  three characters are all digits,
     then there is a check that the same three characters are not
     "999".   This  pattern  does not match "foo" preceded by six
     characters, the first of which are digits and the last three
     of  which  are  not  "999".  For  example,  it doesn't match
     "123abcfoo". A pattern to do that is

       <literal>(?&lt;=\d{3}...)(?&lt;!999)foo</literal>
    </para>
    <para>
     This time the first assertion looks  at  the  preceding  six
     characters,  checking  that  the first three are digits, and
     then the second assertion checks that  the  preceding  three
     characters are not "999".
    </para>
    <para>
     Assertions can be nested in any combination. For example,

       <literal>(?&lt;=(?&lt;!foo)bar)baz</literal>

     matches an occurrence of "baz" that  is  preceded  by  "bar"
     which in turn is not preceded by "foo", while

       <literal>(?&lt;=\d{3}...(?&lt;!999))foo</literal>

     is another pattern which matches  "foo"  preceded  by  three
     digits and any three characters that are not "999".
    </para>
    <para>
     Assertion subpatterns are not capturing subpatterns, and may
     not  be  repeated,  because  it makes no sense to assert the
     same thing several times. If any kind of assertion  contains
     capturing  subpatterns  within it, these are counted for the
     purposes of numbering the capturing subpatterns in the whole
     pattern.   However,  substring capturing is carried out only
     for positive assertions, because it does not make sense  for
     negative assertions.
    </para>
    <para>
     Assertions count towards the maximum  of  200  parenthesized
     subpatterns.
     </para>
    </section>

    <section xml:id="regexp.reference.onlyonce">
     <title>Once-only subpatterns</title>
     <para>
     With both maximizing and minimizing repetition,  failure  of
     what  follows  normally  causes  the repeated item to be
     re-evaluated to see if a different number of repeats allows the
     rest  of  the  pattern  to  match. Sometimes it is useful to
     prevent this, either to change the nature of the  match,  or
     to  cause  it fail earlier than it otherwise might, when the
     author of the pattern knows there is no  point  in  carrying
     on.
    </para>
    <para>
     Consider, for example, the pattern \d+foo  when  applied  to
     the subject line

       <literal>123456bar</literal>
    </para>
    <para>
     After matching all 6 digits and then failing to match "foo",
     the normal action of the matcher is to try again with only 5
     digits matching the \d+ item, and then with 4,  and  so  on,
     before ultimately failing. Once-only subpatterns provide the
     means for specifying that once a portion of the pattern  has
     matched,  it  is  not to be re-evaluated in this way, so the
     matcher would give up immediately on failing to match  "foo"
     the  first  time.  The  notation  is another kind of special
     parenthesis, starting with (?&gt; as in this example:

       <literal>(?&gt;\d+)bar</literal>
    </para>
    <para>
     This kind of parenthesis "locks up" the  part of the pattern
     it  contains once it has matched, and a failure further into
     the pattern is prevented from backtracking  into  it.
     Backtracking  past  it to previous items, however, works as normal.
    </para>
    <para>
     An alternative description is that a subpattern of this type
     matches  the  string  of  characters that an identical standalone
     pattern would match, if anchored at the current point
     in the subject string.
    </para>
    <para>
     Once-only subpatterns are not capturing subpatterns.  Simple
     cases  such as the above example can be thought of as a maximizing
     repeat that must  swallow  everything  it  can.  So,
     while both \d+ and \d+? are prepared to adjust the number of
     digits they match in order to make the rest of  the  pattern
     match, (?&gt;\d+) can only match an entire sequence of digits.
    </para>
    <para>
     This construction can of course contain arbitrarily  complicated
     subpatterns, and it can be nested.
    </para>
    <para>
     Once-only subpatterns can be used in conjunction with
     look-behind  assertions  to specify efficient matching at the end
     of the subject string. Consider a simple pattern such as

       <literal>abcd$</literal>

     when applied to a long string which does not match.  Because
     matching  proceeds  from  left  to right, PCRE will look for
     each "a" in the subject and then see if what follows matches
     the rest of the pattern. If the pattern is specified as

       <literal>^.*abcd$</literal>

     then the initial .* matches the entire string at first,  but
     when  this  fails  (because  there  is no following "a"), it
     backtracks to match all but the last character, then all but
     the  last  two  characters, and so on. Once again the search
     for "a" covers the entire string, from right to left, so  we
     are no better off. However, if the pattern is written as

       <literal>^(?>.*)(?&lt;=abcd)</literal>

     then there can be no backtracking for the .*  item;  it  can
     match  only  the  entire  string.  The subsequent lookbehind
     assertion does a single test on the last four characters. If
     it  fails,  the  match  fails immediately. For long strings,
     this approach makes a significant difference to the processing time.
    </para>
    <para>
     When a pattern contains an unlimited repeat inside a subpattern
     that can itself be repeated an unlimited number of
     times, the use of a once-only subpattern is the only way  to
     avoid  some  failing matches taking a very long time indeed.
     The pattern

       <literal>(\D+|&lt;\d+>)*[!?]</literal>

     matches an unlimited number of substrings that  either  consist
     of  non-digits,  or digits enclosed in &lt;>, followed by
     either ! or ?. When it matches, it runs quickly. However, if
     it is applied to

       <literal>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</literal>

     it takes a long  time  before  reporting  failure.  This  is
     because the string can be divided between the two repeats in
     a large number of ways, and all have to be tried. (The example
     used  [!?]  rather  than a single character at the end,
     because both PCRE and Perl have an optimization that  allows
     for  fast  failure  when  a  single  character is used. They
     remember the last single character that is  required  for  a
     match,  and  fail early if it is not present in the string.)
     If the pattern is changed to

       <literal>((?>\D+)|&lt;\d+>)*[!?]</literal>

     sequences of non-digits cannot be broken, and  failure  happens quickly.
     </para>
    </section>

    <section xml:id="regexp.reference.conditional">
     <title>Conditional subpatterns</title>
     <para>
     It is possible to cause the matching process to obey a  subpattern 
     conditionally  or to choose between two alternative
     subpatterns, depending on the result  of  an  assertion,  or
     whether  a previous capturing subpattern matched or not. The
     two possible forms of conditional subpattern are
    </para>

    <literallayout>
       (?(condition)yes-pattern)
       (?(condition)yes-pattern|no-pattern)
    </literallayout>
    <para>
     If the condition is satisfied, the yes-pattern is used; otherwise
     the  no-pattern  (if  present) is used. If there are
     more than two alternatives in the subpattern, a compile-time
     error occurs.
    </para>
    <para>
     There are two kinds of condition. If the  text  between  the
     parentheses  consists  of  a  sequence  of  digits, then the
     condition is satisfied if the capturing subpattern  of  that
     number  has  previously matched. Consider the following pattern,
     which contains non-significant white space to make  it
     more  readable  (assume  the  <link 
     linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link> 
     option)  and to divide it into three parts for ease of discussion:

       <literal>( \( )?    [^()]+    (?(1) \) )</literal>
    </para>
    <para>
     The first part matches an optional opening parenthesis,  and
     if  that character is present, sets it as the first captured
     substring. The second part matches one  or  more  characters
     that  are  not  parentheses. The third part is a conditional
     subpattern that tests whether the first set  of  parentheses
     matched  or  not.  If  they did, that is, if subject started
     with an opening parenthesis, the condition is &true;,  and  so
     the  yes-pattern  is  executed  and a closing parenthesis is
     required. Otherwise, since no-pattern is  not  present,  the
     subpattern  matches  nothing.  In  other words, this pattern
     matches a sequence of non-parentheses,  optionally  enclosed
     in parentheses.
    </para>
    <para>
     If the condition is the string <literal>(R)</literal>, it is satisfied if
     a recursive call to the pattern or subpattern has been made. At "top
     level", the condition is false.
    </para>
    <para>
     If the condition is not a sequence of digits or (R), it must be  an
     assertion.  This  may be a positive or negative lookahead or
     lookbehind assertion. Consider this pattern, again  containing
     non-significant  white space, and with the two alternatives on
     the second line:
    </para>

    <literallayout>
       (?(?=[^a-z]*[a-z])
       \d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )
    </literallayout>
    <para>
     The condition is a positive lookahead assertion that matches
     an optional sequence of non-letters followed by a letter. In
     other words, it tests for  the  presence  of  at  least  one
     letter  in the subject. If a letter is found, the subject is
     matched against  the  first  alternative;  otherwise  it  is
     matched  against the second. This pattern matches strings in
     one of the two forms dd-aaa-dd or dd-dd-dd,  where  aaa  are
     letters and dd are digits.
     </para>
    </section>

    <section xml:id="regexp.reference.comments">
     <title>Comments</title>
     <para>
     The  sequence  (?#  marks  the  start  of  a  comment  which
     continues   up  to  the  next  closing  parenthesis.  Nested
     parentheses are not permitted. The characters that make up a
     comment play no part in the pattern matching at all.
    </para>
    <para>
     If the <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>  
     option is set, an unescaped # character outside  a character class 
     introduces a comment that continues up to the next newline character 
     in the pattern.
     </para>
    </section>

    <section xml:id="regexp.reference.recursive">
     <title>Recursive patterns</title>
     <para>
     Consider the problem of matching a  string  in  parentheses,
     allowing  for  unlimited nested parentheses. Without the use
     of recursion, the best that can be done is to use a  pattern
     that  matches  up  to some fixed depth of nesting. It is not
     possible to handle an arbitrary nesting depth. Perl 5.6  has
     provided   an  experimental  facility  that  allows  regular
     expressions to recurse (among other things).  The  special 
     item (?R) is  provided for  the specific  case of recursion. 
     This PCRE  pattern  solves the  parentheses  problem (assume 
     the <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>
     option is set so that white space is 
     ignored):

       <literal>\( ( (?>[^()]+) | (?R) )* \)</literal>
    </para>
    <para>
     First it matches an opening parenthesis. Then it matches any
     number  of substrings which can either be a sequence of
     non-parentheses, or a recursive  match  of  the  pattern  itself
     (i.e. a correctly parenthesized substring). Finally there is
     a closing parenthesis.
    </para>
    <para>
     This particular example pattern  contains  nested  unlimited
     repeats, and so the use of a once-only subpattern for matching
     strings of non-parentheses is  important  when  applying
     the  pattern to strings that do not match. For example, when
     it is applied to

       <literal>(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</literal>

     it yields "no match" quickly. However, if a  once-only  subpattern
     is  not  used,  the match runs for a very long time
     indeed because there are so many different ways the + and  *
     repeats  can carve up the subject, and all have to be tested
     before failure can be reported.
    </para>
    <para>
     The values set for any capturing subpatterns are those  from
     the outermost level of the recursion at which the subpattern
     value is set. If the pattern above is matched against

       <literal>(ab(cd)ef)</literal>

     the value for the capturing parentheses is  "ef",  which  is
     the  last  value  taken  on  at the top level. If additional
     parentheses are added, giving

       <literal>\( ( ( (?>[^()]+) | (?R) )* ) \)</literal>
     then the string they capture
     is "ab(cd)ef", the contents of the top level parentheses. If
     there are more than 15 capturing parentheses in  a  pattern,
     PCRE  has  to  obtain  extra  memory  to store data during a
     recursion, which it does by using  pcre_malloc,  freeing  it
     via  pcre_free  afterwards. If no memory can be obtained, it
     saves data for the first 15 capturing parentheses  only,  as
     there is no way to give an out-of-memory error from within a
     recursion.
     </para>
     
     <para>
      Since PHP 4.3.3, <literal>(?1)</literal>, <literal>(?2)</literal> and so on 
      can be used for recursive subpatterns too. It is also possible to use named
      subpatterns: <literal>(?P&gt;name)</literal> or 
      <literal>(?P&amp;name)</literal>.
     </para>
     <para>
      If the syntax for a recursive subpattern reference (either by number or
      by name) is used outside the parentheses to which it refers, it operates
      like a subroutine in a programming language. An earlier example
      pointed out that the pattern
      <literal>(sens|respons)e and \1ibility</literal>
      matches "sense and sensibility" and "response and responsibility", but
      not "sense and responsibility". If instead the pattern
      <literal>(sens|respons)e and (?1)ibility</literal>
      is used, it does match "sense and responsibility" as well as the other
      two strings. Such references must, however, follow the subpattern to
      which they refer.
     </para>
     
     <para>
      The maximum length of a subject string is the largest positive number
      that an integer variable can hold. However, PCRE uses recursion to
      handle subpatterns and indefinite repetition. This means that the
      available stack space may limit the size of a subject string that can be
      processed by certain patterns.
     </para>
     
    </section>

    <section xml:id="regexp.reference.performances">
     <title>Performances</title>
     <para>
     Certain items that may appear in patterns are more efficient
     than  others.  It is more efficient to use a character class
     like [aeiou] than a set of alternatives such as (a|e|i|o|u).
     In  general,  the  simplest  construction  that provides the
     required behaviour is usually the  most  efficient.  Jeffrey
     Friedl's  book contains a lot of discussion about optimizing
     regular expressions for efficient performance.
    </para>
    <para>
     When a pattern begins with .* and the <link 
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>  option  is
     set,  the  pattern  is implicitly anchored by PCRE, since it
     can match only at the start of a subject string. However, if
     <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>   
     is not set, PCRE cannot make this optimization,
     because the . metacharacter does not then match  a  newline,
     and if the subject string contains newlines, the pattern may
     match from the character immediately following one  of  them
     instead of from the very start. For example, the pattern

       <literal>(.*) second</literal>

     matches the subject "first\nand second" (where \n stands for
     a newline character) with the first captured substring being
     "and". In order to do this, PCRE  has  to  retry  the  match
     starting after every newline in the subject.
    </para>
    <para>
     If you are using such a pattern with subject strings that do
     not  contain  newlines,  the best performance is obtained by
     setting <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>,
     or starting the  pattern  with  ^.*  to
     indicate  explicit anchoring. That saves PCRE from having to
     scan along the subject looking for a newline to restart at.
    </para>
    <para>
     Beware of patterns that contain nested  indefinite  repeats.
     These  can  take a long time to run when applied to a string
     that does not match. Consider the pattern fragment

       <literal>(a+)*</literal>
    </para>
    <para>
     This can match "aaaa" in 33 different ways, and this  number
     increases  very  rapidly  as  the string gets longer. (The *
     repeat can match 0, 1, 2, 3, or 4 times,  and  for  each  of
     those  cases other than 0, the + repeats can match different
     numbers of times.) When the remainder of the pattern is such
     that  the entire match is going to fail, PCRE has in principle
     to try every possible variation, and this  can  take  an
     extremely long time.
    </para>
    <para>
     An optimization catches some of the more simple  cases  such
     as

       <literal>(a+)*b</literal>

     where a literal character follows. Before embarking  on  the
     standard matching procedure, PCRE checks that there is a "b"
     later in the subject string, and if there is not,  it  fails
     the  match  immediately. However, when there is no following
     literal this optimization cannot be used. You  can  see  the
     difference by comparing the behaviour of

       <literal>(a+)*\d</literal>

     with the pattern above. The former gives  a  failure  almost
     instantly  when  applied  to a whole line of "a" characters,
     whereas the latter takes an appreciable  time  with  strings
     longer than about 20 characters.
     </para>
    </section>
  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
