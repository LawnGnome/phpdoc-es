<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.8 $ -->
<!-- EN-Revision: 1.12 Maintainer: lboshell Status: ready -->
<!-- splitted from ./en/functions/pcre.xml, last change in rev 1.2 -->
  <refentry id="reference.pcre.pattern.syntax">
   <refnamediv>
    <refname>Sintaxis de los Patrones</refname>
    <refpurpose>Describe la sintaxis de expresiones regulares
    PCRE</refpurpose>
   </refnamediv>

   <refsect1>
    <title>Descripci&oacute;n</title>
    <simpara>
     La biblioteca PCRE es un conjunto de funciones que implementa
     comparaciones con patrones de expresiones regulares usando usando
     la misma sintaxis y sem&aacute;ntica de Perl 5, con tan solo unas
     pocas diferencias (ver m&aacute;s adelante). La
     implementaci&oacute;n actual corresponde a Perl 5.005.
    </simpara>
   </refsect1>

   <refsect1>
    <title>Diferencias con Perl</title>
    <para>
     Las diferencias descritas aqu&iacute; existen con respecto a Perl
     5.005.
    <orderedlist>
     <listitem>
      <simpara>
       Por defecto, un caracter de espacio en blanco es cualquier
       caracter que reconozca la funci&oacute;n isspace() de la
       biblioteca C, aunque es posible compilar PCRE con tablas
       alternativas de tipos de caracteres. Normalmente, isspace()
       coincide con el espacio, la alimentaci&oacute;n de
       p&aacute;gina, la nueva l&iacute;nea, el retorno de carro, el
       tabulador horizontal y el tabulador vertical. Perl 5 ya no
       incluye el tabulador vertical en su conjunto de caracteres de
       espacio en blanco. La secuencia de escape \v que
       permaneci&oacute; durante mucho tiempo en la
       documentaci&oacute;n de Perl nunca fue reconocida en
       realidad. Sin embargo, el caracter mismo era tratado como
       espacio en blanco por lo menos hasta 5.002. En 5.004 y 5.005 no
       coincide con \s.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       PCRE no permite cuantificadores de repetici&oacute;n en
       aserciones hacia adelante. Perl las permite, pero no quieren
       decir lo que probablemente piense. Por ejemplo, (?!a){3} no
       quiere decir que los siguientes tres caracteres no sean
       "a". Simplemente indica que el siguiente caracter no sea "a"
       tres veces.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Los sub-patrones de captura que aparecen al interior de
       aserciones negativas hacia adelante son contados, pero sus
       entradas en el vector de desplazamientos no son definidas. Perl
       define sus variables num&eacute;ricas a partir de cualquiera de
       tales patrones que coinciden antes que la aserci&oacute;n falle
       en coincidir algo (y por lo tanto tiene &eacute;xito), pero
       solo si la aserci&oacute;n negativa hacia adelante contiene
       una sola rama.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Aunque los caracteres de cero binario son soportados en la
       cadena de asunto, no son permitidos en una cadena de
       patr&oacute;n porque &eacute;stas son pasadas como un cadena
       normal de C, terminada en cero. La secuencia de escape "\x00"
       puede ser usada en el patr&oacute;n para representar el cero
       binario.
      </simpara>
      </listitem>
      <listitem>
      <simpara>
       Las siguientes secuencias de escape de Perl no son soportadas:
       \l, \u, \L, \U. De hecho, estas son implementadas por el
       mecanismo de gesti&oacute;n general de cadenas de Perl y no son
       parte de su motor de comparaci&oacute;n de patrones.
      </simpara>
      </listitem>
      <listitem>
      <simpara>
       La aserci&oacute;n \G de Perl no es soportada, ya que no es
       relevante para las coincidencias sencillas de patrones.
      </simpara>
      </listitem>
      <listitem>
      <simpara>
       Obviamente, PCRE no soporta la construcci&oacute;n
       (?{c&oacute;digo}).
      </simpara>
      </listitem>
      <listitem>
      <simpara>
       En la actualidad hay algunas peculiaridades en Perl 5.005_02
       con respecto a los grupos de cadenas capturadas cuando parte de
       un patr&oacute;n se repite. Por ejemplo, al coincidir "aba" con
       el patr&oacute;n /^(a(b)?)+$/ se define $2 como "b", pero al
       coincidir "aabbaa" con /^(aa(bb)?)+$/ deja $2 sin definir. Sin
       embargo, si el patr&oacute;n se modifica a /^(aa(b(b))?)+$/
       entonces $2 (y $3) se definen.

       En Perl 5.004 se define $2 en ambos casos, y tambi&eacute;n
       ocurre en PCRE. Si en el futuro Perl se adapta a un estilo
       consistente que sea diferente, PCRE puede cambiar para
       ajustarse.
      </simpara>
      </listitem>
      <listitem>
      <simpara>
       Otra discrepancia a&uacute;n no resuelta consiste en que, en
       Perl 5.005_02, el patr&oacute;n /^(a)?(?(1)a|b)+$/ coincide con
       la cadena "a", pero en PCRE no. Sin embargo, tanto en Perl como
       en PCRE /^(a)?a/ coincide con "a", dejando $1 sin definir.
      </simpara>
      </listitem>
      <listitem>
      <para>
       PCRE ofrece algunas extensiones a las capacidades de
       expresiones regulares de Perl:
        <orderedlist>
         <listitem>
          <simpara>
           Aunque las aserciones hacia atr&aacute;s deben coincidir
           con cadenas de longitud fija, cada rama alternativa de una
           aserci&oacute;n hacia atr&aacute;s puede coincidir con una
           longitud diferente de cadena. Perl 5.005 requiere que todas
           ellas tengan la misma longitud.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Si <link
          linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
          se define y <link
          linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
          no, el meta-caracter $ s&oacute;lo coincide al final
          absoluto de la cadena.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Si se define <link
          linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link>,
          una barra invertida seguida de una letra sin significado
          especial provoca un error.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Si se define <link
          linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link>,
          la ambici&oacute;n de los cuantificadores de
          repetici&oacute;n es invertida, es decir, no son ambiciosos
          por defecto, pero si son seguidos de un signo de
          interrogaci&oacute;n, s&iacute; lo ser&aacute;n.
         </simpara>
        </listitem>
       </orderedlist>
      </para>
     </listitem>
    </orderedlist>
   </para>
   </refsect1>

   <refsect1 id="regexp.reference">
    <title>Detalles de las Expresiones Regulares</title>
     <refsect2 id="regexp.introduction">
      <title>Introducci&oacute;n</title>
      <para>
       La sintaxis y sem&aacute;ntica de las expresiones regulares
       soportadas por PCRE se describe a continuaci&oacute;n. Las
       expresiones reglurares son descritas en la documentaci&oacute;n
       de Perl y en varios libros m&aacute;s, algunos de los cuales
       contienen numerosos ejemplos. El libro "Mastering Regular
       Expressions" de Jeffrey Friedl, publicado por O'Reilly (ISBN
       1-56592-257-3), las cubre con gran detalle. El prop&oacute;sito
       de la presente descripci&oacute;n es el de servir como
       documentaci&oacute;n de referencia.
    </para>
    <para>
     Una expresi&oacute;n regular es un patr&oacute;n que es comparado
     contra una cadena de asunto, de izquierda a derecha. La
     mayor&iacute;a de caracteres se representan a ellos mismos en un
     patr&oacute;n, y coinciden con el caracter correspondiente en el
     asunto. Como ejemplo trivial, el patr&oacute;n <literal>The quick
     brown fox</literal> coincide con una porci&oacute;n de la cadena
     de asunto que sea id&eacute;ntica al patr&oacute;n dado.
    </para>
    </refsect2>
    <refsect2 id="regexp.reference.meta">
     <title>Meta-caracteres</title>
     <para>
      El poder de las expresiones regulares proviene de la habilidad
      de incluir alternativas y repeticiones en el
      patr&oacute;n. &Eacute;stos recursos son codificados en el
      patr&oacute;n mediante el uso de
      <emphasis>meta-caracteres</emphasis>, los cuales no se
      representan a ellos mismos, en su lugar, son interpretados de
      una forma especial.
    </para>
    <para>
     Hay dos conjuntos diferentes de meta-caracteres: aquellos que son
     reconocidos en cualquier parte dentro del patr&oacute;n excepto
     entre corchetes cuadrados, y aquellos que son reconocidos entre
     corchetes cuadrados. Por fuera de tales corchetes, los
     meta-caracteres son los siguientes:
      <variablelist>
       <varlistentry>
        <term><emphasis>\</emphasis></term>
        <listitem><simpara>caracter de escape general con varios
        usos</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>^</emphasis></term>
        <listitem><simpara>aserci&oacute;n de inicio de la cadena de
        asunto (o l&iacute;nea, en modo
        multil&iacute;nea)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>$</emphasis></term>
        <listitem><simpara>aserci&oacute;n de fin de la cadena de
        asunto (o l&iacute;nea, en modo
        multil&iacute;nea)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>.</emphasis></term>
        <listitem><simpara>coincide con cualquier caracter excepto la
        nueva l&iacute;nea (por defecto)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>[</emphasis></term>
        <listitem><simpara>inicia la definici&oacute;n de clases de
        caracteres</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>]</emphasis></term>
        <listitem><simpara>fin de la definici&oacute;n de clases de
        caracteres</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>|</emphasis></term>
        <listitem><simpara>inicio de rama
        alternativa</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>(</emphasis></term>
        <listitem><simpara>inicio de
        sub-patr&oacute;n</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>)</emphasis></term>
        <listitem><simpara>fin de
        sub-patr&oacute;n</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>?</emphasis></term>
        <listitem><simpara>extiende el significado de (,
        tambi&eacute;n es el cuantificador 0 &oacute; 1 tambi&eacute;n
        es el cuantificador de m&iacute;nimo</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>*</emphasis></term>
        <listitem><simpara>cuantificador cero o
        m&aacute;s</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>+</emphasis></term>
        <listitem><simpara>cuantificador uno o m&aacute;s</simpara>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>{</emphasis></term>
        <listitem><simpara>cuantificador de inicio de valores
        m&iacute;nimo/m&aacute;ximo</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>}</emphasis></term>
        <listitem><simpara>cuantificador de final de valores
        m&iacute;nimo/m&aacute;ximo</simpara></listitem>
       </varlistentry>
      </variablelist>

      Un segmento de un patr&oacute;n que se encuentre entre corchetes
      cuadrados es llamado una "clase de caracteres". En una clase de
      caracteres, los &uacute;nicos meta-caracteres son:

      <variablelist>
       <varlistentry>
        <term><emphasis>\</emphasis></term>
        <listitem><simpara>caracter general de
        escape</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>^</emphasis></term>
        <listitem><simpara>niega la clase, pero s&oacute;lo si se
        trata del primer caracter</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>-</emphasis></term>
        <listitem><simpara>indica un rango de
        caracteres</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>]</emphasis></term>
        <listitem><simpara>finaliza la clase de
        caracteres</simpara></listitem>
       </varlistentry>
      </variablelist>

      Las secciones siguientes describen el uso de cada uno de los
      meta-caracteres.
     </para>
    </refsect2>
   <refsect2 id="regexp.reference.backslash">
    <title>Barra Invertida</title>
    <para>
     El caracter de barra invertida tiene varios usos. Primero, si es
     seguido por un caracter no-alfanum&eacute;rico, remueve cualquier
     significado que el caracter pueda tener. Este uso de la barra
     invertida como un caracter de escape se aplica tanto dentro como
     fuera de las clases de caracteres.
    </para>
    <para>
     Por ejemplo, si desea crear una coincidencia con un caracter "*",
     debe escribir "\*" en el patr&oacute;n. Esto es aplicable bien
     sea que el caracter siguiente hubiese sido interpretado como un
     meta-caracter o no, as&iacute; que siempre es seguro preceder un
     caracter no-alfanum&eacute;rico con "\" para indicar que se
     representa a &eacute;l mismo. En particular, si desea crear una
     coincidencia con una barra invertida, escriba "\\".
    </para>
     <note>
      <para>
       Las <link linkend="language.types.string.syntax">cadenas</link>
       de PHP entre comillas sencillas y dobles tienen un significado
       especial para la barra invertida. Por lo tanto si \ debe ser
       coincidente con una expresi&oacute;n regular \\, entonces debe
       usarse "\\\\" o '\\\\' en c&oacute;digo PHP.
      </para>
     </note>
    <para>
     Si un patr&oacute;n es compilado con la opci&oacute;n <link
     linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>,
     los espacios en blanco del patr&oacute;n (fuera de una clase de
     caracteres) y los caracteres entre un "#", fuera de una clase de
     caracteres, y el siguiente salto de l&iacute;nea son
     ignorados. Una barra invertida de escape puede ser usada para
     incluir un espacio en blanco o un caracter "#" como parte del
     patr&oacute;n.
    </para>
    <para>
     Un segundo uso de la barra invertida ofrece una forma de
     codificar caracteres no-imprimibles en los patrones de una forma
     visible. No hay restricciones sobre la apariencia de los
     caracteres no-imprimibles, aparte del cero binario que finaliza
     un patr&oacute;n, pero cuando un patr&oacute;n est&aacute; siendo
     preparado mediante la edici&oacute;n de texto, usualmente es
     m&aacute;s f&aacute;cil usar una de las siguientes secuencias de
     escape en lugar de los caracteres binarios que representan:
    </para>
    <para>
      <variablelist>
       <varlistentry>
        <term><emphasis>\a</emphasis></term>
        <listitem><simpara>alarma, esto es, el caracter BEL
        (hexadecimal 07)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\cx</emphasis></term>
        <listitem><simpara>"control-x", en donde x es cualquier
        caracter</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\e</emphasis></term>
        <listitem><simpara>escape (hexadecimal
        1B)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\f</emphasis></term>
        <listitem><simpara>alimentaci&oacute;n de p&aacute;gina
        (hexadecimal 0C)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\n</emphasis></term>
        <listitem><simpara>nueva l&iacute;nea (hexadecimal
        0A)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\r</emphasis></term>
        <listitem><simpara>retorno de carro (hexadecimal
        0D)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\t</emphasis></term>
        <listitem><simpara>tabulador (hexadecimal
        09)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\xhh</emphasis></term>
        <listitem><simpara>caracter con c&oacute;digo hexadecimal
        hh</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\ddd</emphasis></term>
        <listitem><simpara>caracter con c&oacute;digo octal ddd, o
        referencia hacia atr&aacute;s</simpara></listitem>
       </varlistentry>
      </variablelist>
     </para>
    <para>
     El efecto preciso de "<literal>\cx</literal>" es como sigue: si
     "<literal>x</literal>" es una letra min&uacute;scula, &eacute;sta
     es convertida a may&uacute;scula. Entonces el sexto bit del
     caracter (40 en hexadecimal) es invertido. Por lo tanto,
     "<literal>\cz</literal>" se convierte en 1A en hexadecimal, pero
     "<literal>\c{</literal>" se convierte en 3B en hexadecimal,
     mientras que "<literal>\c;</literal>" se convierte en 7B en
     hexadecimal.
    </para>
    <para>
     Despu&eacute;s de "<literal>\x</literal>", son leidos hasta dos
     d&iacute;gitos hexadecimales (las letras pueden ser
     may&uacute;sculas o min&uacute;sculas). En <emphasis>modo
     UTF-8</emphasis>, "<literal>\x{...}</literal>" es permitido, en
     donde el contenido entre corchetes es una cadena de
     d&iacute;gitos hexadecimales. Es interpretado como un caracter
     UTF-8 cuyo n&uacute;mero de c&oacute;digo es el n&uacute;mero
     hexadecimal dado. La secuencia de escape hexadecimal original,
     <literal>\xhh</literal>, coincide con un caracter UTF-8 de dos
     bytes si el valor es mayor que 127.
    </para>
    <para>
     Despu&eacute;s de "<literal>\0</literal>", son le&iacute;dos
     hasta dos d&iacute;gitos octales m&aacute;s. En ambos casos, si
     hay menos de dos d&iacute;gitos, se usar&aacute;n s&oacute;lo los
     que est&eacute;n presentes. Por lo tanto, la secuencia
     "<literal>\0\x\07</literal>" especifica dos ceros binarios
     seguidos de un caracter BEL. Aseg&uacute;rese de indicar dos
     d&iacute;gitos despu&eacute;s del cero inicial si el caracter que
     sigue es en s&iacute; un d&iacute;gito octal.
    </para>
    <para>
     La gesti&oacute;n de una barra invertida seguida por un
     d&iacute;gito diferente de cero es complicada. Por fuera de una
     clase de caracteres, PCRE lee el d&iacute;gito y cualquier otro
     que le siga como un n&uacute;mero decimal. Si el n&uacute;mero es
     menor que diez, o si han habido al menos tantos par&eacute;ntesis
     izquierdos de captura en la expresi&oacute;n, entonces la
     secuencia entera es tomada como
     una <emphasis>referencia</emphasis>
     <emphasis>hacia atr&aacute;s</emphasis>. Una descripci&oacute;n
     de c&oacute;mo trabaja esto es presentada m&aacute;s adelante,
     tras la discusi&oacute;n sobre sub-patrones con
     par&eacute;ntesis.
    </para>
    <para>
     Al interior de una clase de caracteres, o si el n&uacute;mero
     decimal es mayor que 9 y no han habido tantos sub-patrones de
     captura, PCRE lee de nuevo hasta tres d&iacute;gitos octales que
     sigan a la barra invertida, y genera un byte sencillo a partir de
     los ocho bits menos significativos del valor. Cualquier
     d&iacute;gito subsiguiente se representa a &eacute;l mismo. Por
     ejemplo:
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\040</emphasis></term>
       <listitem><simpara>es otro modo de escribir un
       espacio</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\40</emphasis></term>
       <listitem>
        <simpara>
         es lo mismo, siempre que haya menos de cuarenta sub-patrones
         de captura previos
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\7</emphasis></term>
       <listitem><simpara>siempre es una referencia hacia
       atr&aacute;s</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\11</emphasis></term>
       <listitem>
        <simpara>
         puede ser una referencia hacia atr&aacute;s, u otra forma de
         escribir un tabulador
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\011</emphasis></term>
       <listitem><simpara>siempre es un tabulador</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\0113</emphasis></term>
       <listitem><simpara>es un tabulador seguido del caracter
       "3"</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\113</emphasis></term>
       <listitem>
        <simpara>
         es el caracter con el c&oacute;digo octal 113 (ya que no
         puede haber m&aacute;s de 99 referencias hacia atr&aacute;s)
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\377</emphasis></term>
       <listitem><simpara>es un byte que consiste completamente de
       bits 1</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\81</emphasis></term>
       <listitem>
        <simpara>
         puede ser una referencia hacia atr&aacute;s, o un cero
         binario seguido por los caracteres "8" y "1"
        </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Note que los valores octales del 100 o n&uacute;meros m&aacute;s
     grandes no deben iniciar con un cero, ya que no se leen
     m&aacute;s de tres d&iacute;gitos octales.
    </para>
    <para>
     Todas las secuencias que definen el valor de un byte sencillo
     pueden ser usadas tanto dentro como fuera de las clases de
     caracteres. Adicionalmente, la secuencia "<literal>\b</literal>"
     es interpretada como el caracter backspace (hexadecimal 08) al
     interior de una clase de caracteres. Por fuera de una clase de
     caracteres tiene un significado diferente (ver m&aacute;s
     adelante).
    </para>
    <para>
     El tercer uso de la barra invertida es para especificar tipos
     gen&eacute;ricos de caracteres:
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\d</emphasis></term>
       <listitem><simpara>cualquier d&iacute;gito
       decimal</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\D</emphasis></term>
       <listitem><simpara>cualquier caracter que no sea un
       d&iacute;gito decimal</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\s</emphasis></term>
       <listitem><simpara>cualquier caracter de espacio en
       blanco</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\S</emphasis></term>
       <listitem><simpara>cualquier caracter que no sea un espacio en
       blanco</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\w</emphasis></term>
       <listitem><simpara>cualquier caracter de
       "palabra"</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\W</emphasis></term>
       <listitem><simpara>cualquier caracter que no sea de
       "palabra"</simpara></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Cada pareja de las secuencias de escape divide el conjunto global
     de caracteres en dos grupos separados. Cualquier caracter dado
     coincide con uno, y s&oacute;lo uno, de cada pareja.
    </para>
    <para>
     Un caracter de "palabra" es cualquier letra o d&iacute;gito, o el
     caracter de subrayado, esto quiere decir, cualquier caracter que
     pueda ser parte de una "<literal>palabra</literal>" en Perl. La
     definici&oacute;n de letras y d&iacute;gitos es controlada por
     las tablas de caracteres de PCRE, y puede variar si se
     est&aacute;n efectuando coincidencias espec&iacute;ficas a
     localidades (vea "Soporte de localidades" m&aacute;s arriba). Por
     ejemplo, en la localidad "fr" (Francia), algunos c&oacute;digos
     de caracteres mayores a 128 son usados para letras con acentos, y
     &eacute;stas coinciden con <literal>\w</literal>.
    </para>
    <para>
     Estas secuencias de tipos de caracter pueden aparecer tanto
     dentro como fuera de las clases de caracteres. Cada una coincide
     con un caracter del tipo apropiado. Si el punto de coincidencia
     actual es el final de la cadena de asunto, todas las secuencias
     fallan, ya que no hay caracteres a coincidir.
    </para>
    <para>
     El cuarto uso de la barra invertida es para ciertas aserciones
     simples. Una aserci&oacute;n especifica una condici&oacute;n que
     tiene que cumplirse en un punto particular de una coincidencia,
     sin consumir caracter alguno de la cadena de asunto. El uso de
     sub-patrones para aserciones m&aacute;s complicadas se describe
     m&aacute;s adelante. Las aserciones de barra invertida son
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\b</emphasis></term>
       <listitem><simpara>l&iacute;mite de
       palabra</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\B</emphasis></term>
       <listitem><simpara>no-l&iacute;mite de
       palabra</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\A</emphasis></term>
       <listitem><simpara>inicio de la cadena de asunto (independiente
       del modo multil&iacute;nea)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\Z</emphasis></term>
       <listitem>
        <simpara>
         fin de la cadena de asunto o una nueva l&iacute;nea al final
         (independiente del modo multil&iacute;nea)
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\z</emphasis></term>
       <listitem><simpara>fin de la cadena de asunto (independiente
       del modo multil&iacute;nea)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\G</emphasis></term>
       <listitem><simpara>primera posici&oacute;n de coincidencia en
       el asunto</simpara></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Estas aserciones no pueden aparecer dentro de clases de
     caracteres (pero note que "<literal>\b</literal>" tiene un
     significado diferente, el cual es el caracter backspace, dentro
     de una clase de caracteres).
    </para>
    <para>
     Un l&iacute;mite de palabra es una posici&oacute;n en la cadena
     de asunto en donde el caracter actual y el anterior no coinciden
     ambos con <literal>\w</literal> o <literal>\W</literal> (es
     decir, uno coincide con <literal>\w</literal> y el otro coincide
     con <literal>\W</literal>), o se puede tratar del principio o el
     final de la cadena, si el primer o &uacute;ltimo caracter
     coincide con <literal>\w</literal>, respectivamente.
    </para>
    <para>
     Las aserciones <literal>\A</literal>, <literal>\Z</literal>, y
     <literal>\z</literal> se diferencian de los caracteres
     tradicionales circunflejo y d&oacute;lar (descritos m&aacute;s
     adelante) en que las primeras s&oacute;lo coinciden al inicio y
     final absolutos de la cadena de asunto, independientemente de las
     opciones definidas. No son influenciadas por las opciones <link
     linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
     o <link
     linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>. La
     diferencia entre <literal>\Z</literal> y <literal>\z</literal> es
     que <literal>\Z</literal> coincide antes de una nueva
     l&iacute;nea que sea el &uacute;ltimo caracter de la cadena como
     tambi&eacute;n al final de la cadena, mientas que
     <literal>\z</literal> s&oacute;lo coincide al final.
     </para>
     <para>
      La aserci&oacute;n <literal>\G</literal> es cierta
      &uacute;nicamente cuando la posici&oacute;n de coincidencia
      actual est&aacute; en el punto de inicio de la coincidencia,
      como se especifica por el argumento
      <parameter>desplazamiento</parameter> de
      <function>preg_match</function>. Difiere de
      <literal>\A</literal> cuando el valor de
      <parameter>desplazamiento</parameter> es diferente de cero. Se
      encuentra disponible desde PHP 4.3.3.
     </para>

     <para>
      Es posible usar <literal>\Q</literal> y <literal>\E</literal>
      para ignorar meta-caracteres de expresiones regulares en el
      patr&oacute;n desde PHP 4.3.3. Por ejemplo:
      <literal>\w+\Q.$.\E$</literal> coincidir&aacute; con uno o
      m&aacute;s caracteres de palabra, seguido por los literales
      <literal>.$.</literal> y anclado al final de la cadena.
     </para>

    </refsect2>

    <refsect2 id="regexp.reference.unicode">
     <title>Propiedades de caracter Unicode</title>
     <para>
      A partir de PHP 4.4.0 y 5.1.0 se encuentran disponibles tres
      secuencias de escape adicionales para comparar tipos de caracter
      gen&eacute;ricos cuando el <emphasis>modo UTF-8</emphasis> es
      seleccionado. &Eacute;stos son:
     </para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\p{xx}</emphasis></term>
       <listitem><simpara>un caracter con la propiedad
       xx</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\P{xx}</emphasis></term>
       <listitem><simpara>un caracter sin la propiedad
       xx</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\X</emphasis></term>
       <listitem><simpara>una secuencia Unicode
       extendida</simpara></listitem>
      </varlistentry>
     </variablelist>
     <para>
      Los nombres de propiedad representados por <literal>xx</literal>
      en la lista anterior est&aacute;n limitados a las propiedades de
      categor&iacute;a general Unicode. Cada caracter tiene
      exactamente una propiedad de aqu&eacute;llas, especificada por
      una abreviaci&oacute;n de dos letras. Para compatibilidad con
      Perl, es posible especificar la negaci&oacute;n incluyendo un
      circunflejo entre el corchete de apertura y el nombre de
      propiedad. Por ejemplo, <literal>\p{^Lu}</literal> es lo mismo
      que <literal>\P{Lu}</literal>.
     </para>
     <para>
      Si solo una letra es especificada con <literal>\p</literal> o
      <literal>\P</literal>, ella incluye todas las propiedades que
      comienzan con esa letra. En este caso, en la ausencia de la
      negaci&oacute;n, los corchetes en la secuencia de escape son
      opcionales; los siguientes dos ejemplos tienen el mismo efecto:
     </para>
     <literallayout>
      \p{L}
      \pL
     </literallayout>
     <table>
      <title>C&oacute;digos de propiedad soportados</title>
      <tgroup cols="2">
       <tbody>
        <row><entry><literal>C</literal></entry><entry>Otro</entry></row>
        <row><entry><literal>Cc</literal></entry><entry>Control</entry></row>
        <row><entry><literal>Cf</literal></entry><entry>Formato</entry></row>
        <row><entry><literal>Cn</literal></entry><entry>Sin asignar</entry></row>
        <row><entry><literal>Co</literal></entry><entry>Uso privado</entry></row>
        <row rowsep="1"><entry><literal>Cs</literal></entry><entry>Sustituto</entry></row>
        <row><entry><literal>L</literal></entry><entry>Letra</entry></row>
        <row><entry><literal>Ll</literal></entry><entry>Letra min&uacute;scula</entry></row>
        <row><entry><literal>Lm</literal></entry><entry>Letra modificadora</entry></row>
        <row><entry><literal>Lo</literal></entry><entry>Otra letra</entry></row>
        <row><entry><literal>Lt</literal></entry><entry>Letra de t&iacute;tulo</entry></row>
        <row
        rowsep="1"><entry><literal>Lu</literal></entry><entry>Letra may&uacute;scula</entry></row>
        <row><entry><literal>M</literal></entry><entry>Marca</entry></row>
        <row><entry><literal>Mc</literal></entry><entry>Marca de espacio</entry></row>
        <row><entry><literal>Me</literal></entry><entry>Marca de clausura</entry></row>
        <row
        rowsep="1"><entry><literal>Mn</literal></entry><entry>Marca
        diferente de espacio</entry></row>
        <row><entry><literal>N</literal></entry><entry>N&uacute;mero</entry></row>
        <row><entry><literal>Nd</literal></entry><entry>N&uacute;mero decimal</entry></row>
        <row><entry><literal>Nl</literal></entry><entry>N&uacute;mero de letra</entry></row>
        <row
        rowsep="1"><entry><literal>No</literal></entry><entry>Otro n&uacute;mero</entry></row>
        <row><entry><literal>P</literal></entry><entry>Puntuaci&oacute;n</entry></row>
        <row><entry><literal>Pc</literal></entry><entry>Puntuaci&oacute;n conector</entry></row>
        <row><entry><literal>Pd</literal></entry><entry>Puntuaci&oacute;n
        de raya</entry></row>
        <row><entry><literal>Pe</literal></entry><entry>Putuaci&oacute;n de cierre</entry></row>
        <row><entry><literal>Pf</literal></entry><entry>Puntuaci&oacute;n final</entry></row>
        <row><entry><literal>Pi</literal></entry><entry>Puntuaci&oacute;n inicial</entry></row>
        <row><entry><literal>Po</literal></entry><entry>Otra puntuaci&oacute;n</entry></row>
        <row
        rowsep="1"><entry><literal>Ps</literal></entry><entry>Puntuaci&oacute;n
        de apertura</entry></row>
        <row><entry><literal>S</literal></entry><entry>S&iacute;mbolo</entry></row>
        <row><entry><literal>Sc</literal></entry><entry>S&iacute;mbolo de moneda</entry></row>
        <row><entry><literal>Sk</literal></entry><entry>S&iacute;mbolo modificador</entry></row>
        <row><entry><literal>Sm</literal></entry><entry>S&iacute;mbolo matem&aacute;tico</entry></row>
        <row
        rowsep="1"><entry><literal>So</literal></entry><entry>Otro s&iacute;mbolo</entry></row>
        <row><entry><literal>Z</literal></entry><entry>Separador</entry></row>
        <row><entry><literal>Zl</literal></entry><entry>Separador de l&iacute;nea</entry></row>
        <row><entry><literal>Zp</literal></entry><entry>Separador de p&aacute;rrafo</entry></row>
        <row><entry><literal>Zs</literal></entry><entry>Separador de espacio</entry></row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Propiedades extendidas como "Greek" o "InMusicalSymbols" no son
      soportadas por PCRE.

     </para>
     <para>
      Especificar coincidencias no sensibles a
      may&uacute;sculas/min&uacute;sculas no afecta estas secuencias
      de escape. Por ejemplo, <literal>\p{Lu}</literal> siempre
      coincide &uacute;nicamente con letras may&uacute;sculas.
     </para>
     <para>
      El escape <literal>\X</literal> coincide con cualquier
      n&uacute;mero de caracteres Unicode que formen una secuencia
      Unicode extendida. <literal>\X</literal> es equivalente a
      <literal>(?>\PM\pM*)</literal>.
     </para>
     <para>
      Es decir, coincide con un caracter sin la propiedad "marca",
      seguido de cero o m&aacute;s caracteres con la propiedad
      "marca", y trata la secuencia como un grupo at&oacute;mico (vea
      m&aacute;s adelante). Los caracteres con la propiedad "marca"
      usualmente son acentos que afectan el caracter precedente.
     </para>
     <para>
      Encontrar coincidencias por propiedades Unicode no es
      r&aacute;pido, ya que PCRE tiene que buscar una estructura que
      contiene datos para m&aacute;s de quince-mil caracteres. Por
      ello es que las secuencias de escape tradicionales como
      <literal>\d</literal> y <literal>\w</literal> no usan
      propiedades Unicode en PCRE.
     </para>
    </refsect2>

    <refsect2 id="regexp.reference.circudollar">
     <title>El circunflejo y el d&oacute;lar</title>
     <para>
      Por fuera de una clase de caracteres, en el modo predeterminado
      de coincidencia, el caracter circunflejo es una aserci&oacute;n
      que s&oacute;lo es verdadera si el punto de coincidencia actual
      es el inicio de la cadena de asunto. Al interior de una clase de
      caracteres, el circunflejo tiene un significado completamente
      distinto (ver m&aacute;s adelante).
     </para>
     <para>
      El circunflejo no necesita ser el primer caracter del
      patr&oacute;n si se involucra un n&uacute;mero de alternativas,
      pero debe ser la primer cosa en cada alternativa en la que
      aparezca si se espera que el patr&oacute;n coincida con esa
      rama.  Si todas las alternativas posibles empiezan con un
      circunflejo, esto es, si el patr&oacute;n est&aacute; limitado a
      coincidir s&oacute;lo con en el inicio del asunto, se dice que
      es un patr&oacute;n "anclado". (Tambi&eacute;n hay otras
      construcciones que pueden hacer que un patr&oacute;n sea
      anclado.)
     </para>
     <para>
      Un caracter de d&oacute;lar es una aserci&oacute;n que es
      verdadera s&oacute;lo si el punto de coincidencia actual se
      encuentra al final de la cadena de asunto, o inmediatamente
      antes de un caracter de nueva l&iacute;nea que sea el
      &uacute;ltimo caracter en la cadena (por defecto). El
      d&oacute;lar no necesita ser el &uacute;ltimo caracter del
      patr&oacute;n si hay varias alternativas involucradas, pero debe
      ser el &uacute;ltimo elemento en cada rama en la que
      aparezca. El d&oacute;lar no tiene un significado especial en
      una clase de caracteres.
     </para>
     <para>
      El significado del d&oacute;lar puede ser modificado para que
      coincida s&oacute;lo al final absoluto de la cadena, definiendo
      la opci&oacute;n <link
      linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
      en tiempo de compilaci&oacute;n o a la hora de efectuar la
      comparaci&oacute;n. Esto no afecta a la aserci&oacute;n \Z.
     </para>
     <para>
      Los significados de los caracteres circunflejo y d&oacute;lar
      son modificados si la opci&oacute;n <link
      linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
      es definida. Cuando &eacute;ste es el caso, &eacute;stos
      caracteres coinciden inmediatamente antes e inmediatamente
      despu&eacute;s de un caracter "\n" interno, respectivamente,
      adem&aacute;s de coincidir con el inicio y el final de la cadena
      de asunto. Por ejemplo, el patr&oacute;n /^abc$/ coincide con la
      cadena de asunto "def\nabc" en modo multil&iacute;nea, pero no
      en otro caso. Consecuentemente, los patrones que son anclados en
      modo de l&iacute;nea sencilla ya que todas las ramas empiezan
      con "^" no son anclados en modo multil&iacute;nea. La
      opci&oacute;n <link
      linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
      es ignorada si <link
      linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
      es definido.
     </para>
     <para>
      Tenga en cuenta que las secuencias \A, \Z y \z pueden ser usadas
      para coincidir con el inicio y el final del asunto en ambos
      modos, y si todas las ramas de un patr&oacute;n comienzan con
      \A, el patr&oacute;n siempre es anclado, independientemente de
      si <link
      linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
      es definido o no.
     </para>
    </refsect2>

    <refsect2 id="regexp.reference.dot">
     <title>Punto</title>
     <para>
      Por fuera de una clase de caracteres, un punto en el
      patr&oacute;n coincide con cualquier caracter del asunto,
      incluyendo caracteres no-imprimibles, pero no el salto de
      l&iacute;nea (por defecto). Si la opci&oacute;n <link
      linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> es
      definida, entonces los puntos coinciden con los saltos de
      l&iacute;nea tambi&eacute;n. El manejo del punto es
      completamente independiente del uso del circunflejo y el
      d&oacute;lar, dado que la &uacute;nica relaci&oacute;n entre
      ellos es que ambos casos involucran caracteres de nueva
      l&iacute;nea. El punto no tiene un significado especial dentro
      de una clase de caracteres.
     </para>
     <para>
      Es posible usar <emphasis>\C</emphasis> para coincidir con un
      byte sencillo. Tiene sentido en <emphasis>modo UTF-8</emphasis>
      en donde el punto coincide con el caracter completo que puede
      consistir de m&uacute;ltiples bytes.
     </para>
    </refsect2>

    <refsect2 id="regexp.reference.squarebrackets">
     <title>Corchetes cuadrados</title>
     <para>
      Un corchete cuadrado de apertura inicia una clase de caracteres,
      terminada por un corchete cuadrado de cierre. Un corchete
      cuadrado de cierre por s&iacute; solo no es especial. Si un
      corchete cuadrado de cierre es requerido como un miembro de la
      clase, deber&iacute;a ser el primer caracter de datos en la
      clase (despu&eacute;s de un circunflejo inicial, si est&aacute;
      presente) o escapado con una barra invertida.
     </para>
     <para>
      Una clase de caracteres coincide con un caracter &uacute;nico en
      el asunto; el caracter debe estar en el conjunto de los
      caracteres definidos por la clase, a menos que el primer
      caracter en la clase sea un circunflejo, en cuyo caso el
      caracter del asunto no debe estar en el conjunto definido por la
      clase. Si un circunflejo es necesitado realmente como un miembro
      de la clase, aseg&uacute;rese de que no sea el primer caracter,
      o esc&aacute;pelo con una barra invertida.
     </para>
     <para>
      Por ejemplo, la clase de caracteres [aeiou] coincide con
      cualquier vocal min&uacute;scula, mientras que [^aeiou] coincide
      con cualquier caracter que no sea una vocal min&uacute;scula.
      Note que un circunflejo es una notaci&oacute;n conveniente para
      especificar los caracteres que est&aacute;n en la clase
      enumerando aquellos que no lo est&aacute;n. No es una
      aserci&oacute;n: aun consume un caracter de la cadena de asunto,
      y falla si el apuntador actual est&aacute; al final de la
      cadena.
     </para>
     <para>
      Cuando se recurre a las comparaciones insensibles a
      may&uacute;sculas y min&uacute;sculas, cualquier letra en una
      clase representa ambas versiones, por ejemplo, un patr&oacute;n
      insensible a may&uacute;sculas y min&uacute;sculas [aeiou]
      coincide tanto con "A" como con "a", y un patr&oacute;n
      insensible a may&uacute;sculas y min&uacute;sculas [^aeiou] no
      coincide con "A", mientras que una versi&oacute;n sensible lo
      har&iacute;a.
     </para>
     <para>
      El caracter de nueva l&iacute;nea nunca es tratado de un modo
      especial entra las clases de caracteres, independientemente de
      los valores de las opciones <link
      linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> o
      <link
      linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>. Una
      clase como [^a] siempre coincidir&aacute; con una nueva
      l&iacute;nea.
     </para>
     <para>
      El caracter menos (gui&oacute;n) puede ser usado para
      especificar un rango de caracteres en una clase de
      caracteres. Por ejemplo, [d-m] coincide con cualquier letra
      entre d y m, ambas inclusive. Si un caracter menos es requerido
      en una clase, debe ser escapado con una barra invertida, o
      aparecer en una posici&oacute;n en donde no pueda ser
      interpretado como indicador de rango, normalmente como primer o
      &uacute;ltimo caracter de la clase.
     </para>
     <para>
      No es posible tener el caracter literal "]" como el caracter
      final de un rango.  Un patr&oacute;n como [W-]46] es
      interpretado como una clase de dos caracteres ("W" y "-")
      seguida por la cadena literal "46]", as&iacute; que
      coincidir&iacute;a con "W46]" o "-46]". Sin embargo, si el
      caracter "]" es escapado con una barra invertida, &eacute;ste es
      interpretado como el final del rango, as&iacute; que [W-\]46] es
      interpretado como una clase &uacute;nica que contiene un rango
      seguido por dos caracteres diferentes. La representaci&oacute;n
      octal o hexadecimal de "]" puede ser usada tambi&eacute;n para
      finalizar un rango.
     </para>
     <para>
      Los rangos trabajan en el orden de la secuencia ASCII. Pueden
      ser usados tambi&eacute;n para caracteres especificados
      num&eacute;ricamente, por ejemplo [\000-\037]. Si un rango que
      incluye letras es usado cuando es definida la comparaci&oacute;n
      insensible a may&uacute;sculas y min&uacute;sculas, el rango
      coincide las letras en cualquiera de los casos. Por ejemplo,
      [W-c] es equivalente a [][\^_`wxyzabc], efectuando la
      coincidencia insensible a may&uacute;sculas y min&uacute;sculas,
      y si las tablas de caracteres para la localidad "fr"
      est&aacute;n en uso, entonces [\xc8-\xcb] coincide con los
      caracteres E acentuados en ambos casos.
     </para>
     <para>
      Los tipos de caracteres \d, \D, \s, \S, \w, y \W tambi&eacute;n
      pueden aparecer en una clase de caracteres, y a&ntilde;aden los
      caracteres que ellos representan a la clase.  Por ejemplo,
      [\dABCDEF] coincide con cualquier d&iacute;gito hexadecimal. Un
      circunflejo puede ser convenientemente usado con los tipos de
      caracter en may&uacute;scula para especificar un conjunto
      m&aacute;s restringido de caracteres que el de una
      comparaci&oacute;n con tipo en min&uacute;scula. Por ejemplo, la
      clase [^\W_] coincide con cualquier letra o d&iacute;gito, pero
      no con el signo de subrayado.
     </para>
     <para>
      Todos los caracteres no-alfanum&eacute;ricos diferentes a \, -,
      ^ (al comienzo) y el caracter ] de cierre no tienen un
      significado especial en una clase de caracteres, pero no hace
      da&ntilde;o que se encuentren escapados..
     </para>
    </refsect2>

    <refsect2 id="regexp.reference.verticalbar">
     <title>Barra vertical</title>
     <para>
      Los caracteres de barra vertical son usados para separar
      patrones alternativos. Por ejemplo, el patr&oacute;n
      <literal>gilbert|sullivan</literal> coincide o bien con
      "gilbert" o con "sullivan". Puede usarse cualquier n&uacute;mero
      de alternativas, y se permiten alternativas vac&iacute;as (que
      coinciden con la cadena vac&iacute;a). El proceso de
      comparaci&oacute;n prueba con cada alternativa de izquierda a
      derecha, y la primera que tenga &eacute;xito es usada. Si las
      alternativas est&aacute;n al interior de un sub-patr&oacute;n
      (definido m&aacute;s adelante), el "&eacute;xito" quiere decir
      que coincida con el resto del patr&oacute;n principal como
      tambi&eacute;n con la alternativa en el sub-patr&oacute;n.
     </para>
    </refsect2>

    <refsect2 id="regexp.reference.internal-options">
     <title>Definici&oacute;n de opciones internas</title>
     <para>
      Los valores de <link
      linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link>,
      <link
      linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>,
      <link
      linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>,
      <link
      linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link>,
      <link
      linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link>,
      y <link
      linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>
      pueden ser modificados desde el interior del patr&oacute;n por
      una secuencia de letras de opciones de Perl encerradas entre
      "(?" y ")".  Las letras de opciones son:

      <table>
       <title>Letras de opciones internas</title>
       <tgroup cols="2">
        <tbody>
         <row>
          <entry><literal>i</literal></entry>
          <entry>para <link
          linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link></entry>
         </row>
         <row>
          <entry><literal>m</literal></entry>
          <entry>para <link
          linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link></entry>
         </row>
         <row>
          <entry><literal>s</literal></entry>
          <entry>para <link
          linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link></entry>
         </row>
         <row>
          <entry><literal>x</literal></entry>
          <entry>para <link
          linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link></entry>
         </row>
         <row>
          <entry><literal>U</literal></entry>
          <entry>para <link
          linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link></entry>
         </row>
         <row>
          <entry><literal>X</literal></entry>
          <entry>para <link
          linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link></entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </para>
     <para>
      Por ejemplo, (?im) define una comparaci&oacute;n insensible a
      may&uacute;sculas y min&uacute;sculas y en modo
      multil&iacute;nea. Tambi&eacute;n es posible eliminar
      &eacute;stas opciones precediendo las letras con un
      gui&oacute;n, as&iacute; como se permite tambi&eacute;n una
      combinaci&oacute;n de activaciones y desactivaciones como
      (?im-sx), la cual define <link
      linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link>
      y <link
      linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
      al mismo tiempo que desactiva <link
      linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> y
      <link
      linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>. Si
      una letra aparece antes y despu&eacute;s del gui&oacute;n, la
      opci&oacute;n ser&aacute; desactivada.
     </para>
     <para>
      Cuando un cambio de opci&oacute;n ocurre en el nivel superior
      (es decir, no al interior de los par&eacute;ntesis de
      sub-patrones), el cambio se aplica al resto del patr&oacute;n a
      seguir. As&iacute; que <literal>/ab(?i)c/</literal> coincide
      &uacute;nicamente con "abc" y "abC". Este comportamiento ha
      cambiado en PCRE 4.0, el cual es distribuido desde PHP
      4.3.3. Antes de aquellas versiones, <literal>/ab(?i)c/</literal>
      actuar&iacute;a como <literal>/abc/i</literal>
      (p.ej. coincidiendo "ABC" y "aBc").
     </para>
     <para>
      Si un cambio de opci&oacute;n sucede dentro de un
      sub-patr&oacute;n, el efecto es diferente. Este es un cambio
      respecto a la conducta de Perl 5.005. Un cambio de opci&oacute;n
      dentro de un sub-patr&oacute;n afecta s&oacute;lo a la parte del
      sub-patr&oacute;n que lo sigue, de modo que

        <literal>(a(?i)b)c</literal>

      coincide con abc y aBc y ninguna otra cadena (asumiendo que no
      se est&aacute; usando <link
      linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link>). De
      esta forma, las opciones pueden definirse para tener diferentes
      significados en diferente partes del patr&oacute;n. Cualquier
      cambio realizado en una alternativa ciertamente se aplica a
      ramas subsecuentes al interior del mismo sub-patr&oacute;n. Por
      ejemplo,

        <literal>(a(?i)b|c)</literal>

      coincide con "ab", "aB", "c", y "C", aun cuando al coincidir con
      "C", la primera rama es abandonada antes de definir la
      opci&oacute;n. Esto es porque los efectos de definir de opciones
      ocurren en tiempo de compilaci&oacute;n. De otro modo,
      ocurrir&iacute;a un comportamiento muy extra&ntilde;o.
     </para>
     <para>
      Las opciones espec&iacute;ficas de PCRE <link
      linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link>
      y <link
      linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link>
      pueden ser modificadas del mismo modo que las opciones
      compatibles con Perl usando los caracteres U y X
      respectivamente. La opci&oacute;n bandera (?X) es especial en el
      sentido en que siempre debe ocurrir antes que cualquier otra
      caracter&iacute;stica adicional que active en el patr&oacute;n,
      incluso cuando es definida en el nivel superior. Su mejor
      ubicaci&oacute;n es el inicio.
     </para>
    </refsect2>

    <refsect2 id="regexp.reference.subpatterns">
     <title>Sub-patrones</title>
     <para>
      Los sub-patrones son delimitados por par&eacute;ntesis, y pueden
      estar anidados. Marcar parte de un patr&oacute;n como un
      sub-patr&oacute;n logra dos cosas:
    </para>
    <para>
     1. Ubica un conjunto de alternativas. Por ejemplo, el
     patr&oacute;n

       <literal>cat(aract|erpillar|)</literal>

     coincide con una de las palabras "cat", "cataract", o
     "caterpillar". Sin los par&eacute;ntesis, coincidir&iacute;a con
     "cataract", "erpillar" o la cadena vac&iacute;a.
    </para>
    <para>
     2. Define el sub-patr&oacute;n como un sub-patr&oacute;n de
     captura (como se defini&oacute; anteriormente). Cuando el
     patr&oacute;n completo coincida, esa porci&oacute;n de la cadena
     de asunto que coincidi&oacute; con el sub-patr&oacute;n es
     devuelta al origen mediante el
     argumento <emphasis>ovector</emphasis>
     de <function>pcre_exec</function>. Los par&eacute;ntesis de
     apertura son contados de izquierda a derecha (empezando desde 1)
     para obtener los n&uacute;meros de los sub-patrones de captura.
    </para>
    <para>
     Por ejemplo, si la cadena "the red king" es comparada contra el
     patr&oacute;n

       <literal>the ((red|white) (king|queen))</literal>

     las sub-cadenas capturadas son "red king", "red", y "king", y son
     numeradas como 1, 2 y 3.
    </para>
    <para>
     El hecho de que los simples par&eacute;ntesis realicen dos
     funciones no siempre es &uacute;til. Con frecuencia se presenta
     el caso en el que un sub-patr&oacute;n de agrupamiento es
     requerido sin necesidad de una captura. Si un par&eacute;ntesis
     de apertura es seguido por "?:", el sub-patr&oacute;n no realiza
     ninguna captura, y no es contado cuando se compute el
     n&uacute;mero de sub-patrones subsiguientes capturados. Por
     ejemplo, si la cadena "the white queen" es comparada con el
     patr&oacute;n

       <literal>the ((?:red|white) (king|queen))</literal>

     las sub-cadenas capturadas son "white queen" y "queen", y son
     numeradas como 1 y 2. El n&uacute;mero m&aacute;ximo de
     sub-cadenas capturadas es de 99, y el n&uacute;mero m&aacute;ximo
     de todos los sub-patrones, de captura o no, es de 200.
    </para>
    <para>
     Como un atajo conveniente, si cualquiera de las opciones se
     requiere al inicio de un sub-patr&oacute;n que no sea de captura,
     las letras de las opciones pueden aparecer entre los caracteres
     "?" y ":". Por lo tanto, los dos patrones
    </para>

    <literallayout>
       (?i:saturday|sunday)
       (?:(?i)saturday|sunday)
    </literallayout>

    <para>
     coinciden con exactamente el mismo conjunto de cadenas. Dado que
     las ramas alternativas son probadas de izquierda a derecha, y las
     opciones no son reestablecidas hasta el final del
     sub-patr&oacute;n, una definici&oacute;n de opci&oacute;n en una
     rama afecta las ramas subsecuentes, as&iacute; que los patrones
     anteriores coinciden con "SUNDAY", al igual que con "Saturday".
     </para>

     <para>
      Es posible nombrer el sub-patr&oacute;n con
      <literal>(?P&lt;nombre&gt;patron)</literal> a partir de PHP
      4.3.3. En ese caso, las matrices con coincidencias
      contendr&aacute;n el resultado indexado por la cadena junto con
      el resultado indexado por un n&uacute;mero.
     </para>
    </refsect2>

    <refsect2 id="regexp.reference.repetition">
     <title>Repetici&oacute;n</title>
     <para>
      La repetici&oacute;n es especificada por cuantificadores, los
      cuales pueden ir tras cualquiera de los siguientes elementos:
      <itemizedlist>
       <listitem><simpara>un caracter sencillo, posiblemente
       escapado</simpara></listitem>
       <listitem><simpara>el meta-caracter .</simpara></listitem>
       <listitem><simpara>una clase de caracteres</simpara></listitem>
       <listitem><simpara>una referencia hacia atr&aacute;s (vea la
       siguiente secci&oacute;n)</simpara></listitem>
       <listitem><simpara>un sub-patr&oacute;n entre par&eacute;ntesis
       (a menos que se trate de una aserci&oacute;n - vea m&aacute;s
       adelante)</simpara></listitem>
      </itemizedlist>
    </para>
    <para>
     El cuantificador general de repetici&oacute;n indica un
     n&uacute;mero m&iacute;nimo y un n&uacute;mero m&aacute;ximo de
     coincidencias permitidas, dando los dos n&uacute;meros entre
     corchetes ondulados (llaves), separados por una coma. Los
     n&uacute;meros deben ser menores a 65536, y el primero debe ser
     menor o igual al segundo. Por ejemplo:

       <literal>z{2,4}</literal>

     coincide con "zz", "zzz", o "zzzz". Una llave de cierre por
     s&iacute; sola no es un caracter especial. Si el segundo
     n&uacute;mero es omitido, pero aparece la coma, entonces no hay
     l&iacute;mite superior; si el segundo n&uacute;mero y la coma son
     omitidos ambos, el cuantificador indica el n&uacute;mero exacto
     de repeticiones requeridas. Por lo tanto

       <literal>[aeiou]{3,}</literal>

     coincide con al menos 3 vocales sucesivas, pero podr&iacute;a
     coincidir con muchas m&aacute;s, mientras que

       <literal>\d{8}</literal>

     coincide con exactamente ocho d&iacute;gitos. Una llave de
     apertura que aparezca en una posici&oacute;n en donde no se
     permite un cuantificador, o una que no coincida con la sintaxis
     de un cuantificador, es tomada como un caracter literal. Por
     ejemplo, {,6} no es un cuantificador, sino una cadena literal de
     cuatro caracteres.
    </para>
    <para>
     Se permite el uso del cuantificador {0}, lo que provoca que la
     expresi&oacute;n se comporte como si el elemento anterior y el
     cuantificador no estuvieran presentes.
    </para>
    <para>
     Por conveniencia (y compatibilidad hist&oacute;rica) los tres
     cuantificadores m&aacute;s comunes tienen abreviaciones de un
     solo caracter:
     <table>
      <title>Cuantificadores de caracter-&uacute;nico</title>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry><literal>*</literal></entry>
         <entry>equivalente a <literal>{0,}</literal></entry>
        </row>
        <row>
         <entry><literal>+</literal></entry>
         <entry>equivalente a <literal>{1,}</literal></entry>
        </row>
        <row>
         <entry><literal>?</literal></entry>
         <entry>equivalente a <literal>{0,1}</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     Es posible construir ciclos infinitos mediante un
     sub-patr&oacute;n que no pueda coincidar con ning&uacute;n
     caracter con un cuantificador que no tenga l&iacute;mite
     superior, por ejemplo:

       <literal>(a?)*</literal>
    </para>
    <para>
     Las primeras versiones de Perl y PCRE sol&iacute;an producir un
     error en tiempo de compilaci&oacute;n para tales patrones. Sin
     embargo, dado que existen casos en donde esto puede ser
     &uacute;til, tales patrones son aceptados ahora, pero si
     cualquier repetici&oacute;n del sub-patr&oacute;n no coincide
     realmente con ning&uacute;n caracter, el ciclo es interrumpido a
     la fuerza.
    </para>
    <para>
     Por defecto, los cuantificadores son "ambiciosos", lo que quiere
     decir, coinciden con tanto material como les es posible (hasta el
     n&uacute;mero m&aacute;ximo de veces permitido), sin provocar que
     el resto del patr&oacute;n falle. El ejemplo cl&aacute;sico en el
     que esto causa problema es a la hora de crear coincidencias con
     comentarios en programas en C. &Eacute;stos aparecen entre las
     secuencias /* y */ y, al interior de la secuencia, los caracteres
     * y / pueden aparecer individualmente. Un intento por coincidir
     comentarios en C al aplicar el patr&oacute;n

       <literal>/\*.*\*/</literal>

     sobre la cadena

       <literal>/* primer comentario */ no comentado /* segundo
       comentario */</literal>


     falla, ya que coincide con la cadena entera debido a la
     ambici&oacute;n del elemento .*
    </para>
    <para>
     Sin embargo, si un cuantificador es seguido por un signo de
     interrogaci&oacute;n, entonces deja de ser ambicioso, y en su
     lugar coincide el m&iacute;nimo n&uacute;mero de veces posibles,
     de tal suerte que el patr&oacute;n

       <literal>/\*.*?\*/</literal>

     hace lo correcto con los comentarios en C. El significado de los
     varios cuantificadores no se modifica en otro modo, tan
     s&oacute;lo el n&uacute;mero preferido de coincidencias. No
     confunda &eacute;ste uso del signo de interrogaci&oacute;n con su
     uso como un cuantificador por s&iacute; solo. Debido a que tiene
     dos usos, a veces puede aparecer dos veces seguidas, como en

       <literal>\d??\d</literal>

     caso que coincide con un d&iacute;gito de ser posible, pero puede
     coincidir con dos si ese el &uacute;nico modo en que el resto del
     patr&oacute;n coincida.
    </para>
    <para>
     Si se encuentra definida la opci&oacute;n <link
     linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link>
     (la cual no est&aacute; disponible en Perl) entonces los
     cuantificadores no son ambiciosos por defecto, pero cada uno por
     separado puede serlo cuando a continuaci&oacute;n de ellos se
     encuentra un signo de interrogaci&oacute;n. En otras palabras,
     invierte el comportamiento predeterminada.
    </para>
    <para>
     Los cuantificadores seguidos por <literal>+</literal> son
     "posesivos". Ellos consumen tantos caracteres como es posible y
     no regresan para coincidir con el resto del patr&oacute;n. Por lo
     tanto <literal>.*abc</literal> coincide con "aabc" pero
     <literal>.*+abc</literal> no ya que <literal>.*+</literal>
     consume la cadena completa. Los cuantificadores posesivos pueden
     ser usados para incrementar la rapidez de procesamiento desde PHP
     4.3.3.
    </para>
    <para>
     Cuando un sub-patr&oacute;n entre par&eacute;ntesis es
     cuantificado con un n&uacute;mero m&iacute;nimo de repeticiones
     superior a 1 o con un l&iacute;mite m&aacute;ximo, se necesita
     mayor almacenamiento para el patr&oacute;n compilado, en
     proporci&oacute;n al tama&ntilde;o del m&iacute;nimo o del
     m&aacute;ximo.
    </para>
    <para>
     Si un patr&oacute;n empieza con .* o .{0,} y la opci&oacute;n
     <link
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>
     (equivalente a /s en Perl) es definida, permitiendo de esa forma
     que . coincida con nuevas l&iacute;neas, entonces el
     patr&oacute;n es anclado impl&iacute;citamente, ya que cualquier
     cosa a continuaci&oacute;n ser&aacute; comparada contra cada
     posici&oacute;n de caracter en la cadena de asunto, as&iacute;
     que no hay razones para reintentar la coincidencia en su
     totalidad en cualquier posici&oacute;n luego de la primera. PCRE
     trata tales patrones como si estuvieran precedidos por \A. En los
     casos donde se conoce que la cadena de asunto no contiene nuevas
     l&iacute;neas, vale la pena definir <link
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>
     cuando el patr&oacute;n comienza con .* para obtener esta
     optimizaci&oacute;n, o alternativamente usar ^ para indicar el
     anclamiento expl&iacute;citamente.
    </para>
    <para>
     Cuando un sub-patr&oacute;n de captura es repetido, el valor
     capturado es la sub-cadena que coincidi&oacute; con la
     iteraci&oacute;n final. Por ejemplo, luego de que

       <literal>(tweedle[dume]{3}\s*)+</literal>

     ha coincidido con "tweedledum tweedledee" el valor de la
     sub-cadena capturada es "tweedledee". Sin embargo, si hay
     sub-patrones de captura anidados, los valores capturados
     correspondientes pueden haber sido definidos en las iteraciones
     anteriores. Por ejemplo, despu&eacute;s de que
     
       <literal>/(a|(b))+/</literal>

     coincide con "aba", el valor de la segunda sub-cadena capturada
     es "b".
     </para>
    </refsect2>

    <refsect2 id="regexp.reference.back-references">
     <title>Referencias hacia atr&aacute;s</title>
     <para>
     Por fuera de una clase de caracteres, una barra invertida seguida
     por un digito mayor que cero (y posiblemente m&aacute;s
     d&iacute;gitos) es una referencia hacia atr&aacute;s a un
     sub-patr&oacute;n de captura anterior (es decir, a su izquierda)
     en el patr&oacute;n, siempre y cuando existan tantos
     par&eacute;ntesis izquierdos de captura.
    </para>
    <para>
     Sin embargo, si el n&uacute;mero decimal a continuaci&oacute;n de
     la barra invertida es menor que diez, siempre es tomado como una
     referencia hacia atr&aacute;s, y causa un error s&oacute;lo si no
     hay los suficientes par&eacute;ntesis izquierdos de captura en
     todo el patr&oacute;n. En otras palabras, los par&eacute;ntesis
     que son referidos no necesitan estar a la izquierda de la
     referencia para n&uacute;meros menores que diez.  Vea la
     secci&oacute;n anterior titulada "Barra invertida" para
     m&aacute;s detalles sobre el manejo de los d&iacute;gitos que
     siguen a una barra invertida.
    </para>
    <para>
     Una referencia hacia atr&aacute;s coincide con cualquier cosa que
     haya coincidido realmente con el sub-patr&oacute;n de captura en
     la cadena de asunto actual, en lugar de hacerlo con cualquier
     cosa que coincida con el sub-patr&oacute;n mismo. De modo que el
     patr&oacute;n

       <literal>(sens|respons)e and \1ibility</literal>

     coincide con "sense and sensibility" y "response and
     responsibility", pero no "sense and responsibility". Si se
     est&aacute; aplicando una comparaci&oacute;n sensible a
     may&uacute;sculas y min&uacute;sculas al momento de la referencia
     hacia atr&aacute;s, entonces la distinci&oacute;n de las letras
     es importante. Por ejemplo,

       <literal>((?i)rah)\s+\1</literal>

     coincide con "rah rah" y "RAH RAH", pero no "RAH rah", incluso
     cuando el sub-patr&oacute;n de captura original fue comparado de
     forma insensible a may&uacute;sculas y min&uacute;sculas.
    </para>
    <para>
     Puede haber m&aacute;s de una referencia hacia atr&aacute;s hacia
     el mismo sub-patr&oacute;n. Si un sub-patr&oacute;n no ha sido
     usado realmente en una coincidencia particular, entonces
     cualquier referencia hacia atr&aacute;s hacia aqu&eacute;l
     siempre falla. Por ejemplo, el patr&oacute;n

       <literal>(a|(bc))\2</literal>

     siempre falla si comienza coincidiendo con "a" en lugar de
     "bc". Ya que puede haber hasta 99 referencias hacia atr&aacute;s,
     todos los d&iacute;gitos que siguen a la barra invertida son
     tomados como parte de un potencial n&uacute;mero de referencia
     hacia atr&aacute;s. Si el patr&oacute;n contin&uacute;a con un
     caracter de d&iacute;gito, entonces debe ser usado alg&uacute;n
     delimitador para terminar la referencia hacia atr&aacute;s. Si la
     opci&oacute;n <link
     linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>
     es definida, este puede ser el espacio en blanco. De otro modo,
     un comentario vaci&oacute; puede ser usado.
    </para>
    <para>
     Una referencia hacia atr&aacute;s que ocurra dentro del
     par&eacute;ntesis al cual hace referencia falla cuando el
     sub-patr&oacute;n es usado por primera vez, as&iacute; que, por
     ejemplo, (a\1) nunca crea coincidencias. Sin embargo, tales
     referencia pueden ser &uacute;tiles al interior de sub-patrones
     repetidos. Por ejemplo, el patr&oacute;n

       <literal>(a|b\1)+</literal>

     coincide con cualquier n&uacute;mero de "a"s y tambi&eacute;n con
     "aba", "ababaa" etc. Para cada iteraci&oacute;n del
     sub-patr&oacute;n, la referencia hacia atr&aacute;s coincide con
     la cadena de caracteres correspondiente a la iteraci&oacute;n
     anterior. Para que esto funcione, el patr&oacute;n debe ser tal
     que la primera iteraci&oacute;n no necesite coincidir con la
     referencia hacia atr&aacute;s. Esto puede lograrse usando
     alternaciones, como en el ejemplo anterior, o por medio de un
     cuantificador con un m&iacute;nimo de cero.
     </para>
    </refsect2>

    <refsect2 id="regexp.reference.assertions">
     <title>Aserciones</title>
     <para>
      Una aserci&oacute;n es una prueba sobre los caracteres a
      continuaci&oacute;n o antes del punto actual de coincidencia que
      no consume caracteres en realidad. Las aserciones simples
      codificadas como \b, \B, \A, \Z, \z, ^ y $ son descritas
      anteriormente. Las aserciones m&aacute;s complicadas son
      codificadas como sub-patrones. Hay dos tipos: aquellas que
      trabajan con material m&aacute;s adelante de la posici&oacute;n
      actual en la cadena de asunto y aquellas que lo hacen con
      material hacia atr&aacute;s.
    </para>
    <para>
     Un sub-patr&oacute;n de aserci&oacute;n es comparado del modo
     usual, excepto que no causa que el punto actual de coincidencia
     cambie. Las aserciones hacia adelante comienzan con (?= en el
     caso de aserciones positivas y (?! para las negativas. Por
     ejemplo,

       <literal>\w+(?=;)</literal>

     coincide con una palabra seguida por un punto-y-coma. pero no
     incluye el punto-y-coma en la coincidencia, y

       <literal>foo(?!bar)</literal>

     coincide con cualquier ocurrencia de "foo" que no sea seguida por
     "bar". Note que el patr&oacute;n, en apariencia semejante,

       <literal>(?!foo)bar</literal>

     no encuentra una ocurrencia de "bar" que sea precedida por algo
     diferente de "foo"; encuentra cualquier ocurrencia de "bar", ya
     que la aserci&oacute;n (?!foo) es siempre verdadera cuando los
     siguientes tres caracteres son "bar". Una aserci&oacute;n hacia
     atr&aacute;s es necesaria para conseguir este efecto.
    </para>
    <para>
     Las aserciones hacia atr&aacute;s comienzan con (?&lt;= para las
     aserciones positivas y (?&lt;!  para las negativas. Por ejemplo,

       <literal>(?&lt;!foo)bar</literal>

     encuentra una ocurrencia de "bar" que no es precedida por "foo".
     Los contenidos de una aserci&oacute;n hacia atr&aacute;s son
     restringidos de tal forma que todas las cadenas con las que
     coinciden deben tener una longitud fija. Sin embargo, si hay
     varias alternativas, no todas tienen que tener la misma
     longitud. Por lo tanto

       <literal>(?&lt;=bullock|donkey)</literal>

     se permite, pero

       <literal>(?&lt;!dogs?|cats?)</literal>

     genera un error en tiempo de compilaci&oacute;n. Las ramas que
     coinciden con cadenas de diferentes longitudes son permitidas
     s&oacute;lo en el nivel superior de la aserci&oacute;n hacia
     atr&aacute;s. &Eacute;sta es una extensi&oacute;n en
     comparaci&oacute;n con Perl 5.005, en donde se requiere que todas
     las ramas coincidan con la misma longitud de cadena. Una
     aserci&oacute;n como

       <literal>(?&lt;=ab(c|de))</literal>

     no es permitida, ya que su rama &uacute;nica de nivel superior
     puede coincidir con dos longitudes diferentes, pero es aceptable
     si se reescribe para usar dos ramas de nivel superior:

       <literal>(?&lt;=abc|abde)</literal>

     La implementaci&oacute;n de las aserciones hacia atr&aacute;s
     consiste en, para cada alternativa, mover temporalmente la
     posici&oacute;n actual hacia atr&aacute;s en el ancho fijo e
     intentar la coincidencia. Si no hay suficientes caracteres antes
     de la posici&oacute;n actual, la coincidencia est&aacute;
     destinada a fallar. Las aserciones hacia atr&aacute;s, en
     uni&oacute;n con los sub-patrones de una sola aplicaci&oacute;n,
     pueden ser particularmente &uacute;tiles para las coincidencias
     al final de cadenas; un ejemplo es dado al final de la
     secci&oacute;n sobre sub-patrones de una aplicaci&oacute;n.
    </para>
    <para>
     Varias aserciones (de cualquier tipo) pueden ocurrir en
     sucesi&oacute;n. Por ejemplo,

       <literal>(?&lt;=\d{3})(?&lt;!999)foo</literal>

     coincide con "foo" precedido de tres d&iacute;gitos que no sean
     "999". Note que cada una de las aserciones es aplicada
     independientemente en el mismo punto en la cadena de
     asunto. Primero hay un chequeo para que los tres caracteres
     previos sean todos d&iacute;gitos, luego hay un chequeo para que
     los mismos caracteres no sean "999". Este patr&oacute;n no
     coincide con "foo" precedido de seis caracteres, en donde los
     primeros son d&iacute;gitos y los &uacute;ltimos tres no son
     "999". Por ejemplo, no coincide con "123abcfoo". Un patr&oacute;n
     para conseguir eso es

       <literal>(?&lt;=\d{3}...)(?&lt;!999)foo</literal>
    </para>
    <para>
     En este caso la primera aserci&oacute;n revisa los seis
     caracteres anteriores, y chequea que los tres primeros sean
     d&iacute;gitos, y luego la segunda aserci&oacute;n chequea que
     los tres caracteres anteriores no sean "999".
    </para>
    <para>
     Las aserciones puede ser anidadas en cualquier
     combinaci&oacute;n. Por ejemplo,

       <literal>(?&lt;=(?&lt;!foo)bar)baz</literal>

     coincide con una ocurrencia de "baz" que sea precedida por "bar",
     la cual a su vez no sea precedida por "foo", mientras que

       <literal>(?&lt;=\d{3}...(?&lt;!999))foo</literal>

     es otro patr&oacute;n que coincide con "foo" precedido por tres
     d&iacute;gitos y tres caracteres cualquiera que no sean "999".

    </para>
    <para>
     Los sub-patrones de aserci&oacute;n no son sub-patrones de
     captura, y no pueden ser repetidos, ya que no tiene sentido
     afirmar la misma cosa varias veces. Si una aserci&oacute;n de
     cualquier tipo contiene sub-patrones de captura en su interior,
     &eacute;stos son contados con el prop&oacute;sito de numerar los
     sub-patrones de captura en todo el patr&oacute;n. Sin embargo, la
     captura de subcadenas solo se lleva a cabo en las aserciones
     positivas, porque no tiene sentido para las negativas.
    </para>
    <para>
     Las aserciones cuentan para el m&aacute;ximo de 200 sub-patrones
     entre par&eacute;ntesis.
     </para>
    </refsect2>

    <refsect2 id="regexp.reference.onlyonce">
     <title>Sub-patrones de una sola aplicaci&oacute;n</title>
     <para>
      Tanto con las repeticiones m&aacute;ximas como en las
      m&iacute;nimas, el hecho de que falle de lo que se encuentra a
      continuaci&oacute;n causa por lo general que el item repetido
      sea re-evaluado para ver si un n&uacute;mero diferente de
      repeticiones permite que el resto del patr&oacute;n coincida. A
      veces es &uacute;til prevenir esto, ya sea cambiando la
      naturaleza de la coincidencia, o causando que falle antes de
      cuando ocurrir&iacute;a de otra forma, cuando el creador del
      patr&oacute;n sabe que no tiene sentido continuar.
    </para>
    <para>
     Considere, por ejemplo, el patr&oacute;n \d+foo cuando se aplica
     a la l&iacute;nea de asunto

       <literal>123456bar</literal>
    </para>
    <para>
     Despu&eacute;s de coincidir con los seis d&iacute;gitos y fallar
     al comparar con "foo", la acci&oacute;n normal del motor es
     intentar otra vez con s&oacute;lo cinco d&iacute;gitos para
     coincidir con \d+, y luego con cuatro, y as&iacute;
     sucesivamente, antes de fallar por completo. Los sub-patrones de
     una aplicaci&oacute;n ofrecen el medio de especificar que una vez
     una porci&oacute;n del patr&oacute;n ha coincidido, no debe ser
     re-evaluada en esta manera, as&iacute; que el motor se
     rendir&iacute;a inmediamente al fallar su intento por coincidir
     con "foo" la primera vez. La notaci&oacute;n es otra forma
     especial de par&eacute;ntesis, iniciado con (?&gt; como en este
     ejemplo:

       <literal>(?&gt;\d+)bar</literal>
    </para>
    <para>
     Este tipo de par&eacute;ntesis "bloquea" la parte del
     patr&oacute;n que contiene una vez ha coincidido, y se previene
     que un fallo m&aacute;s al interior del patr&oacute;n retroceda
     al punto original. El retroceso hacia elementos previos funciona
     normalmente, despu&eacute;s de todo.
    </para>
    <para>
     Una descripci&oacute;n alternativa es que un sub-patr&oacute;n de
     este tipo coincide con la cadena de carecteres que un
     patr&oacute;n independiente id&eacute;ntico coincidir&iacute;a,
     si estuviera anclado en el punto actual de la cadena de asunto.
    </para>
    <para>
     Los sub-patrones de una sola aplicaci&oacute;n no son
     sub-patrones de captura. Los casos simples como el ejemplo
     anterior pueden verse como una repetici&oacute;n m&aacute;xima
     que debe tragar todo lo que pueda. As&iacute; que, mientras que
     tanto \d+ como \d?  est&aacute;n preparados para ajustar el
     n&uacute;mero de d&iacute;gitos con los que coinciden para hacer
     que el resto del patr&oacute;n coincida, (?&gt;\d+) puede
     coincidir s&oacute;lo con un secuencia enteramente de
     d&iacute;gitos.
    </para>
    <para>
     Esta construcci&oacute;n puede, por supuesto, contener
     sub-patrones arbitrariamente complicados, y pueden estar
     anidados.
    </para>
    <para>
     Los sub-patrones de una aplicaci&oacute;n pueden ser usados en
     uni&oacute;n con aserciones hacia atr&aacute;s para especificar
     coincidencias eficientes al final de la cadena de asunto.
     Considere un patr&oacute;n sencillo como

       <literal>abcd$</literal>

     cuando se aplica a una cadena larga con la cual no coincide. Dado
     que la comparaci&oacute;n se realiza de izquierda a derecha, PCRE
     buscar&aacute; cada "a" en el asunto y luego ver&aacute; si lo
     que sigue coincide con el resto del patr&oacute;n. Si el
     patr&oacute;n se especifica como

       <literal>^.*abcd$</literal>

     entonces el segmento .* inicial coincide con la cadena entera
     primero, pero cuando esto falle (ya que no habr&aacute; una "a" a
     continuaci&oacute;n), retrocede para coincidir con todo menos el
     &uacute;ltimo caracter, luego con todo excepto los dos
     &uacute;ltimos y as&iacute; sucesivamente. Una vez m&aacute;s, la
     b&uacute;squeda de "a" cubre la cadena completa, de derecha a
     izquierda, as&iacute; que no hemos mejorado. Sin embargo, si el
     patr&oacute;n se escribiese como

       <literal>^(?&gt;.*)(?&lt;=abcd)</literal>

     entonces no hay retroceso para el elemento .*; s&oacute;lo puede
     coincidir con la cadena entera. La aserci&oacute;n hacia
     atr&aacute;s subsiguiente realiza una prueba &uacute;nica sobre
     los &uacute;ltimos cuatro caracteres. Si falla, la coincidencia
     falla inmediatamente. Para cadena largas, este enfoque representa
     una diferencia significativa en el tiempo de procesamiento.
    </para>
    <para>
     Cuando un patr&oacute;n contiene una repetici&oacute;n ilimitada
     al interior de un sub-patr&oacute;n que puede ser por s&iacute;
     mismo repetido un n&uacute;mero ilimitado de veces, el uso de un
     sub-patr&oacute;n de una aplicaci&oacute;n es la &uacute;nica
     forma de evitar algunas coincidencias fallidas que consumen
     ciertamente un tiempo muy largo. El patr&oacute;n

       <literal>(\D+|&lt;\d+>)*[!?]</literal>

     coincide con un n&uacute;mero ilimitado de subcadenas que
     consisten ya sea de no-d&iacute;gitos, o d&iacute;gitos entre
     &lt;>, seguidos por ! o ?. Cuando coincida, se ejecuta
     r&aacute;pido. Sin embargo, si se aplica sobre

       <literal>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</literal>

     toma un largo tiempo antes de reportar el fallo. Esto es porque
     la cadena puede ser dividida entre las dos repeticiones en un
     gran n&uacute;mero de formas, y todas deben ser probadas. (El
     ejemplo us&oacute; [!?] en lugar de un caracter sencillo al
     final, ya que tanto PCRE como Perl cuentan con una
     optimizaci&oacute;n que permite reportar fallos
     r&aacute;pidamente cuando un caracter sencillo es
     usado. Recuerdan el &uacute;ltimo caracter simple que es
     requerido para una coincidencia, y falla tempranamente si no
     est&aacute; presente en la cadena.) Si el patr&oacute;n es
     modificado a

       <literal>((?>\D+)|&lt;\d+>)*[!?]</literal>

     las secuencias de no-d&iacute;gitos no pueden ser interrumpidas,
     y la falla ocurre r&aacute;pidamente.
     </para>
    </refsect2>

    <refsect2 id="regexp.reference.conditional">
     <title>Sub-patrones condicionales</title>
     <para>
      Es posible hacer que el proceso de comparaci&oacute;n obedezca a
      un sub-patr&oacute;n condicionalmente o que elija entre dos
      sub-patrones alternativos, dependiendo del resultado de una
      aserci&oacute;n, o de si un sub-patr&oacute;n de captura previo
      coincidi&oacute; o no. Las dos formas posibles de sub-patrones
      condicionales son:
    </para>

    <literallayout>
       (?(condici&oacute;n)patr&oacute;n-si)
       (?(condici&oacute;n)patr&oacute;n-si|patr&oacute;n-no)
    </literallayout>
    <para>
     Si la condici&oacute;n es satisfecha, el patr&oacute;n-si es
     usado; de otra forma el patr&oacute;n-no es usado (si est&aacute;
     presente). Si hay m&aacute;s de dos alternativas en el
     sub-patr&oacute;n, se produce un error en tiempo de
     compilaci&oacute;n.
    </para>
    <para>
     Hay dos clases de condici&oacute;n. Si el texto entre los
     par&eacute;ntesis consiste de una secuencia de d&iacute;gitos,
     entonces la condici&oacute;n es satisfecha si el
     sub-patr&oacute;n de captura de ese n&uacute;mero ha sido
     coincidido previamente. Consideremos el siguiente patr&oacute;n,
     el cual contiene espacios en blanco sin significado para hacerlo
     m&aacute;s legible (asumiendo la opci&oacute;n <link
     linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>)
     y lo dividimos en tres partes para facilitar su discusi&oacute;n:

       <literal>( \( )?    [^()]+    (?(1) \) )</literal>
    </para>
    <para>
     La primera parte coincide con un par&eacute;ntesis de apertura
     opcional, y si ese caracter est&aacute; presente, lo define como
     la primera subcadena capturada. La segunda parte coincide con uno
     o m&aacute;s caracteres que no sean par&eacute;ntesis. La tercera
     parte es un sub-patr&oacute;n condicional que examina si el
     primer conjunto de par&eacute;ntesis coincidi&oacute; o no. Si lo
     hizo, es decir, si el asunto comenz&oacute; con un
     par&eacute;ntesis de apertura, la condici&oacute;n es cierta,
     as&iacute; que el patr&oacute;n-si es ejecutado y un
     par&eacute;ntesis de cierre es requerido. De otro modo, ya que no
     existe un patr&oacute;n-no, el sub-patr&oacute;n coincide con
     nada. En otras palabras, este patr&oacute;n coincide con una
     secuencia de no-par&eacute;ntesis, opcionalmente entre
     par&eacute;ntesis.
    </para>
    <para>
     Si la condici&oacute;n es la cadena <literal>(R)</literal>, es
     satisfecha si se ha hecho una llamada recursiva al patr&oacute;n
     o sub-part&oacute;n. En el "nivel superior", la condici&oacute;n
     es falsa.
    </para>
    <para>
     Si la condici&oacute;n no es una secuencia de d&iacute;gitos o
     (R), debe ser una aserci&oacute;n.  &Eacute;sta puede ser una
     aserci&oacute;n positiva o negativa hacia adelante o hacia
     atr&aacute;s. Considere este patr&oacute;n, el cual contiene una
     vez m&aacute;s espacios en blanco sin significado, y con las dos
     alternativas en la siguiente l&iacute;nea:
    </para>

    <literallayout>
       (?(?=[^a-z]*[a-z])
       \d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )
    </literallayout>
    <para>
     La condici&oacute;n es una aserci&oacute;n positiva hacia
     adelante que coincide con una secuencia opcional de no-letras
     seguida por una letra. En otras palabras, examina la presencia de
     al menos una letra en el asunto. Si se encuentra una letra, el
     asunto es comparado contra la primera alternativa; de otra forma
     lo es con la segunda. Este patr&oacute;n coincide con cadenas en
     una de las dos formas dd-aaa-dd o dd-dd-dd, en donde aaa son
     letras y dd son d&iacute;gitos.
     </para>
    </refsect2>

    <refsect2 id="regexp.reference.comments">
     <title>Comentarios</title>
     <para>
      La secuencia (?# marca el inicio de un comentario el cual
      contin&uacute;a hasta el siguiente par&eacute;ntesis de
      cierre. Los par&eacute;ntesis anidados no son permitidos. Los
      caracteres que forman un comentario no hacen parte del
      patr&oacute;n de coincidencia en ning&uacute;n caso.
    </para>
    <para>
     Si la opci&oacute;n <link
     linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>
     es definida, un caracter # no escapado por fuera de una clase de
     caracteres crea un comentario que contin&uacute;a hasta el
     pr&oacute;ximo caracter de nueva l&iacute;nea en el
     patr&oacute;n.
     </para>
    </refsect2>

    <refsect2 id="regexp.reference.recursive">
     <title>Patrones recursivos</title>
     <para>
      Considere el problema de coincidir con una cadena entre
      par&eacute;ntesis, permitiendo un n&uacute;mero ilimitado de
      par&eacute;ntesis anidados. Sin el uso de recursiones, lo mejor
      que puede lograrse es usar un patr&oacute;n que coincida hasta
      un n&uacute;mero l&iacute;mite de profundidad en el
      anidamiento. No es posible manejar una profundidad arbitraria de
      anidamiento. Perl 5.6 contiene una caracter&iacute;stica
      experimental que permite que las expresiones regulares sean
      recursivas (entre otras cosas). El elemento especial (?R)
      est&aacute; disponible para el caso espec&iacute;fico de
      recursi&oacute;n. Este patr&oacute;n de PCRE resuelve el
      problema de los par&eacute;ntesis (asumiendo que la
      opci&oacute;n <link
      linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>
      es definida, de modo que los espacios en blanco sean ignorados):

       <literal>\( ( (?>[^()]+) | (?R) )* \)</literal>
    </para>
    <para>
     Primero coincide con un par&eacute;ntesis de apertura. Luego
     coincide con cualquier n&uacute;mero de subcadenas, que pueden
     ser o bien una secuencia de no-par&eacute;ntesis, o una
     coincidencia recursiva del patr&oacute;n mismo (es decir, una
     subcadena correctamente envuelta por
     par&eacute;ntesis). Finalmente hay un par&eacute;ntesis de
     cierre.
    </para>
    <para>
     Este patr&oacute;n de ejemplo en particular contiene repeticiones
     anidadas ilimitadas, as&iacute; que el uso de un
     sub-patr&oacute;n de una aplicaci&oacute;n para la
     comparaci&oacute;n de cadenas de no-par&eacute;ntesis es
     importante cuando se aplica el patr&oacute;n a cadenas que no
     coinciden. Por ejemplo, cuando se aplica a

       <literal>(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</literal>

     descubre una "no coincidencia" r&aacute;pidamente. Sin embargo,
     si un sub-patr&oacute;n de una aplicaci&oacute;n no es usado, la
     comparaci&oacute;n es ejecutada por un tiempo muy largo realmente
     ya que hay muchas formas diferentes en las que las repeticiones +
     y * pueden moldear el asunto, y todas deben ser probadas antes
     que pueda reportarse el fallo.
    </para>
    <para>
     Los valores establecidos para cualquier sub-patr&oacute;n de
     captura son aquellos del nivel de recursi&oacute;n m&aacute;s
     externo en el que est&eacute; definido el valor del
     sub-patr&oacute;n. Si el patr&oacute;n anterior fuera comparado
     contra

       <literal>(ab(cd)ef)</literal>

     el valor para los par&eacute;ntesis de captura es "ef", el cual
     es el &uacute;ltimo valor tomado del nivel superior. Si se
     agregan par&eacute;ntesis adicionales, produciendo

       <literal>\( ( ( (?>[^()]+) | (?R) )* ) \)</literal>

     entonces la cadena que capturan es "ab(cd)ef", los contenidos de
     los par&eacute;ntesis del nivel superior. Si hay m&aacute;s de 15
     par&eacute;ntesis de captura en un patr&oacute;n, PCRE tiene que
     obtener memoria extra para almacenar datos durante una
     recursi&oacute;n, cosa que logra usando pcre_malloc, y la libera
     m&aacute;s adelante mediante pcre_free. Si no se puede obtener
     memoria, guarda datos &uacute;nicamente para los primeros 15
     par&eacute;ntesis de captura, dado que no hay forma de producir
     un error de memoria-insuficiente desde el interior de una
     recursi&oacute;n.
     </para>

     <para>
      A partir de PHP 4.3.3, <literal>(?1)</literal>,
      <literal>(?2)</literal> y dem&aacute;s pueden usarse para
      sub-patrones recursivos tambi&eacute;n. Asimismo es posible usar
      sub-patrones con nombre:
      <literal>(?P>foo)</literal>.
     </para>
     <para>
      Si la sintaxis para una referencia de sub-patr&oacute;n
      recursivo (ya sea por n&uacute;mero o por nombre) es usada por
      fuera de los par&eacute;ntesis a los que hace referencia, opera
      como una subrutina en un lenguaje de programaci&oacute;n. Un
      ejemplo anterior anotaba que el patr&oacute;n
      <literal>(sens|respons)e and \1ibility</literal> coincide con
      "sense and sensibility" y "response and responsibility", pero no
      con "sense and responsibility". Si en su lugar se usa el
    patr&oacute;n <literal>(sens|respons)e and
      (?1)ibility</literal>, entonces efectivamente coincide con
      "sense and responsibility" al igual que con las otras dos
      cadenas. Sin embargo, tales referencias deben seguir al
      sub-patr&oacute;n al que hacer referencia.
     </para>

    </refsect2>

    <refsect2 id="regexp.reference.performances">
     <title>Rendimientos</title>
     <para>
      Ciertos elementos que pueden aparecer entre los patrones son
      m&aacute;s eficientes que otros. Es m&aacute;s eficiente usar
      una clase de caracteres como [aeiou] que un conjunto de
      alternativas tal como (a|e|i|o|u). En general, la
      contrucci&oacute;n m&aacute;s simple que ofrezca el
      comportamiento requerido es usualmente la m&aacute;s
      eficiente. El libro de Jeffrey Friedl contiene una cantidad
      considerable de comentarios sobre la optimizaci&oacute;n de
      expresiones regulares para un rendimiento eficiente.
    </para>
    <para>
     Cuando un patr&oacute;n empieza con .* y la opci&oacute;n <link
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>
     est&aacute; definida, el patr&oacute;n es anclado
     impl&iacute;citamente por PCRE, ya que s&oacute;lo puede
     coincidir al inicio de la cadena de asunto. Sin embargo, si <link
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> no
     es definido, PCRE no puede hacer esta optimizaci&oacute;n, ya que
     el meta-caracter . no coincide entonces con una nueva
     l&iacute;nea y si la cadena de asunto contiene nuevas
     l&iacute;neas, el patr&oacute;n podr&iacute;a coincidir desde el
     caracter inmediatamente siguiente a una de ellas en vez del
     inicio absoluto. Por ejemplo, el patr&oacute;n

       <literal>(.*) second</literal>

     coincide con el asunto "first\nand second" (en donde \n
     representa un caracter de nueva l&iacute;nea) con la primera
     subcadena capturada que sea "and". Para conseguirlo, PCRE tiene
     que reintentar la coincidencia comenzando en cada nueva
     l&iacute;nea del asunto.
    </para>
    <para>
     Si est&aacute; usando un patr&oacute;n as&iacute; con cadenas de
     asunto que no contienen nuevas l&iacute;neas, el mejor
     rendimiento se obtiene definiendo <link
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> o
     iniciando el patr&oacute;n con ^.* para indicar un anclamiento
     expl&iacute;cito. Esto le ahorra a PCRE tener que examinar toda
     la cadena de entrada buscando nuevas l&iacute;neas para empezar
     de nuevo.
    </para>
    <para>
     Tenga cuidado con los patrones que contienen repeticiones
     anidadas ilimitadas. &Eacute;stos pueden tomar un tiempo de
     ejecuci&oacute;n muy largo cuando se aplican sobre una cadena que
     no coincide. Considere el fragmento de patr&oacute;n

       <literal>(a+)*</literal>
    </para>
    <para>
     &Eacute;ste puede coincidir con "aaaa" en 33 maneras diferentes,
     y este n&uacute;mero crece muy r&aacute;pidamente a medida que la
     cadena se hace m&aacute;s larga. (La repetici&oacute;n * puede
     coincidir 0, 1, 2, 3, o 4 veces, y por cada uno de esos casos
     diferentes a 0, las repeticiones + pueden coincidir un
     n&uacute;mero diferente de veces.)  Cuando el resto del
     patr&oacute;n es de tal forma que la coincidencia completa
     est&aacute; destinada a fallar, PCRE en principio intenta cada
     variaci&oacute;n posible, y esto puede tomar un tiempo
     extremadamente largo.
    </para>
    <para>
     Una optimizaci&oacute;n atrapa algunos de los casos m&aacute;s
     simples tales como

       <literal>(a+)*b</literal>

     en donde un caracter literal se encuentra a
     continuaci&oacute;n. Antes de embarcarse en el procedimiento
     est&aacute;ndar de comparaci&oacute;n, PCRE chequea que haya una
     letra "b" m&aacute;s adelante en la cadena de asunto, y si no lo
     hay, falla la coincidencia inmediatamente. Sin embargo, cuando no
     hay un literal a continuaci&oacute;n, esta optimizaci&oacute;n no
     puede ser usada. Puede apreciar la diferencia al comparar el
     comportamiento de

       <literal>(a+)*\d</literal>

     con el patr&oacute;n anterior. El primero produce un fallo casi
     instant&aacute;neamente cuando se aplica a una l&iacute;nea
     completa de caracteres "a", mientras que el segundo toma un
     tiempo apreciable con cadenas m&aacute;s largas de
     aproximadamente 20 caracteres.
     </para>
    </refsect2>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
