<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 290376 $ -->
<!-- splitted from ./en/functions/pcre.xml, last change in rev 1.2 -->
<!-- EN-Revision: 290376 Maintainer: seros Status: partial -->
<chapter xml:id="reference.pcre.pattern.syntax" xmlns="http://docbook.org/ns/docbook">
 <title>Sintaxis de Patrón</title>
 <titleabbrev>Sintaxis de expresiones regulares de PCRE</titleabbrev>

    <section xml:id="regexp.introduction">
     <title>Introducción</title>
     <para>
      La sintaxis y semántica de las expresiones regulares
      soportadas por PCRE están descritas más adelante. Las expresiones regulares
      también están descritas en la documentación de Perl y en otros
      libros, algunos de los cuales tienen abundantes ejemplos. El libro de Jeffrey
      Friedl "Mastering  Regular  Expressions", publicado por
      O'Reilly  (ISBN 1-56592-257-3), las cubre en gran detalle.
      La descripción aquí dada está prevista como documentación de referencia.
     </para>
     <para>
      Una expresión regular es un patrón que se compara con una
      cadena objetivo de izquierda a derecha. La mayoría de los caracteres se
      representan a sí mismos en un patrón, y se comparan con el carácter
      correspondiente en el sujeto. Como ejemplo trivial, el patrón
      <literal>The quick brown fox</literal>
      coincide con una porción de una cadena objetivo que es idéntica a dicho patrón.  
     </para>
    </section>
    <section xml:id="regexp.reference.meta">
     <title>Meta-caracteres</title>
     <para>     
      El poder de las expresiones regulares viene por la
      capacidad de incluir alternativas y repeticiones en el
      patrón. Éstos están codificadoes en el patrón por el uso de
      <emphasis>meta-caracteres</emphasis>, los cuales no se representan a sí mismos,
      sino que son interpretados de una forma especial.
     </para>
     <para>
      Hay dos conjuntos diferentes de meta-caracteres: aquéllos que
      son reconocidos en cualquier lugar de un patrón excepto dentro de
      los corchetes, y aquéllos que son reconocidos dentro de los corchetes.
      Fuera de los corchetes, los meta-caracteres son los siguientes:
      <variablelist>
       <varlistentry>
        <term><emphasis>\</emphasis></term>
        <listitem><simpara>carácter de escape general con varios usos</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>^</emphasis></term>
        <listitem><simpara>declaración de inicio de sujeto (o línea, en modo multi-línea)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>$</emphasis></term>
        <listitem><simpara>declaración de fin de sujeto (o línea, en modo multi-línea)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>.</emphasis></term>
        <listitem><simpara>coincide con cualquier carácter excepto con el de nueva línea (por defecto)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>[</emphasis></term>
        <listitem><simpara>inicio de la definición de la clase carácter</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>]</emphasis></term>
        <listitem><simpara>fin de la definición de la clase carácter</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>|</emphasis></term>
        <listitem><simpara>inicio de rama alternativa</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>(</emphasis></term>
        <listitem><simpara>inicio de sub-patrón</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>)</emphasis></term>
        <listitem><simpara>fin de sub-patrón</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>?</emphasis></term>
        <listitem><simpara>extiende el significado de (, también cuantificador 0 ó 1,
        también cuantificador minimizador</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>*</emphasis></term>
        <listitem><simpara>cuantificador 0 o más</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>+</emphasis></term>
        <listitem><simpara>cuantificador 1 o más</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>{</emphasis></term>
        <listitem><simpara>inicio de cuantificador mín/máx</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>}</emphasis></term>
        <listitem><simpara>fin de cuantificador mín/máx</simpara></listitem>
       </varlistentry>
      </variablelist>

      La parte de un patrón que está entre corchetes se llama una
      "clase carácter". En una clase carácter los únicos meta-caracteres son:

      <variablelist>
       <varlistentry>
        <term><emphasis>\</emphasis></term>
        <listitem><simpara>carácter de escape general</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>^</emphasis></term>
        <listitem><simpara>niega la clase, pero sólo si se trata del primer carácter</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>-</emphasis></term>
        <listitem><simpara>define el rango de caracteres</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>]</emphasis></term>
        <listitem><simpara>finaliza la clase carácter</simpara></listitem>
       </varlistentry>
      </variablelist>

      Las siguientes secciones describen el uso de cada
      meta-carácter.
     </para>
    </section>

    <section xml:id="regexp.reference.backslash">
     <title>Barra invertida</title>
     <para>
      El carácter barra invertida tiene varios usos. El primero es que si está
      seguido de un carácter no alfanumérico, toma cualquier
      significado especial que el carácter pueda tener. Este uso de
      la barra invertida como carácter de escape se aplica tanto dentro como fuera de
      las clases carácter.
     </para>
     <para>
      Por ejemplo, si quiere coincidir un carácter "*", escriba
      "\*" en el patrón. Esto se aplica aunque el
      siguiente carácter pudiera ser interpretado como un
      meta-carácter, por lo que es mejor asegurarse de preceder un carácter no alfanumérico
      con "\" para especificar que éste se representa a sí mismo. En
      particular, si quiere coincidir una barra invertida, escriba "\\".
     </para>
     <note>
      <para>
       Las <link linkend="language.types.string.syntax">cadenas</link> PHP entre comillas
       simples y dobles tienen un significado especial para la barra invertida.
       Así, si \ ha de ser comparado con una expresión
       regular \\, entonces se debe usar "\\\\" o '\\\\' en código PHP.
      </para>
     </note>
     <para>
      Si un patrón es compilado con la opción
      <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>,
      los espacios en blanco en el patrón (distinto de una clase carácter) y los
      caracteres entre un "#" fuera de una clase carácter y el siguiente carácter de nueva
      línea se ignoran. Una barra invertida de escape se puede usar para incluir un
      carácter espacio en blanco o "#" como parte del patrón.
     </para>
     <para>
      Un segundo uso de la barra invertida proporciona una manera de codificar
      caracteres no imprimibles en patrones de una forma visible. No hay
      restricciones en la aparición de los caracteres no imprimibles,
      excepto para el cero binario el cual finaliza en patrón,
      pero cuando un patrón está siendo preparado para edición de texto, normalmente
      es más fácil usar una de las siguientes secuencias de escape
      en vez del carácter binario que representa:
     </para>
     <para>
      <variablelist>
       <varlistentry>
        <term><emphasis>\a</emphasis></term>
        <listitem><simpara>alarma, es decir, el carácter BEL (07 hex)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\cx</emphasis></term>
        <listitem><simpara>"control-x", donde x es cualquier carácter</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\e</emphasis></term>
        <listitem><simpara>escape (1B hex)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\f</emphasis></term>
        <listitem><simpara>salto de página (0C hex)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\n</emphasis></term>
        <listitem><simpara>nueva línea (0A hex)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\r</emphasis></term>
        <listitem><simpara>retorno de carro (0D hex)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\t</emphasis></term>
        <listitem><simpara>tabulador (09 hex)</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\xhh</emphasis></term>
        <listitem><simpara>carácter con el código hexadecimal hh</simpara></listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis>\ddd</emphasis></term>
        <listitem><simpara>carácter con el código octal ddd, o retro-referencia</simpara></listitem>
       </varlistentry>
      </variablelist>
     </para>
    <para>
     El efecto exacto de "<literal>\cx</literal>" es como sigue: 
     si "<literal>x</literal>" es una letra minúscula, ésta se convierte
     a mayúscula. Después se invierte el bit 6 del carácter (40 hex). 
     Así, "<literal>\cz</literal>" se convierte en 1A hex, pero
     "<literal>\c{</literal>" se convierte en 3B hex, mientras que "<literal>\c;</literal>"
     se conviente en 7B hex.
    </para>
    <para>
     Después de "<literal>\x</literal>", se leen hasta dos dígitos
     hexadecimales (las letras pueden ser tanto mayúsculas como minúsculas).
     En <emphasis>modo UTF-8</emphasis>, "<literal>\x{...}</literal>" se
     permite, donde el contenido entre las llaves es una cadena de dígitos
     hexadecimales. Esto se interpreta como un carácter UTF-8 cuyo número de código es
     el dado por el número hexadecimal. La secuencia de escape hexadecimal original,
     <literal>\xhh</literal>, conincide con un carácter UTF-8 de dos bytes si el valor
     es mayor que 127.
    </para>
    <para>
     Después de "<literal>\0</literal>", se leen hasta dos dígitos octales más.
     En cualquier caso, si hay menos de dos dígitos, sólo se usan
     aquéllos que están presentes. Así, la secuencia "<literal>\0\x\07</literal>" 
     especifica dos ceros binarios seguidos de un carácter BEL. Asegúrese de
     proporcionar dos dígitos después del cero inicial si el carácter
     que sigue es también un dígito octal.
    </para>
    <para>
     El manejo de una barra invertida seguida de un dígito distinto de 0
     es complicado. Fuera de una clase carácter, PCRE lee este dígito,
     así como cualesquiera dígitos siguientes, como un número decimal. Si el número
     es menor que 10, o si ha habido al menos tantas
     capturas previas anteriores en la expresión, la
     secuencia entera es tomada como una <emphasis>retro-referencia</emphasis>. Una descripción
     de cómo funciona esto se da más adelante, seguido de una discusión
     sobre sub-patrones entre paréntesis.
    </para>
    <para>
     Dentro de una clase carácter, o si el número decimal es
     mayor que 9 y no han habido tantos sub-patrones de captura,
     PCRE relee hasta tres dígitos octales siguientes a la
     barra invertida, y genera un sólo byte de los
     8 bits menos significativos del valor. Cualesquiera dígitos subsiguientes
     se representan a sí mismos. Por ejemplo:
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\040</emphasis></term>
       <listitem><simpara>es otra manera de escribir un espacio</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\40</emphasis></term>
       <listitem>
        <simpara>
         es lo mismo, siempre que haya menos de 40
         sub-patrones de captura previos
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\7</emphasis></term>
       <listitem><simpara>es siempre una retro-referencia</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\11</emphasis></term>
       <listitem>
        <simpara>
         puede ser una retro-refenrencia, u otra manera de
         escribir una tabulación
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\011</emphasis></term>
       <listitem><simpara>es siempre una tabulación</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\0113</emphasis></term>
       <listitem><simpara>es una tabulación seguida del carácter "3"</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\113</emphasis></term>
       <listitem>
        <simpara>
         es el carácter con el código octal 113 (ya que no
         puede haber más de 99 retro-referencias)
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\377</emphasis></term>
       <listitem><simpara>es un byte consistente en bits 1 enteramente</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\81</emphasis></term>
       <listitem>
        <simpara>
         es tanto una retro-referencia como un cero binario
         seguido de los caracteres "8" y "1"
        </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Observe que los valores octales 100 y mayores no deben de ser
     precedidos por un cero inicial, ya que nunca se leen más de tres
     dígitos octales.
    </para>
    <para>
     Todas las secuencias que definen un valor de byte único se pueden
     usar tanto dentro como fuera de las clases carácter. Además,
     dentro de una clase carácter, la secuencia "<literal>\b</literal>"
     se interpreta como el carácter retroceso (08 hex). Fuera de una clase
     carácter tiene diferentes significados (véase más abajo).
    </para>
    <para>
     El tercer uso de la barra invertida es parar especificar tipos
     de caracteres genéricos:
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\d</emphasis></term>
       <listitem><simpara>cualquier dígito decimal</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\D</emphasis></term>
       <listitem><simpara>cualquier carácter que no es un dígito decimal</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\h</emphasis></term>
       <listitem><simpara>cualquier carácter espacio en blanco horizontal
       (desde PHP 5.2.4)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\H</emphasis></term>
       <listitem><simpara>cualquier carácter que no es un carácter espacio en blanco horizontal
       (desde PHP 5.2.4)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\s</emphasis></term>
       <listitem><simpara>cualquier carácter espacio en blanco</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\S</emphasis></term>
       <listitem><simpara>cualquier carácter que no es un carácter espacio en blanco</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\v</emphasis></term>
       <listitem><simpara>cualquier carácter espacio en blanco vertical
       (desde PHP 5.2.4)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\V</emphasis></term>
       <listitem><simpara>cualquier carácter que no es un carácter espacio en blanco vertical
       (desde PHP 5.2.4)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\w</emphasis></term>
       <listitem><simpara>cualquier carácter "palabra"</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\W</emphasis></term>
       <listitem><simpara>cualquier carácter que no es "palabra"</simpara></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Cada par de sencuencias de escape divide el conjunto completo de
     caracteres en dos conjuntos separados. Cualquier carácter dado
     concide con uno, y sólo uno, de cada par.
    </para>
    <para>
     Un carácter "palabra" es cualquier letra o dígito o el carácter
     subrayado, es decir, cualquier carácter que pueda ser parte de una
     "<emphasis>palabra</emphasis>" Perl. La definición de letras y dígitos está
     controlada por las tablas de caracteres de PCRE, y pueden variar si 
     tiene lugar la comparación de localizaciones específicas. Por ejemplo,
     en la localización "fr" (Francés), algunos códigos de caracteres
     mayores que 128 se usan para letras acentuadas,
     y éstos se comparan por <literal>\w</literal>.
    </para>
    <para>
     Estas secuencias de tipo de caracteres puede aparecer tanto dentro como
     fuera de las clases carácter. Cada una coincide con un carácter del
     tipo apropiado. Si el punto de coincidencia actual está
     al final de la cadena objetivo, todas ellas fallarán, ya que no
     hay caracteres a comparar.
    </para>
    <para>
     El cuarto uso de la barra invertida es para ciertas declaraciones
     simples. Una declaración especifica una condición que se debe encontrar
     en un punto particular de una comparación, sin consumir ningún
     carácter de la cadena objetivo. El uso de sub-patrones
     para declaraciones más complicadas se describe después. Las
     declaraciones de la barra invertida son
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\b</emphasis></term>
       <listitem><simpara>límite de palabra</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\B</emphasis></term>
       <listitem><simpara>distinto a límite de palabra</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\A</emphasis></term>
       <listitem><simpara>comienzo del sujeto
       (independientemente del modo multi-linea)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\Z</emphasis></term>
       <listitem>
        <simpara>
         fin del sujeto o nueva línea al final (independientemente del
         modo multi-linea)
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\z</emphasis></term>
       <listitem><simpara>final del sujeto (independientemente del modo multi-línea)</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\G</emphasis></term>
       <listitem><simpara>primera posición de coincidencia del sujeto</simpara></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Estas declaraciones pueden no aparecer en clases carácter (pero
     observe que "<literal>\b</literal>" tiene un significado diferente, a saber, el carácter
     retroceso, dentro de una clase carácter).
    </para>
    <para>
     Un límite de palabra es una posición en la cadena objetivo donde
     es carácter actual y el carácter previo no coinciden con
     <literal>\w</literal> o <literal>\W</literal> (es decir, uno coincide con
     <literal>\w</literal> y el otro coincice con
     <literal>\W</literal>), o el inicio o final de la cadena si el primero o último
     carácter coincide con <literal>\w</literal>, respectivamente.
    </para>
    <para>
     Las declaraciones <literal>\A</literal>, <literal>\Z</literal>, y
     <literal>\z</literal> difieren de los tradicionales
     circumflejo y dólar (descritos después) de modo que siempre
     coinciden con el inicio y final absolutos de la cadena objetivo,
     sin importar las opciones que se apliquen. No le afectan las opciones
     <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link> o
     <link linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>.
     La diferencia entre <literal>\Z</literal> y
     <literal>\z</literal> es que <literal>\Z</literal> coincide antes de una
     nueva línea que es el último carácter de la cadena, además de al final de
     la cadena, mientras que <literal>\z</literal> coincide sólo con el final.
     </para>
     <para>
      La declaración <literal>\G</literal> es verdadera sólo cuando la posición
      de coincidencia actual está al principio del punto de coincidencia, tal como se especifica
      en el argumento <parameter>índice</parameter> de
      <function>preg_match</function>. Difiere de <literal>\A</literal>
      cuando el valor de <parameter>índice</parameter> no es cero.
      Está disponible a partir de PHP 4.3.3.
     </para>
     
     <para>
      <literal>\Q</literal> y <literal>\E</literal> se pueden usar para ignorar
      meta-caracteres de expresiones regulares a partir de PHP 4.3.3. Por ejemplo:
      <literal>\w+\Q.$.\E$</literal> coincidirá con uno o más caracteres palabra,
      seguidos por los literales <literal>.$.</literal> y anclados al final de
      la cadena.
     </para>
     
     <para>
      <literal>\K</literal> se puede usar para reiniciar el comienzo de comparación a partir
      de PHP 5.2.4. Por ejemplo, el patrón <literal>foo\Kbar</literal> coincide con
      "foobar", pero informa de que ha coincidido con "bar". El uso de
      <literal>\K</literal> no interfiere con el parámetro de las cadenas
      capturadas. Por ejemplo, cuando el patrón <literal>(foo)\Kbar</literal>
      coincide con "foobar", la primera sub-cadena está establecida aún a "foo".
     </para>
     
    </section>
 
    <section xml:id="regexp.reference.unicode">
     <title>Propiedades de los caracteres Unicode</title>
     <para>
      A partir de PHP 4.4.0 y 5.1.0, están disponibles
      tres secuencias de escape adicionales para comparar tipos de caracteres genéricos
      cuando el <emphasis>modo UTF-8</emphasis> está seleccionado. Son:
     </para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\p{xx}</emphasis></term>
       <listitem><simpara>un carácter con la propiedad xx</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\P{xx}</emphasis></term>
       <listitem><simpara>un carácter sin la propiedad xx</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\X</emphasis></term>
       <listitem><simpara>una secuencia Unicode extendida</simpara></listitem>
      </varlistentry>
     </variablelist>
     <para>
      Los nombres de las propiedades representadas arriba por <literal>xx</literal> están limitadas
      a las propiedades de la categoría general de Unicode. Cada carácter tiene exactamente una
      propiedad, especificada por una abreviatura de dos letras. Por compatibilidad con
      Perl, la negación se puede especificar incluyendo un acento circunflejo entre la
      llave de apertura y el nombre de la propiedad. Por ejemplo, <literal>\p{^Lu}</literal> 
      es lo mismo que <literal>\P{Lu}</literal>.
     </para>
     <para>
      Si sólo se especifica una letra con <literal>\p</literal> o 
      <literal>\P</literal>, se incluyen todas las propiedades que comienzan con esa
      letra. En este caso, en la ausencia de negación, las llaves en la
      secuencia de escape son opcionales; estos dos ejemplos tienen el mismo efecto:
     </para>
     <literallayout>
      \p{L}
      \pL
     </literallayout>
     <table>
      <title>Códigos de propiedades soportados</title>
      <tgroup cols="2">
       <tbody>
        <row><entry><literal>C</literal></entry><entry>Otro</entry></row>
        <row><entry><literal>Cc</literal></entry><entry>Control</entry></row>
        <row><entry><literal>Cf</literal></entry><entry>Formato</entry></row>
        <row><entry><literal>Cn</literal></entry><entry>Sin asignar</entry></row>
        <row><entry><literal>Co</literal></entry><entry>Uso privado</entry></row>
        <row rowsep="1"><entry><literal>Cs</literal></entry><entry>Sustituto</entry></row>
        <row><entry><literal>L</literal></entry><entry>Letra</entry></row>
        <row><entry><literal>Ll</literal></entry><entry>Letra minúscula</entry></row>
        <row><entry><literal>Lm</literal></entry><entry>Letra modificadora</entry></row>
        <row><entry><literal>Lo</literal></entry><entry>Otra letra</entry></row>
        <row><entry><literal>Lt</literal></entry><entry>Letra de título</entry></row>
        <row rowsep="1"><entry><literal>Lu</literal></entry><entry>Letra mayúscula</entry></row>
        <row><entry><literal>M</literal></entry><entry>Marca</entry></row>
        <row><entry><literal>Mc</literal></entry><entry>Marca de espacio</entry></row>
        <row><entry><literal>Me</literal></entry><entry>Marca de cierre</entry></row>
        <row rowsep="1"><entry><literal>Mn</literal></entry><entry>Marca de no-espacio</entry></row>
        <row><entry><literal>N</literal></entry><entry>Número</entry></row>
        <row><entry><literal>Nd</literal></entry><entry>Número decimal</entry></row>
        <row><entry><literal>Nl</literal></entry><entry>Número letra</entry></row>
        <row rowsep="1"><entry><literal>No</literal></entry><entry>Otro número</entry></row>
        <row><entry><literal>P</literal></entry><entry>Puntuación</entry></row>
        <row><entry><literal>Pc</literal></entry><entry>Puntuación de conexión</entry></row>
        <row><entry><literal>Pd</literal></entry><entry>Puntuación guión</entry></row>
        <row><entry><literal>Pe</literal></entry><entry>Puntuación de cierre</entry></row>
        <row><entry><literal>Pf</literal></entry><entry>Puntuación final</entry></row>
        <row><entry><literal>Pi</literal></entry><entry>Puntuación inicial</entry></row>
        <row><entry><literal>Po</literal></entry><entry>Otra puntuación</entry></row>
        <row rowsep="1"><entry><literal>Ps</literal></entry><entry>Puntuación de apertura</entry></row>
        <row><entry><literal>S</literal></entry><entry>Símbolo</entry></row>
        <row><entry><literal>Sc</literal></entry><entry>Símbolo de moneda</entry></row>
        <row><entry><literal>Sk</literal></entry><entry>Símbolo modificador</entry></row>
        <row><entry><literal>Sm</literal></entry><entry>Símbolo matemático</entry></row>
        <row rowsep="1"><entry><literal>So</literal></entry><entry>Otro símbolo</entry></row>
        <row><entry><literal>Z</literal></entry><entry>Separador</entry></row>
        <row><entry><literal>Zl</literal></entry><entry>Separador de línea</entry></row>
        <row><entry><literal>Zp</literal></entry><entry>Separador de párrafo</entry></row>
        <row><entry><literal>Zs</literal></entry><entry>Separador de espacio</entry></row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Las propiedades extendidas tales como "Greek" o "InMusicalSymbols" no están
      soportadas por PCRE.
     </para>
     <para>
      El especificar coincidicencias insensibles a mayúsculas-minúsculas no afecta a estas secuencias
      de escape. Por ejemplo, <literal>\p{Lu}</literal> siempre coincide con letras mayúsculas.
     </para>
     <para>
      El escape <literal>\X</literal> coincide con cualquier número de caracteres Unicode
      que forman un secuencia Unicode extendida. <literal>\X</literal> es equivalente
      a <literal>(?>\PM\pM*)</literal>.
     </para>
     <para>
      Es decir, coincide con un carácter sin la propiedad "marca", seguido
      por cero o más caracteres sin la propiedad "marca", y trata la
      secuencia como un grupo atómico (véase más adelante). Los caracteres con la propiedad
      "marca" son típicamente acentos que afectan al carácter precedente.
     </para>
     <para>
      La comparación de caracteres por propiedades Unicode no es rápida, porque PCRE ha
      de buscar una estructura que contiene datos por más de quince mil
      caracteres. Es por esto por lo que las secuencias de escape tradicionales tales como
      <literal>\d</literal> y <literal>\w</literal> no usan propiedades Unicode
      en PCRE.
     </para>
    </section>

    <section xml:id="regexp.reference.circudollar">
     <title>Circunflejo y dólar</title>
     <para>
      Fuera de una clase carácter, en el modo de comparación por defecto, el
      carácter circunflejo (<literal>^</literal>) es una declaración que
      es verdadera sólo si el punto de coincidencia actual está en el inicio de
      de la cadena objetivo. Dentro de una clase carácter, circunflejo (<literal>^</literal>)
      tiene un significado totalmente diferente (véase más adelante).
     </para>
     <para>
      Circunflejo (<literal>^</literal>) no necesita ser el primer carácter
      del patrón si están implicadas un número de alternativas, pero
      debería ser la primera cosa en cada alternativa en la que aparece
      si el patrón es comparado siempre con esa rama. Si todas las posibles
      alternativas comienzan con un circunflejo (<literal>^</literal>), es decir,
      si el patrón es obligado a coincidir sólo con el comienzo de la cadena objetivo,
      se dice que el patrón está "anclado". (También hay otras
      contrucciones que pueden causar que un patrón esté anclado.)
     </para>
     <para>
      Un carácter dólar (<literal>$</literal>) es una declaración la cual es
      &true; sólo si el punto actual de coincidencia está al final de la cadena
      objetivo, o inmediatamente antes de un carácter de nueva línea que es el último
      carácter en la cadena (por defecto). Dólar (<literal>$</literal>)
      no necesita ser el último carácter del patrón si están implicadas un número de
      alternativas, pero debería ser el último elemento en cualquier rama
      en el que aparezca. Dólar no tiene un significado especial en una
      clase carácter.
     </para>
     <para>
      El significado de dólar se puede cambiar, de modo que sólo coincida
      con el final absoluto de la cadena, estableciendo la opción
      <link linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
      en tiempo de compilación o comparación. Esto no afecta a la declaración \Z.
     </para>
     <para>
      El significado de los caracteres circunflejo y dólar se
      cambia si la opción
      <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
      es establecida. Cuando este es el caso, conciden inmediatemente después e
      inmediatamente antes que un carácter "\n" interno, respectivamente, además
      de coincidir al principio y final de la cadena objetivo. Por ejemplo, el
      patrón /^abc$/ coincide con la cadena objetivo "def\nabc" en el modo multi-línea,
      y no en otros. Consecuentemente, los patrones que están anclados en el modo
      de una sóla línea, a causa del inicio de todas las ramas con "^", no están anclados en
      el modo multi-línea. La opción
      <link linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
      es ignorada si
      <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link> está
      establecido.
     </para>
     <para>
      Observe que las secuencias \A, \Z, y \z se pueden usar para coincidir
      el inicio y final de la cadena objetivo en ambos modos, y si todas
      las ramas de un patrón comienzan con \A, el patrón siempre es anclado,
      sin tener en cuenta si <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>  
      este establecido o no.
     </para>
    </section>

    <section xml:id="regexp.reference.dot">
     <title>Punto</title>
     <para>
     Fuera de una clase carácter, un punto en el patrón coincide con
     un carácter en el sujeto, incluyendo un carácter no imprimible,
     pero no (por defecto) una nueva línea. Si la opción
     <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> 
     está establecida, entonces los puntos coinciden con nuevas líneas tambíen. El
     manejo del punto es totalmente independiente del manejo de
     circunflejo y dólar, la única relación existente es que ambos
     implican caracteres de nueva línea. El punto no tiene un significado especial
     en una clase carácter.
     </para>
     <para>
      <emphasis>\C</emphasis> se puede usar para comparar un único byte. Tiene sentido
      en <emphasis>modo UTF-8</emphasis> donde el punto coincide con el carácter
      entero, el cual puede consistir en múltiples bytes.
     </para>
    </section>

    <section xml:id="regexp.reference.squarebrackets">
     <title>Corchetes</title>
     <para>
      Un corchete de apertura introduce una clase carácter,
      finalizada por un corchete de cierre. Un corchete de
      cierre por sí solo no es especial. Si se requiere
      un corchete de cierre como un miembro de la clase, éste debería ser
      el primer carácter de datos en la clase (después de un circunflejo
      inicial, si está presente) o escapado con una barra invertida.
     </para>
     <para>
      Una clase carácter coincide con un sólo carácter en el sujeto;
      el carácter debe estar en el conjunto de caracteres definido por
      la clase, a menos que el primer carácter en la clase sea un
      circunflejo, en cuyo caso el carácter sujeto no debe de estar en
      el conjunto definido por la clase. Si un circunflejo es requerido
      en realidad como un miembro de la clase, asegúrese de que no sea el
      primer carácter, o escápelo con una barra invertida.
     </para>
     <para>
      Por ejemplo, la clase carácter [aeiou] coincide con cualquier vocal
      minúscula, mientras que [^aeiou] con cualquier carácter que no sea
      una vocal minúscula. Observe que un circunflejo es sólo una
      notación conveniente para especificar los caracteres que están en
      la clase enumerando los que no están. Si no es una
      declaración: aún consume un carácter de la cadena objetivo,
      y falla si el punto actual está al final de la
      cadena.
     </para>
     <para>
      Cuando está establecida la coincidencia insensible a mayúsculas-minúculas, cualquier
      letra en una clase representa tanto su versión en mayúsculas como
      minusculas, así, por ejemplo, una clase insensible [aeiou] coincidice con "A"
      así como con "a", y una clase insensible [^aeiou] no coincide con
      "A", mientras que una versión sensible lo haría.
     </para>
     <para>
      El carácter nueva línea nunca es tratado de manera especial en
      las clases carácter, sin importar el establecimiento de la opción <link
       linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> 
      o <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>.
      Una clase como [^a] siempre coincidirá con una nueva línea.
     </para>
     <para>
      El carácter menos (guión) se puede usar para especificar un rango
      de caracteres en una clase carácter. Por ejemplo, [d-m]
      coincide con cualquier letra entre d y m, inclusive. Si un carácter
      menos se requiere en una clase, se debe escapar con una
      barra invertida o aparecer en una posición donde no pueda ser
      interpretado como indicador de rango, típicamente como el primer o último
      carácter en una clase.
     </para>
     <para>
      No es posible tener un carácter literal "]" como el
      carácter final de un rango. Un patrón como [W-]46] es
      interpretado como una clase de dos caracteres ("W" y "-")
      seguido de una cadena literal "46]", por lo que coincidiría con "W46]" o
      "-46]". Sin embargo, si el "]" es escapado con una barra invertida
      es interpretado como el final del rango, así [W-\]46] es
      interpretado como un clase individual que contiene un rango seguido de dos
      caracteres aparte. La representación octal o hexadecimal
      de "]" también se puede usar al final del rango.
     </para>
     <para>
      Los rangos operan en la secuencia de colación de ASCII. También se pueden
      usar para caracteres especificados numéricamente, por ejemplo
      [\000-\037]. Si un rango que incluye letras se usa cuando
      se establece la coincidencia insensible a mayúsculas-minúsculas, coincide con las
      letras en cualquier caso. Por ejemplo, [W-c] es equivalente a
      [][\^_`wxyzabc], coincidido insensiblemente, y si las tablas
      de caracteres para la localización "fr" están siendo usadas, [\xc8-\xcb] coincide
      con caracteres E acentudos en ambos casos.
     </para>
     <para>
      Los tipos de caracteres \d, \D, \s, \S, \w, y \W también pueden
      aparecer en la clase carácter, y añaden a la clase los caracteres que
      que ellos representan. Por ejemplo, [\dABCDEF] coincide con cualquier
      dígito hexadecimal. Un circunflejo se puede usar convenientemente
      con los tipos de caracteres en mayúsculas para especificar un
      conjunto de caracteres más restrictivo que el tipo de coincidencia en minúscula.
      por ejemplo, la clase [^\W_] coincide con cualquier letra o dígito,
      excepto con el subrayado.
     </para>
     <para>
      Todos los caracteres no alfanuméricos distintos de \, -, ^ (al
      comienzo) y el ] finalizador no son especiales en una clase
      carácter, pero no es perjudicial si se escapan. El terminador
      del patrón siempre es especial y debe ser escapado cuando se usa
      dentro de una expresión.
     </para>
    </section>

    <section xml:id="regexp.reference.verticalbar">
     <title>Barra vertical</title>
     <para>
     Los caracteres barra vertical se usan para separar patrones
     alternativos. Por ejemplo, el patrón
      <literal>gilbert|sullivan</literal>
     coincide tanto con "gilbert" como con "sullivan". Pueden aparecer
     cualquier número de alternativas, y se permite una alternativa vacía
     (coincidiendo con la cadena vacía). El proceso de comparación prueba
     cada alternativa sucesivamente, de izquierda a derecha, y la primera
     que tenga éxito se usa. Si las alternativas están dentro de un
     sub-patrón (definido más adelante), "tener éxito" significa coincidir con el
     resto del patrón principal así como con la alternativa en el
     sub-patrón.
     </para>
    </section>

    <section xml:id="regexp.reference.internal-options">
     <title>Ajuste de opciones internas</title>
     <para>
      Los ajustes de <link linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link>, 
      <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>,  
      <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>,
      <link linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link>,
      <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link>,
      <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>
      y PCRE_DUPNAMES se pueden cambiar desde dentro de un patrón por
      una secuencia de letras de opciones de Perl encerradas entre "(?" y
      ")". Las letras de opciones son:

      <table>
       <title>Letras de opciones internas</title>
       <tgroup cols="2">
        <tbody>
         <row>
          <entry><literal>i</literal></entry>
          <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link></entry>
         </row>
         <row>
          <entry><literal>m</literal></entry>
          <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link></entry>
         </row>
         <row>
          <entry><literal>s</literal></entry>
          <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link></entry>
         </row>
         <row>
          <entry><literal>x</literal></entry>
          <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link></entry>
         </row>
         <row>
          <entry><literal>U</literal></entry>
          <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link></entry>
         </row>
         <row>
          <entry><literal>X</literal></entry>
          <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link></entry>
         </row>
         <row>
          <entry><literal>J</literal></entry>
          <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_INFO_JCHANGED</link></entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </para>
     <para>
      Por ejemplo, (?im) establece la coincidencia insensible a mayúsculas-minúsculas,
      multi-línea. También es posible eliminar estas opciones precediendo la letra
      con un guión, y un establecimiento y eliminación combinados como
      (?im-sx), el cual establece <link
       linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link> y
      <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
      mientras que elimina <link
       linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> y
      <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>,
      también está permitido. Si una letra apareca tanto antes como después del
      guión, la opción es eliminada.
     </para>
     <para>
      Cuando un cambio de opción sucede en el nivel más alto (es decir, fuera
      de sub-patrones entre paréntesis), el cambio se aplica al resto del
      patrón que sigue. Así, <literal>/ab(?i)c/</literal> coincide sólo con "abc"
      y "abC". Este comportamiento ha sido cambiado en PCRE 4.0, el cual está incluído
      desde PHP 4.3.3. Antes de estas versiones, <literal>/ab(?i)c/</literal> se
      ejecutaría como <literal>/abc/i</literal> (p.ej. coincidiendo con "ABC" y "aBc").
     </para>
     <para>
      Si un cambio de opción sucede dentro de un sub-patrón, el efecto
      es diferente. Esto es un cambio de comportamiento en Perl 5.005.
      Un cambio de opción dentro de un sub-patrón afecta sólo a aquella parte
      del sub-patrón que le sigue, por lo que

        <literal>(a(?i)b)c</literal>

      coincide con abc y aBc y ninguna otra cadena más (asumiendo que no se usa
      <link linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link>).
      Por medio de esto, las opciones pueden ser producidas para tener diferentes ajustes en
      diferentes partes del patrón. Cualquier cambio hecho en un alternativa
      continúa en ramas subsiguientes dentro del mismo sub-patrón. Por
      ejemplo,

        <literal>(a(?i)b|c)</literal>

      coincide con "ab", "aB", "c", and "C", incluso cuando al coincidir con
      "C" la primera rama es abandonada después de establecer la opción.
      Esto es porque los efectos del establecimiento de opciones ocurren en
      tiempo de compilación. De otro modo habría algunos comportamiento extraños.
     </para>
     <para>
      Las opciones específicas de PCRE <link 
      linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link> y  
      <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link> se pueden
      cambiar de la misma forma que las opciones compatibles con Perl
      usando los caracteres U y X respectivamente. La bandera
      de ajuste (?X) es especial ya que debe producirse siempre antes
      de que se active cualquier otra característica en el patrón,
      incluso si está en el nivel más alto. Lo mejor es ponerlo al principio.
     </para>
    </section>

    <section xml:id="regexp.reference.subpatterns">
     <title>Sub-patrones</title>
     <para>
     Los sub-patrones están delimitados por paréntesis,
     los cuales pueden estar anidados. Marcar parte de un patrón como un sub-patrón
     hace dos cosas:
    </para>
    <para>
     1. Localiza un conjunto de alternativas. Por ejemplo, el
     patrón

       <literal>cat(aract|erpillar|)</literal>

     coincide con una de las palabras "cat", "cataract", o "caterpillar".
     Sin los paréntesis, coincidiría con "cataract",
     "erpillar" o la cadena vacía.
    </para>
    <para>
     2. Establece el sub-patrón como un sub-patrón de captura (como
     se definió antes). Cuando el patrón completo coincide, esa porción
     de la cadena objetivo que coincidió con el sub-patrón es
     devuelta la llamador mediante el argumento <emphasis>ovector</emphasis> de
     <function>pcre_exec</function>. Los paréntesis de apertura se cuentan
     de izquierda a derecha (comenzando por 1) para obtener el número de los
     sub-patrones de captura.
    </para>
    <para>
     Por ejemplo, si la cadena "the red king" se compara con
     el patrón

       <literal>the ((red|white) (king|queen))</literal>

     las cadenas capturadas son "red king", "red", y "king",
     y son numeradas como 1, 2, y 3.
    </para>
    <para>
     El hecho de que los simples paréntesis lleven a cabo dos funciones no es
     siempre útil. Con frecuencia se presenta el caso en el que un
     sub-patrón de agrupamiento se requiere sin la necesidad de una captura. Si un
     paréntesis de apertura es seguido por "?:", el sub-patrón no
     realiza ninguna captura, y no es contado cuando se computa el
     número de cualquier sub-patrón de captura subsiguiente. Por ejemplo,
     si la cadena "the white queen" se compara con el
     patrón

       <literal>the ((?:red|white) (king|queen))</literal>

     las sub-cadenas capturadas son "white queen" y "queen", y
     son numeradas como 1 y 2. El número máximo de sub-cadenas capturadas
     es de 99, y el número máximo de todos los sub-patrones,
     tanto de captura como de no-captura, es de 200.
    </para>
    <para>
     Como abreviación conveniente, si se necesita cualquier establecimiento
     de opciones al inicio de un sup-patrón de no-captura, las
     letras de opcioes pueden aparecen entre el "?" y ":". Así
     lo dos patrones
    </para>

    <literallayout>
       (?i:saturday|sunday)
       (?:(?i)saturday|sunday)
    </literallayout>

    <para>
     coinciden exactamente con el mismo conjunto de cadenas. Dado que las ramas
     alternativas son probadas de izquierda a derecha, y las opciones no
     se reinician hasta que se alcance el final del sub-patrón, el establecimiento
     de una opción en una rama afecta a las ramas siguientes, por lo que
     los patrones de arriba coinciden tanto con "SUNDAY" como con "Saturday".
     </para>
     
     <para>
      Es posible nombrar a los sub-patrones con
      <literal>(?P&lt;nombre&gt;patrón)</literal> a partir de PHP 4.3.3. Así, las matrices
      con coincidencias contendrán la coincidencia indexada por la cadena al lado de la 
      coincidencia indexada por un número.
     </para>
    </section>

    <section xml:id="regexp.reference.repetition">
     <title>Repetición</title>
     <para>
     La repetición se especifica mediante cuantificadores, los cuales pueden ir detrás
     de cualquiera de los siguientes elementos:

      <itemizedlist>
       <listitem><simpara>un único carácter, posiblemente escapado</simpara></listitem>
       <listitem><simpara>el meta-carácter . (punto)</simpara></listitem>
       <listitem><simpara>una clase carácter</simpara></listitem>
       <listitem><simpara>una retro-referencia (véase la siguiente sección)</simpara></listitem>
       <listitem><simpara>un sub-patrón entre paréntesis (a menos que haya una declaración -
     véase más adelante)</simpara></listitem>
      </itemizedlist>
    </para>
    <para>
     El cuantificador de repetición general especifíca un mínimo y
     un máximo del número de coincidencias pertmitidas, dándose los dos
     números entre llaves, separados por una coma.
     Los números deben ser menores que 65536, y el primero debe ser
     menor o igual que el segundo. Por ejemplo:

       <literal>z{2,4}</literal>

     coincide con "zz", "zzz", o "zzzz". Una llave de cierre por sí misma
     no es un carácter especial. Si se omite el segundo número,
     pero la coma está presente, no hay límite superior; si el
     segundo número y la coma se omiten, el cuantificador
     especifica un número exacto de coincidencias requeridas. Así

       <literal>[aeiou]{3,}</literal>

     coincide al menos con 3 vocales sucesivas, pero puede coincidir con
     muchas más, mientras que

       <literal>\d{8}</literal>

     coincide exactamente con 8 dígitos. Una llave que
     aparezca en una posición donde no se permite un cuantificador, o
     una que no coincida con la sintaxis de un cuantificador, se toma
     como un carácter literal. Por ejemplo, {,6} no es un cuantificador,
     sino una cadena literal de cuatro caracteres.
    </para>
    <para>
     El cuantificador {0} está permitido, lo que provoca que la expresión se
     comporte como si el elemento anterior y el cuantificador no estuvieran
     presentes.
    </para>
    <para>
     Por conveniencia (y compatibilidad histórica) los tres
     cuantificadores más comunes tiene como abreviatura un carácter simple:

     <table>
      <title>Cuantificadores de carácter simple</title>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry><literal>*</literal></entry>
         <entry>equivale a <literal>{0,}</literal></entry>
        </row>
        <row>
         <entry><literal>+</literal></entry>
         <entry>equivale a <literal>{1,}</literal></entry>
        </row>
        <row>
         <entry><literal>?</literal></entry>
         <entry>equivale a <literal>{0,1}</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     Es posible construir bucles infinitos mediante un
     sub-patrón que pueda no coincidir con caracteres, seguido de un cuantificador
     que no tenga límite superior, por ejemplo:

       <literal>(a?)*</literal>
    </para>
    <para>
     Versiones anteriores de Perl y PCRE solían dar un error en
     tiempo de ejecución para tales patrones. Sin embargo, ya que hay
     casos donde esto puede ser útil, tales patrones se aceptan ahora,
     pero si cualquier repetición de un sub-patrón de hecho no coincide
     con caracteres, el bucle se abandona por la fuerza.
    </para>
    <para>
     Por defecto, los cuantificadores son "codiciosos", es decir, comparan
     todo lo posible (hasta el número máximo de veces permitido),
     sin provocar que el resto del patrón falle.
     El ejemplo clásico de cómo esto da problemas es al
     intentar coincidir comentarios en programas de C. Éstos aparecen entre
     las secuencias /* y */ y dentro de la secuencia, pueden aparecer
     caracteres * y / individuales. Un intento de coincidir comentarios tipo C
     aplicando el patrón

       <literal>/\*.*\*/</literal>

     a la cadena

       <literal>/* primer comentario */  no comentado  /* segundo comentario */</literal>

     falla, ya que coincide con la cadena completa debido al
     elemento .* que es codicioso.
    </para>
    <para>
     Sin embargo, si un cuantificador es seguido por un signo de interrogación,
     entonces deja de ser codicioso, coincidiendo el mínimo número
     de veces posible, así el patrón

       <literal>/\*.*?\*/</literal>

     funciona de forma correcta con los comentarios tipo C. Por lo demás,
     el significado de los diferentes cuantificadores no varía, sólo el número
     de coincidencias preferidas. No confunda este uso del
     signo de interrogación con su uso como un cuantificador por derecho propio.
     Ya que tiene dos usos, puede aparecer a veces doble, como
     en

       <literal>\d??\d</literal>

     que coincide con un dígito preferentemente, pero puede coincidir con dos si
     esa es la única manera de que el resto del patrón coincida.
    </para>
    <para>
     Si la opción <link linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link>  
     se establece (una opción que no está
     disponible en Perl), los cuantificadores no son codiciosos por
     defecto, pero se les puede hacer codiciosos si les sigue
     un signo de interrogación. En otras palabras, invierte el
     comportamiento por defecto.
    </para>
    <para>
     Los cuantificadores seguidos de <literal>+</literal> son "posesivos". Consumen
     tantos caracteres como les es posible y no retornan para coincidir con el resto del
     patrón. Así, <literal>.*abc</literal> coincide con "aabc" pero
     <literal>.*+abc</literal> no, ya que <literal>.*+</literal> consume la
     cadena entera. Los cuantificadores posesivos se pueden usar para acelerar el procesamiento
     a partir de PHP 4.3.3.
    </para>
    <para>
     Cuando un sub-patrón entre paréntesis es cuantificado con un mínimo
     de cuenta de repeticiones que es mayor que 1 o con un máximo limitado,
     se necesita más capacidad de almacenamiento para el patrón compilado, en
     proporción al tamaño del mínimo o máximo.
    </para>
    <para>
     Si un patrón comienza con .* o .{0,} y la opción <link 
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> 
     (equivalente a la de Perl /s) está establecida, así permitiendo al .
     coincidir con nuevas líneas, entonces el patrón está implícitamente anclado,
     porque ***whatever follows will be tried against every character
     position in the subject string, so there is no point  in
     retrying  the overall match at any position after the first.
     PCRE treats such a pattern as though it were preceded by \A.
     In  cases where it is known that the subject string contains
     no newlines, it is worth setting <link 
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>  when  the  
     pattern begins with .* in order to
     obtain this optimization, or
     alternatively using ^ to indicate anchoring explicitly.
    </para>
    <para>
     When a capturing subpattern is repeated, the value  captured
     is the substring that matched the final iteration. For example, after

       <literal>(tweedle[dume]{3}\s*)+</literal>

     has matched "tweedledum tweedledee" the value  of  the  captured
     substring  is  "tweedledee".  However,  if  there are
     nested capturing  subpatterns,  the  corresponding  captured
     values  may  have been set in previous iterations. For example,
     after
     
       <literal>/(a|(b))+/</literal>

     matches "aba" the value of the second captured substring  is
     "b".
     </para>
    </section>

    <section xml:id="regexp.reference.back-references">
     <title>Retro-referencias</title>
     <para>
     Fuera de una clase carácter, una barra invertida seguida por un dígito
     mayor que 0  (y posiblemente más dígitos) es una retro-referencia
     a un sub-patrón de captura anterior (esto es a su izquierda)
     en el patrón, siempre que hayan habido tantas antes
     capturas previas entre paréntesis.
    </para>
    <para>
     **Sin embargo, si el número decimal que sigue a la barra invertida es
     menor que 10, siempre es tomado como una retro-referencia, y
     produce un error sólo si no hay tantas capturas
     anteriores entre paréntesis en el patrón completo. En otras palabras, los
     paréntesis que son referenciados no necesitan estar a la izquierda de
     la referencia para números menores que 10. Véase la sección anterior
     titulada "Barra invertida" para más detalles acerca del manejo de
     los dígitos que siguen una barra invertida.
    </para>
    <para>
     Una retro-referencia coincide con cualquier cosa que en realidad haya coincidido
     con el sub-patrón de captura en la cadena objetivo actual, más que con
     cualquier cosa que coincida en el sub-patrón mismo. Así, el patrón

       <literal>(sens|respons)e and \1ibility</literal>

     coindice con "sense and sensibility" y con "response and responsibility",
     pero no con "sense and responsibility". Si la coincidencia sensible a
     mayúsculas-minúsculas está en vigor en el momento de la retro-referencia,
     la distinción de letras es relevante. Por ejemplo,

       <literal>((?i)rah)\s+\1</literal>

     coincide con "rah rah" y "RAH RAH", pero no con "RAH rah", incluso
     si el patrón de captura original es coincidido de forma insensible a
     mayúsculas-minúsculas.
    </para>
    <para>
     Puede haber más de una retro-referencia hacia el mismo sub-patrón.
     Si un sub-patrón no ha sido usado en realidad en una
     coincidencia en particular, cualquier retro-referencia a él siempre
     falla. Por ejemplo, el patrón

       <literal>(a|(bc))\2</literal>

     siempre falla si comienza coincidiendo con "a" en vez de con "bc".
     Ya que puede haber hasta 99 retro-referencias, todos los dígitos
     que siguen a la barra invertida se toman como parte de un número
     posible de retro-referencias. Si el patrón continúa con un carácter
     dígito, entonces se deben usat algunos delimitadores para finalizar la
     retro-referencia. Si la opción <link 
     linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link> está
     establecida, esto puede ser un espacio en blanco. De otra manera se puede usar un comentario vacío.
    </para>
    <para>
     Una retro-referencia que sucede dentro de los paréntesis la los cuales
     se refiere, falla cuando el sub-patrón se usa primero, así, por
     ejemplo, (a\1) nunca coincide. Sin embargo, tales referencias pueden
     ser útiles dentro de sub-patrones repetidos. Por ejemplo, el patrón

       <literal>(a|b\1)+</literal>

     coincide con cualquier número de "a"es y tambíen con "aba", "ababba", etc. En
     cada iteración del subpatrón, la retro-referencia coincide con
     el cadena correspondiente a la iteración anterior.
     Para que esto funcione, el patrón debe ser tal
     que la primera iteración no necesite coincidir con la retro-referencia.
     Esto se puede lograr usando alternancia, como en el
     ejemplo anterior, o mediante un cuantificador con un mínimo de cero.
     </para>
     
     <para>
      Las retro-referencias a sub-patrones nominados se pueden lograr mediante
      <literal>(?P=nombre)</literal> o, desde PHP 5.2.4, también por
      <literal>\k&lt;nombre&gt;</literal>, <literal>\k'nombre'</literal>,
      <literal>\k{nombre}</literal> o <literal>\g{nombre}</literal>.
     </para>
    </section>

    <section xml:id="regexp.reference.assertions">
     <title>Declaraciones</title>
     <para>
     Una declaración es un test sobre los caracteres siguientes o
     anteriores al punto de coincidencia actual que en realidad no
     consumen carácter alguno. Las declaraciones simples codificadas como \b,
     \B, \A, \Z, \z, ^ y $ están descritas anteriormente. Las declaraciones
     más complicadas están codificadas como sub-patrones. Hay dos tipos:
     aquéllas que <emphasis>buscan hacia delante</emphasis> desde punto actual de la
     cadena objetivo, y aquéllas que <emphasis>buscan hacia atrás</emphasis> desde él.
    </para>
    <para>
     Un patrón declaración es comparado de la forma habitual, excepto
     que no causa que la posición actual de coincidencia
     cambie. Las declaraciones de <emphasis>búsqueda hacia delante</emphasis> comienzan con
     (?= para declaraciones positivas y con (?! para declaraciones negativas. Por ejemplo,

       <literal>\w+(?=;)</literal>

     coincide con una palabra seguida de un punto y coma, pero no incluye
     el punto y coma en la coincidencia, y

       <literal>foo(?!bar)</literal>

     coincide con cualquier incidencias de "foo" que no esté seguida de
     "bar". Observer que el aparentemente patrón similar

       <literal>(?!foo)bar</literal>

     no encuentra una incidencia de "bar" que esté precedida por
     algo distinto de "foo"; no encuentra ninguna incidencia de "bar"
     en absoluto, ya que la declaración (?!foo) es siempre &true;
     cuando los tres caracteres siguientes son "bar". Se necesita una
     declaración de búsqueda hacia atrás para conseguir este efecto.
    </para>
    <para>
     Las declaraciones de <emphasis>búsqueda hacia atrás</emphasis> comienzan con (?&lt;=
     para declaraciones positivas y con (?&lt;! para declaraciones negativas. Por ejemplo,

       <literal>(?&lt;!foo)bar</literal>

     encuentra una incidencia de "bar" que no esté precedida por
     "foo". El contenido de una declaración de búsqueda hacia atrás está restringido
     de tal manera que todas las cadenas que se comparen con ella deben tener una longitud
     fija. Sin embargo, si hay varias alternativas, no es necesario que
     tengan todas la misma longitud fija. Así,

       <literal>(?&lt;=bullock|donkey)</literal>

     está permitido, pero

       <literal>(?&lt;!dogs?|cats?)</literal>

     produce un error en tiempo de compilación. Las ramas que se comparan con cadenas
     de diferente longitud están permitidas sólo en el nivel más alto de
     una declaración de búsqueda hacia atrás. Esto es una extensión comparado con
     Perl 5.005, la cual requiere que todas las ramas a comparar tengan la misma
     longitud de cadena. Una declaración como

       <literal>(?&lt;=ab(c|de))</literal>

     no está permitida porque su rama del nivel más alto puede
     coincidir con dos longitudes diferentes, pero es aceptable si se reescribe
     para usar dos ramas del nivel más alto:

       <literal>(?&lt;=abc|abde)</literal>

     La implementación de las declaraciones de búsqueda hacia atrás ***is,  for  each
     alternative,  to  temporarily move the current position back
     by the fixed width and then  try  to  match.  If  there  are
     insufficient  characters  before  the  current position, the
     match is deemed to fail.  Lookbehinds  in  conjunction  with
     once-only  subpatterns can be particularly useful for matching
     at the ends of strings; an example is given at  the  end
     of the section on once-only subpatterns.
    </para>
    <para>
     Varias declaraciones (de cualquier tipo) pueden producirse en suceción.
     Por ejemplo,

       <literal>(?&lt;=\d{3})(?&lt;!999)foo</literal>

     coincide con "foo" precedido de tres dígitos que no seao"999".
     ***Notice  that each of the assertions is applied independently
     at the same point in the subject string. First  there  is  a
     check  that  the  previous  three characters are all digits,
     then there is a check that the same three characters are not
     "999".   This  pattern  does not match "foo" preceded by six
     characters, the first of which are digits and the last three
     of  which  are  not  "999".  For  example,  it doesn't match
     "123abcfoo". A pattern to do that is

       <literal>(?&lt;=\d{3}...)(?&lt;!999)foo</literal>
    </para>
    <para>
     This time the first assertion looks  at  the  preceding  six
     characters,  checking  that  the first three are digits, and
     then the second assertion checks that  the  preceding  three
     characters are not "999".
    </para>
    <para>
     Assertions can be nested in any combination. For example,

       <literal>(?&lt;=(?&lt;!foo)bar)baz</literal>

     matches an occurrence of "baz" that  is  preceded  by  "bar"
     which in turn is not preceded by "foo", while

       <literal>(?&lt;=\d{3}...(?&lt;!999))foo</literal>

     is another pattern which matches  "foo"  preceded  by  three
     digits and any three characters that are not "999".
    </para>
    <para>
     Assertion subpatterns are not capturing subpatterns, and may
     not  be  repeated,  because  it makes no sense to assert the
     same thing several times. If any kind of assertion  contains
     capturing  subpatterns  within it, these are counted for the
     purposes of numbering the capturing subpatterns in the whole
     pattern.   However,  substring capturing is carried out only
     for positive assertions, because it does not make sense  for
     negative assertions.
    </para>
    <para>
     Assertions count towards the maximum  of  200  parenthesized
     subpatterns.
     </para>
    </section>

    <section xml:id="regexp.reference.onlyonce">
     <title>Once-only subpatterns</title>
     <para>
     With both maximizing and minimizing repetition,  failure  of
     what  follows  normally  causes  the repeated item to be
     re-evaluated to see if a different number of repeats allows the
     rest  of  the  pattern  to  match. Sometimes it is useful to
     prevent this, either to change the nature of the  match,  or
     to  cause  it fail earlier than it otherwise might, when the
     author of the pattern knows there is no  point  in  carrying
     on.
    </para>
    <para>
     Consider, for example, the pattern \d+foo  when  applied  to
     the subject line

       <literal>123456bar</literal>
    </para>
    <para>
     After matching all 6 digits and then failing to match "foo",
     the normal action of the matcher is to try again with only 5
     digits matching the \d+ item, and then with 4,  and  so  on,
     before ultimately failing. Once-only subpatterns provide the
     means for specifying that once a portion of the pattern  has
     matched,  it  is  not to be re-evaluated in this way, so the
     matcher would give up immediately on failing to match  "foo"
     the  first  time.  The  notation  is another kind of special
     parenthesis, starting with (?&gt; as in this example:

       <literal>(?&gt;\d+)bar</literal>
    </para>
    <para>
     This kind of parenthesis "locks up" the  part of the pattern
     it  contains once it has matched, and a failure further into
     the pattern is prevented from backtracking  into  it.
     Backtracking  past  it to previous items, however, works as normal.
    </para>
    <para>
     An alternative description is that a subpattern of this type
     matches  the  string  of  characters that an identical standalone
     pattern would match, if anchored at the current point
     in the subject string.
    </para>
    <para>
     Once-only subpatterns are not capturing subpatterns.  Simple
     cases  such as the above example can be thought of as a maximizing
     repeat that must  swallow  everything  it  can.  So,
     while both \d+ and \d+? are prepared to adjust the number of
     digits they match in order to make the rest of  the  pattern
     match, (?&gt;\d+) can only match an entire sequence of digits.
    </para>
    <para>
     This construction can of course contain arbitrarily  complicated
     subpatterns, and it can be nested.
    </para>
    <para>
     Once-only subpatterns can be used in conjunction with
     look-behind  assertions  to specify efficient matching at the end
     of the subject string. Consider a simple pattern such as

       <literal>abcd$</literal>

     when applied to a long string which does not match.  Because
     matching  proceeds  from  left  to right, PCRE will look for
     each "a" in the subject and then see if what follows matches
     the rest of the pattern. If the pattern is specified as

       <literal>^.*abcd$</literal>

     then the initial .* matches the entire string at first,  but
     when  this  fails  (because  there  is no following "a"), it
     backtracks to match all but the last character, then all but
     the  last  two  characters, and so on. Once again the search
     for "a" covers the entire string, from right to left, so  we
     are no better off. However, if the pattern is written as

       <literal>^(?>.*)(?&lt;=abcd)</literal>

     then there can be no backtracking for the .*  item;  it  can
     match  only  the  entire  string.  The subsequent lookbehind
     assertion does a single test on the last four characters. If
     it  fails,  the  match  fails immediately. For long strings,
     this approach makes a significant difference to the processing time.
    </para>
    <para>
     When a pattern contains an unlimited repeat inside a subpattern
     that can itself be repeated an unlimited number of
     times, the use of a once-only subpattern is the only way  to
     avoid  some  failing matches taking a very long time indeed.
     The pattern

       <literal>(\D+|&lt;\d+>)*[!?]</literal>

     matches an unlimited number of substrings that  either  consist
     of  non-digits,  or digits enclosed in &lt;>, followed by
     either ! or ?. When it matches, it runs quickly. However, if
     it is applied to

       <literal>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</literal>

     it takes a long  time  before  reporting  failure.  This  is
     because the string can be divided between the two repeats in
     a large number of ways, and all have to be tried. (The example
     used  [!?]  rather  than a single character at the end,
     because both PCRE and Perl have an optimization that  allows
     for  fast  failure  when  a  single  character is used. They
     remember the last single character that is  required  for  a
     match,  and  fail early if it is not present in the string.)
     If the pattern is changed to

       <literal>((?>\D+)|&lt;\d+>)*[!?]</literal>

     sequences of non-digits cannot be broken, and  failure  happens quickly.
     </para>
    </section>

    <section xml:id="regexp.reference.conditional">
     <title>Conditional subpatterns</title>
     <para>
     It is possible to cause the matching process to obey a  subpattern 
     conditionally  or to choose between two alternative
     subpatterns, depending on the result  of  an  assertion,  or
     whether  a previous capturing subpattern matched or not. The
     two possible forms of conditional subpattern are
    </para>

    <literallayout>
       (?(condition)yes-pattern)
       (?(condition)yes-pattern|no-pattern)
    </literallayout>
    <para>
     If the condition is satisfied, the yes-pattern is used; otherwise
     the  no-pattern  (if  present) is used. If there are
     more than two alternatives in the subpattern, a compile-time
     error occurs.
    </para>
    <para>
     There are two kinds of condition. If the  text  between  the
     parentheses  consists  of  a  sequence  of  digits, then the
     condition is satisfied if the capturing subpattern  of  that
     number  has  previously matched. Consider the following pattern,
     which contains non-significant white space to make  it
     more  readable  (assume  the  <link 
     linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link> 
     option)  and to divide it into three parts for ease of discussion:

       <literal>( \( )?    [^()]+    (?(1) \) )</literal>
    </para>
    <para>
     The first part matches an optional opening parenthesis,  and
     if  that character is present, sets it as the first captured
     substring. The second part matches one  or  more  characters
     that  are  not  parentheses. The third part is a conditional
     subpattern that tests whether the first set  of  parentheses
     matched  or  not.  If  they did, that is, if subject started
     with an opening parenthesis, the condition is &true;,  and  so
     the  yes-pattern  is  executed  and a closing parenthesis is
     required. Otherwise, since no-pattern is  not  present,  the
     subpattern  matches  nothing.  In  other words, this pattern
     matches a sequence of non-parentheses,  optionally  enclosed
     in parentheses.
    </para>
    <para>
     If the condition is the string <literal>(R)</literal>, it is satisfied if
     a recursive call to the pattern or subpattern has been made. At "top
     level", the condition is false.
    </para>
    <para>
     If the condition is not a sequence of digits or (R), it must be  an
     assertion.  This  may be a positive or negative lookahead or
     lookbehind assertion. Consider this pattern, again  containing
     non-significant  white space, and with the two alternatives on
     the second line:
    </para>

    <literallayout>
       (?(?=[^a-z]*[a-z])
       \d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )
    </literallayout>
    <para>
     The condition is a positive lookahead assertion that matches
     an optional sequence of non-letters followed by a letter. In
     other words, it tests for  the  presence  of  at  least  one
     letter  in the subject. If a letter is found, the subject is
     matched against  the  first  alternative;  otherwise  it  is
     matched  against the second. This pattern matches strings in
     one of the two forms dd-aaa-dd or dd-dd-dd,  where  aaa  are
     letters and dd are digits.
     </para>
    </section>

    <section xml:id="regexp.reference.comments">
     <title>Comments</title>
     <para>
     The  sequence  (?#  marks  the  start  of  a  comment  which
     continues   up  to  the  next  closing  parenthesis.  Nested
     parentheses are not permitted. The characters that make up a
     comment play no part in the pattern matching at all.
    </para>
    <para>
     If the <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>  
     option is set, an unescaped # character outside  a character class 
     introduces a comment that continues up to the next newline character 
     in the pattern.
     </para>
    </section>

    <section xml:id="regexp.reference.recursive">
     <title>Recursive patterns</title>
     <para>
     Consider the problem of matching a  string  in  parentheses,
     allowing  for  unlimited nested parentheses. Without the use
     of recursion, the best that can be done is to use a  pattern
     that  matches  up  to some fixed depth of nesting. It is not
     possible to handle an arbitrary nesting depth. Perl 5.6  has
     provided   an  experimental  facility  that  allows  regular
     expressions to recurse (among other things).  The  special 
     item (?R) is  provided for  the specific  case of recursion. 
     This PCRE  pattern  solves the  parentheses  problem (assume 
     the <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>
     option is set so that white space is 
     ignored):

       <literal>\( ( (?>[^()]+) | (?R) )* \)</literal>
    </para>
    <para>
     First it matches an opening parenthesis. Then it matches any
     number  of substrings which can either be a sequence of
     non-parentheses, or a recursive  match  of  the  pattern  itself
     (i.e. a correctly parenthesized substring). Finally there is
     a closing parenthesis.
    </para>
    <para>
     This particular example pattern  contains  nested  unlimited
     repeats, and so the use of a once-only subpattern for matching
     strings of non-parentheses is  important  when  applying
     the  pattern to strings that do not match. For example, when
     it is applied to

       <literal>(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</literal>

     it yields "no match" quickly. However, if a  once-only  subpattern
     is  not  used,  the match runs for a very long time
     indeed because there are so many different ways the + and  *
     repeats  can carve up the subject, and all have to be tested
     before failure can be reported.
    </para>
    <para>
     The values set for any capturing subpatterns are those  from
     the outermost level of the recursion at which the subpattern
     value is set. If the pattern above is matched against

       <literal>(ab(cd)ef)</literal>

     the value for the capturing parentheses is  "ef",  which  is
     the  last  value  taken  on  at the top level. If additional
     parentheses are added, giving

       <literal>\( ( ( (?>[^()]+) | (?R) )* ) \)</literal>
     then the string they capture
     is "ab(cd)ef", the contents of the top level parentheses. If
     there are more than 15 capturing parentheses in  a  pattern,
     PCRE  has  to  obtain  extra  memory  to store data during a
     recursion, which it does by using  pcre_malloc,  freeing  it
     via  pcre_free  afterwards. If no memory can be obtained, it
     saves data for the first 15 capturing parentheses  only,  as
     there is no way to give an out-of-memory error from within a
     recursion.
     </para>
     
     <para>
      Since PHP 4.3.3, <literal>(?1)</literal>, <literal>(?2)</literal> and so on 
      can be used for recursive subpatterns too. It is also possible to use named
      subpatterns: <literal>(?P&gt;name)</literal> or 
      <literal>(?P&amp;name)</literal>.
     </para>
     <para>
      If the syntax for a recursive subpattern reference (either by number or
      by name) is used outside the parentheses to which it refers, it operates
      like a subroutine in a programming language. An earlier example
      pointed out that the pattern
      <literal>(sens|respons)e and \1ibility</literal>
      matches "sense and sensibility" and "response and responsibility", but
      not "sense and responsibility". If instead the pattern
      <literal>(sens|respons)e and (?1)ibility</literal>
      is used, it does match "sense and responsibility" as well as the other
      two strings. Such references must, however, follow the subpattern to
      which they refer.
     </para>
     
     <para>
      The maximum length of a subject string is the largest positive number
      that an integer variable can hold. However, PCRE uses recursion to
      handle subpatterns and indefinite repetition. This means that the
      available stack space may limit the size of a subject string that can be
      processed by certain patterns.
     </para>
     
    </section>

    <section xml:id="regexp.reference.performances">
     <title>Performances</title>
     <para>
     Certain items that may appear in patterns are more efficient
     than  others.  It is more efficient to use a character class
     like [aeiou] than a set of alternatives such as (a|e|i|o|u).
     In  general,  the  simplest  construction  that provides the
     required behaviour is usually the  most  efficient.  Jeffrey
     Friedl's  book contains a lot of discussion about optimizing
     regular expressions for efficient performance.
    </para>
    <para>
     When a pattern begins with .* and the <link 
     linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>  option  is
     set,  the  pattern  is implicitly anchored by PCRE, since it
     can match only at the start of a subject string. However, if
     <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>   
     is not set, PCRE cannot make this optimization,
     because the . metacharacter does not then match  a  newline,
     and if the subject string contains newlines, the pattern may
     match from the character immediately following one  of  them
     instead of from the very start. For example, the pattern

       <literal>(.*) second</literal>

     matches the subject "first\nand second" (where \n stands for
     a newline character) with the first captured substring being
     "and". In order to do this, PCRE  has  to  retry  the  match
     starting after every newline in the subject.
    </para>
    <para>
     If you are using such a pattern with subject strings that do
     not  contain  newlines,  the best performance is obtained by
     setting <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>,
     or starting the  pattern  with  ^.*  to
     indicate  explicit anchoring. That saves PCRE from having to
     scan along the subject looking for a newline to restart at.
    </para>
    <para>
     Beware of patterns that contain nested  indefinite  repeats.
     These  can  take a long time to run when applied to a string
     that does not match. Consider the pattern fragment

       <literal>(a+)*</literal>
    </para>
    <para>
     This can match "aaaa" in 33 different ways, and this  number
     increases  very  rapidly  as  the string gets longer. (The *
     repeat can match 0, 1, 2, 3, or 4 times,  and  for  each  of
     those  cases other than 0, the + repeats can match different
     numbers of times.) When the remainder of the pattern is such
     that  the entire match is going to fail, PCRE has in principle
     to try every possible variation, and this  can  take  an
     extremely long time.
    </para>
    <para>
     An optimization catches some of the more simple  cases  such
     as

       <literal>(a+)*b</literal>

     where a literal character follows. Before embarking  on  the
     standard matching procedure, PCRE checks that there is a "b"
     later in the subject string, and if there is not,  it  fails
     the  match  immediately. However, when there is no following
     literal this optimization cannot be used. You  can  see  the
     difference by comparing the behaviour of

       <literal>(a+)*\d</literal>

     with the pattern above. The former gives  a  failure  almost
     instantly  when  applied  to a whole line of "a" characters,
     whereas the latter takes an appreciable  time  with  strings
     longer than about 20 characters.
     </para>
    </section>
  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
