<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.6 $ -->
<!-- EN-Revision: 1.18 Maintainer: lboshell Status: ready -->
<!-- splitted from ./en/functions/pcre.xml, last change in rev 1.2 -->
  <refentry id="function.preg-match-all">
   <refnamediv>
    <refname>preg_match_all</refname>
    <refpurpose>Realizar una comparaci&oacute;n global con una
    expresi&oacute;n regular</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripci&oacute;n</title>
     <methodsynopsis>
      <type>int</type><methodname>preg_match_all</methodname>
      <methodparam><type>string</type><parameter>patron</parameter></methodparam>
      <methodparam><type>string</type><parameter>asunto</parameter></methodparam>
      <methodparam><type>array</type><parameter role="reference">coincidencias</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>banderas</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>desplazamiento</parameter></methodparam>
     </methodsynopsis>
    <para>
     Busca el <parameter>asunto</parameter> por todas las
     coincidencias con la expresi&oacute;n regular dada
     en <parameter>patron</parameter>, y las coloca en
     <parameter>coincidencias</parameter> en el orden especificado
     por <parameter>banderas</parameter>.
    </para>
    <para>
     Despu&eacute;s de que la primera coincidencia es encontrada, las
     b&uacute;squedas subsiguientes contin&uacute;an desde el final de
     la &uacute;ltima coincidencia.
    </para>
    <para>
     <parameter>banderas</parameter> puede ser una combinaci&oacute;n
     de las siguientes banderas (note que no tiene sentido
     usar <constant>PREG_PATTERN_ORDER</constant> junto con
     <constant>PREG_SET_ORDER</constant>):
     <variablelist>
      <varlistentry>
       <term>PREG_PATTERN_ORDER</term>
       <listitem>
        <para>
         Ordena los resultados de tal forma que $coincidencias[0] es
         una matriz con las coincidencias completas del patr&oacute;n,
         $coincidencias[1] es una matriz con las cadenas que coinciden
         con el primer sub-patr&oacute;n entre par&eacute;ntesis, y
         as&iacute; sucesivamente.
        </para>
        <para>
         <informalexample>
          <programlisting role="php">
<![CDATA[
<?php
preg_match_all("|<[^>]+>(.*)</[^>]+>|U", 
    "<b>ejemplo: </b><div align=left>esta es una prueba</div>", 
    $salida, PREG_PATTERN_ORDER);
echo $salida[0][0] . ", " . $salida[0][1] . "\n";
echo $salida[1][0] . ", " . $salida[1][1] . "\n";
?>
]]>
          </programlisting>
          <para>
           Este ejemplo producir&aacute;:
          </para>
          <screen role="html">
<![CDATA[
<b>ejemplo: </b>, <div align=left>esta es una prueba</div>
ejemplo: , esta es una prueba
]]>
          </screen>
          <para>
           As&iacute; que $salida[0] contiene una matriz de cadenas
           que coincidieron con el patr&oacute;n completo, y
           $salida[1] contiene una matriz de cadenas ubicadas entre
           etiquetas.
          </para>
         </informalexample>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>PREG_SET_ORDER</term>
       <listitem>
        <para>
         Ordena los resultados de forma tal que $coincidencias[0] es
         una matriz que contiene el primer conjunto de coincidencias,
         $coincidencias[1] es una matriz con el segundo conjunto de
         coincidencias, y as&iacute; sucesivamente.
         <informalexample>
          <programlisting role="php">
<![CDATA[
<?php
preg_match_all("|<[^>]+>(.*)</[^>]+>|U", 
    "<b>ejemplo: </b><div align=\"left\">esta es una prueba</div>", 
    $salida, PREG_SET_ORDER);
echo $salida[0][0] . ", " . $salida[0][1] . "\n";
echo $salida[1][0] . ", " . $salida[1][1] . "\n";
?>
]]>
          </programlisting>
          <para>
           Este ejemplo producir&aacute;:
          </para>
          <screen role="html">
<![CDATA[
<b>ejemplo: </b>, ejemplo: 
<div align="left">esta es una prueba</div>, esta es una prueba
]]>
          </screen>
         </informalexample>
        </para>
        <para>
         En este caso, $coincidencias[0] es el primer conjunto de
         coincidencias, y $coincidencias[0][0] tiene el texto que
         coincidi&oacute; con el patr&oacute;n completo,
         $coincidencias[0][1] tiene el texto que coincidi&oacute; con
         el primer sub-patr&oacute;n y as&iacute; sucesivamente. De
         forma semejante, $coincidencias[1] es el segundo conjunto de
         coincidencias, etc.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>PREG_OFFSET_CAPTURE</term>
       <listitem>
        <para>
         Si es pasada esta bandera, para cada coincidencia que ocurre,
         ser&aacute; devuelto tambi&eacute;n el desplazamiento de la
         cadena adjunta. Note que esto modifica el valor de retorno,
         convirti&eacute;ndolo en una matriz en donde cada elemento es
         una matriz que consiste de la cadena que coincidi&oacute; en
         la posici&oacute;n <literal>0</literal>, y su desplazamiento
         de cadena al interior del <parameter>asunto</parameter> en la
         posici&oacute;n <literal>1</literal>. Esta bandera se
         encuentra disponible a partir de PHP 4.3.0.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Si no se indica bandera alguna, se asume el uso
     de <constant>PREG_PATTERN_ORDER</constant>.
    </para>

    <para>
     Normalmente, la b&uacute;squeda comienza desde el inicio de la
     cadena de asunto. El par&aacute;metro opcional
     <parameter>desplazamiento</parameter> puede ser usado para
     especificar el lugar alternativo desde donde debe iniciar la
     b&uacute;squeda. El par&aacute;metro
     <parameter>desplazamiento</parameter> se encuentra disponible a
     partir de PHP 4.3.3.
    </para>

    <note>
     <para>
      El uso de <parameter>desplazamiento</parameter> no es
      equivalente a pasar <literal>substr($asunto,
      $desplazamiento)</literal> a <function>preg_match_all</function>
      en lugar de la cadena de asunto, ya que
      <parameter>patron</parameter> puede contener aserciones como
      <emphasis>^</emphasis>, <emphasis>$</emphasis> o
      <emphasis>(?&lt;=x)</emphasis>. Vea
      <function>preg_match</function> para m&aacute;s ejemplos.
     </para>
    </note>

    <para>
     Devuelve el n&uacute;mero de coincidencias con el patr&oacute;n
     completo (que puede ser cero), o &false; si ocurre un error.
    </para>
    <para>
     <example>
      <title>Obtener todos los n&uacute;meros telef&oacute;nicos de un
      segmento de texto.</title>
      <programlisting role="php">
<![CDATA[
<?php
preg_match_all("/\(?  (\d{3})?  \)?  (?(1)  [\-\s] ) \d{3}-\d{4}/x",
                "Llame al 555-1212  1-800-555-1212", $telefonos);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Encontrar etiquetas HTML coincidentes (de forma
      ambiciosa)</title>
      <programlisting role="php">
<![CDATA[
<?php

// El \\2 es un ejemplo de referencia hacia atras. Este le dice a pcre
// que debe buscar el segundo conjunto de parentesis en la expresion
// regular misma, que seria ([\w]+) en este caso. La barra invertida
// extra es requerida ya que la cadena se encuentra entre comillas
// dobles.
$html = "<b>texto en negrilla</b><a href=hola.html>haga clic aqui</a>";

preg_match_all("/(<([\w]+)[^>]*>)(.*)(<\/\\2>)/", $html, $coincidencias);

for ($i=0; $i< count($coincidencias[0]); $i++) {
  echo "coincidencia: " . $coincidencias[0][$i] . "\n";
  echo "parte 1: " . $coincidencias[1][$i] . "\n";
  echo "parte 2: " . $coincidencias[3][$i] . "\n";
  echo "parte 3: " . $coincidencias[4][$i] . "\n\n";
}
?>
]]>
      </programlisting>
      <para>
       Este ejemplo producir&aacute;
      </para>
      <screen role="html">
<![CDATA[
coincidencia: <b>texto en negrilla</b>
parte 1: <b>
parte 2: texto en negrilla
parte 3: </b>

coincidencia: <a href=hola.html>haga clic aqui</a>
parte 1: <a href=hola.html>
parte 2: haga clic aqui
parte 3: </a>
]]>
      </screen>
     </example>
    </para>
    <simpara>
     Vea tambi&eacute;n <function>preg_match</function>,
     <function>preg_replace</function>,
     y <function>preg_split</function>.
    </simpara>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
