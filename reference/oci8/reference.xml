<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.9 $ -->
<!-- EN-Revision: 1.21 Maintainer: lboshell Status: ready -->
<!-- Purpose: database.vendors -->
<!-- Membership: bundled, external -->

 <reference xml:id="ref.oci8" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Funciones de Oracle</title>
  <titleabbrev>OCI8</titleabbrev>

  <partintro>
   <section xml:id="oci8.intro">
    &reftitle.intro;
    <para>
     Estas funciones le permiten acceder a bases de datos Oracle 10, Oracle
     9, Oracle 8 y Oracle 7 usando la Interfaz de Llamados Oracle (OCI por
     sus siglas en inglés). Ellas soportan la vinculación de variables PHP a
     recipientes Oracle, tienen soporte completo LOB, FILE y ROWID, y le
     permiten usar variables de definición entregadas por el usuario.
    </para>
   </section>

   <section xml:id="oci8.requirements">
    &reftitle.required;
   <para>
    Es necesario contar con las bibliotecas de cliente Oracle para usar esta
    extensión. Los usuarios de Windows necesitarán bibliotecas con una
    versión de al menos 10 para usar <filename>php_oci8.dll</filename>.
   </para>
   <para>
    La forma más conveniente de instalar todos los archivos requeridos es
    usar el Cliente Instantáneo de Oracle, que está disponible en: <link
    xlink:href="&url.oracle.instant.client;">&url.oracle.instant.client;</link>.
    Para trabajar con el módulo OCI8, la versión "básica" del Cliente
    Instantáneo de Oracle es suficiente. El Cliente Instantáneo no necesita
    que estén definidas las variables de entorno ORACLE_SID o ORACLE_HOME.
    Sin embargo, puede que aun necesite definir LD_LIBRARY_PATH y NLS_LANG.
   </para>
   <para>
    Antes de usar esta extensión, asegúrese de haber configurado
    apropiadamente sus variables de entorno Oracle para que correspondan con
    el usuario de Oracle, así como su usuario del demonio web. Estas
    variables deben ser configuradas <emphasis>antes</emphasis> de iniciar
    su servidor web. Las variables que necesita definir son las siguientes:
    <itemizedlist>
     <listitem>
      <simpara>
       ORACLE_HOME
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       ORACLE_SID
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       LD_PRELOAD
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       LD_LIBRARY_PATH
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       NLS_LANG
      </simpara>
     </listitem>
    </itemizedlist>
     Para más información sobre variables de entorno de Oracle usadas con
     menos frecuencia como TNS_ADMIN, TWO_TASK, ORA_TZFILE, y los varios
     parámetros de globalización de Oracle como ORA_NLS33, ORA_NLS10 y las
     variables NLS_* refiérase a la documentación de Oracle.
   </para>
   <para>
    Después de definir las variables de entorno para su usuario de servidor
    web, asegúrese también de agregar al usuario del servidor web (nobody,
    www) al grupo oracle.
   </para>
   <note>
    <title>Si su servidor web no arranca, o falla al arrancar</title>
    <para>
     Verifique que Apache esté enlazado con la biblioteca pthread:
    </para>
    <para>
     <informalexample>
      <screen>
<![CDATA[
# ldd /www/apache/bin/httpd
    libpthread.so.0 => /lib/libpthread.so.0 (0x4001c000)
    libm.so.6 => /lib/libm.so.6 (0x4002f000)
    libcrypt.so.1 => /lib/libcrypt.so.1 (0x4004c000)
    libdl.so.2 => /lib/libdl.so.2 (0x4007a000)
    libc.so.6 => /lib/libc.so.6 (0x4007e000)
    /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
]]>
      </screen>
     </informalexample>
    </para>
    <para>
     Si libpthread no se encuentra en la lista, necesita re-instalar Apache:
    </para>
    <para>
     <informalexample>
      <screen>
<![CDATA[
# cd /usr/src/apache_1.3.xx
# make clean
# LIBS=-lpthread ./config.status
# make
# make install
]]>
      </screen>
     </informalexample>
    </para>
    <para>
     Por favor note que en algunos sistemas, como UnixWare, se trata de
     libthread en lugar de libpthread. PHP y Apache deben configurarse con
     EXTRA_LIBS=-lthread.
    </para>
   </note>
   </section>

   &reference.oci8.ini;

   &reference.oci8.constants;

   <section xml:id="oci8.examples">
    &reftitle.examples;
    <para>
     <example>
      <title>Consulta básica</title>
       <programlisting role="php">
<![CDATA[
<?php

  $conexion = oci_connect('hr', 'hr', 'orcl');
  if (!$conexion) {
    $e = oci_error();
    print htmlentities($e['message']);
    exit;
  }

  $consulta = 'SELECT * FROM DEPARTMENTS';

  $id_sentencia = oci_parse($conexion, $consulta);
  if (!$id_sentencia) {
    $e = oci_error($conexion);
    print htmlentities($e['message']);
    exit;
  }

  $r = oci_execute($id_sentencia, OCI_DEFAULT);
  if (!$r) {
    $e = oci_error($id_sentencia);
    echo htmlentities($e['message']);
    exit;
  }

  print '<table border="1">';
  while ($fila = oci_fetch_array($id_sentencia, OCI_RETURN_NULLS)) {
    print '<tr>';
       foreach ($fila as $item) {
         print '<td>'.($item?htmlentities($item):'&nbsp;').'</td>';
       }
       print '</tr>';
  }
  print '</table>';

  oci_close($conexion);
?>
]]>
       </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Insertar con variables enlazadas</title>
       <programlisting role="php">
<![CDATA[
<?php

  // Antes de ejecutar, cree la tabla:
  //   CREATE TABLE MITABLA (mid NUMBER, myd VARCHAR2(20));

  $conexion = oci_connect('scott', 'tiger', 'orcl');

  $consulta = 'INSERT INTO MITABLA VALUES(:myid, :mydata)';

  $id_sentencia = oci_parse($conexion, $consulta);

  $id = 60;
  $datos = 'Algún dato';

  oci_bind_by_name($id_sentencia, ':myid', $id);
  oci_bind_by_name($id_sentencia, ':mydata', $datos);

  $r = oci_execute($id_sentencia);

  if ($r)
    print "Una fila insertada";

  oci_close($conexion);

?>
]]>
       </programlisting>
     </example>
    </para>


    <para>
    <example>
     <title>Inserción de datos en una columna CLOB</title>
      <programlisting role="php">
<![CDATA[
<?php

// Antes de ejecutar, cree la tabla:
//     CREATE TABLE mitabla (miclave NUMBER, miclob CLOB);

$conexion = oci_connect('scott', 'tiger', 'orcl');

$mi_clave = 12343;  // clave arbitraria para este ejemplo

$sql = "INSERT INTO mitabla (miclave, miclob)
        VALUES (:miclave, EMPTY_CLOB())
        RETURNING miclob INTO :miclob";

$id_sentencia = oci_parse($conexion, $sql);
$clob = oci_new_descriptor($conexion, OCI_D_LOB);
oci_bind_by_name($id_sentencia, ":miclave", $mi_clave, 5);
oci_bind_by_name($id_sentencia, ":miclob", $clob, -1, OCI_B_CLOB);
oci_execute($id_sentencia, OCI_DEFAULT);
$clob->save("Una cadena muy larga");

oci_commit($conexion);

// Recuperación de datos CLOB

$consulta = 'SELECT miclob FROM mitabla WHERE miclave = :miclave';

$id_sentencia = oci_parse ($conexion, $consulta);
oci_bind_by_name($id_sentencia, ":miclave", $mi_clave, 5);
oci_execute($id_sentencia, OCI_DEFAULT);

print '<table border="1">';
while ($fila = oci_fetch_array($id_sentencia, OCI_ASSOC)) {
  $resultado = $fila['MYCLOB']->load();
  print '<tr><td>'.$resultado.'</td></tr>';
}
print '</table>';

?>
]]>
     </programlisting>
    </example>
    </para>
    <para>
     Es posible acceder fácilmente a procedimientos almacenados en la misma
     forma en que lo haría desde la línea de comandos.
    <example>
     <title>Uso de Procedimientos Almacenados</title>
      <programlisting role="php">
<![CDATA[
<?php
// por webmaster arroba remoterealty punto com
$sth = oci_parse($dbh, "begin proc_nueva_dir( :id_direccion, '$nombre',
 '$apellido', '$companyia', '$dir1', '$dir2', '$ciudad', '$estado',
 '$cod_postal', '$pais', :cod_error );end;");

// Esto llama al procedimiento almacenado proc_nueva_dir, en donde
// :id_direccion es una variable de entrada/salida y :cod_error es una
// variable de salida.
// Entonces crea la vinculación:

   oci_bind_by_name($sth, ":id_direccion", $id_direccion, 10);
   oci_bind_by_name($sth, ":cod_error", $cod_error, 10);
   oci_execute($sth);

?>
]]>
      </programlisting>
    </example>
    </para>
   </section>

   <section xml:id="oci8.connection">
    <title>Manejo de Conexiones</title>
    <para>
     La extensión oci8 le ofrece 3 funciones diferentes para conectarse con
     Oracle. Depende de usted usar la función más apropiada para su
     aplicación, y la información en esta sección tiene la intención de
     ayudarle a realizar una selección informada.
    </para>
    <para>
     Conectarse a un servidor Oracle es una operación razonablemente
     costosa, en términos del tiempo que toma en ser completada. La función
     <function>oci_pconnect</function> usa un caché persistente de
     conexiones que puede ser re-usado a través de peticiones de diferentes
     scripts. Esto quiere decir que usualmente sólo se incurrirá en el costo
     de conexión una vez por proceso php (o hijo de apache).
    </para>
    <para>
     Si su aplicación se conecta a Oracle usando un conjunto de credenciales
     diferente para cada usuario web, el caché persistente usado por
     <function>oci_pconnect</function> será menos útil a medida que el
     número de usuarios concurrentes se incrementa, al punto en que puede
     empezar a afectar adversamente el rendimiento general de su servidor
     Oracle debido al mantenimiento de demasiadas conexiones en reposo. Si
     su aplicación está estructurada de este modo, es recomendable que
     configure su aplicación usando los parmámetros <link
     linkend="ini.oci8.max_persistent">oci8.max_persistent</link> y <link
     linkend="ini.oci8.persistent_timeout">oci8.persistent_timeout</link>
     (estos le darán control sobre el tamaño y tiempo de vida del caché de
     conexiones persistentes) o use <function>oci_connect</function> en su
     lugar.
    </para>
    <para>
     Tanto <function>oci_connect</function> como
     <function>oci_pconnect</function> emplean un caché de conexiones; si
     realiza múltiples llamadas a <function>oci_connect</function> en un
     script dado, usando los mismo parámetros, la segunda llamada y demás
     después de ésta devolverán el gestor de conexión existente. El caché
     usado por <function>oci_connect</function> es limpiado al final de la
     ejecución del script, o cuando se cierra el gestor de conexión
     explícitamente. <function>oci_pconnect</function> tiene un
     comportamiento similar, aunque su caché es mantenido por separado y
     sobrevive entre múltiples peticiones.
    </para>
    <para>
     Es importante recordar esta característica del uso de cachés, ya que da
     la apariencia de que dos gestores no están aislados transaccionalmente
     (en realidad son el mismo gestor de conexión, así que no hay separación
     de ningún tipo). Si su aplicación necesita dos conexiones separadas,
     aisladas transaccionalmente, debería usar
     <function>oci_new_connect</function>.
    </para>
    <para>
     <function>oci_new_connect</function> siempre crea una nueva conexión al
     servidor Oracle, independientemente de cualquier otra conexión que
     pueda existir. Las aplicaciones con alto tráfico web deberúan tratar de
     evitar el uso de <function>oci_new_connect</function>, especialmente en
     las secciones más ocupadas de la aplicación.
    </para>
   </section>

   <section xml:id="oci8.datatypes">
    <title>Tipos de datos soportados por el controlador</title>
    <table>
     <title>El controlador soporta los siguientes tipos cuando enlaza
     parámetros con la función
     <function>oci_bind_by_name</function>:</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Tipo</entry>
        <entry>Asociación</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>SQLT_NTY</entry>
        <entry>Asigna un tipo nativo de colección desde un objeto colección
        PHP, tal como aquellos creados por
        <function>oci_new_collection</function>.</entry>
       </row>
       <row>
        <entry>SQLT_BFILEE</entry>
        <entry>Asigna un descriptor nativo, tal como aquellos creados por
        <function>oci_new_descriptor</function>.</entry>
       </row>
       <row>
        <entry>SQLT_CFILEE</entry>
        <entry>Asigna un descriptor nativo, tal como aquellos creados por
        <function>oci_new_descriptor</function>.</entry>
       </row>
       <row>
        <entry>SQLT_CLOB</entry>
        <entry>Asigna un descriptor nativo, tal como aquellos creados por
        <function>oci_new_descriptor</function>.</entry>
       </row>
       <row>
        <entry>SQLT_BLOB</entry>
        <entry>Asigna un descriptor nativo, tal como aquellos creados por
        <function>oci_new_descriptor</function>.</entry>
       </row>
       <row>
        <entry>SQLT_RDD</entry>
        <entry>Asigna un descriptor nativo, tal como aquellos creados por
        <function>oci_new_descriptor</function>.</entry>
       </row>
       <row>
        <entry>SQLT_NUM</entry>
        <entry>Convierte el parámetro PHP a un tipo largo 'C', y lo enlaza a
        ese valor.</entry>
       </row>
       <row>
        <entry>SQLT_RSET</entry>
        <entry>Asigna un gestor de sentencia nativo, tal como aquellos
        creados por <function>oci_parse</function> o aquellos recuperados
        desde otras consultas OCI.</entry>
       </row>
       <row>
        <entry>SQLT_CHR y cualquier otro tipo</entry>
        <entry>Convierte el parámetro PHP a un tipo cadena y lo enlaza como
        una cadena.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <table>
     <title>Los siguientes tipos son soportados cuando se recuperan columnas
     desde un conjunto de resultados:</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Tipo</entry>
        <entry>Asociación</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>SQLT_RSET</entry>
        <entry>Crea un recurso de sentencia oci para representar el
        cursor.</entry>
       </row>
       <row>
        <entry>SQLT_RDD</entry>
        <entry>Crea un objeto ROWID.</entry>
       </row>
       <row>
        <entry>SQLT_BLOB</entry>
        <entry>Crea un objeto LOB.</entry>
       </row>
       <row>
        <entry>SQLT_CLOB</entry>
        <entry>Crea un objeto LOB.</entry>
       </row>
       <row>
        <entry>SQLT_BFILE</entry>
        <entry>Crea un objeto LOB.</entry>
       </row>
       <row>
        <entry>SQLT_LNG</entry>
        <entry>Enlazado como SQLT_CHR, devuelto como una cadena</entry>
       </row>
       <row>
        <entry>SQLT_LBI</entry>
        <entry>Enlazado como SQLT_BIN, devuelto como una cadena</entry>
       </row>
       <row>
        <entry>Any other type</entry>
        <entry>Enlazado como SQLT_BIN, devuelto como una cadena</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </section>

  </partintro>

&reference.oci8.functions;

 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
