<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.12 $ -->
<!-- EN-Revision: 1.26 Maintainer: lboshell Status: ready -->
<!-- Purpose: remote.other -->
<!-- Membership: bundled -->

 <reference xml:id="ref.sockets" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Funciones de Socket</title>
  <titleabbrev>Sockets</titleabbrev>

  <partintro>

   <section xml:id="sockets.intro">
    &reftitle.intro;
    <para>
     La extensión de sockets implementa una interfaz de bajo nivel con las
     funciones de comunicación de sockets, basadas en los populares sockets
     BSD, ofreciendo la posibilidad de actuar como un servidor de sockets,
     así como cliente.
    </para>
    <para>
     Para una interfaz más genérica de sockets del lado del cliene, vea
     <function>stream_socket_client</function>,
     <function>stream_socket_server</function>,
     <function>fsockopen</function>, y <function>pfsockopen</function>.
    </para>
    <para>
     Cuando use estas funciones, es importante recordar que, aunque muchas
     de ellas tienen nombres idénticos a sus contrapartes en C, usualmente
     cuentan con declaraciones distintas. Por favor, asegúrese de leer las
     descripciones, con el propósito de evitar confusiones.
    </para>
    <para>
     Aquellos que no se encuentran familiarizados con programación de
     sockets, pueden encontrar una gran cantidad de material útil en las
     páginas man de Unix apropiadas, y existe una enorme cantidad de
     información estilo tutorial sobre programación de sockets en C en la
     web, mucha de la cual puede aplicarse, con ligeras modificaciones, a la
     programación de sockets en PHP. El <link
     xlink:href="&url.socket.faq;">FAQ de Sockets Unix</link> puede ser un
     buen comienzo.
    </para>
    <note>
     <para>
      &pecl.moved-ver;5.3.0.
     </para>
    </note>
   </section>

   <section xml:id="sockets.requirements">
    &reftitle.required;
    &no.requirement;
   </section>

   &reference.sockets.configure;

   <section xml:id="sockets.configuration">
    &reftitle.runtime;
    &no.config;
   </section>

   <section xml:id="sockets.resources">
    &reftitle.resources;
    <para>
     <function>socket_accept</function>,
     <function>socket_create_listen</function> y
     <function>socket_create</function> devuelven recursos de socket.
    </para>
   </section>

   &reference.sockets.constants;

   <section xml:id="sockets.errors">
    <title>Errores de Socket</title>
    <para>
     La extensión de sockets fue escrita para ofrecer una interfaz usable a
     los poderosos sockets BSD. Se ha tenido cuidado para que las funciones
     trabajen igualmente bien en implementaciones Win32 y Unix. Casi todas
     las funciones de sockets pueden fallar bajo ciertas condiciones y por
     lo tanto emiten un mensaje <constant>E_WARNING</constant> que describe
     el error. Algunas veces esto no ocurre conforme al deseo del
     desarrollador. Por ejemplo, la función <function>socket_read</function>
     puede emitir repentinamente un mensaje <constant>E_WARNING</constant>
     debido a que la conexión ha sido cerrada inesperadamente. Es común
     suprimir la advertencia con el operador <literal>@</literal> y atrapar
     el código de error dentro de la aplicación con la función
     <function>socket_last_error</function>. Puede llamar la función
     <function>socket_strerror</function> con este código de error para
     recuperar una cadena que describe el error. Vea su descripción para más
     información.
    </para>
    <note>
     <para>
      Los mensajes <constant>E_WARNING</constant> generados por la extensión
      de sockets se encuentran en inglés, aunque el mensaje de error
      recuperado aparecerá dependiendo de la localidad actual
      (<constant>LC_MESSAGES</constant>):
      <programlisting role="php">
<![CDATA[
Warning - socket_bind() unable to bind address [98]: Die Adresse wird bereits verwendet
]]>
      </programlisting>
     </para>
    </note>
   </section>

   <section xml:id="sockets.examples">
    &reftitle.examples;
    <para>
     <example>
      <title>Ejemplo de Socket: Servidor TCP/IP simple</title>
      <para>
       Este ejemplo le muestra un servidor simple que repite de vuelta su
       entrada. Modifique las variables <varname>direccion</varname> y
       <varname>puerto</varname> para que se acomoden a su configuración y
       ejecútelo. Puede entonces conectarse con el servidor mediante un
       comando similar a: <command>telnet 192.168.1.53 10000</command> (en
       donde la dirección y el puerto se ajustan a su configuración).
       Cualquier cosa que escriba será entonces impresa en el lado del
       servidor, y devuelta a su lado. Para desconectarse, ingrese 'salir'.
      </para>
      <programlisting role="php">
<![CDATA[
#!/usr/local/bin/php -q
<?php
error_reporting(E_ALL);

/* Permitir que el script permanezca en espera de conexiones. */
set_time_limit(0);

/* Habilitar vaciado de salida implícito, de modo que veamos lo que
 * obtenemos a medida que va llegando. */
ob_implicit_flush();

$direccion = '192.168.1.53';
$puerto    = 10000;

if (($sock = socket_create(AF_INET, SOCK_STREAM, SOL_TCP)) === false) {
    echo "socket_create() falló: motivo: " . socket_strerror(socket_last_error()) . "\n";
}

if (socket_bind($sock, $direccion, $puerto) === false) {
    echo "socket_bind() falló: motivo: " . socket_strerror(socket_last_error($sock)) . "\n";
}

if (socket_listen($sock, 5) === false) {
    echo "socket_listen() falló: motivo: " . socket_strerror(socket_last_error($sock)) . "\n";
}

do {
    if (($mens_sock = socket_accept($sock)) === false) {
        echo "socket_accept() falló: motivo " . socket_strerror(socket_last_error($sock)) . "\n";
        break;
    }
    /* Enviar instrucciones. */
    $mensaje = "\nBienvenido al Servidor de Prueba PHP. \n" .
               "Para salir, escriba 'salir'. " .
               "Para detener el servidor, escriba 'detener'.\n";
    socket_write($mens_sock, $mensaje, strlen($mensaje));

    do {
        if (false === ($buf = socket_read($mens_sock, 2048, PHP_NORMAL_READ))) {
            echo "socket_read() falló: motivo: " . socket_strerror(socket_last_error($mens_sock)) . "\n";
            break 2;
        }
        if (!$buf = trim($buf)) {
            continue;
        }
        if ($buf == 'salir') {
            break;
        }
        if ($buf == 'detener') {
            socket_close($mens_sock);
            break 2;
        }
        $respuesta = "PHP: Usted dijo '$buf'.\n";
        socket_write($mens_sock, $respuesta, strlen($respuesta));
        echo "$buf\n";
    } while (true);
    socket_close($mens_sock);
} while (true);

socket_close($sock);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Ejemplo de Socket: Cliente TCP/IP simple</title>
      <para>
       Este ejemplo muestra un cliente HTTP simple, de un paso. Simplemente
       se conecta con una página, envia una petición HEAD, imprime la
       respuesta, y sale.
      </para>
      <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);

echo "<h2>Conexión TCP/IP</h2>\n";

/* Obtener el puerto para el servicio WWW. */
$puerto_servicio = getservbyname('www', 'tcp');

/* Obtener la dirección IP del host de destino. */
$direccion = gethostbyname('www.example.com');

/* Crear un socket TCP/IP. */
$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
if ($socket === false) {
    echo "socket_create() falló: motivo: " . socket_strerror(socket_last_error()) . "\n";
} else {
    echo "OK.\n";
}

echo "Intentando una conexión con '$direccion' en el puerto '$puerto_servicio'...";
$resultado = socket_connect($socket, $direccion, $puerto_servicio);
if ($resultado === false) {
    echo "socket_connect() falló.\nMotivo: ($resultado) " .
         socket_strerror(socket_last_error($socket)) . "\n";
} else {
    echo "OK.\n";
}

$entrada = "HEAD / HTTP/1.1\r\n";
$entrada .= "Host: www.example.com\r\n";
$entrada .= "Connection: Close\r\n\r\n";
$salida = '';

echo "Enviando petición HTTP HEAD...";
socket_write($socket, $entrada, strlen($entrada));
echo "OK.\n";

echo "Leyendo respuesta:\n\n";
while ($salida = socket_read($socket, 2048)) {
    echo $salida;
}

echo "Cerrando socket...";
socket_close($socket);
echo "OK.\n\n";
?>
]]>
      </programlisting>
     </example>
    </para>
   </section>
  </partintro>

&reference.sockets.entities.functions;

 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

