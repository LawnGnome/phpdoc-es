<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.10 $ -->
<!-- EN-Revision: 1.63 Maintainer: lboshell Status: ready -->
 <chapter id="language.oop">
  <title>Clases y Objetos (PHP 4)</title>

  <sect1 id="keyword.class">
   <title><literal>class</literal></title>
   <para>
    Una clase es una colecci&oacute;n de variables y funciones que
    trabajan con &eacute;stas variables. Una clase es definida usando
    la siguiente sintaxis:
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Carrito {
    var $items;  // Items en nuestro carrito de compras

    // Agregar $num articulos de $artnr al carrito

    function agregar_item($artnr, $num) {
        $this->items[$artnr] += $num;
    }

    // Tomar $num articulos de $artnr del carrito

    function retirar_item($artnr, $num) {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return true;
        } elseif ($this->items[$artnr] == $num) {
            unset($this->items[$artnr]);
            return true;
        } else {
            return false;
        }
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Esto define una clase llamada Carrito que consiste de una matriz
    asociativa de art&iacute;culos en el carrito y dos funciones para
    agregar y eliminar elementos del carrito.
   </para>

   <warning>
    <simpara>
     <emphasis>NO</emphasis> es posible separar la definici&oacute;n
     de una clase en varios archivos. Asimismo <emphasis>NO</emphasis>
     es posible separar la definici&oacute;n de una clase en bloques
     PHP diferentes, a menos que la separaci&oacute;n sea al interior
     de una declaraci&oacute;n de m&eacute;todo. Lo siguiente no
     funciona:
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class prueba {
?>
<?php
    function prueba() {
        print 'Bien';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Sin embargo, lo siguiente es permitido:
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class prueba {
    function prueba() {
        ?>
        <?php
        print 'Bien';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </warning>

   <simpara>
    Las siguientes notas de precauci&oacute;n son v&aacute;lidas para
    PHP 4.
   </simpara>

   <caution>
    <simpara>
     El nombre <literal>stdClass</literal> es usado internamente por
     Zend y es reservado. No puede tener una clase con el nombre
     <literal>stdClass</literal> en PHP.
    </simpara>
   </caution>

   <caution>
    <simpara>
     Los nombres de funci&oacute;n <literal>__sleep</literal> y
     <literal>__wakeup</literal> son m&aacute;gicos en las clases
     PHP. No puede tener funciones con &eacute;stos nombres en
     cualquiera de sus clases a menos que desee usar la funcionalidad
     m&aacute;gica asociada con ellas. Vea m&aacute;s
     informaci&oacute;n a continuaci&oacute;n.
    </simpara>
   </caution>

   <caution>
    <simpara>
     PHP reserva todos los nombres de funci&oacute;n que comienzan con
     __ como m&aacute;gicos. Se recomienda que no use nombres de
     funci&oacute;n con __ en PHP a menos que desee usar alguna
     funcionalidad m&aacute;gica documentada.
    </simpara>
   </caution>

   <simpara>
    En PHP 4, s&oacute;lo se permiten inicializadores constantes para
    variables <literal>var</literal>. Para inicializar variables con
    valores no-constantes, necesita una funci&oacute;n de
    inicializaci&oacute;n que sea llamada autom&aacute;ticamente
    cuando un objeto es construido a partir de la clase. Tal
    funci&oacute;n es llamada constructora (vea m&aacute;s
    informaci&oacute;n a continuaci&oacute;n).
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Carrito {
    /* Ninguna de estas expresiones funciona en PHP 4. */
    var $fecha_hoy = date("Y-m-d");
    var $nombre = $primer_nombre;
    var $duenyo = 'Fred ' . 'Jones';
    /* Aunque, las matrices que contienen valores constantes funcionan */
    var $items = array("VCR", "TV");
}

/* Asi es como debe declararse. */
class Carrito {
    var $fecha_hoy;
    var $nombre;
    var $duenyo;
    var $items = array("VCR", "TV");

    function Carrito() {
        $this->fecha_hoy = date("Y-m-d");
        $this->nombre = $GLOBALS['primer_nombre'];
        /* etc. . . */
    }
}
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Las clases son tipos, es decir, son planos usados para variables
    reales. Necesita crear una variable del tipo deseado con el
    operador <literal>new</literal>.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$carrito = new Carrito;
$carrito->agregar_item("10", 1);

$otro_carrito = new Carrito;
$otro_carrito->agregar_item("0815", 3);
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Esto crea los objetos <varname>$carrito</varname> y
    <varname>$otro_carrito</varname>, ambos de la clase Carrito. La
    funci&oacute;n agregar_item() del objeto
    <varname>$carrito</varname> es llamada para agregar 1 item del
    art&iacute;culo n&uacute;mero 10 al
    <varname>$carrito</varname>. Se agregan 3 items del
    art&iacute;culo n&uacute;mero 0815 al
    <varname>$otro_carrito</varname>.
   </para>
   
   <para>
    Ambos, <varname>$carrito</varname> y
    <varname>$otro_carrito</varname>, tienen funciones agregar_item(),
    retirar_item() y una variable items. Estas son variables y
    funciones diferentes. Puede pensar sobre los objetos como algo
    similar a las directorios en un sistema de archivos. En un sistema
    de archivos es posible tener dos archivos
    <filename>LEAME.TXT</filename> diferentes, siempre y cuando
    est&eacute;n en directorios diferentes. Tal y como con los
    directorios, en donde es necesario escribir las rutas de nombres
    completas para llegar a cada archivo a partir del directorio del
    nivel superior, es necesario especificar el nombre completo de la
    funci&oacute;n que desea llamar: en t&eacute;rminos de PHP, el
    directorio de nivel superior ser&iacute;a el espacio de nombres
    global, y el separador de ruta ser&iacute;a
    <literal>-&gt;</literal>. De tal modo que los nombres
    <varname>$carrito-&gt;items</varname> y
    <varname>$otro_carrito-&gt;items</varname> hacen referencia a dos
    variables diferentes. Note que la variable se llama
    <varname>$carrito-&gt;items</varname>, no
    <varname>$carrito-&gt;$items</varname>, es decir, un nombre de
    variable en PHP solo tiene un &uacute;nico signo de d&oacute;lar.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// correcto, un solo $
$carrito->items = array("10" => 1); 

// invalido, ya que $carrito->$items se convierte en $carrito->""
$carrito->$items = array("10" => 1);

// correcto, pero puede o no ser lo que se busca:
// $carrito->$mivar se convierte en $carrito->items
$mivar = 'items';
$carrito->$mivar = array("10" => 1);
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Al interior de una definici&oacute;n de clase, no se conoce el
    nombre bajo el que el objeto ser&aacute; accesible en su programa:
    en el momento en que la clase Carrito fue escrita, no se
    conoc&iacute;a que el objeto se llamar&iacute;a
    <varname>$carrito</varname> u <varname>$otro_carrito</varname>
    m&aacute;s adelante. Por lo tanto, no es posible escribir
    <varname>$carrito-&gt;items</varname> al interior de la clase
    Carrito. En su lugar, para poder acceder a sus propias funciones y
    variables desde el interior de una clase, es posible usar la
    pseudo-variable <varname>$this</varname>, la cual puede leerse
    como 'mi propio' o 'el objeto actual'. Por lo tanto,
    '<varname>$this-&gt;items[$num_art]</varname> +=
    <varname>$num</varname>' puede leerse como 'agregar
    <varname>$num</varname> al contador <varname>$num_art</varname> de
    mi propia matriz de items', o 'agregar <varname>$num</varname> al
    contador <varname>$num_art</varname> de la matriz de items al
    interior del objeto actual'.
   </para>

   <note>
    <para>
     Usualmente, la pseudo-variable <varname>$this</varname> no es
     definida si el m&eacute;todo en el que se encuentra es llamado
     est&aacute;ticamente. Sin embargo, esta no es una regla estricta:
     <varname>$this</varname> se define si un m&eacute;todo es llamado
     est&aacute;ticamente desde el interior de otro objeto. En este
     caso, el valor de <varname>$this</varname> es aqu&eacute;l del
     objeto que hace la llamada. Esto se ilustra en el siguiente
     ejemplo:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this se define (';
            echo get_class($this);
            echo ")\n";
        } else {
            echo "\$this no se define.\n";
        }
    }
}

class B
{
    function bar()
    {
        A::foo();
    }
}

$a = new A();
$a->foo();
A::foo();
$b = new B();
$b->bar();
B::bar();
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
$this se define (a)
$this no se define.
$this se define (b)
$this no se define.
]]>
      </screen>
     </informalexample>
    </para>
   </note>

   <note>
    <para>
     Existen algunas funciones interesantes que manejan clases y
     objetos. Puede que quiera echar un vistazo a las <link
     linkend="ref.classobj">Funciones de Clase/Objeto</link>.
    </para>
   </note>
  </sect1>

  <sect1 id="keyword.extends">
   <title><literal>extends</literal></title>

   <para>
    Con frecuencia es necesario tener clases con variables y funciones
    similares a otra clase existente. De hecho, es una buena
    pr&aacute;ctica definir una clase gen&eacute;rica que pueda ser
    usada en todos sus proyectos y adaptar &eacute;sta clase para las
    necesidades de cada uno de sus proyectos espec&iacute;ficos. Para
    facilitar esto, las clases pueden ser extensiones de otras
    clases. La clase extendida o derivada tiene todas las variables y
    funciones de la clase base (esto es llamado 'herencia', a pesar
    del hecho de que nadie muera) y lo que se agregue en la
    definici&oacute;n extendida. No es posible substraer de una clase,
    es decir, remover la definici&oacute;n de cualquier funci&oacute;n
    o variable existente. Una clase extendida siempre depende de una
    clase base &uacute;nica, lo que quiere decir que no se soporta
    herencia m&uacute;ltiple. Las clases son extendidas usando la
    palabra clave 'extends'.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Carrito_Con_Nombre extends Carrito {
    var $duenyo;
  
    function definir_duenyo ($nombre) {
        $this->duenyo = $nombre;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Esto define una clase Carrito_Con_Nombre que tiene todas las
    variables y funciones de Carrito, m&aacute;s una variable
    adicional <varname>$duenyo</varname> y una funci&oacute;n
    adicional definir_duenyo(). Se crea un carrito con nombre en la
    forma usual y ahora es posible definir y obtener el due&ntilde;o
    del carrito. Aun es posible usar las funciones normales de un
    carrito sobre los carritos con nombre:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$carrito_n = new Carrito_Con_Nombre;  // Crear un carrito con nombre
$carrito_n->definir_duenyo("kris");   // Nombrar el carrito
print $carrito_n->duenyo;             // imprimir el nombre del duenyo
$carrito_n->agregar_item("10", 1);    // (funcionalidad heredada de carrito)
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Esto tambi&eacute;n se conoce como una relaci&oacute;n
    "padre-hijo". Se crea una clase, padre, y se usa
    <literal>extends</literal> para crear una clase
    <emphasis>basada</emphasis> en la clase padre: la clase hija. Es
    posible incluso usar esta nueva clase hija y crear otra clase
    basada en esta clase hija.
   </para>
   <note>
    <para>
     &iexcl;Las clases deben ser definidas antes de ser usadas! Si
     desea que la clase <literal>Carrito_Con_Nombre</literal> extienda
     la clase <literal>Carrito</literal>, tendr&aacute; que definir la
     clase <literal>Carrito</literal> primero. Si desea crear otra
     clase llamada <literal>Carrito_amarillo_con_nombre</literal>
     basada en la clase <literal>Carrito_Con_Nombre</literal>, debe
     definir <literal>Carrito_Con_Nombre</literal>
     primero. Resumiendo: el orden en que se definen las clases es
     importante.
    </para>
   </note>
  </sect1>

  <sect1 id="language.oop.constructor">
   <title>Constructores</title>

   <para>
    Los constructores son funciones en una clase que son llamadas
    autom&aacute;ticamente cuando se crea una nueva instancia de una
    clase con <literal>new</literal>. Una funci&oacute;n se convierte
    en constructor cuando tiene el mismo nombre que la clase. Si una
    clase no tiene constructor, el constructor de la clase base es
    llamado, si existe.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Auto_Carrito extends Carrito {
    function Auto_Carrito() {
        $this->agregar_item("10", 1);
    }
}
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Esto define una clase Auto_Carrito que es un Carrito m&aacute;s un
    constructor que inicializa el carrito con un item del
    n&uacute;mero de art&iacute;culo "10" cada vez que un nuevo
    Auto_Carrito se crea con "new". Los constructores pueden recibir
    argumentos y tales argumentos pueden ser opcionales, lo que los
    hace mucho m&aacute;s &uacute;tiles. Para poder usar aun la clase
    sin par&aacute;metros, todos los par&aacute;metros deben ser
    opcionales, al proveer valores predeterminados.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Constructor_Carrito extends Carrito {
    function Constructor_Carrito($item = "10", $num = 1) {
        $this->agregar_item ($item, $num);
    }
}

// Comprar lo mismo de antes.
$carrito_predeterminado = new Constructor_Carrito;

// Comprar esta vez en serio...
$carrito_diferente = new Constructor_Carrito("20", 17);
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Tambi&eacute;n puede usar el operador <literal>@</literal> para
    <emphasis>callar</emphasis> los errores que ocurren en el
    constructor, p.ej.  <literal>@new</literal>.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A
{
    function A()
    {
        echo "Soy el constructor de A.<br />\n";
    }

    function B()
    {
        echo "Soy una funci&oacute;n regular llamada B en la clase A.<br />\n";
        echo "No soy un constructor en A.<br />\n";
    }
}

class B extends A
{
}

// Esto llama a B() como un constructor
$b = new B;
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    La funci&oacute;n B() en la clase A se convertir&aacute; de
    repente en un constructor en la clase B, aun cuando nunca fue esa
    la intenci&oacute;n. A PHP 4 no le importa si la funci&oacute;n
    est&aacute; siendo definida en la clase B, o si ha sido heredada.
   </para>

   <caution>
    <simpara>
     PHP 4 no llama constructores de la clase base
     autom&aacute;ticamente desde un constructor de una clase
     derivada. Es su responsabilidad propagar la llamada a
     constructores m&aacute;s arriba en la jerarqu&iacute;a cuando sea
     apropiado.
    </simpara>
   </caution>

   <para>
    Los destructores son funciones que son llamadas
    autom&aacute;ticamente cuando un objeto es destruido, ya sea con
    <function>unset</function> o simplemente al finalizarse su
    contexto. No hay destructores en PHP. Es posible usar
    <function>register_shutdown_function</function> en su lugar para
    simular la mayor&iacute;a de efectos de los destructores.
   </para>
  </sect1>

 <sect1 id="keyword.paamayim-nekudotayim"><!-- :-) -->
   <title>Operador de Resoluci&oacute;n de Contexto
   (<literal>::</literal>)</title>


   <caution>
    <simpara>
     Lo siguiente es v&aacute;lido &uacute;nicamente para PHP 4 y
     versiones posteriores.
    </simpara>
   </caution>

   <para>
    Algunas veces es &uacute;til referirse a funciones y variables en
    clases base o referirse a funciones en clases que no tienen aun
    alguna instancia. El operador :: es usado en tales casos.
  </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A {
    function ejemplo() {
        echo "Soy la funci&oacute;n original A::ejemplo().<br />\n";
    }
}

class B extends A {
    function ejemplo() {
        echo "Soy la funci&oacute;n redefinida B::ejemplo().<br />\n";
        A::ejemplo();
    }
}

// no hay un objeto de la clase A.
// esto imprime
//   Soy la funcion original A::ejemplo().<br />
A::ejemplo();

// crear un objeto de clase B.
$b = new B;

// esto imprime
//   Soy la funcion redefinida B::ejemplo().<br />
//   Soy la funcion original A::ejemplo().<br />
$b->ejemplo();
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    El ejemplo anterior llama la funci&oacute;n ejemplo() en la clase
    A, pero no hay un objeto de la clase A, as&iacute; que no podemos
    escribir $a->ejemplo() o algo semejante. En su lugar llamamos
    ejemplo() como una 'funci&oacute;n de clase', es decir, una
    funci&oacute;n de la clase misma, no de un objeto de tal clase.
   </para>

   <para>
    Existen funciones de clase, pero no existen variables de clase. De
    hecho, no hay un objeto en absoluto al momento de la llamada. Por
    lo tanto, una funci&oacute;n de clase no puede usar variables del
    objeto (pero puede usar variables locales y globales), y
    quiz&aacute;s no pueda usar <varname>$this</varname> en absoluto.
   </para>

   <para>
    En el ejemplo anterior, la clase B redefine la funci&oacute;n
    ejemplo(). La definici&oacute;n original en la clase A es cubierta
    y ya no se encuentra disponible, a menos que haga referencia
    espec&iacute;ficamente a la implementaci&oacute;n de ejemplo() en
    la clase A usando el operador ::. Escriba A::ejemplo() para
    hacerlo (en realidad, deber&iacute;a usar parent::ejemplo(), como
    se muestra en la siguiente secci&oacute;n).
   </para>
   
   <para>
    En este contexto, hay un objeto actual y puede tener variables de
    objeto. Por lo tanto, cuando se usa DESDE EL INTERIOR de una
    funci&oacute;n de objeto, es posible usar <varname>$this</varname>
    y variables de objeto.
   </para>

 </sect1>

 <sect1 id="keyword.parent">
   <title><literal>parent</literal></title>

  <para>
   Es posible que se encuentre escribiendo c&oacute;digo que hace
   referencia a variables y funciones de las clases base. Esto es
   particularmente cierto si su clase derivada es una
   refinaci&oacute;n o especializaci&oacute;n del c&oacute;digo en su
   clase base.
  </para>
  
  <para>
   En lugar de usar el nombre literal de la clase base en su
   c&oacute;digo, deber&iacute;a usar el nombre especial
   <literal>parent</literal>, el cual hace referencia al nombre de su
   clase base tal y como se entrega en la declaraci&oacute;n
   <literal>extends</literal> de su clase. Al hacer esto, evita usar
   el nombre de su clase base en m&aacute;s de un lugar. Llegado el
   caso de que su &aacute;rbol de jerarqu&iacute;a cambie durante la
   implementaci&oacute;n, el cambio se puede efectuar con facilidad
   simplemente modificando la declaraci&oacute;n
   <literal>extends</literal> de su clase.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class A {
    function ejemplo() {
        echo "Soy A::ejemplo() y ofrezco funcionalidad b&aacute;sica.<br />\n";
    }
}

class B extends A {
    function ejemplo() {
        echo "Soy B::ejemplo() y ofrezco funcionalidad adicional.<br />\n";
        parent::ejemplo();
    }
}

$b = new B;

// Esto hace la llamada a B::ejemplo(), la cual llama a su vez a A::ejemplo().
$b->ejemplo();
?>
]]>
   </programlisting>
  </informalexample>
 </sect1>

 <sect1 id="language.oop.serialization">
  <title>Seriaci&oacute;n de objetos, objetos en sesiones</title>

  <note>
   <simpara>
    En PHP 3, los objetos perd&iacute;an su asociaci&oacute;n de clase
    a lo largo del proceso de seriaci&oacute;n y
    decodificaci&oacute;n. La variable resultante es de tipo objeto,
    pero no tiene clase ni m&eacute;todos, de modo que es
    in&uacute;til (se ha convertido en algo como una matriz con una
    sintaxis curiosa).
   </simpara>
  </note>

  <caution>
   <simpara>
    La siguiente informaci&oacute;n es v&aacute;lida para PHP 4
    &uacute;nicamente.
   </simpara>
  </caution>

  <para>
   <function>serialize</function> devuelve una cadena que contiene una
   representaci&oacute;n tipo secuencia-de-bytes de cualquier valor
   que pueda ser almacenado en PHP. <function>unserialize</function>
   puede causar que &eacute;stas cadenas recreen los valores de
   variable originales. Usando el m&eacute;todo de seriaci&oacute;n
   para guardar un objeto guardar&aacute; todas las variables en un
   objeto. Las funciones en un objeto no se guardar&aacute;n,
   s&oacute;lo el nombre de la clase.
  </para>
  
  <para>
   Para poder usar <function>unserialize</function> con un objeto, la
   clase de ese objeto necesita ser definida. Es decir, si tiene un
   objeto <varname>$a</varname> de la clase A en pagina1.php y
   codifica &eacute;sta variable, obtendr&aacute; una cadena que hace
   referencia a la clase A y contiene todos los valores de variables
   contenidas en <varname>$a</varname>. Si desea tener la capacidad de
   revertir el proceso de seriaci&oacute;n en pagina2.php, recreando
   <varname>$a</varname> de la clase A, la definici&oacute;n de la
   clase A debe estar presente en pagina2.php. Esto puede conseguirse
   por ejemplo almacenando la definici&oacute;n de la clase A en un
   archivo de inclusi&oacute;n e incluy&eacute;ndolo tanto en
   pagina1.php como en pagina2.php.
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
// clase_a.inc:
  
  class A {
      var $uno = 1;
    
      function mostrar_uno() {
          echo $this->uno;
      }
  }
  
// pagina1.php:

  include("clase_a.inc");
  
  $a = new A;
  $s = serialize($a);
  // almacenar $s en alguna parte en donde pagina2.php lo pueda encontrar.
  $fp = fopen("almacenamiento", "w");
  fwrite($fp, $s);
  fclose($fp);

// pagina2.php:
  
  // esto es necesaria para revertir la seriacion apropiadamente.
  include("clase_a.inc");

  $s = implode("", @file("almacenamiento"));
  $a = unserialize($s);

  // ahora use la funcion mostrar_uno() del objeto $a.
  $a->mostrar_uno();
?>
]]>
   </programlisting>
  </informalexample>
  
   <para>
   Si est&aacute; usando sesiones y usa
   <function>session_register</function> para registrar objetos,
   &eacute;stos objetos son seriados autom&aacute;ticamente al final
   de cada p&aacute;gina PHP, y son decodificados de vuelta
   autom&aacute;ticamente en cada una de las siguientes
   p&aacute;ginas. Esto quiere decir, b&aacute;sicamente, que tales
   objetos pueden aparecer en cualquiera de sus p&aacute;ginas una vez
   hacen parte de su sesi&oacute;n.
  </para>
  
  <para>
   Es bastante recomendable que incluya las definiciones de clase de
   todos esos objetos registrados en todas sus p&aacute;ginas, incluso
   si no va a usar realmente &eacute;stas clases en todas sus
   p&aacute;ginas. Si no lo hace y un objeto est&aacute; siendo
   decodificado sin que su definici&oacute;n de clase est&eacute;
   presente, perder&aacute; su asociaci&oacute;n de clase y se
   convertir&aacute; en un objeto de la clase
   <literal>stdClass</literal> sin ninguna funci&oacute;n disponible,
   es decir, se har&aacute; pr&aacute;cticamente in&uacute;til.
  </para>
  
  <para>
   De modo que si en el ejemplo anterior <varname>$a</varname> se
   hac&iacute;a parte de una sesi&oacute;n ejecutando
   <literal>session_register("a")</literal>, deber&iacute;a
   inclu&iacute;rse el archivo <literal>clase_a.inc</literal> en todas
   sus p&aacute;ginas, no s&oacute;lo en pagina1.php y pagina2.php.
  </para>
 </sect1>

 <sect1 id="language.oop.magic-functions">
  <title>Las funciones m&aacute;gicas <literal>__sleep</literal> y
  <literal>__wakeup</literal></title>

  <para>
   <function>serialize</function> revisa si su clase tiene una
   funci&oacute;n con el nombre m&aacute;gico
   <literal>__sleep</literal>. De ser as&iacute;, esa funci&oacute;n
   es ejecutada antes de cualquier intento de seriaci&oacute;n. Puede
   limpiar el objeto y su intenci&oacute;n es que devuelva una matriz
   con los nombres de todas las variables de ese objeto que
   deber&iacute;an ser seriadas.
  </para>
  
  <para>
   El uso planeado para <literal>__sleep</literal> es cerrar todas las
   conexiones de bases de datos que pueda tener el objeto, aplicando
   datos pendientes o realizando tareas similares de
   limpieza. Asimismo, la funci&oacute;n resulta &uacute;til si tiene
   objetos bastante grandes que no necesitan ser guardados en su
   totalidad.
  </para>
  
  <para>
   De forma semejante, <function>unserialize</function> revisa por la
   presencia de una funci&oacute;n con el nombre m&aacute;gico
   <literal>__wakeup</literal>. Si est&aacute; presente, &eacute;sta
   funci&oacute;n puede reconstruir cualquier recurso que el objeto
   pueda tener.
  </para>
  
  <para>
   El uso planeado para <literal>__wakeup</literal> es reestablecer
   cualquier conexi&oacute;n con bases de datos que hayan podido
   perderse durante la seriaci&oacute;n y realizar otras tareas de
   reinicializaci&oacute;n.
  </para>
 </sect1>
  
 <sect1 id="language.oop.newref">
   <title>Las referencias al interior del constructor</title>
   <para>
    Crear referencias al interior del constructor puede llevar a
    resultados confusos. Esta secci&oacute;n tipo-tutorial le ayuda a
    evitar problemas.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Foo {
    function Foo($nombre) {
        // crear una referencia al interior de la matriz global $refglobal
        global $refglobal;
        $refglobal[] = &$this;
        // definir el nombre al valor pasado
        $this->definirNombre($nombre);
        // e imprimirlo
        $this->imprimirNombre();
    }

    function imprimirNombre() {
        echo "<br />", $this->nombre;
    }
 
    function definirNombre($nombre) {
        $this->nombre = $nombre;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>
    
   <para>
    Revisemos si existe una diferencia entre <varname>$bar1</varname>,
    que ha sido creado usando el operador de copia
    <literal>=</literal> y <varname>$bar2</varname> que ha sido creado
    usando el operador de referencia <literal>=&amp;</literal>...
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bar1 = new Foo('definido en el constructor');
$bar1->imprimirNombre();
$refglobal[0]->imprimirNombre();

/* salida:
definido en el constructor
definido en el constructor
definido en el constructor */

$bar2 =& new Foo('definido en el constructor');
$bar2->imprimirNombre();
$refglobal[1]->imprimirNombre();

/* salida:
definido en el constructor
definido en el constructor
definido en el constructor */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Aparentemente no hay ninguna diferencia, pero en realidad hay una
    bastante importante: <varname>$bar1</varname> y
    <varname>$refglobal[0]</varname> _NO_ son referenciados, NO son la
    misma variable. Esto se debe a que "new" no devuelve una
    referencia por defecto, en su lugar devuelve una copia.
    <note>
     <simpara>
      No existe una p&eacute;rdida de rendimiento (ya que desde PHP 4
      se usa el conteo de referencias) al devolver copias en lugar de
      referencias. Al contrario, con frecuencia es mejor trabajar
      simplemente con copias en lugar de referencias, ya que crear
      referencias toma cierto tiempo mientras que crear copias
      pr&aacute;cticamente no toma nada de tiempo (a menos que ninguna
      de ellas sea una matriz u objeto grande y una de ellas se
      modifique y luego las otras subsecuentemente, entonces
      ser&iacute;a buena idea usar referencias para modificarlas todas
      al mismo tiempo).
     </simpara>
    </note>
    Para probar lo que se dice m&aacute;s arriba, veamos el siguiente
    c&oacute;digo.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// ahora cambiaremos el nombre. que espera que pase?
// puede que espere que tanto $bar1 como $refglobal[0] cambien sus nombres...
$bar1->definirNombre('definido desde afuera');

// como se ha mencionado antes, ese no es el caso.
$bar1->imprimirNombre();
$refglobal[0]->imprimirNombre();

/* salida:
definido desde afuera
definido en el constructor */

// veamos que cambia entre $bar2 y $refglobal[1]
$bar2->definirNombre('definido desde afuera');

// por suerte, no solo son iguales, son la misma variable, de modo que
// $bar2->nombre y $refglobal[1]->nombre son el mismo tambien
$bar2->imprimirNombre();
$refglobal[1]->imprimirNombre();

/* salida:
definido desde afuera
definido desde afuera */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   Otro ejemplo final, intente entenderlo.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class A {
    function A($i) {
        $this->valor = $i;
        // intente descubrir porque no necesitamos una referencia aqui
        $this->b = new B($this);
    }

    function crearRef() {
        $this->c = new B($this);
    }

    function echoValor() {
        echo "<br />","clase ",get_class($this),': ',$this->valor;
    }
}


class B {
    function B(&$a) {
        $this->a = &$a;
    }

    function echoValor() {
        echo "<br />","clase ",get_class($this),': ',$this->a->valor;
    }
}

// intente entender porque usar una simple copia produciria
// un resultado no deseado en la linea marcada con *
$a =& new A(10);
$a->crearRef();

$a->echoValor();
$a->b->echoValor();
$a->c->echoValor();

$a->valor = 11;

$a->echoValor();
$a->b->echoValor(); // *
$a->c->echoValor();

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
clase A: 10
clase B: 10
clase B: 10
clase A: 11
clase B: 11
clase B: 11
]]>
     </screen>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="language.oop.object-comparison">
   <title>Comparaci&oacute;n de objetos</title>
  <para>
   En PHP 4, los objetos son comparados en una forma muy simple: Dos
   instancias de objeto son iguales si tienen los mismos atributos y
   valores, y son instancias de la misma clase. Reglas similares se
   aplican cuando se comparan dos objetos usando el operador de
   identidad (<literal>===</literal>).
  </para>
  <para>
   Si ejecut&aacute;ramos el c&oacute;digo del siguiente ejemplo:
   <example>
    <title>Ejemplo de comparaci&oacute;n de objetos en PHP 4</title>
    <programlisting role='php'>
<![CDATA[
<?php
function bool_a_cadena($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function compararObjetos(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool_a_cadena($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool_a_cadena($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool_a_cadena($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool_a_cadena($o1 !== $o2)."\n";
}

class Bandera {
    var $bandera;

    function Bandera($bandera=true) {
            $this->bandera = $bandera;
    }
}

class BanderaCambiante extends Bandera {

    function encender() {
        $this->bandera = true;
    }

    function apagar() {
        $this->bandera = false;
    }
}

$o = new Bandera();
$p = new Bandera(false);
$q = new Bandera();

$r = new BanderaCambiante();

echo "Comparar instancias creadas con los mismos par&aacute;metros\n";
compararObjetos($o, $q);

echo "\nComparar instancias creadas con par&aacute;metros diferentes\n";
compararObjetos($o, $p);

echo "\nComparar una instancia de una clase padre con una de una subclase\n";
compararObjetos($o, $r);
?>
]]>
    </programlisting>
    &example.outputs;
   <screen>
<![CDATA[
Comparar instancias creadas con los mismos par&aacute;metros
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Comparar instancias creadas con par&aacute;metros diferentes
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Comparar una instancia de una clase padre con una de una subclase
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
]]>
    </screen>
   </example>
   Que es la salida que podemos esperar dadas las reglas de
   comparaci&oacute;n descritas anteriormente. Solo las instancias con
   los mismos valores para sus atributos y de la misma clase son
   consideradas iguales e id&eacute;nticas.
  </para>
  <para>
   Incluso en los casos en donde tenemos composici&oacute;n de
   objetos, se aplican las mismas reglas de comparaci&oacute;n. En el
   ejemplo siguiente creamos una clase contenedora que almacena una
   matriz asociativa de objetos <classname>Bandera</classname>.
   <example>
    <title>Comparaci&oacute;n de objetos compuestos en PHP 4</title>
    <programlisting role='php'>
<![CDATA[
<?php
class ConjuntoBanderas {
    var $conjunto;

    function ConjuntoBanderas($matrizBanderas = array()) {
        $this->conjunto = $matrizBanderas;
    }

    function agregarBandera($nombre, $bandera) {
        $this->conjunto[$nombre] = $bandera;
    }

    function eliminarBandera($nombre) {
        if (array_key_exists($nombre, $this->conjunto)) {
            unset($this->conjunto[$nombre]);
        }
    }
}


$u = new ConjuntoBanderas();
$u->agregarBandera('bandera1', $o);
$u->agregarBandera('bandera2', $p);
$v = new ConjuntoBanderas(array('bandera1'=>$q, 'bandera2'=>$p));
$w = new ConjuntoBanderas(array('bandera1'=>$q));

echo "\nObjetos compuestos u(o,p) y v(q,p)\n";
compararObjetos($u, $v);

echo "\nu(o,p) y w(q)\n";
compararObjetos($u, $w);
?>
]]>
    </programlisting>
    &example.outputs;
   <screen>
<![CDATA[
Objetos compuestos u(o,p) y v(q,p)
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

u(o,p) y w(q)
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
]]>
    </screen>
   </example>
  </para>
 </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
