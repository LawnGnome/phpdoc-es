<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.14 $ -->
<!-- EN-Revision: 1.68 Maintainer: lboshell Status: ready -->
 <chapter xml:id="language.oop" xmlns="http://docbook.org/ns/docbook">
  <title>Clases y Objetos (PHP 4)</title>

  <sect1 xml:id="keyword.class">
   <title><literal>class</literal></title>
   <para>
    Una clase es una colección de variables y funciones que trabajan con
    estas variables. Una clase es definida usando la siguiente sintaxis:
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Carrito {
    var $items;  // Ítems en nuestro carrito de compras

    // Agregar $num artículos de $artnr al carrito

    function agregar_item($artnr, $num) {
        $this->items[$artnr] += $num;
    }

    // Tomar $num artículos de $artnr del carrito

    function retirar_item($artnr, $num) {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return true;
        } elseif ($this->items[$artnr] == $num) {
            unset($this->items[$artnr]);
            return true;
        } else {
            return false;
        }
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Esto define una clase llamada Carrito que consiste de una matriz
    asociativa de artículos en el carrito y dos funciones para agregar y
    eliminar elementos del carrito.
   </para>

   <warning>
    <simpara>
     <emphasis>NO</emphasis> es posible separar la definición de una clase
     en varios archivos. Asimismo <emphasis>NO</emphasis> es posible separar
     la definición de una clase en bloques PHP diferentes, a menos que la
     separación sea al interior de una declaración de método. Lo siguiente
     no funciona:
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class prueba {
?>
<?php
    function prueba() {
        print 'Bien';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Sin embargo, lo siguiente es permitido:
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class prueba {
    function prueba() {
        ?>
        <?php
        print 'Bien';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </warning>

   <simpara>
    Las siguientes notas de precaución son válidas para PHP 4.
   </simpara>

   <caution>
    <simpara>
     El nombre <literal>stdClass</literal> es usado internamente por Zend y
     es reservado. No puede tener una clase con el nombre
     <literal>stdClass</literal> en PHP.
    </simpara>
   </caution>

   <caution>
    <simpara>
     Los nombres de función <literal>__sleep</literal> y
     <literal>__wakeup</literal> son mágicos en las clases PHP. No puede
     tener funciones con estos nombres en cualquiera de sus clases a menos
     que desee usar la funcionalidad mágica asociada con ellas. Vea más
     información a continuación.
    </simpara>
   </caution>

   <caution>
    <simpara>
     PHP reserva todos los nombres de función que comienzan con __ como
     mágicos. Se recomienda que no use nombres de función con __ en PHP a
     menos que desee usar alguna funcionalidad mágica documentada.
    </simpara>
   </caution>

   <simpara>
    En PHP 4, sólo se permiten inicializadores constantes para variables
    <literal>var</literal>. Para inicializar variables con valores
    no-constantes, necesita una función de inicialización que sea llamada
    automáticamente cuando un objeto es construido a partir de la clase. Tal
    función es llamada constructora (vea más información a continuación).
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Carrito {
    /* Ninguna de estas expresiones funciona en PHP 4. */
    var $fecha_hoy = date("Y-m-d");
    var $nombre = $primer_nombre;
    var $duenyo = 'Fred ' . 'Jones';
    /* Aunque, las matrices que contienen valores constantes funcionan */
    var $items = array("VCR", "TV");
}

/* Así es como debe declararse. */
class Carrito {
    var $fecha_hoy;
    var $nombre;
    var $duenyo;
    var $items = array("VCR", "TV");

    function Carrito() {
        $this->fecha_hoy = date("Y-m-d");
        $this->nombre = $GLOBALS['primer_nombre'];
        /* etc. . . */
    }
}
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Las clases son tipos, es decir, son planos usados para variables reales.
    Necesita crear una variable del tipo deseado con el operador
    <literal>new</literal>.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$carrito = new Carrito;
$carrito->agregar_item("10", 1);

$otro_carrito = new Carrito;
$otro_carrito->agregar_item("0815", 3);
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Esto crea los objetos <varname>$carrito</varname> y
    <varname>$otro_carrito</varname>, ambos de la clase Carrito. La función
    agregar_item() del objeto <varname>$carrito</varname> es llamada para
    agregar 1 item del artículo número 10 al <varname>$carrito</varname>. Se
    agregan 3 items del artículo número 0815 al
    <varname>$otro_carrito</varname>.
   </para>

   <para>
    Ambos, <varname>$carrito</varname> y <varname>$otro_carrito</varname>,
    tienen funciones agregar_item(), retirar_item() y una variable items.
    Estas son variables y funciones diferentes. Puede pensar sobre los
    objetos como algo similar a las directorios en un sistema de archivos.
    En un sistema de archivos es posible tener dos archivos
    <filename>LEAME.TXT</filename> diferentes, siempre y cuando estén en
    directorios diferentes. Tal y como con los directorios, en donde es
    necesario escribir las rutas de nombres completas para llegar a cada
    archivo a partir del directorio del nivel superior, es necesario
    especificar el nombre completo de la función que desea llamar: en
    términos de PHP, el directorio de nivel superior sería el espacio de
    nombres global, y el separador de ruta sería <literal>-&gt;</literal>.
    De tal modo que los nombres <varname>$carrito-&gt;items</varname> y
    <varname>$otro_carrito-&gt;items</varname> hacen referencia a dos
    variables diferentes. Note que la variable se llama
    <varname>$carrito-&gt;items</varname>, no
    <varname>$carrito-&gt;$items</varname>, es decir, un nombre de variable
    en PHP solo tiene un único signo de dólar.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// correcto, un solo $
$carrito->items = array("10" => 1);

// inválido, ya que $carrito->$items se convierte en $carrito->""
$carrito->$items = array("10" => 1);

// correcto, pero puede o no ser lo que se busca:
// $carrito->$mivar se convierte en $carrito->items
$mivar = 'items';
$carrito->$mivar = array("10" => 1);
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Al interior de una definición de clase, no se conoce el nombre bajo el
    que el objeto será accesible en su programa: en el momento en que la
    clase Carrito fue escrita, no se conocía si el objeto se llamaría
    <varname>$carrito</varname>, <varname>$otro_carrito</varname>, o algo
    diferente más adelante. Por lo tanto, no es posible escribir
    <varname>$carrito-&gt;items</varname> al interior de la clase Carrito.
    En su lugar, para poder acceder a sus propias funciones y variables
    desde el interior de una clase, es posible usar la pseudo-variable
    <varname>$this</varname>, la cual puede leerse como 'mi propio' o 'el
    objeto actual'. Por lo tanto,
    '<varname>$this-&gt;items[$num_art]</varname> +=
    <varname>$num</varname>' puede leerse como 'agregar
    <varname>$num</varname> al contador <varname>$num_art</varname> de mi
    propia matriz de items', o 'agregar <varname>$num</varname> al contador
    <varname>$num_art</varname> de la matriz de items al interior del objeto
    actual'.
   </para>

   <note>
    <para>
     Usualmente, la pseudo-variable <varname>$this</varname> no es definida
     si el método en el que se encuentra es llamado estáticamente. Sin
     embargo, esta no es una regla estricta: <varname>$this</varname> se
     define si un método es llamado estáticamente desde el interior de otro
     objeto. En este caso, el valor de <varname>$this</varname> es aquél del
     objeto que hace la llamada. Esto se ilustra en el siguiente ejemplo:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this se define (';
            echo get_class($this);
            echo ")\n";
        } else {
            echo "\$this no se define.\n";
        }
    }
}

class B
{
    function bar()
    {
        A::foo();
    }
}

$a = new A();
$a->foo();
A::foo();
$b = new B();
$b->bar();
B::bar();
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
$this se define (a)
$this no se define.
$this se define (b)
$this no se define.
]]>
      </screen>
     </informalexample>
    </para>
   </note>

   <note>
    <para>
     Existen algunas funciones interesantes que manejan clases y objetos.
     Puede que quiera echar un vistazo a las <link
     linkend="ref.classobj">Funciones de Clase/Objeto</link>.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="keyword.extends">
   <title><literal>extends</literal></title>

   <para>
    Con frecuencia es necesario tener clases con variables y funciones
    similares a otra clase existente. De hecho, es una buena práctica
    definir una clase genérica que pueda ser usada en todos sus proyectos y
    adaptar esta clase para las necesidades de cada uno de sus proyectos
    específicos. Para facilitar esto, las clases pueden ser extensiones de
    otras clases. La clase extendida o derivada tiene todas las variables y
    funciones de la clase base (esto es llamado 'herencia', a pesar del
    hecho de que nadie muera) y lo que se agregue en la definición
    extendida. No es posible substraer de una clase, es decir, remover la
    definición de cualquier función o variable existente. Una clase
    extendida siempre depende de una clase base única, lo que quiere decir
    que no se soporta herencia múltiple. Las clases son extendidas usando la
    palabra clave 'extends'.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Carrito_Con_Nombre extends Carrito {
    var $duenyo;

    function definir_duenyo ($nombre) {
        $this->duenyo = $nombre;
    }
}
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Esto define una clase Carrito_Con_Nombre que tiene todas las variables y
    funciones de Carrito, más una variable adicional
    <varname>$duenyo</varname> y una función adicional definir_duenyo(). Se
    crea un carrito con nombre en la forma usual y ahora es posible definir
    y obtener el dueño del carrito. Aun es posible usar las funciones
    normales de un carrito sobre los carritos con nombre:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$carrito_n = new Carrito_Con_Nombre;  // Crear un carrito con nombre
$carrito_n->definir_duenyo("kris");   // Nombrar el carrito
print $carrito_n->duenyo;             // imprimir el nombre del dueño
$carrito_n->agregar_item("10", 1);    // (funcionalidad heredada de carrito)
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Esto también se conoce como una relación "padre-hijo". Se crea una
    clase, padre, y se usa <literal>extends</literal> para crear una clase
    <emphasis>basada</emphasis> en la clase padre: la clase hija. Es posible
    incluso usar esta nueva clase hija y crear otra clase basada en esta
    clase hija.
   </para>
   <note>
    <para>
     ¡Las clases deben ser definidas antes de ser usadas! Si desea que la
     clase <literal>Carrito_Con_Nombre</literal> extienda la clase
     <literal>Carrito</literal>, tendrá que definir la clase
     <literal>Carrito</literal> primero. Si desea crear otra clase llamada
     <literal>Carrito_amarillo_con_nombre</literal> basada en la clase
     <literal>Carrito_Con_Nombre</literal>, debe definir
     <literal>Carrito_Con_Nombre</literal> primero. Resumiendo: el orden en
     que se definen las clases es importante.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="language.oop.constructor">
   <title>Constructores</title>

   <para>
    Los constructores son funciones en una clase que son llamadas
    automáticamente cuando se crea una nueva instancia de una clase con
    <literal>new</literal>. Una función se convierte en constructor cuando
    tiene el mismo nombre que la clase. Si una clase no tiene constructor,
    el constructor de la clase base será llamado, si existe.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Auto_Carrito extends Carrito {
    function Auto_Carrito() {
        $this->agregar_item("10", 1);
    }
}
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Esto define una clase Auto_Carrito que es un Carrito más un constructor
    que inicializa el carrito con un item del número de artículo "10" cada
    vez que un nuevo Auto_Carrito se crea con "new". Los constructores
    pueden recibir argumentos y tales argumentos pueden ser opcionales, lo
    que los hace mucho más útiles. Para poder usar aun la clase sin
    parámetros, todos los parámetros deben ser opcionales, al proveer
    valores predeterminados.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Constructor_Carrito extends Carrito {
    function Constructor_Carrito($item = "10", $num = 1) {
        $this->agregar_item ($item, $num);
    }
}

// Comprar lo mismo de antes.
$carrito_predeterminado = new Constructor_Carrito;

// Comprar esta vez en serio...
$carrito_diferente = new Constructor_Carrito("20", 17);
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    También puede usar el operador <literal>@</literal> para
    <emphasis>callar</emphasis> los errores que ocurren en el constructor,
    p.ej.  <literal>@new</literal>.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A
{
    function A()
    {
        echo "Soy el constructor de A.<br />\n";
    }

    function B()
    {
        echo "Soy una función regular llamada B en la clase A.<br />\n";
        echo "No soy un constructor en A.<br />\n";
    }
}

class B extends A
{
}

// Esto llama a B() como un constructor
$b = new B;
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    La función B() en la clase A se convertirá de repente en un constructor
    en la clase B, aun cuando nunca fue esa la intención. A PHP 4 no le
    importa si la función está siendo definida en la clase B, o si ha sido
    heredada.
   </para>

   <caution>
    <simpara>
     PHP 4 no llama constructores de la clase base automáticamente desde un
     constructor de una clase derivada. Es su responsabilidad propagar la
     llamada a constructores más arriba en la jerarquía cuando sea
     apropiado.
    </simpara>
   </caution>

   <para>
    Los destructores son funciones que son llamadas automáticamente cuando
    un objeto es destruido, ya sea con <function>unset</function> o
    simplemente al finalizarse su contexto. No hay destructores en PHP. Es
    posible usar <function>register_shutdown_function</function> en su lugar
    para simular la mayoría de efectos de los destructores.
   </para>
  </sect1>

 <sect1 xml:id="keyword.paamayim-nekudotayim"><!-- :-) -->
   <title>Operador de Resolución de Contexto
   (<literal>::</literal>)</title>


   <caution>
    <simpara>
     Lo siguiente es válido únicamente para PHP 4 y versiones posteriores.
    </simpara>
   </caution>

   <para>
    Algunas veces es útil referirse a funciones y variables en clases base o
    referirse a funciones en clases que no tienen aun alguna instancia. El
    operador :: es usado en tales casos.
  </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A {
    function ejemplo() {
        echo "Soy la función original A::ejemplo().<br />\n";
    }
}

class B extends A {
    function ejemplo() {
        echo "Soy la función redefinida B::ejemplo().<br />\n";
        A::ejemplo();
    }
}

// no hay un objeto de la clase A.
// esto imprime
//   Soy la función original A::ejemplo().<br />
A::ejemplo();

// crear un objeto de clase B.
$b = new B;

// esto imprime
//   Soy la función redefinida B::ejemplo().<br />
//   Soy la función original A::ejemplo().<br />
$b->ejemplo();
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    El ejemplo anterior llama la función ejemplo() en la clase A, pero no
    hay un objeto de la clase A, así que no podemos escribir $a->ejemplo() o
    algo semejante. En su lugar llamamos ejemplo() como una 'función de
    clase', es decir, una función de la clase misma, no de un objeto de tal
    clase.
   </para>

   <para>
    Existen funciones de clase, pero no existen variables de clase. De
    hecho, no hay un objeto en absoluto al momento de la llamada. Por lo
    tanto, una función de clase no puede usar variables del objeto (pero
    puede usar variables locales y globales), y quizás no pueda usar
    <varname>$this</varname> en absoluto.
   </para>

   <para>
    En el ejemplo anterior, la clase B redefine la función ejemplo(). La
    definición original en la clase A es cubierta y ya no se encuentra
    disponible, a menos que haga referencia específicamente a la
    implementación de ejemplo() en la clase A usando el operador ::. Escriba
    A::ejemplo() para hacerlo (en realidad, debería usar parent::ejemplo(),
    como se muestra en la siguiente sección).
   </para>

   <para>
    En este contexto, hay un objeto actual y puede tener variables de
    objeto. Por lo tanto, cuando se usa DESDE EL INTERIOR de una función de
    objeto, es posible usar <varname>$this</varname> y variables de objeto.
   </para>

 </sect1>

 <sect1 xml:id="keyword.parent">
   <title><literal>parent</literal></title>

  <para>
   Es posible que se encuentre escribiendo código que hace referencia a
   variables y funciones de las clases base. Esto es particularmente cierto
   si su clase derivada es una refinación o especialización del código en su
   clase base.
  </para>

  <para>
   En lugar de usar el nombre literal de la clase base en su código, debería
   usar el nombre especial <literal>parent</literal>, el cual hace
   referencia al nombre de su clase base tal y como se entrega en la
   declaración <literal>extends</literal> de su clase. Al hacer esto, evita
   usar el nombre de su clase base en más de un lugar. Llegado el caso de
   que su árbol de jerarquía cambie durante la implementación, el cambio se
   puede efectuar con facilidad simplemente modificando la declaración
   <literal>extends</literal> de su clase.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class A {
    function ejemplo() {
        echo "Soy A::ejemplo() y ofrezco funcionalidad básica.<br />\n";
    }
}

class B extends A {
    function ejemplo() {
        echo "Soy B::ejemplo() y ofrezco funcionalidad adicional.<br />\n";
        parent::ejemplo();
    }
}

$b = new B;

// Esto hace la llamada a B::ejemplo(), la cual llama a su vez a A::ejemplo().
$b->ejemplo();
?>
]]>
   </programlisting>
  </informalexample>
 </sect1>

 <sect1 xml:id="language.oop.serialization">
  <title>Seriación de objetos, objetos en sesiones</title>

  <note>
   <simpara>
    En PHP 3, los objetos perdían su asociación de clase a lo largo del
    proceso de seriación y decodificación. La variable resultante es de tipo
    objeto, pero no tiene clase ni métodos, de modo que es inútil (se ha
    convertido en algo como una matriz con una sintaxis curiosa).
   </simpara>
  </note>

  <caution>
   <simpara>
    La siguiente información es válida para PHP &gt;= 4 únicamente.
   </simpara>
  </caution>

  <para>
   <function>serialize</function> devuelve una cadena que contiene una
   representación tipo secuencia-de-bytes de cualquier valor que pueda ser
   almacenado en PHP. <function>unserialize</function> puede causar que
   estas cadenas recreen los valores de variable originales. Usando el
   método de seriación para guardar un objeto guardará todas las variables
   en un objeto. Las funciones en un objeto no se guardarán, sólo el nombre
   de la clase.
  </para>

  <para>
   Para poder usar <function>unserialize</function> con un objeto, la clase
   de ese objeto necesita ser definida. Es decir, si tiene un objeto
   <varname>$a</varname> de la clase A en pagina1.php y codifica ésta
   variable, obtendrá una cadena que hace referencia a la clase A y contiene
   todos los valores de variables contenidas en <varname>$a</varname>. Si
   desea tener la capacidad de revertir el proceso de seriación en
   pagina2.php, recreando <varname>$a</varname> de la clase A, la definición
   de la clase A debe estar presente en pagina2.php. Esto puede conseguirse
   por ejemplo almacenando la definición de la clase A en un archivo de
   inclusión e incluyéndolo tanto en pagina1.php como en pagina2.php.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
// clase_a.inc:

  class A {
      var $uno = 1;

      function mostrar_uno() {
          echo $this->uno;
      }
  }

// pagina1.php:

  include("clase_a.inc");

  $a = new A;
  $s = serialize($a);
  // almacenar $s en alguna parte en donde pagina2.php lo pueda encontrar.
  $fp = fopen("almacenamiento", "w");
  fwrite($fp, $s);
  fclose($fp);

// pagina2.php:

  // esto es necesario para revertir la seriación apropiadamente.
  include("clase_a.inc");

  $s = implode("", @file("almacenamiento"));
  $a = unserialize($s);

  // ahora use la función mostrar_uno() del objeto $a.
  $a->mostrar_uno();
?>
]]>
   </programlisting>
  </informalexample>

   <para>
   Si está usando sesiones y usa <function>session_register</function> para
   registrar objetos, estos objetos son seriados automáticamente al final de
   cada página PHP, y son decodificados de vuelta automáticamente en cada
   una de las siguientes páginas. Esto quiere decir, básicamente, que tales
   objetos pueden aparecer en cualquiera de sus páginas una vez hacen parte
   de su sesión.
  </para>

  <para>
   Es bastante recomendable que incluya las definiciones de clase de todos
   esos objetos registrados en todas sus páginas, incluso si no va a usar
   realmente estas clases en todas sus páginas. Si no lo hace y un objeto
   está siendo decodificado sin que su definición de clase esté presente,
   perderá su asociación de clase y se convertirá en un objeto de la clase
   <literal>stdClass</literal> sin ninguna función disponible, es decir, se
   hará prácticamente inútil.
  </para>

  <para>
   De modo que si en el ejemplo anterior <varname>$a</varname> se hacía
   parte de una sesión ejecutando <literal>session_register("a")</literal>,
   debería incluírse el archivo <literal>clase_a.inc</literal> en todas sus
   páginas, no sólo en pagina1.php y pagina2.php.
  </para>
 </sect1>

 <sect1 xml:id="language.oop.magic-functions">
  <title>Las funciones mágicas <literal>__sleep</literal> y
  <literal>__wakeup</literal></title>

  <para>
   <function>serialize</function> revisa si su clase tiene una función con
   el nombre mágico <literal>__sleep</literal>. De ser así, esa función es
   ejecutada antes de cualquier intento de seriación. Puede limpiar el
   objeto y su intención es que devuelva una matriz con los nombres de todas
   las variables de ese objeto que deberían ser seriadas.
  </para>

  <para>
   El uso planeado para <literal>__sleep</literal> es aplicar o sincronizar
   datos pendientes o realizar tareas similares de limpieza. Asimismo, la
   función resulta útil si tiene objetos bastante grandes que no necesitan
   ser guardados en su totalidad.
  </para>

  <para>
   De forma semejante, <function>unserialize</function> revisa por la
   presencia de una función con el nombre mágico
   <literal>__wakeup</literal>. Si está presente, esta función puede
   reconstruir cualquier recurso que el objeto pueda tener.
  </para>

  <para>
   El uso planeado para <literal>__wakeup</literal> es reestablecer
   cualquier conexión con bases de datos que hayan podido perderse durante
   la seriación y realizar otras tareas de reinicialización.
  </para>
 </sect1>

 <sect1 xml:id="language.oop.newref">
   <title>Las referencias al interior del constructor</title>
   <para>
    Crear referencias al interior del constructor puede llevar a resultados
    confusos. Esta sección tipo-tutorial le ayuda a evitar problemas.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Foo {
    function Foo($nombre) {
        // crear una referencia al interior de la matriz global $refglobal
        global $refglobal;
        $refglobal[] = &$this;
        // definir el nombre al valor pasado
        $this->definirNombre($nombre);
        // e imprimirlo
        $this->imprimirNombre();
    }

    function imprimirNombre() {
        echo "<br />", $this->nombre;
    }

    function definirNombre($nombre) {
        $this->nombre = $nombre;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>

   <para>
    Revisemos si existe una diferencia entre <varname>$bar1</varname>, que
    ha sido creado usando el operador de copia <literal>=</literal> y
    <varname>$bar2</varname> que ha sido creado usando el operador de
    referencia <literal>=&amp;</literal>...
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bar1 = new Foo('definido en el constructor');
$bar1->imprimirNombre();
$refglobal[0]->imprimirNombre();

/* salida:
definido en el constructor
definido en el constructor
definido en el constructor */

$bar2 =& new Foo('definido en el constructor');
$bar2->imprimirNombre();
$refglobal[1]->imprimirNombre();

/* salida:
definido en el constructor
definido en el constructor
definido en el constructor */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Aparentemente no hay ninguna diferencia, pero en realidad hay una
    bastante importante: <varname>$bar1</varname> y
    <varname>$refglobal[0]</varname> _NO_ son referenciados, NO son la misma
    variable. Esto se debe a que "new" no devuelve una referencia por
    defecto, en su lugar devuelve una copia.
    <note>
     <simpara>
      No existe una pérdida de rendimiento (ya que desde PHP 4 se usa el
      conteo de referencias) al devolver copias en lugar de referencias. Al
      contrario, con frecuencia es mejor trabajar simplemente con copias en
      lugar de referencias, ya que crear referencias toma cierto tiempo
      mientras que crear copias prácticamente no toma nada de tiempo (a
      menos que ninguna de ellas sea una matriz u objeto grande y una de
      ellas se modifique y luego las otras subsecuentemente, entonces sería
      buena idea usar referencias para modificarlas todas al mismo tiempo).
     </simpara>
    </note>
    Para probar lo que se dice más arriba, veamos el siguiente código.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// ahora cambiaremos el nombre. ¿qué espera que pase?
// puede que espere que tanto $bar1 como $refglobal[0] cambien sus nombres...
$bar1->definirNombre('definido desde afuera');

// como se ha mencionado antes, ese no es el caso.
$bar1->imprimirNombre();
$refglobal[0]->imprimirNombre();

/* salida:
definido desde afuera
definido en el constructor */

// veamos qué cambia entre $bar2 y $refglobal[1]
$bar2->definirNombre('definido desde afuera');

// por suerte, no solo son iguales, son la misma variable, de modo que
// $bar2->nombre y $refglobal[1]->nombre son el mismo también
$bar2->imprimirNombre();
$refglobal[1]->imprimirNombre();

/* salida:
definido desde afuera
definido desde afuera */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   Otro ejemplo final, intente entenderlo.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class A {
    function A($i) {
        $this->valor = $i;
        // intente descubrir porqué no necesitamos una referencia aquí
        $this->b = new B($this);
    }

    function crearRef() {
        $this->c = new B($this);
    }

    function echoValor() {
        echo "<br />","clase ",get_class($this),': ',$this->valor;
    }
}


class B {
    function B(&$a) {
        $this->a = &$a;
    }

    function echoValor() {
        echo "<br />","clase ",get_class($this),': ',$this->a->valor;
    }
}

// intente entender porqué usar una simple copia produciría
// un resultado no deseado en la línea marcada con *
$a =& new A(10);
$a->crearRef();

$a->echoValor();
$a->b->echoValor();
$a->c->echoValor();

$a->valor = 11;

$a->echoValor();
$a->b->echoValor(); // *
$a->c->echoValor();

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
clase A: 10
clase B: 10
clase B: 10
clase A: 11
clase B: 11
clase B: 11
]]>
     </screen>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="language.oop.object-comparison">
   <title>Comparación de objetos</title>
  <para>
   En PHP 4, los objetos son comparados en una forma muy simple: Dos
   instancias de objeto son iguales si tienen los mismos atributos y
   valores, y son instancias de la misma clase. Reglas similares se aplican
   cuando se comparan dos objetos usando el operador de identidad
   (<literal>===</literal>).
  </para>
  <para>
   Si ejecutáramos el código del siguiente ejemplo:
   <example>
    <title>Ejemplo de comparación de objetos en PHP 4</title>
    <programlisting role='php'>
<![CDATA[
<?php
function bool_a_cadena($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function compararObjetos(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool_a_cadena($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool_a_cadena($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool_a_cadena($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool_a_cadena($o1 !== $o2)."\n";
}

class Bandera {
    var $bandera;

    function Bandera($bandera=true) {
            $this->bandera = $bandera;
    }
}

class BanderaCambiante extends Bandera {

    function encender() {
        $this->bandera = true;
    }

    function apagar() {
        $this->bandera = false;
    }
}

$o = new Bandera();
$p = new Bandera(false);
$q = new Bandera();

$r = new BanderaCambiante();

echo "Comparar instancias creadas con los mismos parámetros\n";
compararObjetos($o, $q);

echo "\nComparar instancias creadas con parámetros diferentes\n";
compararObjetos($o, $p);

echo "\nComparar una instancia de una clase padre con una de una subclase\n";
compararObjetos($o, $r);
?>
]]>
    </programlisting>
    &example.outputs;
   <screen>
<![CDATA[
Comparar instancias creadas con los mismos parámetros
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Comparar instancias creadas con parámetros diferentes
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Comparar una instancia de una clase padre con una de una subclase
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
]]>
    </screen>
   </example>
   Que es la salida que podemos esperar dadas las reglas de comparación
   descritas anteriormente. Solo las instancias con los mismos valores para
   sus atributos y de la misma clase son consideradas iguales e idénticas.
  </para>
  <para>
   Incluso en los casos en donde tenemos composición de objetos, se aplican
   las mismas reglas de comparación. En el ejemplo siguiente creamos una
   clase contenedora que almacena una matriz asociativa de objetos
   <classname>Bandera</classname>.
   <example>
    <title>Comparación de objetos compuestos en PHP 4</title>
    <programlisting role='php'>
<![CDATA[
<?php
class ConjuntoBanderas {
    var $conjunto;

    function ConjuntoBanderas($matrizBanderas = array()) {
        $this->conjunto = $matrizBanderas;
    }

    function agregarBandera($nombre, $bandera) {
        $this->conjunto[$nombre] = $bandera;
    }

    function eliminarBandera($nombre) {
        if (array_key_exists($nombre, $this->conjunto)) {
            unset($this->conjunto[$nombre]);
        }
    }
}


$u = new ConjuntoBanderas();
$u->agregarBandera('bandera1', $o);
$u->agregarBandera('bandera2', $p);
$v = new ConjuntoBanderas(array('bandera1'=>$q, 'bandera2'=>$p));
$w = new ConjuntoBanderas(array('bandera1'=>$q));

echo "\nObjetos compuestos u(o,p) y v(q,p)\n";
compararObjetos($u, $v);

echo "\nu(o,p) y w(q)\n";
compararObjetos($u, $w);
?>
]]>
    </programlisting>
    &example.outputs;
   <screen>
<![CDATA[
Objetos compuestos u(o,p) y v(q,p)
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

u(o,p) y w(q)
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
]]>
    </screen>
   </example>
  </para>
 </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
