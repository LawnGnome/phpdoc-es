<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
<!-- EN-Revision: n/a Maintainer: webstudio Status: ready -->
 <chapter xml:id="language.references" xmlns="http://docbook.org/ns/docbook">
  <title>Explicando las Referencias</title>
   <sect1 xml:id="language.references.whatare">
    <title>What References Are</title>
    <simpara>  
		Las Referencias en PHP son un medio para acceder al mismo
		contenido de una variable pero con diferentes nombres. No son
		como los punteros de C, sino que son alias en la tabla de s&iacute;mbolos.
		Hay que tener en cuenta, que en PHP el nombre de una variable y
		el contenido de una variable son diferentes, de manera que el 
		mismo contenido, puede tener varios nombres.
		La analog&iacute;a m&aacute;s cercana podr&iacute;a ser la de los archivos de Unix
		y sus nombres, d&oacute;nde los nombres de las variables ser&iacute;an los
		directorios, y el contenido de las variables es el archivo en si.
		Las referencias tambi&eacute;n pueden ser pensadas como un enlace 
		duro en un sistema de archivos Unix.
		 </simpara>
	</sect1>
	<sect1 xml:id="language.references.whatdo">
		<title>Lo que las Referencias son</title>
		<para>
		Las Referencias en PHP te permiten lograr que dos variables &quot;apunten&quot;
		al mismo contenido. Cuando haces algo como:
    <informalexample>
				<programlisting role="php"><![CDATA[
$a =& $b 
]]></programlisting>
			</informalexample>
    significa que <varname>$a</varname> y <varname>$b</varname>
    apuntan a la misma variable.
	<note>
				<para>
					<varname>$a</varname> y <varname>$b</varname> son completamente iguales, no es que <varname>$a</varname> est&eacute; apuntando a 
      			<varname>$b</varname> o viceversa, sino que tanto 
      			<varname>$a</varname> como <varname>$b</varname> apuntan al mismo lugar.
     		</para>
			</note>
		</para>
		<para>
   La misma sint&aacute;xis puede ser utilizada con funciones, que devuelven Referencias,
   y con el operador <literal>new</literal> (en PHP 4.0.4 o superior):
<informalexample>
				<programlisting role="php"><![CDATA[
$bar =& new fooclass();
$foo =& find_var ($bar);
]]></programlisting>
			</informalexample>
		</para>
		<note>
			<para>
			El no utilizar el operador <literal>&amp;</literal> causa que
			el objeto sea copiado en memoria. Si utilizamos <literal>$this</literal>
			en la clase, entonces actuaremos sobre la instancia actual de
			la clase. Las asignaciones sin  <literal>&amp;</literal> har&aacute;n una
			copia de la instancia (por ejemplo, del objeto) y <literal>$this</literal>
			operar&aacute; en la copia, lo que no siempre es el comportamiento
			deseado. Usualmente se desea utilizar una sola instancia, debido
			a razones de memoria y performance de la aplicaci&oacute;n.
			</para>
			<para>
			Mientras que se puede utilizar <literal>@</literal> para 
			<emphasis>silenciar</emphasis> cualquier error en el constructor
			utilizando <literal>@new</literal>, esto no funciona cuando
			utilizamos <literal>&amp;new</literal>. Esto es una limitaci&oacute;n
			del Zend Engine y por lo tanto, resultar&aacute; en un error de sint&aacute;xis.
     </para>
		</note>
		<para>
		Otro uso que se le puede dar a las referencias es el traspaso de variables
		por-referencia. Esto se logra haciendo que una variable 'local' a la 
		funci&oacute;n y una variable en el script 'referencien' al mismo contenido.
		Por ejemplo:
    <informalexample>
				<programlisting role="php"><![CDATA[
function foo (&$var)
{
    $var++;
}

$a=5;
foo ($a);
]]></programlisting>
			</informalexample>
    har&aacute; que <varname>$a</varname> valga 6. Esto es posible porque en 
    la funci&oacute; <varname>foo</varname>, la variable <varname>$var</varname>
    'referencia' al mismo contenido que la variable <varname>$a</varname>. M&aacute;s
     informaci&oacute;n acerca de <link linkend="language.references.pass">paso por referencia</link>.
   </para>
		<simpara>
    Un tercer uso de las referencias es el <link linkend="language.references.return">retorno por referencia</link>.
   </simpara>
	</sect1>
	<sect1 xml:id="language.references.arent">
		<title>Lo que las Referencias no son</title>
		<para>
		Como se ha mencionado antes, las Referencias NO son punteros.
		Esto significa que el siguiente ejemplo no har&aacute; lo que se espera:
    <informalexample>
				<programlisting role="php"><![CDATA[
function foo (&$var)
{
    $var =& $GLOBALS["baz"];
}
foo($bar); 
]]></programlisting>
			</informalexample>
		</para>
		<simpara>
		Lo que ocurrir&aacute; aqu&iacute; es que <varname>$var</varname> en <varname>foo</varname>
		ser&aacute; 'ligada' con <varname>$bar</varname> al momento de llamar a la funci&oacute;n.
		Pero luego ser&aacute; 're-ligada' con <varname>$GLOBALS["baz"]</varname>. No existe
		manera de ligar <varname>$bar</varname> en el &aacute;mbito global del script con alguna
		otra cosa utilizando el mecanismo de Referencias, ya que <varname>$bar</varname>
		no existe dentro de <varname>foo</varname> (est&aacute; representado por <varname>$var</varname>,
		 pero <varname>$var</varname> solo est&aacute; ligado por el contenido, no por el nombre
		 en la tabla de s&iacute;mbolos).
   </simpara>
	</sect1>
	<sect1 xml:id="language.references.pass">
		<title>Paso de variables por Referencia</title>
		<para>
		Podemos pasar variables a una funci&oacute;n por referencia, para que &eacute;sta pueda modificar
		sus argumentos. La sint&aacute;xis es la siguiente :
    <informalexample>
				<programlisting role="php"><![CDATA[
function foo (&$var)
{
    $var++;
}

$a=5;
foo ($a);
// $a ser&aacute; 6 aqui
]]></programlisting>
			</informalexample>
		Notar que no hay signo de referencia en la llamada a la funci&oacute;n - 
		solo en la definici&oacute;n de la misma. Colocar el signo de referencia
		solo en la definici&oacute;n de la funci&oacute;n alcanza para pasar correctamente
		el argumento por referencia.
  </para>
		<para>
		La lista siguiente indica que puede ser pasado por referencia:
   <itemizedlist>
				<listitem>
					<simpara>
      Variables, por ejemplo <literal>foo($a)</literal>
					</simpara>
				</listitem>
				<listitem>
					<simpara>
      Operador New, por ejemplo <literal>foo(new foobar())</literal>
					</simpara>
				</listitem>
				<listitem>
					<para>
					Referencias, devueltas por una funci&oacute;n: 
    <informalexample>
							<programlisting role="php"><![CDATA[
function &bar()
{
    $a = 5;
    return $a;
}
foo(bar());
]]></programlisting>
						</informalexample>
    Se recomienda leer tambi&eacute;n la explicaci&oacute;n sobre <link linkend="language.references.return">retorno por referencia</link>. 
     </para>
				</listitem>
			</itemizedlist>
		</para>
		<para>
		Cualquier otro tipo de expresi&oacute;n no deber&iacute;a pasarse por referencia,
		ya que el resultado ser&iacute;a indefinido. Los ejemplos de paso 
		por referencia siguientes son inv&aacute;lidos:
	<informalexample>
		<programlisting role="php"><![CDATA[
function bar() // Notar que falta &
{
    $a = 5;
    return $a;
}
foo(bar());

foo($a = 5) // Expresi&oacute;n, no variable
foo(5) // Constante, no variable
]]>
		</programlisting>
	</informalexample>
		Estos requerimientos son para PHP 4.0.4 y superior.
  </para>
	</sect1>
	<sect1 xml:id="language.references.return">
		<title>Retorno por Referencia</title>
		<para>
		Devolver por Referencia es muy &uacute;til cuando se quiere utilizar una funci&oacute;n
		para averiguar a que variable debe estar una referencia ligada. Cuando
		se devuelve por referencia, se debe utilizar esta sint&aacute;xis:
	<informalexample>
				<programlisting role="php"><![CDATA[
function &encontrar_var ($param)
{
    ...codigo...
    return $var_encontrada;
}

$foo =& encontrar_var ($bar);
$foo->x = 2; 
]]></programlisting>
	</informalexample>
	En este ejemplo, el atributo del objeto devuelto por la funci&oacute;n
	<varname>encontrar_var</varname> fue asignado, no ya en 
	la copia, como habr&iacute;a sucedido si no se utilizaba la sint&aacute;xis de 
	referencias.
   </para>
		<note>
			<simpara>
	A diferencia del paso de par&aacute;metros, aqu&iacute; se debe utilizar
	<literal>&amp;</literal> en ambos lugares - para indicar que
	se pretende devolver por referencia ( y no una copia, como
	usualmente sucede) y que adem&aacute;s esa referencia sea
	'ligada' a una variable, y no solo asignada.
    </simpara>
		</note>
	</sect1>
	<sect1 xml:id="language.references.unset">
		<title>Borrando Referencias</title>
		<para>
		Cuando de borra una referencia, solo se rompe esa uni&oacute;n entre
		el nombre de la variable y el contenido. Esto no significa que el contenido
		haya sido destruido. Por ejemplo :
    <informalexample>
				<programlisting role="php"><![CDATA[
$a = 1;
$b =& $a;
unset ($a); 
]]></programlisting>
			</informalexample>
    no destruir&iacute;a <varname>$b</varname>, solo <varname>$a</varname>. 
   </para>
		<simpara>
		Nuevamente, ser&iacute;a &uacute;til pensar el tema de las referencias como una
		analog&iacute;a al comando <command>unlink</command> de Unix.
   </simpara>
	</sect1>
	<sect1 xml:id="language.references.spot">
		<title>M&aacute;s Referencias</title>
		<simpara>
		Muchas construcciones sint&aacute;cticas en PHP son implementadas utilizando
		el mecanismo referencial, de manera que todo lo dicho anteriormente sobre
		las referencias tambi&eacute;n se aplica a estas construcciones. Algunas de ellas,
		como pasar o retornar por referencia, se mencionaron antes. Otras 
		construcciones que utilizan referencias son:
   </simpara>
		<sect2 xml:id="references.global">
			<title>
				Referencias <literal>globales</literal></title>
			<para>
			Cuando declaramos una variable como <command>global $var</command>
			en realidad estamos creando una referencia a una variable global. Esto 
			significa, que es lo mismo que hacer :
     <informalexample>
					<programlisting role="php"><![CDATA[
$var =& $GLOBALS["var"];
]]></programlisting>
				</informalexample>
			</para>
			<simpara>
			De esta manera, por ejemplo, si borramos <varname>$var</varname>
			no estar&iacute;amos borrando la variable global.
    </simpara>
		</sect2>
		<sect2 xml:id="references.this">
			<title>
				<literal>$this</literal>
			</title>
			<simpara>
			En un m&eacute;todo de objeto, <varname>$this</varname> es siempre una
			referencia al objeto que contiene el m&eacute;todo.
    </simpara>
		</sect2>
	</sect1>
 </chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
