<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.6 $ -->
<chapter id="language.references">
	<title>Explicando las Referencias</title>
	<sect1 id="language.references.whatare">
		<title>What References Are</title>
		<simpara>  
		Las Referencias en PHP son un medio para acceder al mismo
		contenido de una variable pero con diferentes nombres. No son
		como los punteros de C, sino que son alias en la tabla de s&iacute;mbolos.
		Hay que tener en cuenta, que en PHP el nombre de una variable y
		el contenido de una variable son diferentes, de manera que el 
		mismo contenido, puede tener varios nombres.
		La analog&iacute;a m&aacute;s cercana podr&iacute;a ser la de los archivos de Unix
		y sus nombres, d&oacute;nde los nombres de las variables ser&iacute;an los
		directorios, y el contenido de las variables es el archivo en si.
		Las referencias tambi&eacute;n pueden ser pensadas como un enlace 
		duro en un sistema de archivos Unix.
		 </simpara>
	</sect1>
	<sect1 id="language.references.whatdo">
		<title>Lo que las Referencias son</title>
		<para>
		Las Referencias en PHP te permiten lograr que dos variables &quot;apunten&quot;
		al mismo contenido. Cuando haces algo como:
    <informalexample>
				<programlisting role="php"><![CDATA[
$a =& $b 
]]></programlisting>
			</informalexample>
    significa que <varname>$a</varname> y <varname>$b</varname>
    apuntan a la misma variable.
	<note>
		<para>
			<varname>$a</varname> y <varname>$b</varname> son completamente iguales, no es que <varname>$a</varname> esté apuntando a 
      			<varname>$b</varname> o viceversa, sino que tanto 
      			<varname>$a</varname> como <varname>$b</varname> apuntan al mismo lugar.
     		</para>
	</note>
		</para>
		<para>
   La misma sintaxis puede ser utilizada con funciones, que devuelven Referencias,
   y con el operador <literal>new</literal> (en PHP 4.0.4 o mayor):
<informalexample>
	<programlisting role="php"><![CDATA[
$bar =& new fooclass();
$foo =& find_var ($bar);
]]></programlisting>
</informalexample>
		</para>
		<note>
			<para>
     Not using the <literal>&amp;</literal> operator causes a copy of the
     object to be made. If you use <literal>$this</literal> in the class it
     will operate on the current instance of the class. The assignment without
     <literal>&amp;</literal> will copy the instance (i.e. the object) and
     <literal>$this</literal> will operate on the copy, which is not always
     what is desired. Usually you want to have a single instance to work with,
     due to performance and memory consumption issues.
     </para>
			<para>
      While you can use the <literal>@</literal> operator to
      <emphasis>mute</emphasis> any errors in the constructor when using it as
      <literal>@new</literal>, this does not work when using the
      <literal>&amp;new</literal> statement. This is a limitation of the Zend
      Engine and will therefore result in a parser error.
     </para>
		</note>
		<para>
    The second thing references do is to pass variables
    by-reference. This is done by making a local variable in a function and
    a variable in the calling scope reference to the same content. Example:
    <informalexample>
				<programlisting role="php"><![CDATA[
function foo (&$var)
{
    $var++;
}

$a=5;
foo ($a);
]]></programlisting>
			</informalexample>
    will make <varname>$a</varname> to be 6. This happens because in
    the function <varname>foo</varname> the variable
    <varname>$var</varname> refers to the same content as
    <varname>$a</varname>. See also more detailed explanations about <link linkend="language.references.pass">passing by reference</link>.
   </para>
		<simpara>
    The third thing reference can do is <link linkend="language.references.return">return by reference</link>.
   </simpara>
	</sect1>
	<sect1 id="language.references.arent">
		<title>What References Are Not</title>
		<para>
    As said before, references aren't pointers. That means, the
    following construct won't do what you expect:
    <informalexample>
				<programlisting role="php"><![CDATA[
function foo (&$var)
{
    $var =& $GLOBALS["baz"];
}
foo($bar); 
]]></programlisting>
			</informalexample>
		</para>
		<simpara>
    What happens is that <varname>$var</varname> in
    <varname>foo</varname> will be bound with
    <varname>$bar</varname> in caller, but then it will be
    re-bound with <varname>$GLOBALS["baz"]</varname>. There's no way
    to bind <varname>$bar</varname> in the calling scope to something else
    using the reference mechanism, since <varname>$bar</varname> is not
    available in the function <varname>foo</varname> (it is represented by
    <varname>$var</varname>, but <varname>$var</varname> has only
    variable contents and not name-to-value binding in the calling
    symbol table).
   </simpara>
	</sect1>
	<sect1 id="language.references.pass">
		<title>Passing by Reference</title>
		<para>
   You can pass variable to function by reference, so that function could modify
   its arguments. The syntax is as follows:
    <informalexample>
				<programlisting role="php"><![CDATA[
function foo (&$var)
{
    $var++;
}

$a=5;
foo ($a);
// $a is 6 here
]]></programlisting>
			</informalexample>
  Note that there's no reference sign on function call - only on
  function definition. Function definition alone is enough to
  correctly pass the argument by reference. 
  </para>
		<para>
  Following things can be passed by reference:
   <itemizedlist>
				<listitem>
					<simpara>
      Variable, i.e. <literal>foo($a)</literal>
					</simpara>
				</listitem>
				<listitem>
					<simpara>
      New statement, i.e. <literal>foo(new foobar())</literal>
					</simpara>
				</listitem>
				<listitem>
					<para>
      Reference, returned from a function, i.e.:
    <informalexample>
							<programlisting role="php"><![CDATA[
function &bar()
{
    $a = 5;
    return $a;
}
foo(bar());
]]></programlisting>
						</informalexample>
    See also explanations about <link linkend="language.references.return">returning by reference</link>. 
     </para>
				</listitem>
			</itemizedlist>
		</para>
		<para>
  Any other expression should not be passed by reference, as the
  result is undefined. For example, the following examples of passing
  by reference are invalid:
    <informalexample>
				<programlisting role="php"><![CDATA[
function bar() // Note the missing &
{
    $a = 5;
    return $a;
}
foo(bar());

foo($a = 5) // Expression, not variable
foo(5) // Constant, not variable
]]></programlisting>
			</informalexample>
		These requirements are for PHP 4.0.4 and later.
  </para>
	</sect1>
	<sect1 id="language.references.return">
		<title>Returning References</title>
		<para>
    Returning by-reference is useful when you want to use a function
    to find which variable a reference should be bound to. When
    returning references, use this syntax:
    <informalexample>
				<programlisting role="php"><![CDATA[
function &find_var ($param)
{
    ...code...
    return $found_var;
}

$foo =& find_var ($bar);
$foo->x = 2; 
]]></programlisting>
			</informalexample>
    In this example, the property of the object returned by the
    <varname>find_var</varname> function would be set, not the
    copy, as it would be without using reference syntax.
   </para>
		<note>
			<simpara>
     Unlike parameter passing, here you have to use
     <literal>&amp;</literal> in both places - to indicate that you
     return by-reference, not a copy as usual, and to indicate that
     reference binding, rather than usual assignment, should be done
     for <varname>$foo</varname>.
    </simpara>
		</note>
	</sect1>
	<sect1 id="language.references.unset">
		<title>Unsetting References</title>
		<para>
    When you unset the reference, you just break the binding between
    variable name and variable content. This does not mean that
    variable content will be destroyed. For example:
    <informalexample>
				<programlisting role="php"><![CDATA[
$a = 1;
$b =& $a;
unset ($a); 
]]></programlisting>
			</informalexample>
    won't unset <varname>$b</varname>, just <varname>$a</varname>. 
   </para>
		<simpara>
    Again, it might be useful to think about this as analogous to Unix
    <command>unlink</command> call.
   </simpara>
	</sect1>
	<sect1 id="language.references.spot">
		<title>Spotting References</title>
		<simpara>
    Many syntax constructs in PHP are implemented via referencing
    mechanisms, so everything told above about reference binding also
    apply to these constructs. Some constructs, like passing and
    returning by-reference, are mentioned above. Other constructs that
    use references are:
   </simpara>
		<sect2 id="references.global">
			<title>
				<literal>global</literal> References</title>
			<para>
     When you declare variable as <command>global $var</command> you
     are in fact creating reference to a global variable. That means,
     this is the same as:
     <informalexample>
					<programlisting role="php"><![CDATA[
$var =& $GLOBALS["var"];
]]></programlisting>
				</informalexample>
			</para>
			<simpara>
     That means, for example, that unsetting <varname>$var</varname>
     won't unset global variable.
    </simpara>
		</sect2>
		<sect2 id="references.this">
			<title>
				<literal>$this</literal>
			</title>
			<simpara>
     In an object method, <varname>$this</varname> is always reference
     to the caller object.
    </simpara>
		</sect2>
	</sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
