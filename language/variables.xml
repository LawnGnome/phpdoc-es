 <chapter id="language.variables">
  <title>Variables</title>
  
  <sect1 id="language.variables.basics">
   <title>Conceptos Básicos</title>

   <para>
    En PHP las variables se representan como un signo de dólar seguido
    por el nombre de la variable. El nombre de la variable es sensible a
minúsculas y mayúsculas.
    <informalexample>
     <programlisting role="php"> 
$var = "Bob";
$Var = "Joe";
echo "$var, $Var"; // produce la salida "Bob, Joe"
     </programlisting>
    </informalexample>
   </para>
   <para>
    En PHP3, las variables siempre se asignan por valor. Esto significa que
    cuando se asigna una expresión a una variable, el valor íntegro de
    la expresión original se copia en la variable
    de destino. Esto quiere decir que, por ejemplo, después e asignar el
    valor de una variable a otra, los cambios que se efectúen a una de esas
    variables no afectará a la otra. Para más información sobre este tipo de
    asignación, vea <link
    linkend="language.expressions">Expresiones</link>.
   </para>
   <para>
    PHP4 ofrece otra forma de asignar valores a las variables:
    <emphasis>asignar por referencia</emphasis>. Esto significa que la nueva
    variable simplemente referencia (en otras palabras, "se convierte en un
    alias de" o "apunta a") la variable original. Los cambios a la nueva
    variable afectan a la original, y viceversa. Esto también significa que no
    se produce una copia de valores; por tanto, la asignación ocurre más
    rápidamente. De cualquier forma, cualquier incremento de velocidad se 
    notará sólo en los bucles críticos cuando se asignen grandes arrays u 
    objetos.
   </para>
   <para>
    Para asignar por referencia, simplemente se antepone un ampersand (&amp;) 
    al comienzo de la variable cuyo valor se está asignando (la variable
    fuente). Por ejemplo, el siguiente trozo de código produce la salida 'Mi
    nombre es Bob' dos veces:

    <informalexample>
     <programlisting role="php">
&lt;?php
$foo = 'Bob';              // Asigna el valor 'Bob' a $foo
$bar = &amp;$foo;              // Referencia $foo vía $bar.
$bar = "Mi nombre es $bar";  // Modifica $bar...
echo $foo;                 // $foo también se modifica.
echo $bar;
?&gt;
     </programlisting>
    </informalexample>
   </para>

   <para>
    Algo importante a tener en cuenta es que sólo las variables con nombre 
    pueden ser asignadas por referencia.
    <informalexample>
     <programlisting role="php">
&lt;?php
$foo = 25;
$bar = &amp;$foo;      // Esta es una asignación válida.
$bar = &amp;(24 * 7);  // Inválida; referencia una expresión sin nombre.

function test() {
   return 25;
}

$bar = &amp;test();    // Inválida.
?&gt;
     </programlisting>
    </informalexample>
   </para>

  </sect1>

  <sect1 id="language.variables.predefined">
   <title>Variables predefinidas</title>
   
   <simpara>
    PHP proporciona una gran cantidad de variables predefinidas a cualquier 
    script que se ejecute. De todas formas, muchas de esas variables no pueden 
    estar completamente documentadas ya que dependen de sobre qué servidor se 
    esté ejecutando, la versión y configuración de dicho servidor, y otros 
    factores. Algunas de estas variables no estarán disponibles cuando se 
    ejecute PHP desde la línea de comandos.
   </simpara>
   <simpara>
    A pesar de estos factores, aquí tenemos una lista de variables
    predefinidas disponibles en una instalación por defecto de PHP 3 
    corriendo como modulo de un <ulink url="&url.apache;">Apache</ulink> 1.3.6
    con su configuración también por defecto.
   </simpara>
   <simpara>
    Para una lista de variables predefinidas (y muchas más información útil), 
    por favor, vea (y use) <function>phpinfo</function>.
   </simpara>

   <note>
    <simpara>
     Esta lista no es exhaustiva ni pretende serlo. Simplemente es una guía de
     qué tipo de variables predefinidas se puede esperar tener disponibles en
     un script.
    </simpara>
   </note>

   <sect2 id="language.variables.predefined.apache">
    <title>Variables de Apache</title>

    <simpara>
     Estas variables son creadas por el servidor web <ulink
     url="&url.apache;">Apache</ulink>. Si se está utilizando
     otro servidor web, no hay garantía de que proporcione las
     mismas variables; pueden faltar algunas, o proporcionar otras no 
     listadas aquí. Dicho esto, también están presentes las variables de la
     <ulink url="&url.cgispec;">especificación CGI 1.1</ulink>, por lo que 
     también se deben tener en cuenta.
    </simpara>
    <simpara>
     Tenga en cuenta que unas pocas, como mucho, de estas variables van a estar
     disponibles (o simplemente tener sentido) si se ejecuta PHP desde la línea
     de comandos.
    </simpara>

    <para>
     <variablelist>
      <varlistentry>
       <term>GATEWAY_INTERFACE</term>
       <listitem>
	<simpara>
	 Qué revisión de la especificación CGI está usando el servidor;
	 por ejemplo 'CGI/1.1'.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>SERVER_NAME</term>
       <listitem>
	<simpara>
	 El nombre del equipo servidor en el que se está ejecutando el
	 script. Si el script se está ejecutando en un servidor virtual, este
	 será el valor definido para dicho servidor virtual.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>SERVER_SOFTWARE</term>
       <listitem>
	<simpara>
	 Una cadena de identificación del servidor, que aparece en las
	 cabeceras al responderse a las peticiones.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>SERVER_PROTOCOL</term>
       <listitem>
	<simpara>
	 Nombre y revisión del protocolo a través del que se solicitó
	 la página; p.ej. 'HTTP/1.0';
	</simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>REQUEST_METHOD</term>
       <listitem>
	<simpara>
	 Qué método de petición se usó para acceder a la página; p.ej. 'GET',
	 'HEAD', 'POST', 'PUT'.
	</simpara>
       </listitem>
      </varlistentry>
	  
      <varlistentry>
       <term>QUERY_STRING</term>
       <listitem>
	<simpara>
	 La cadena de la petición, si la hubo, mediante la que se accedió
	 a la página.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>DOCUMENT_ROOT</term>
       <listitem>
	<simpara>
	 El directorio raíz del documento bajo el que se ejecuta el script, 
	 tal y como está definido en el fichero de configuración del servidor.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>HTTP_ACCEPT</term>
       <listitem>
	<simpara>
	 Los contenidos de la cabecera <literal>Accept:</literal> de la
	 petición actual, si hay alguna.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>HTTP_ACCEPT_CHARSET</term>
       <listitem>
	<simpara>
	 Los contenidos de la cabecera <literal>Accept-Charset:</literal>
	 de la petición actual, si hay alguna. Por ejemplo:
	 'iso-8859-1,*,utf-8'.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>HTTP_ENCODING</term>
       <listitem>
	<simpara>
	 Los contenidos de la cabecera <literal>Accept-Encoding:</literal>
	 de la petición actual, si la hay. Por ejemplo: 'gzip'.
	</simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>HTTP_ACCEPT_LANGUAGE</term>
       <listitem>
	<simpara>
	 Los contenidos de la cabecera <literal>Accept-Language:</literal>
	 de la petición actual, si hay alguna. Por ejemplo: 'en'.
	</simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>HTTP_CONNECTION</term>
       <listitem>
	<simpara>
	 Los contenidos de la cabecera <literal>Connection:</literal> de
	 la petición actual, si hay alguna. Por ejemplo: 'Keep-Alive'.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>HTTP_HOST</term>
       <listitem>
	<simpara>
	 Los contenidos de la cabecera <literal>Host:</literal> de la
	 petición actual, si hay alguna.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>HTTP_REFERER</term>
       <listitem>
	<simpara>
	 La dirección de la página (si la hay) desde la que el navegador
	 saltó a la página actual. Esto lo establece el navegador del usuario; 
	 no todos los navegadores lo hacen.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>HTTP_USER_AGENT</term>
       <listitem>
	<simpara>
	 Los contenidos de la cabecera <literal>User_Agent:</literal> de
	 la petición actual, si hay alguna. Indica el navegador que se
	 está utilizando para ver la página actual; p.ej. 
	 <computeroutput>Mozilla/4.5 [en] (X11; U; Linux 
	 2.2.9 i586)</computeroutput>. Entre otras cosas, se puede usar
	 este valor con <function>get_browser</function> para adaptar
	 la funcionalidad de la página a las posibilidades del navegador
	 del usuario.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>REMOTE_ADDR</term>
       <listitem>
	<simpara>
	 La dirección IP desde la que el usuario está viendo la página 
	 actual.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>REMOTE_PORT</term>
       <listitem>
	<simpara>
	 El puerto que se está utilizando en la máquina del usuario para
	 comunicarse con el servidor web.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>SCRIPT_FILENAME</term>
       <listitem>
	<simpara>
	 La vía de acceso absoluta del script que se está ejecutando.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>SERVER_ADMIN</term>
       <listitem>
	<simpara>
	 El valor que se haya dado a la directiva SERVER_ADMIN (en Apache)
	 en el fichero de configuración del servidor web. Si el script se
	 está ejecutando en un servidor virtual, será el valor definido
	 para dicho servidor virtual.
	</simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>SERVER_PORT</term>
       <listitem>
	<simpara>
	 El puerto del equipo servidor que está usando el servidor web para
	 la comunicación. Para configuraciones por defecto, será '80';
	 al usar SSL, por ejemplo, cambiará al puerto que se haya definido
	 como seguro para HTTP.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>SERVER_SIGNATURE</term>
       <listitem>
	<simpara>
	 Una cadena que contiene la versión del servidor y el nombre del 
	 servidor virtual que es añadida a las páginas generadas por el
	 servidor, si está característica está activa.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>PATH_TRANSLATED</term>
       <listitem>
	<simpara>
	 Vía de acceso basada en el sistema de ficheros- (no el directorio
	 raíz del documento-) del script en cuestión, después de que el
	 servidor haya hecho la conversión virtual-a-real.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>SCRIPT_NAME</term>
       <listitem>
	<simpara>
	 Contiene la vía de acceso del script actual. Es útil para páginas
	 que necesitan apuntar a sí mismas.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>REQUEST_URI</term>
       <listitem>
	<simpara>
	 La URI que se dió para acceder a esta página; por ejemplo, 
	 '/index.html'.
	</simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

   </sect2>

   <sect2 id="language.variables.predefined.environment">
    <title>Variables de entorno</title>

    <simpara>
     Estas variables se importan en el espacio de nombres global de PHP desde
     el entorno en el que se esté ejecutando el intérprete PHP. Muchas son
     proporcionadas por el intérprete de comandos en el que se está ejecutando
     PHP, y dado que a sistemas diferentes les gusta ejecutar diferentes tipos
     de intérpretes de comandos, es imposible hacer una lista definitiva. Por
     favor, mire la documentación de su intérprete de comandos para ver una
     lista de las variables de entorno definidas.
    </simpara>
    <simpara>
     Otras variables de entorno son las de CGI, que están ahí sin importar si
     PHP se está ejecutando como un módulo del servidor o como un intérprete
     CGI.
    </simpara>
	
   </sect2>

   <sect2 id="language.variables.predefined.php">
    <title>Variables de PHP</title>

    <simpara>
     Estas variables son creadas por el propio PHP.
    </simpara>

    <para>
     <variablelist>
      <varlistentry>
       <term>argv</term>
       <listitem>
	<simpara>
	 Array de argumentos pasados al script. Cuando el script se ejecuta
	 desde la línea de comandos, esto da un acceso, al estilo de C, a 
	 los parámetros pasados en línea de comandos. Cuando se le llama
	 mediante el método GET, contendrá la cadena de la petición.
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>argc</term>
       <listitem>
	<simpara>
	 Contiene el número de parámetros de la línea de comandos pasados
	 al script (si se ejecuta desde la línea de comandos).
	</simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>PHP_SELF</term>
       <listitem>
	<simpara>
	 El nombre del fichero que contiene el script que se esta 
	 ejecutando, relativo al directorio raíz de los documentos. 
	 Si PHP se está ejecutando como intérprete de línea de comandos,
	 esta variable no está disponible.
	</simpara>
       </listitem>
      </varlistentry>
	  
      <varlistentry>
       <term>HTTP_COOKIE_VARS</term>
       <listitem>
	<simpara>
	 Un array asociativo de variables pasadas al script actual
	 mediante cookies HTTP. Sólo está disponible si el seguimiento de
	 variables ha sido activado mediante la directiva de configuración 
	 <link linkend="ini.track-vars">track_vars</link> o la directiva 
	 <computeroutput>&lt;?php_track_vars?&gt;</computeroutput>.
	</simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>HTTP_GET_VARS</term>
       <listitem>
	<simpara>
	 Un array asociativo de variables pasadas al script actual mediante
	 el método HTTP GET. Sólo está disponible si --variable tracking--
	 ha sido activado mediante la directiva de configuración
	 <link linkend="ini.track-vars">track_vars</link> o la directiva
	 <computeroutput>&lt;?php_track_vars?&gt;</computeroutput>.
	</simpara>
       </listitem>
      </varlistentry>
	 
      <varlistentry>
       <term>HTTP_POST_VARS</term>
       <listitem>
	<simpara>
	 Un array asociativo de variables pasadas al script actual mediante
	 el método HTTP POST. Sólo está disponible si --variable tracking--
	 ha sido activado mediante la directiva de configuración
	 <link linkend="ini.track-vars">track_vars</link> o la directiva
	 <computeroutput>&lt;?php_track_vars?&gt;</computeroutput>.
	</simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
	
   </sect2>

  </sect1>


  <sect1 id="language.variables.scope">
   <title>Ambito de las variables</title>

   <simpara>
    El ámbito de una variable es el contexto dentro del que la variable está
    definida. La mayor parte de las variables PHP sólo tienen un ámbito
    simple. Este ámbito simple también abarca los ficheros incluidos y los
    requeridos. Por ejemplo:
   </simpara>
   <informalexample>
    <programlisting role="php">
$a = 1;
include "b.inc";
    </programlisting>
   </informalexample>
   <simpara>
    Aquí, la variable $a dentro del script incluido b.inc.  De todas formas, 
    dentro de las funciones definidas por el usuario aparece un ámbito local
    a la función.  Cualquier variables que se use dentro de una función está,
    por defecto, limitada al ámbito local de la función.  Por ejemplo:
   </simpara>
    
   <informalexample>
    <programlisting role="php"> 
$a = 1; /* ámbito global */ 

Function Test () { 
    echo $a; /* referencia a una variable de ámbito local */ 
} 

Test ();
    </programlisting>
   </informalexample>

   <simpara>
    Este script no producirá salida, ya que la orden echo utiliza una versión
    local de la variable $a, a la que no se ha asignado ningún valor en su
    ámbito.  Puede que usted note que hay una pequeña diferencia con el
    lenguaje C, en el que las variables globales están disponibles
    automáticamente dentro de la función a menos que sean expresamente
    sobreescritas por una definición local.  Esto puede causar algunos
    problemas, ya que la gente puede cambiar variables globales
    inadvertidamente.  En PHP, las variables globales deben ser declaradas
    globales dentro de la función si van a ser utilizadas dentro de dicha
    función. Veamos un ejemplo:</simpara>

   <informalexample>
    <programlisting role="php">
$a = 1;
$b = 2;

Function Sum () {
    global $a, $b;

    $b = $a + $b;
} 

Sum ();
echo $b;
    </programlisting>
   </informalexample>

   <simpara>
    El script anterior producirá la salida &quot;3&quot;. Al declarar $a y 
    $b globales dentro de la función, todas las referencias a tales variables
    se referirán a la versión global.  No hay límite al número de variables
    globales que se pueden manipular dentro de una función.
   </simpara>

   <simpara>
    Un segundo método para acceder a las variables desde un ámbito global es
    usando el array $GLOBALS propio de PHP3.  El ejemplo anterior se puede
    reescribir así:
   </simpara>

   <informalexample>
    <programlisting role="php">
$a = 1;
$b = 2;

Function Sum () {
    $GLOBALS["b"] = $GLOBALS["a"] + $GLOBALS["b"];
} 

Sum ();
echo $b;
    </programlisting>
   </informalexample>

   <simpara>
    El array $GLOBALS es un array asociativo con el nombre de la
    variable global como clave y los contenidos de dicha variable
    como el valor del elemento del array.
   </simpara>

   <simpara>
    Otra característica importante del ámbito de las variables es la
    variable <emphasis>static</emphasis>.  Una variable estática existe
    sólo en el ámbito local de la función, pero no pierde su valor
    cuando la ejecución del programa abandona este ámbito.  Consideremos
    el siguiente ejemplo:
   </simpara>

   <informalexample>
    <programlisting role="php">
Function Test () {
    $a = 0;
    echo $a;
    $a++;
}
    </programlisting>
   </informalexample>

   <simpara>
    Esta función tiene poca utilidad ya que cada vez que es llamada 
    asigna a $a el valor 0 y representa un &quot;0&quot;.  La sentencia
    $a++, que incrementa la variable, no sirve para nada, ya que en cuanto la
    función termina la variable $a desaparece.  Para hacer una función útil
    para contar, que no pierda la pista del valor actual del conteo, la
    variable $a debe declararse como estática:</simpara>

   <informalexample>
    <programlisting role="php">
Function Test () {
    static $a = 0;
    echo $a;
    $a++;
}
    </programlisting>
   </informalexample>

   <simpara>
    Ahora, cada vez que se llame a la función Test(), se representará el
    valor de $a y se incrementará.
   </simpara>

   <simpara>
    Las variables estáticas también proporcionan una forma de manejar
    funciones recursivas. Una función recursiva es la que se llama a sí misma.
    Se debe tener cuidado al escribir una función recursiva, ya que puede
    ocurrir que se llame a sí misma indefinidamente.  Hay que asegurarse
    de implementar una forma adecuada de terminar la recursión.  La siguiente
    función cuenta recursivamente hasta 10, usando la variable estática 
    $count para saber cuándo parar:
   </simpara>

   <informalexample>
    <programlisting role="php">
Function Test () {
    static $count = 0;

    $count++;
    echo $count;
    if ($count < 10) {
        Test ();
    }
    $count--;
}
    </programlisting>
   </informalexample>

  </sect1>

  <sect1 id="language.variables.variable">
   <title>Variables variables</title>

   <simpara>
    A veces es conveniente tener nombres de variables variables.  
    Dicho de otro modo, son nombres de variables que se pueden establecer
    y usar dinámicamente.  Una variable normal se establece con una
    sentencia como:
   </simpara>

   <informalexample>
    <programlisting role="php">
$a = "hello";
    </programlisting>
   </informalexample>

   <simpara>
    Una variable variable toma el valor de una variable y lo trata como
    el nombre de una variable.  En el ejemplo anterior,
    <emphasis>hello</emphasis>, se puede usar como el nombre de una variable
    utilizando dos signos de dólar. p.ej.
   </simpara>

   <informalexample>
    <programlisting role="php">
$$a = "world";
    </programlisting>
   </informalexample>

   <simpara>
    En este momento se han definido y almacenado dos variables en el
    árbol de símbolos de PHP: $a, que contiene "hello", y $hello, que
    contiene "world".  Es más, esta sentencia:
   </simpara>

   <informalexample>
    <programlisting role="php">
echo "$a ${$a}";
    </programlisting>
   </informalexample>

   <simpara>
    produce el mismo resultado que:
   </simpara>

   <informalexample>
    <programlisting>
echo "$a $hello";
    </programlisting>
   </informalexample>

   <simpara>
     p.ej. ambas producen el resultado: <emphasis>hello world</emphasis>.
   </simpara>

   <simpara>
    Para usar variables variables con arrays, hay que resolver
    un problema de ambigüedad.  Si se escribe $$a[1] el intérprete
    necesita saber si nos referimos a utilizar $a[1] como una variable,
    o si se pretendía utilizar $$a como variable y el índice [1] como índice
    de dicha variable.  La sintaxis para resolver esta ambiguedad es:
    ${$a[1]} para el primer caso y ${$a}[1] para el segundo.
   </simpara>
  
  </sect1>

  <sect1 id="language.variables.external">
   <title>Variables externas a PHP</title>

   <sect2 id="language.variables.external.form">
    <title>Formularios HTML (GET y POST)</title>

    <simpara>
     Cuando se envía un formulario a un script PHP, las variables de
     dicho formulario pasan a estar automáticamente disponibles en el
     script gracias a PHP. Por ejemplo, consideremos el siguiente
     formulario:
    </simpara>

    <para>
     <example>
      <title>Variables de formulario simples</title>
      <programlisting role="php">
&lt;form action="foo.php3" method="post">
    Name: &lt;input type="text" name="name">&lt;br>
    &lt;input type="submit">
&lt;/form>
      </programlisting>
     </example>
    </para>

    <simpara>
     Cuando es enviado, PHP creará la variable
     <computeroutput>$name</computeroutput>, que contendrá
     lo que sea que se introdujo en el campo <emphasis>Name:</emphasis>
     del formulario.
    </simpara>

    <simpara>
     PHP también maneja arrays en el contexto de variables de formularios,
     pero sólo en una dimensión. Se puede, por ejemplo, agrupar juntas
     variables relacionadas, o usar esta característica para recuperar
     valores de un campo select input múltiple:</simpara>

    <para>
     <example>
      <title>Variables de formulario más complejas</title>
      <programlisting role="php">
&lt;form action="array.php" method="post">
    Name: &lt;input type="text" name="personal[name]">&lt;br>
    Email: &lt;input type="text" name="personal[email]">&lt;br>
    Beer: &lt;br>
    &lt;select multiple name="beer[]">
        &lt;option value="warthog">Warthog
        &lt;option value="guinness">Guinness
        &lt;option value="stuttgarter">Stuttgarter Schwabenbr&auml;u
        &lt;/select>
    &lt;input type="submit">
&lt;/form>
      </programlisting>
     </example>
    </para>

    <simpara>
     Si la posibilidad de PHP de track_vars está activada, ya sea
     mediante la opción de configuración <link 
     linkend="ini.track-vars">track_vars</link> o mediante la directiva
     <computeroutput>&lt;?php_track_vars?&gt;</computeroutput>, las
     variables enviadas con los métodos POST o GET también se encontrarán
     en los arrays asociativos globales $HTTP_POST_VARS y $HTTP_GET_VARS.
    </simpara>

    <sect3>
     <title>IMAGE SUBMIT variable names</title>

     <simpara>
      Cuando se envía un formulario, es posible usar una imagen en vez
      del botón submit estándar con una etiqueta como:</simpara>

     <informalexample>
      <programlisting role="php">
&lt;input type=image src="image.gif" name="sub">
      </programlisting>
     </informalexample>

     <simpara>
      Cuando el usuario hace click en cualquier parte de la imagen, el
      formulario que la acompaña se transmitirá al servidor con dos
      variables adicionales, sub_x y sub_y. Estas contienen las coordenadas
      del click del usuario dentro de la imagen.  Los más experimentados 
      puede notar que los nombres de variable enviados por el navegador 
      contienen un guión en vez de un subrayado (guión bajo), pero PHP 
      convierte el guión en subrayado automáticamente.
     </simpara>
    </sect3>

   </sect2>

   <sect2 id="language.variables.external.cookies">
    <title>Cookies HTTP</title>

    <simpara>
     PHP soporta cookies de HTTP de forma transparente tal y como están
     definidas en en las <ulink url="&spec.cookies;">Netscape's Spec</ulink>.
     Las cookies son un mecanismo para almacenar datos en el navegador y así 
     rastrear o identificar a usuarios que vuelven.  Se pueden crear cookies
     usando la función <function>SetCookie</function>.  Las cookies son parte
     de la cabecera HTTP, así que se debe llamar a la función SetCookie antes
     de que se envíe cualquier salida al navegador.  Es la misma restricción
     que para la función <function>Header</function>.  Cualquier cookie que
     se reciba procedente del cliente será convertida automáticamente en
     una variable de PHP como con los datos en los métodos  GET y POST.</simpara>

    <simpara>
     Si se quieren asignar múltiples valores a una sola cookie, 
     basta con añadir <emphasis>[]</emphasis> al nombre de la.  
     Por ejemplo:
    </simpara>

    <informalexample>
     <programlisting role="php">
SetCookie ("MyCookie[]", "Testing", time()+3600);
     </programlisting>
    </informalexample>

    <simpara>
     Nótese que una cookie reemplazará a una cookie anterior que tuviese el
     mismo nombre en el navegador a menos que el camino (path) o el
     dominio fuesen diferentes.  Así, para una aplicación de carro de la
     compra se podría querer mantener un contador e ir pasándolo. P.ej.
    </simpara>

    <example>
     <title>SetCookie Example</title>
     <programlisting role="php">
$Count++;
SetCookie ("Count", $Count, time()+3600);
SetCookie ("Cart[$Count]", $item, time()+3600);
     </programlisting>
    </example>

   </sect2>

   <sect2 id="language.variables.external.environment">
    <title>Variables de entorno</title>

    <para>
     PHP hace accesibles las variables de entorno automáticamente 
     tratándolas como variables normales.
     
     <informalexample>
      <programlisting role="php">
echo $HOME;  /* Shows the HOME environment variable, if set. */
      </programlisting>
     </informalexample>
    </para>

    <para>
     Dado que la información que llega vía mecanismos GET, POST y Cookie 
     crean automáticamente variables de PHP, algunas veces es mejor
     leer variables del entorno explícitamente para asegurarse
     de que se está trabajando con la versión correcta.  La función
     <function>getenv</function> se puede usar para ello.  También
     se puede asignar un valor a una variable de entorno con la
     función <function>putenv</function>.
    </para>
   </sect2>

   <sect2>
    <title>Puntos en los nombres de variables de entrada</title>

    <para>
     Típicamente, PHP no altera los nombres de las variables cuando se 
     pasan a un script. De todas formas, hay que notar que el punto
     no es un carácter válido en el nombre de una variable PHP. 
     Por esta razón, mire esto:
     <programlisting role="php">
$varname.ext;  /* nombre de variable no válido */
     </programlisting>
     Lo que el intérprete ve es el nombre de una variable $varname, seguido
     por el operador de concatenación, y seguido por la prueba
     (es decir, una cadena sin entrecomillar que no coincide con ninguna
     palabra clave o reservada conocida) 'ext'. Obviamente, no se pretendía
     que fuese este el resultado.
    </para>

    <para>
     Por esta razón, es importante hacer notar que PHP reemplazará
     automáticamente cualquier punto en los nombres de variables de 
     entrada por guiones bajos (subrayados).
    </para>

   </sect2>

   <sect2>
    <title>Determinando los tipos de variables</title>

    <para>
     Dado que PHP determina los tipos de las variables y los convierte
     (generalmente) según necesita, no siempre resulta obvio de qué tipo
     es una variable dada en un momento concreto.  PHP incluye varias
     funciones que descubren de qué tipo es una variable. Son
     <function>gettype</function>, <function>is_long</function>,
     <function>is_double</function>, <function>is_string</function>,
     <function>is_array</function>, y
     <function>is_object</function>.
    </para>
   </sect2>

  </sect1>
     
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
