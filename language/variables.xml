<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.11 $ -->
<!-- EN-Revision: 1.63 Maintainer: rafael Status: ready -->

 <chapter id="language.variables">
 <title>Variables</title>
 
 <sect1 id="language.variables.basics">
  <title>Conceptos B&aacute;sicos</title>
  
  <simpara>
   En PHP las variables se representan como un signo de d&oacute;lar
   seguido por el nombre de la variable. El nombre de la variable es
   sensible a min&uacute;sculas y may&uacute;sculas.
  </simpara>
  
  <para>
   Los nombres de variables siguen las mismas reglas que otras
   etiquetas en PHP. Un nombre de variable valido tiene que empezar
   con una letra o una raya (underscore), seguido de cualquier n&uacute;mero
   de letras, n&uacute;meros y rayas. Como expresi&oacute;n regular se podria
   expresar como: '[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'
  </para>
  
  <note>
   <simpara>
    En nuestro caso, una letra es a-z, A-Z, y los caracteres ASCII del
    127 al 255 (0x7f-0xff).
   </simpara>
  </note>
  
  <para>
   <informalexample>
    <programlisting role="php"> 
<![CDATA[
<?php
$var = "Bob";
$Var = "Joe";
echo "$var, $Var";      // outputs "Bob, Joe"

$4site = 'not yet';     // invalid; starts with a number
$_4site = 'not yet';    // valid; starts with an underscore
$täyte = 'mansikka';    // valid; 'ä' is ASCII 228 (Extendido)
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   En PHP3, las variables siempre se asignan por valor. Esto significa
   que cuando se asigna una expresi&oacute;n a una variable, el valor
   &iacute;ntegro de la expresi&oacute;n original se copia en la
   variable de destino. Esto quiere decir que, por ejemplo,
   despu&eacute;s e asignar el valor de una variable a otra, los
   cambios que se efect&uacute;en a una de esas variables no
   afectar&aacute; a la otra. Para m&aacute;s informaci&oacute;n sobre
   este tipo de asignaci&oacute;n, vea <link
    linkend="language.expressions">Expresiones</link>.
  </para>
  <para>
   PHP4 ofrece otra forma de asignar valores a las variables:
   <emphasis>asignar por referencia</emphasis>. Esto significa que la
   nueva variable simplemente referencia (en otras palabras, "se
   convierte en un alias de" &oacute; "apunta a") la variable original. Los
   cambios a la nueva variable afectan a la original, y
   viceversa. Esto tambi&eacute;n significa que no se produce una
   copia de valores; por tanto, la asignaci&oacute;n ocurre m&aacute;s
   r&aacute;pidamente. De cualquier forma, cualquier incremento de
   velocidad se notar&aacute; s&oacute;lo en los bucles
   cr&iacute;ticos cuando se asignen grandes <link
   linkend="language.types.array">matrices</link> u <link
   linkend="language.types.object">objetos</link>.
  </para>
  <para>
   Para asignar por referencia, simplemente se antepone un
   ampersandsigno "&amp;" al comienzo de la variable cuyo valor se
   est&aacute; asignando (la variable fuente). Por ejemplo, el
   siguiente trozo de c&oacute;digo produce la salida 'Mi nombre es
   Bob' dos veces:

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$foo = 'Bob';              // Asigna el valor 'Bob' a $foo
$bar = &amp;$foo;              // Referencia $foo v&iacute;a $bar.
$bar = "Mi nombre es $bar";  // Modifica $bar...
echo $foo;                 // $foo tambi&eacute;n se modifica.
echo $bar;
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  
  <para>
   Algo importante a tener en cuenta es que s&oacute;lo las variables
   con nombre pueden ser asignadas por referencia.
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$foo = 25;
$bar = &amp;$foo;      // Esta es una asignaci&oacute;n v&aacute;lida.
$bar = &amp;(24 * 7);  // Inv&aacute;lida; referencia una expresi&oacute;n sin nombre.

function test() {
   return 25;
}

$bar = &amp;test();    // Inv&aacute;lida.
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  
 </sect1>
 
 <sect1 id="language.variables.predefined">
  <title>Variables predefinidas</title>
  
  <simpara>
   PHP proporciona una gran cantidad de variables predefinidas a
   cualquier script que se ejecute. De todas formas, muchas de esas
   variables no pueden estar completamente documentadas ya que
   dependen de sobre qu&eacute; servidor se est&eacute; ejecutando, la
   versi&oacute;n y configuraci&oacute;n de dicho servidor, y otros
   factores. Algunas de estas variables no estar&aacute;n disponibles
   cuando se ejecute PHP desde la <link
   linkend="features.commandline">l&iacute;nea de
   comandos</link>.Para obtener una lista de estas variables podeis
   consultar la secci&oacute;n <link
   linkend="reserved.variables">Variables predefinidas
   reservadas</link>.
   </simpara>

  <warning>
    <simpara>
    A partir de PHP 4.2.0, el valor por defecto de la directiva PHP
    <link linkend="ini.register-globals">register_globals</link> es
    <emphasis>off</emphasis> (desactivada). Este es un cambio
    importante en PHP. Teniendo register_globals
    <emphasis>off</emphasis> afecta el conjunto de variables
    predefinidas disponibles en el sistema. Por ejemplo, para obtener
    <varname>DOCUMENT_ROOT</varname> se usar&aacute;
    <varname>$_SERVER['DOCUMENT_ROOT']</varname> en vez de
    <varname>$DOCUMENT_ROOT</varname> &oacute; <varname>$_GET['id']</varname>
    de la URL <literal>http://www.example.com/test.php?id=3</literal>
    en vez de <varname>$id</varname> &oacute;
    <varname>$_ENV['HOME']</varname> en vez de
    <varname>$HOME</varname>.
   </simpara>
   <simpara>
    Para m&aacute;s informaci&oacute;n sobre este cambio, podeis consultar el
    apartado de configuraci&oacute;n sobre <link
     linkend="ini.register-globals">register_globals</link>, el
    cap&iacute;tulo sobre seguridad <link
     linkend="security.registerglobals">Usando "Register Globals"
    </link>, asi como los anuncios de lanzamiento de PHP <ulink
     url="&url.php.release4.1.0;">4.1.0 </ulink> y <ulink
     url="&url.php.release4.2.0;">4.2.0</ulink>
   </simpara>
   <simpara>
    El uso de las variables reservadas predefinidas en PHP, como <link
    linkend="language.variables.superglobals">matrices
     superglobales</link> es recomendable.
   </simpara>
  </warning>
  
   <simpara>
   A partir de PHP 4.1.0, PHP ofrece un conjunto adicional de matrices
   predefinidas, conteniendo variables del servidor web, el entorno y
   entradas del usuario. Estas nuevas matrices son un poco especiales
   porque son autom&aacute;ticamente globales. Por esta raz&oacute;n, son conocidas a
   menudo como "autoglobales" &oacute; "superglobales". Las superglobales se
   mencionan m&aacute;s abajo; sin embargo para una lista de sus contenidos y
   m&aacute;s informaci&oacute;n sobre variables predefinidas en PHP, consultar la
   secci&oacute;n <link linkend="reserved.variables">Variables predefinidas
   reservadas</link>. Podreis ver como las variables predefinidas
   antiguas (<varname>$HTTP_*_VARS</varname>) todav&iacute;a existen.

   &avail.register-long-arrays;
  </simpara>

  <note>
   <title>Variables variables</title>
   <para>
    Las superglobales no pueden usarse como <link
     linkend="language.variables.variable">variables variables</link>.
   </para>
  </note>
  
  <para>
   Si ciertas variables no son definidas en <link
    linkend="ini.variables-order">variables_order</link>, las matrices
   PHP predefinidas asociadas a estas, estar&aacute;n vacias.
  </para>

   <variablelist id="language.variables.superglobals">
    <title>PHP superglobales</title>
    <varlistentry>
     <term><link linkend="reserved.variables.globals">$GLOBALS</link></term>
     <listitem>
      <simpara>
      Contiene una referencia a cada variable disponible en el
      espectro de las variables del script. Las llaves de esta matriz
      son los nombres de las variables
      globales. <varname>$GLOBALS</varname> existe dese PHP 3.
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link linkend="reserved.variables.server">$_SERVER</link></term>
    <listitem>
     <simpara>
      Variables definidas por el servidor web &oacute; directamente
      relacionadas con el entorno en don el script se esta
      ejecutando. An&aacute;loga a la antigua matriz
      <varname>$HTTP_SERVER_VARS</varname> (la cual est&aacute; todav&iacute;a
      disponible, aunque no se use).
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link linkend="reserved.variables.get">$_GET</link></term>
    <listitem>
     <simpara>
      Variables proporcionadas al script por medio de HTTP GET.
      An&aacute;loga a la antigua matriz <varname>$HTTP_GET_VARS</varname>
      (la cual est&aacute; todav&iacute;a disponible, aunque no se use).
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link linkend="reserved.variables.post">$_POST</link></term>
    <listitem>
     <simpara>
       Variables proporcionadas al script por medio de HTTP POST.
      An&aacute;loga a la antigua matriz <varname>$HTTP_POST_VARS</varname>
      (la cual est&aacute; todav&iacute;a disponible, aunque no se use).
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link linkend="reserved.variables.cookies">$_COOKIE</link></term>
    <listitem>
     <simpara>
      Variables proporcionadas al script por medio de HTTP cookies.
      An&aacute;loga a la antigua matriz <varname>$HTTP_COOKIE_VARS</varname>
      (la cual est&aacute; todav&iacute;a disponible, aunque no se use).
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link linkend="reserved.variables.files">$_FILES</link></term>
    <listitem>
     <simpara>
      Variables proporcionadas al script por medio de la subida de
      ficheros via HTTP .  An&aacute;loga a la antigua matriz
      <varname>$HTTP_POST_FILES</varname> (la cual est&aacute; todav&iacute;a
      disponible, aunque no se use). Vea tambi&eacute;n <link
       linkend="features.file-upload.post-method">Subiendo ficheros por
       m&eacute;todo POST</link> para m&aacute;s informaci&oacute;n.
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link linkend="reserved.variables.environment">$_ENV</link></term>
    <listitem>
     <simpara>
      Variables proporcionadas al script por medio del entorno.
      An&aacute;loga a la antigua matriz <varname>$HTTP_ENV_VARS</varname>
      (la cual est&aacute; todav&iacute;a disponible, aunque no se use).
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link linkend="reserved.variables.request">$_REQUEST</link></term>
    <listitem>
     <simpara>
      Variables proporcionadas al script por medio de cuaquier
      mecanismo de entrada del usuario y por lo tanto no se puede
      confiar en ellas. La presencia y el orden en que aparecen las
      variables en esta matriz es definido por la directiva de
      configuraci&oacute;n <link
      linkend="ini.variables-order">variables_order</link>. Esta
      matriz no tiene un an&aacute;logo en versiones anteriores a PHP
      4.1.0. Vea tambi&eacute;n
      <function>import_request_variables</function>.
     </simpara>
     <note>
      <simpara>
       Cuando se utiliza la <link linkend="features.commandline">linea
	de comandos</link>, <varname>argv</varname> y
       <varname>argc</varname> <emphasis>no</emphasis> son incluidas
       aqu&iacute;; estas variables se podr&aacute;n encontrar en la matriz
      </simpara>
     </note> 
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link linkend="reserved.variables.session">$_SESSION</link></term>
    <listitem>
     <simpara>
      Variables registradas en la sesi&oacute;n del script.  An&aacute;loga a la
      antigua matriz <varname>$HTTP_SESSION_VARS</varname> (la cual
      est&aacute; todav&iacute;a disponible, aunque no se use). Vea tambi&eacute;n la
      secci&oacute;n <link linkend="ref.session">Funciones para el manejo de
      sessiones</link> para m&aacute;s informaci&oacute;n.
     </simpara>
    </listitem>
   </varlistentry>
  </variablelist>
  
 </sect1>
 

  <sect1 id="language.variables.scope">
  <title>Ambito de las variables</title>
  
  <simpara>
   El &aacute;mbito de una variable es el contexto dentro del que la
   variable est&aacute; definida. La mayor parte de las variables PHP
   s&oacute;lo tienen un &aacute;mbito simple. Este &aacute;mbito
   simple tambi&eacute;n abarca los ficheros incluidos y los
   requeridos. Por ejemplo:
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$a = 1;
include "b.inc";
?>
]]>
   </programlisting>
  </informalexample>
  <simpara>
   Aqu&iacute;, la variable <varname>$a</varname> dentro del script
    incluido <filename>b.inc</filename>.  De todas formas, dentro de las funciones
    definidas por el usuario aparece un &aacute;mbito local a la
    funci&oacute;n.  Cualquier variables que se use dentro de una
    funci&oacute;n est&aacute;, por defecto, limitada al &aacute;mbito
    local de la funci&oacute;n.  Por ejemplo:
   </simpara>
  
  <informalexample>
   <programlisting role="php"> 
<![CDATA[
<?php
$a = 1; /* global scope */ 

function Test()
{ 
    echo $a; /* reference to local scope variable */ 
} 

Test();
?>
]]>
   </programlisting>
  </informalexample>
  
  <simpara>
   Este script no producir&aacute; salida, ya que la orden echo
   utiliza una versi&oacute;n local de la variable
   <varname>$a</varname>, a la que no se ha asignado ning&uacute;n
   valor en su &aacute;mbito.  Puede que usted note que hay una
   peque&ntilde;a diferencia con el lenguaje C, en el que las
   variables globales est&aacute;n disponibles autom&aacute;ticamente
   dentro de la funci&oacute;n a menos que sean expresamente
   sobreescritas por una definici&oacute;n local.  Esto puede causar
   algunos problemas, ya que la gente puede cambiar variables globales
   inadvertidamente.  En PHP, las variables globales deben ser
   declaradas globales dentro de la funci&oacute;n si van a ser
   utilizadas dentro de dicha funci&oacute;n. Veamos un
   ejemplo:</simpara>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;

function Sum()
{
    global $a, $b;

    $b = $a + $b;
} 

Sum();
echo $b;
?>
]]>
   </programlisting>
  </informalexample>
  
   <simpara>
   El script anterior producir&aacute; la salida &quot;3&quot;. Al
   declarar <varname>$a</varname> y <varname>$b</varname> globales
   dentro de la funci&oacute;n, todas las referencias a tales
   variables se referir&aacute;n a la versi&oacute;n global.  No hay
   l&iacute;mite al n&uacute;mero de variables globales que se pueden
   manipular dentro de una funci&oacute;n.
  </simpara>
  
  <simpara>
   Un segundo m&eacute;todo para acceder a las variables desde un
   &aacute;mbito global es usando la matriz
   <varname>$GLOBALS</varname>.  El ejemplo anterior se puede
   reescribir as&iacute;:
   </simpara>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;

function Sum()
{
    $GLOBALS["b"] = $GLOBALS["a"] + $GLOBALS["b"];
} 

Sum();
echo $b;
?>
]]>
   </programlisting>
  </informalexample>
  
  <simpara>
   La matriz <varname>$GLOBALS</varname> es una matriz asociativa con
   el nombre de la variable global como clave y los contenidos de
   dicha variable como el valor del elemento de la
   matriz. <varname>$GLOBALS</varname> existe en cualquier &aacute;mbito,
   esto pasa porque $GLOBALS es una <link
   linkend="language.variables.superglobals">superglobal</link>. Aqui
   teneis un ejemplo que demuestra el poder de las superglobales:
  </simpara>
   
  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function test_global()
{
    // Most predefined variables aren't "super" and require 
    // 'global' to be available to the functions local scope.
    global $HTTP_POST_VARS;
    
    print $HTTP_POST_VARS['name'];
    
    // Superglobals are available in any scope and do 
    // not require 'global'.  Superglobals are available 
    // as of PHP 4.1.0
    print $_POST['name'];
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  
  <simpara>
   Otra caracter&iacute;stica importante del &aacute;mbito de las
   variables es la variable <emphasis>static</emphasis>.  Una variable
   est&aacute;tica existe s&oacute;lo en el &aacute;mbito local de la
   funci&oacute;n, pero no pierde su valor cuando la ejecuci&oacute;n
   del programa abandona este &aacute;mbito.  Consideremos el
   siguiente ejemplo:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function Test ()
{
    $a = 0;
    echo $a;
    $a++;
}
?>
]]>

   </programlisting>
  </informalexample>
  
  <simpara>
    Esta funci&oacute;n tiene poca utilidad ya que cada vez que es
    llamada asigna a <varname>$a</varname> el valor
    <literal>0</literal> y representa un &quot;0&quot;.  La sentencia
    <varname>$a</varname>++, que incrementa la variable, no sirve para
    nada, ya que en cuanto la funci&oacute;n termina la variable
    <varname>$a</varname> desaparece.  Para hacer una funci&oacute;n
    &uacute;til para contar, que no pierda la pista del valor actual
    del conteo, la variable <varname>$a</varname> debe declararse como
    est&aacute;tica:
  </simpara>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function Test()
{
    static $a = 0;
    echo $a;
    $a++;
}
?>
]]>
   </programlisting>
  </informalexample>
  
  <simpara>
   Ahora, cada vez que se llame a la funci&oacute;n Test(), se
   representar&aacute; el valor de <varname>$a</varname> y se
   incrementar&aacute;.
   </simpara>

   <simpara>
    Las variables est&aacute;ticas tambi&eacute;n proporcionan una
    forma de manejar funciones recursivas. Una funci&oacute;n
    recursiva es la que se llama a s&iacute; misma.  Se debe tener
    cuidado al escribir una funci&oacute;n recursiva, ya que puede
    ocurrir que se llame a s&iacute; misma indefinidamente.  Hay que
    asegurarse de implementar una forma adecuada de terminar la
    recursi&oacute;n.  La siguiente funci&oacute;n cuenta
    recursivamente hasta 10, usando la variable est&aacute;tica
    <varname>$count</varname> para saber cu&aacute;ndo parar:
   </simpara>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function Test()
{
    static $count = 0;

    $count++;
    echo $count;
    if ($count < 10) {
        Test ();
    }
    $count--;
}
?>
]]>
   </programlisting>
  </informalexample>

   <simpara>
   En motor Zend 1, utilizado por <literal>PHP4</literal>, implementa
   los modificadores <literal>static</literal> y
   <literal>global</literal> para variables en t&eacute;rminos de
   referencias. Por ejemplo, una variable global verdadera importada
   dentro del &aacute;mbito de una funci&oacute;n con <literal>global</literal>,
   crea una referencia a la variable global. Esto puede ser causa de
   un comportamiento inesperado, tal y como podemos comprobar en el
   siguiente ejemplo:
  </simpara>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function test_global_ref() {
    global $obj;
    $obj = &new stdclass;
}

function test_global_noref() {
    global $obj;
    $obj = new stdclass;
}

test_global_ref();
var_dump($obj);
test_global_noref();
var_dump($obj);
?>
]]>
   </programlisting>
  </informalexample>
  
  <simpara>
   Al ejecutar este ejemplo obtendremos la siguiente salida:
  </simpara>
  
  <screen>
NULL
object(stdClass)(0) {
}
  </screen>
  
  <simpara>
   Un comportamiento similar se aplica a
   <literal>static</literal>. Referencias no son guardadas
   est&aacute;ticamente.
  </simpara>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function &get_instance_ref() {
    static $obj;

    echo "Static object: ";
    var_dump($obj);
    if (!isset($obj)) {
        // Assign a reference to the static variable
        $obj = &new stdclass;
    }
    $obj->property++;
    return $obj;
}

function &get_instance_noref() {
    static $obj;

    echo "Static object: ";
    var_dump($obj);
    if (!isset($obj)) {
        // Assign the object to the static variable
        $obj = new stdclass;
    }
    $obj->property++;
    return $obj;
}

$obj1 = get_instance_ref();
$still_obj1 = get_instance_ref();
echo "\n";
$obj2 = get_instance_noref();
$still_obj2 = get_instance_noref();
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
   Al ejecutar este ejemplo obtendremos la siguiente salida:
  </simpara>
  
  <screen>
Static object: NULL
Static object: NULL

Static object: NULL
Static object: object(stdClass)(1) {
  ["property"]=>
  int(1)
}
  </screen>
  
   <simpara>
   Este ejemplo demuestra que al asignar una referencia a una variable
   est&aacute;tica, esta no es <emphasis>recordada</emphasis> cuando se
   invoca la funcion <literal>&amp;get_instance_ref()</literal> por
   segunda vez.
  </simpara>
  
  </sect1>

 <sect1 id="language.variables.variable">
  <title>Variables variables</title>
  
  <simpara>
   A veces es conveniente tener nombres de variables variables.  Dicho
   de otro modo, son nombres de variables que se pueden establecer y
   usar din&aacute;micamente.  Una variable normal se establece con
   una sentencia como:
   </simpara>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$a = "hello";
?>
]]>
   </programlisting>
  </informalexample>
  
  <simpara>
   Una variable variable toma el valor de una variable y lo trata como
   el nombre de una variable.  En el ejemplo anterior,
   <emphasis>hello</emphasis>, se puede usar como el nombre de una
   variable utilizando dos signos de d&oacute;lar. p.ej.
  </simpara>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$$a = "world";
?>
]]>
   </programlisting>
  </informalexample>
  
  <simpara>
   En este momento se han definido y almacenado dos variables en el
   &aacute;rbol de s&iacute;mbolos de PHP: <varname>$a</varname>, que
   contiene "hello", y <varname>$hello</varname>, que contiene
   "world".  Es m&aacute;s, esta sentencia:
  </simpara>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
echo "$a ${$a}";
?>
]]>
   </programlisting>
  </informalexample>
  
  <simpara>
   produce el mismo resultado que:
  </simpara>
  
  <informalexample>
   <programlisting>
<![CDATA[
<?php
echo "$a $hello";
?>
]]>
   </programlisting>
  </informalexample>
  
  <simpara>
   p.ej. ambas producen el resultado: <emphasis>hello
   world</emphasis>.
  </simpara>
  
   <simpara>
    Para usar variables variables con matrices, hay que resolver un
    problema de ambigüedad.  Si se escribe <varname>$$a[1]</varname>
    el int&eacute;rprete necesita saber si nos referimos a utilizar
    <varname>$a[1]</varname> como una variable, o si se
    pretend&iacute;a utilizar <varname>$$a</varname> como variable y
    el &iacute;ndice [1] como &iacute;ndice de dicha variable.  La
    sintaxis para resolver esta ambiguedad es:
    <varname>${$a[1]}</varname> para el primer caso y ${$a}[1] para el
    segundo.
   </simpara>
  
   <warning>
    <simpara>
    Tener en cuenta que variables variables no pueden usarse con <link
    linkend="language.variables.superglobals">Matrices
    superglobales</link>. Esto significa que no se pueden hacer cosas
    como <varname>${$_GET}</varname>. Si buscais un m&eacute;todo para
    manejar la disponibilidad de superglobales y las antiguas
    <varname>HTTP_*_VARS</varname>, podeis intentar <link
     linkend="language.references">referiros</link> a ellas.
   </simpara>
  </warning>

  </sect1>

 <sect1 id="language.variables.external">
  <title>Variables externas a PHP</title>
  
  <sect2 id="language.variables.external.form">
   <title>Formularios HTML (GET y POST)</title>
   
   <simpara>
    Cuando se env&iacute;a un formulario a un script PHP, las
    variables de dicho formulario pasan a estar autom&aacute;ticamente
    disponibles en el script gracias a PHP. Por ejemplo, consideremos
    el siguiente formulario:
   </simpara>
   
   <para>
    <example>
     <title>Variables de formulario simples</title>
     <programlisting role="php">
<![CDATA[
<form action="foo.php" method="POST">
    Name:  <input type="text" name="username"><br>
    Email: <input type="text" name="email"><br>
    <input type="submit" name="submit" value="Submit me!">
</form>
]]>
     </programlisting>
    </example>
   </para>
   
   <para>
    Dependiendo de tu configuraci&oacute;n y preferencias personales, existen
    muchas maneras de acceder a los datos de tus formularios
    HTML. Algunos ejemplos:
   </para>
   
   <para>
    <example>
     <title>Accediendo datos de un formulario simple HTML POST</title>
     <programlisting role="html">
<![CDATA[
<?php 
// Available since PHP 4.1.0

   print $_POST['username'];
   print $_REQUEST['username'];

   import_request_variables('p', 'p_');
   print $p_username;

// Available since PHP 3.  As of PHP 5.0.0, these long predefined
// variables can be disabled with the register_long_arrays directive.

   print $HTTP_POST_VARS['username'];

// Available if the PHP directive register_globals = on.  As of 
// PHP 4.2.0 the default value of register_globals = off.
// Using/relying on this method is not preferred.

   print $username;
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Usando un formulario GET es similar excepto en el uso de variables
    predefinidas, que en este caso ser&aacute;n del tipo GET. GET tambi&eacute;n se
    usa con QUERY_STRING (la informaci&oacute;n despues del s&iacute;mbolo '?' en
    una URL). Por ejemplo
    <literal>http://www.example.com/test.php?id=3</literal> contiene
    datos GET que son accesibles con
    <varname>$_GET['id']</varname>. Vea tambi&eacute;n <link
    linkend="reserved.variables.request">$_REQUEST</link> y
    <function>import_request_variables</function>.
   </para>
   
   <note>
    <para>
     <link linkend="language.variables.superglobals">Matrices
     superglobales</link>, como <varname>$_POST</varname>
     y<varname>$_GET</varname>, est&aacute;n disponibles desde PHP 4.1.0.
    </para>
   </note>
   
   <para>
    Como hemos dicho, antes de PHP 4.2.0, el valor por defecto de
     <link linkend="ini.register-globals">register_globals</link> era
     <emphasis>on</emphasis> (activado). Y, en PHP 3 estba siempre
     activado. La comunidad PHP anima a no confiar en esta directiva
     ya que es preferible asumir que tiene el valor
     <emphasis>off</emphasis> (desactivada) y programar teniendo en
    cuenta esto.
   </para>
   
   <note>
    <para>
     La directiva de configuraci&oacute;n <link
     linkend="ini.magic-quotes-gpc">magic_quotes_gpc</link> afecta a
     valores Get, Post y Cookie, Si esta activada (on) el valor (It's
     "PHP!") sera convertido automaticamente a (It\'s
     \"PHP!\"). "Escaping" es necesario en inserciones a bases de
     datos. Vea tambi&eacute;n <function>addslashes</function>,
     <function>stripslashes</function> y <link
      linkend="ini.magic-quotes-sybase">magic_quotes_sybase</link>.
    </para>
   </note>
    
    <simpara>
    PHP tambien entiende matrices en el contexto de variables de
    formularios. (vea la <link linkend="faq.html">faq
    relacionada</link>). Se puede, por ejemplo, agrupar juntas
    variables relacionadas &oacute; usar esta caracter&iacute;stica para obtener
    valores de una entrada "select2 m&uacute;ltiple. Por ejemplo, vamos a
    mandar un formulario asi mismo y a presentar los datos cuando se
    reciban:
    </simpara>


   <para>
    <example>
     <title>Variables de formulario m&aacute;s complejas</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($HTTP_POST_VARS['action'] == 'submitted') {
    print '<pre>';

    print_r($HTTP_POST_VARS);
    print '<a href="'. $HTTP_SERVER_VARS['PHP_SELF'] .'">Please try again</a>';

    print '</pre>';
} else {
?>
<form action="<?php echo $HTTP_SERVER_VARS['PHP_SELF']; ?>" method="POST">
    Name:  <input type="text" name="personal[name]"><br>
    Email: <input type="text" name="personal[email]"><br>
    Beer: <br>
    <select multiple name="beer[]">
        <option value="warthog">Warthog</option>
        <option value="guinness">Guinness</option>
        <option value="stuttgarter">Stuttgarter Schwabenbräu</option>
    </select><br>
    <input type="hidden" name="action" value="submitted">
    <input type="submit" name="submit" value="submit me!">
</form>
<?php
}
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <para>
    en PHP 3, el uso de matrices de variables de formularios est&aacute;
    limitado a matrices unidimensionales. En PHP 4, no existe esta
    restricci&oacute;n.
   </para>
   
   <sect3 id="language.variables.external.form.submit">
     <title>IMAGE SUBMIT variable names</title>

     <simpara>
     Cuando mandamos un formulario, es posible usar una imagen en vez
     del bot&oacute;n estandar de "mandar":
    </simpara>
    
    <informalexample>
     <programlisting role="html">
<![CDATA[
<input type="image" src="image.gif" name="sub">
]]>
     </programlisting>
    </informalexample>

     <simpara>
     Cuando el usuario hace click en cualquier parte de la imagen, el
     formulario que la acompa&ntilde;a se transmitir&aacute; al
     servidor con dos variables adicionales, sub_x y sub_y. Estas
     contienen las coordenadas del click del usuario dentro de la
     imagen.  Los m&aacute;s experimentados puede notar que los
     nombres de variable enviados por el navegador contienen un
     gui&oacute;n en vez de un subrayado (gui&oacute;n bajo), pero PHP
     convierte el gui&oacute;n en subrayado autom&aacute;ticamente.
     </simpara>
    </sect3>

   </sect2>

   <sect2 id="language.variables.external.cookies">
   <title>Cookies HTTP</title>
   
   <simpara>
    PHP soporta cookies de HTTP de forma transparente tal y como
    est&aacute;n definidas en en las <ulink
    url="&spec.cookies;">Netscape's Spec</ulink>.  Las cookies son un
    mecanismo para almacenar datos en el navegador y as&iacute;
    rastrear o identificar a usuarios que vuelven.  Se pueden crear
    cookies usando la funci&oacute;n <function>SetCookie</function>.
    Las cookies son parte de la cabecera HTTP, as&iacute; que se debe
    llamar a la funci&oacute;n SetCookie antes de que se env&iacute;e
    cualquier salida al navegador.  Es la misma restricci&oacute;n que
    para la funci&oacute;n <function>header</function>. Los datos de
    una cookie estan disponibles en la matriz con datos de cookies
    apropiada, tal como <varname>$_COOKIE</varname>,
    <varname>$HTTP_COOKIE_VARS</varname> y tambi&eacute;n en
    <varname>$_REQUEST</varname>. vea la funci&oacute;n
    <function>setcookie</function> para m&aacute;s detalles y ejemplos.
   </simpara>
   
   <simpara>
    Si se quieren asignar m&uacute;ltiples valores a una sola cookie,
    basta con a&ntilde;adir <emphasis>[]</emphasis> al nombre de la
    cookie para definirla como una matriz. Por ejemplo:
   </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
  setcookie("MyCookie[foo]", "Testing 1", time()+3600);
  setcookie("MyCookie[bar]", "Testing 2", time()+3600);
?>
]]>
    </programlisting>
   </informalexample>
   
   <simpara>
    Esto creara dos cookies separadas aunque MyCookie ser&aacute; una matriz
    simple en el script. Si se quiere definir una sola cookie con
    valores multiples, considerar primero el uso de la funci&oacute;n
    <function>serialize</function> &oacute; <function>explode</function> en
    el valor.
   </simpara>
   
   <simpara>
    N&oacute;tese que una cookie reemplazar&aacute; a una cookie
    anterior que tuviese el mismo nombre en el navegador a menos que
    el camino (path) o el dominio fuesen diferentes.  As&iacute;, para
    una aplicaci&oacute;n de carro de la compra se podr&iacute;a
    querer mantener un contador e ir pas&aacute;ndolo. P.ej.
    </simpara>

    <example>
    <title>Ejemplo SetCookie</title>
     <programlisting role="php">
<![CDATA[
<?php
$count++;
setcookie("count", $count, time()+3600);
setcookie("Cart[$count]", $item, time()+3600);
?>
]]>
    </programlisting>
   </example>
   
  </sect2>
  
  <sect2 id="language.variables.external.dot-in-names">
   <title>Puntos en los nombres de variables de entrada</title>
   
   <para>
    T&iacute;picamente, PHP no altera los nombres de las variables
    cuando se pasan a un script. De todas formas, hay que notar que el
    punto no es un car&aacute;cter v&aacute;lido en el nombre de una
    variable PHP.  Por esta raz&oacute;n:
     <programlisting role="php">
<![CDATA[
<?php
$varname.ext;  /* nombre de variable invalido */
?>
]]>
    </programlisting>
    Lo que el int&eacute;rprete ve es el nombre de una variable
    $varname, seguido por el operador de concatenaci&oacute;n, y
    seguido por la prueba (es decir, una cadena sin entrecomillar que
    no coincide con ninguna palabra clave o reservada conocida)
    'ext'. Obviamente, no se pretend&iacute;a que fuese este el
    resultado.
   </para>
   
   <para>
    Por esta raz&oacute;n, es importante hacer notar que PHP
    reemplazar&aacute; autom&aacute;ticamente cualquier punto en los
    nombres de variables de entrada por guiones bajos (subrayados).
   </para>
   
  </sect2>
  
  <sect2 id="language.variables.determining-type-of">
   <title>Determinando los tipos de variables</title>
   
   <para>
    Dado que PHP determina los tipos de las variables y los convierte
    (generalmente) seg&uacute;n lo necesita, no siempre resulta obvio
    de qu&eacute; tipo es una variable dada en un momento concreto.
    PHP incluye varias funciones que descubren de qu&eacute; tipo es
    una variable: <function>gettype</function>,
    <function>is_array</function>, <function>is_float</function>,
    <function>is_int</function>, <function>is_object</function>, y
    <function>is_string</function>.  Vea tambi&eacute;n el cap&iacute;tulo sobre <link
    linkend="language.types">Tipos</link>.
   </para>
  </sect2>

 </sect1>
 
 
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
