<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.13 $ -->
<!-- EN-Revision: 1.154 Maintainer: lboshell Status: ready -->
 <chapter id="language.types">
  <title>Tipos</title>

  <sect1 id="language.types.intro">
  <title>Introducci&oacute;n</title>

  <simpara>
   PHP soporta ocho tipos primitivos.
  </simpara>

  <para>
   Cuatro tipos escalares:
   <itemizedlist>

    <listitem>
     <simpara>
      <type>boolean</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>integer</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>float</type> (n&uacute;mero de punto-flotante,
      tambi&eacute;n conocido como '<type>double</type>')
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>string</type>
     </simpara>
    </listitem>

   </itemizedlist>
   Dos tipos compuestos:
   <itemizedlist>

    <listitem>
     <simpara>
      <type>array</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>object</type>
     </simpara>
    </listitem>

   </itemizedlist>
   Y finalmente dos tipos especiales:
   <itemizedlist>

    <listitem>
     <simpara>
      <type>resource</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>NULL</type>
     </simpara>
    </listitem>

   </itemizedlist>
   Este manual introduce tambi&eacute;n algunos <link
   linkend="language.pseudo-types">pseudo-tipos</link> por razones de
   legibilidad:
   <itemizedlist>
 
    <listitem>
     <simpara>
      <type>mixed</type>
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      <type>number</type>
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      <type>callback</type>
     </simpara>
    </listitem>

   </itemizedlist>
   Tambi&eacute;n puede encontrar algunas referencias al tipo
   "double". Considere al tipo double como el mismo que float, los dos
   nombres existen solo por razones hist&oacute;ricas.
  </para>

   <simpara>
    El tipo de una variable usualmente no es declarado por el
    programador; en cambio, es decidido en tiempo de
    compilaci&oacute;n por PHP dependiendo del contexto en el que es
    usado la variable.
   </simpara>
   <note>
    <simpara>
     Si desea chequear el tipo y valor de una cierta <link
     linkend="language.expressions">expresi&oacute;n</link>, use
     <function>var_dump</function>.
    </simpara>
    <para>
     Si tan solo desea una representaci&oacute;n legible para humanos
     del tipo para prop&oacute;sitos de depuraci&oacute;n, use
     <function>gettype</function>. Para chequear por un cierto tipo,
     <emphasis>no</emphasis> use <function>gettype</function>; en su
     lugar utilice las funciones
     <literal>is_<replaceable>tipo</replaceable></literal>. Algunos
     ejemplos:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$bool = TRUE;   // un valor booleano
$str  = "foo";  // una cadena
$int  = 12;     // un entero

echo gettype($bool); // imprime "boolean"
echo gettype($str);  // imprime "string"

// Si este valor es un entere, incrementarlo en cuatro
if (is_int($int)) {
    $int += 4;
}

// Si $bool es una cadena, imprimirla
// (no imprime nada)
if (is_string($bool)) {
    echo "Cadena: $bool";
}
?>
]]>
     </programlisting>
    </informalexample>
    </para>
   </note>
   <simpara>
    Si quisiera forzar la conversi&oacute;n de una variable a cierto
    tipo, puede <link
    linkend="language.types.typecasting">moldear</link> la variable, o
    usar la funci&oacute;n <function>settype</function> sobre ella.
   </simpara>
   <simpara>
    Note que una variable puede ser evaluada con valores diferentes en
    ciertas situaciones, dependiendo del tipo que posee en cada
    momento. Para m&aacute;s informaci&oacute;n, vea la secci&oacute;n
    sobre <link
    linkend="language.types.type-juggling">Manipulaci&oacute;n de
    Tipos</link>. Asimismo, puede encontrarse interesado en consultar
    las <link linkend="types.comparisons">tablas de comparaci&oacute;n
    de tipos</link>, ya que &eacute;stas muestran ejemplos de las
    varias comparaciones relacionadas con tipos.
   </simpara>
  </sect1>
   
  <sect1 id="language.types.boolean">
   <title>Booleanos</title>
    
   <simpara>
    Este es el tipo m&aacute;s simple. Un <type>boolean</type> expresa
    un valor de verdad. Puede ser &true; or &false;.
   </simpara>

   <note>
    <simpara>
     El tipo booleano fue introducido en PHP 4.
    </simpara>
   </note>

   <sect2 id="language.types.boolean.syntax">
    <title>Sintaxis</title>
    <para>
     Para especificar un literal booleano, use alguna de las palabras
     clave &true; o &false;. Ambas son insensibles a may&uacute;sculas
     y min&uacute;sculas.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = True; // asignar el valor TRUE a $foo
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Usualmente se usa alg&uacute;n tipo de <link
     linkend="language.operators">operador</link> que deuelve un valor
     <type>boolean</type>, y luego &eacute;ste es pasado a una <link
     linkend="language.control-structures">estructura de
     control</link>.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// == es un operador que prueba por
// igualdad y devuelve un booleano
if ($accion == "mostrar_version") {
    echo "La versi&oacute;n es 1.23";
}

// esto no es necesario...
if ($mostrar_separadores == TRUE) {
    echo "<hr>\n";
}

// ...porque se puede escribir simplemente
if ($mostrar_separadores) {
    echo "<hr>\n";
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>

   <sect2 id="language.types.boolean.casting">
    <title>Conversi&oacute;n a booleano</title>
    <simpara>
     Para convertir expl&iacute;citamente un valor a
     <type>boolean</type>, use el moldeamiento
     <literal>(bool)</literal> o <literal>(boolean)</literal>. Sin
     embargo, en la mayor&iacute;a de casos no es necesario usar el
     moldeamiento, ya que un valor ser&aacute; convertido
     autom&aacute;ticamente si un operador, funci&oacute;n o
     estructura de control requiere un argumento tipo
     <type>boolean</type>.
    </simpara>
    <simpara>
     Vea tambi&eacute;n <link
     linkend="language.types.type-juggling">Manipulaci&oacute;n de
     Tipos</link>.
    </simpara>

    <para>
     Cuando se realizan conversiones a <type>boolean</type>, los
     siguientes valores son considerados &false;:
     <itemizedlist>
      <listitem>
       <simpara>el <link
        linkend="language.types.boolean">boolean</link> &false;
        mismo</simpara>
      </listitem>
      <listitem>
       <simpara>el <link
       linkend="language.types.integer">integer</link> 0 (cero)
       </simpara>
      </listitem>
      <listitem>
       <simpara>el <link linkend="language.types.float">float</link>
       0.0 (cero) </simpara>
      </listitem>
      <listitem>
       <simpara>el valor <link
       linkend="language.types.string">string</link> vac&iacute;o, y
       el <link linkend="language.types.string">string</link>
       "0"</simpara>
      </listitem>
      <listitem>
       <simpara>un <link linkend="language.types.array">array</link>
        con cero elementos</simpara>
      </listitem>
      <listitem>
       <simpara>un <link linkend="language.types.object">object</link>
        con cero variables miembro (s&oacute;lo en PHP 4)</simpara>
      </listitem>
      <listitem>
       <simpara>el tipo especial <link
       linkend="language.types.null">NULL</link> (incluyendo variables
       no definidas)
       </simpara>
      </listitem>
     </itemizedlist>
     Cualquier otro valor es considerado &true; (incluyendo cualquier
     <link linkend="language.types.resource">resource</link>).
     <warning>
      <simpara>
       &iexcl;<literal>-1</literal> es considerado &true;, como
       cualquier otro n&uacute;mero diferente a cero (ya sea negativo
       o positivo)!
      </simpara>
     </warning>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
var_dump((bool) "");        // bool(false)
var_dump((bool) 1);         // bool(true)
var_dump((bool) -2);        // bool(true)
var_dump((bool) "foo");     // bool(true)
var_dump((bool) 2.3e5);     // bool(true)
var_dump((bool) array(12)); // bool(true)
var_dump((bool) array());   // bool(false)
var_dump((bool) "false");   // bool(true)
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.integer">
   <title>Enteros</title>
    
   <simpara>
    Un <type>integer</type> es un n&uacute;mero del conjunto Z = {...,
    -2, -1, 0, 1, 2, ...}.
   </simpara>
     
   <para>
    Vea tambi&eacute;n: <link linkend="ref.gmp">Entero de longitud
    arbitraria / GMP</link>, <link
    linkend="language.types.float">N&uacute;meros de punto
    flotante</link>, y <link linkend="ref.bc">Precisi&oacute;n
    arbitraria / BCMath</link>
   </para>

   <sect2 id="language.types.integer.syntax">
    <title>Sintaxis</title>
    <simpara>
     Los enteros pueden ser especificados en notaci&oacute;n decimal
     (base-10), hexadecimal (base-16) u octal (base-8), opcionalmente
     precedidos por un signo (- o +).
    </simpara>
    <para>
     Si usa la notaci&oacute;n octal, debe preceder el n&uacute;mero
     con un <literal>0</literal> (cero), para usar la notaci&oacute;n
     hexadecimal, preceda el n&uacute;mero con <literal>0x</literal>.
     <example>
      <title>Literales tipo entero</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 1234; // numero decimal
$a = -123; // un numero negativo
$a = 0123; // numero octal (equivalente al 83 decimal)
$a = 0x1A; // numero hexadecimal (equivalente al 26 decimal)
?>
]]>
      </programlisting>
     </example>
     Formalmente, la posible estructura para literales enteros es:
     <informalexample>
      <programlisting>
<![CDATA[
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
]]>
      </programlisting>
     </informalexample>
     El tama&ntilde;o de un entero es dependiente de la plataforma,
     aunque un valor m&aacute;ximo de aproximadamente dos billones es
     el valor usual (lo que es un valor de 32 bits con signo). PHP no
     soporta enteros sin signo.
    </para>
    <warning>
     <para>
      Si un d&iacute;gito inv&aacute;lido es pasado a un entero octal
      (p.ej. 8 o 9), el resto del n&uacute;mero es ignorado.
      <example>
       <title>Curiosidad de valores octales</title>
       <programlisting role="php">
<![CDATA[
<?php
var_dump(01090); // 010 octal = 8 decimal
?>
]]>
       </programlisting>
      </example>
     </para>
    </warning>
   </sect2>

   <sect2 id="language.types.integer.overflow">
    <title>Desbordamiento de enteros</title>
    <para>
     Si especifica un n&uacute;mero m&aacute;s all&aacute; de los
     l&iacute;mites del tipo <type>integer</type>, ser&aacute;
     interpretado en su lugar como un <type>float</type>. Asimismo, si
     realiza una operaci&oacute;n que resulta en un n&uacute;mero
     m&aacute;s all&aacute; de los l&iacute;mites del tipo
     <type>integer</type>, un <type>float</type> es retornado en su
     lugar.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$numero_grande =  2147483647;
var_dump($numero_grande);
// salida: int(2147483647)

$numero_grande =  2147483648;
var_dump($numero_grande);
// salida: float(2147483648)

// esto no ocurre con los enteros indicados como hexadecimales:
var_dump( 0x100000000 );
// salida: int(2147483647)

$millon = 1000000;
$numero_grande =  50000 * $millon;
var_dump($numero_grande);
// salida: float(50000000000)
?>
]]>
      </programlisting>
     </informalexample>
     <warning>
      <simpara>
       Desafortunadamente, hab&iacute;a un fallo en PHP que provocaba
       que esto no siempre funcionara correctamente cuando se
       presentaban n&uacute;meros negativos. Por ejemplo: cuando hace
       <literal>-50000 * $millon</literal>, el resultado ser&aacute;
       <literal>-429496728</literal>. Sin embargo, cuando ambos
       operandos son positivos no se presenta ning&uacute;n problema.
      </simpara>
      <simpara>
       Este problema fue resuelto en PHP 4.1.0.
      </simpara>
     </warning>
    </para>
    <para>
     No hay un operador de divisi&oacute;n de enteros en PHP.
     <literal>1/2</literal> produce el <type>float</type>
     <literal>0.5</literal>. Puede moldear el valor a un entero para
     asegurarse de redondearlo hacia abajo, o puede usar la
     funci&oacute;n <function>round</function>.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         // float(3.5714285714286) 
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4) 
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
   
   <sect2 id="language.types.integer.casting">
    <title>Conversi&oacute;n a entero</title>
    <simpara>
     Para convertir expl&iacute;citamente un valor a
     <type>integer</type>, use alguno de los moldeamientos
     <literal>(int)</literal> o <literal>(integer)</literal>. Sin
     embargo, en la mayor&iacute;a de casos no necesita usar el
     moldeamiento, ya que un valor ser&aacute; convertido
     autom&aacute;ticamente si un operador, funci&oacute;n o
     estructura de control requiere un argumento tipo
     <type>integer</type>. Tambi&eacute;n puede convertir un valor a
     entero con la funci&oacute;n <function>intval</function>.
    </simpara>
    <simpara>
     Vea tambi&eacute;n <link
     linkend="language.types.type-juggling">Manipulaci&oacute;n de
     Tipos</link>.
    </simpara>
      
    <sect3 id="language.types.integer.casting.from-boolean">
     <title>Desde <link
       linkend="language.types.boolean">booleans</link></title>
     <simpara>
      &false; producir&aacute; <literal>0</literal> (cero), y &true;
      producir&aacute; <literal>1</literal> (uno).
     </simpara>
    </sect3>

    <sect3 id="language.types.integer.casting.from-float">
     <title>Desde <link linkend="language.types.float">n&uacute;meros
     de punto flotante</link></title>
     <simpara>
      Cuando se realizan conversiones desde un flotante a un entero,
      el n&uacute;mero ser&aacute; redondeado <emphasis>hacia
      cero</emphasis>.
     </simpara>
       
     <para>
      Si el flotante se encuentra m&aacute;s all&aacute; de los
      l&iacute;mites del entero (usualmente <literal>+/- 2.15e+9 =
      2^31</literal>), el resultado es indefinido, ya que el flotante
      no tiene suficiente precisi&oacute;n para dar un resultado
      entero exacto. No se producir&aacute; una advertencia, &iexcl;ni
      siquiera una noticia en este caso!
     </para>
       
     <warning>
      <para>
       Nunca moldee una fracci&oacute;n desconocida a
       <type>integer</type>, ya que esto en ocasiones produce
       resultados inesperados.
       <informalexample>
        <programlisting role="php">
<![CDATA[
<?php
echo (int) ( (0.1+0.7) * 10 ); // imprime 7!
?>
]]>
        </programlisting>
       </informalexample>
       Para m&aacute;s informaci&oacute;n, consulte la <link
       linkend="warn.float-precision">advertencia sobre
       precisi&oacute;n-flotante</link>.
      </para>
     </warning>
    </sect3>
      
    <sect3 id="language.types.integer.casting.from-string">
     <title>Desde cadenas</title>
     <simpara>
      Vea <link
      linkend="language.types.string.conversion">Conversi&oacute;n de
      cadenas a n&uacute;meros</link>
     </simpara>
    </sect3>
    
    <sect3 id="language.types.integer.casting.from-other">
     <title>Desde otros tipos</title>
     <para>
      <caution>
       <simpara>
        El comportamiento de convertir desde entero no es definido
        para otros tipos. Actualmente, el comportamiento es el mismo
        que si el valor fuera antes <link
        linkend="language.types.boolean.casting">convertido a
        booleano</link>. Sin embargo, <emphasis>no</emphasis>
        conf&iacute;e en este comportamiente, ya que puede ser
        modificado sin aviso.
       </simpara>
      </caution>
     </para>
    </sect3>
   </sect2>
  </sect1>

  <sect1 id="language.types.float">
   <title>N&uacute;meros de punto flotante</title>
   <para>
    Los n&uacute;meros de punto flotante (tambi&eacute;n conocidos
    como "flotantes", "dobles" o "n&uacute;meros reales") pueden ser
    especificados usando cualquiera de las siguientes sintaxis:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1.234;
$b = 1.2e3;
$c = 7E-10;
?>
]]>
     </programlisting>
    </informalexample>
    Formalmente:
    <informalexample>
     <programlisting role="php">
<![CDATA[
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]? {LNUM})
]]>
     </programlisting>
    </informalexample>
    El tama&ntilde;o de un flotante depende de la plataforma, aunque
    un valor com&uacute;n consiste en un m&aacute;ximo de ~1.8e308 con
    una precisi&oacute;n de aproximadamente 14 d&iacute;gitos
    decimales (lo que es un valor de 64 bits en formato IEEE).
   </para>

   <warning id="warn.float-precision">
    <title>Precisi&oacute;n del punto flotante</title>
    <para>
     Es bastante com&uacute;n que algunas fracciones decimales simples
     como <literal>0.1</literal> o <literal>0.7</literal> no puedan
     ser convertidas a su representaci&oacute;n binaria interna sin
     perder un poco de precisi&oacute;n. Esto puede llevar a
     resultados confusos: por ejemplo,
     <literal>floor((0.1+0.7)*10)</literal> usualmente
     devolver&aacute; <literal>7</literal> en lugar del esperado
     <literal>8</literal> ya que el resultado de la
     representaci&oacute;n interna es en realidad algo como
     <literal>7.9999999999...</literal>.
    </para>
    <para>
     Esto se encuentra relacionado al hecho de que es imposible
     expresar de forma exacta algunas fracciones en notaci&oacute;n
     decimal con un n&uacute;mero finito de d&iacute;gitos. Por
     ejemplo, <literal>1/3</literal> en forma decimal se convierte en
     <literal>0.3333333. . .</literal>.
    </para>
    <para>
     As&iacute; que nunca conf&iacute;e en resultados de
     n&uacute;meros flotantes hasta el &uacute;ltimo d&iacute;gito, y
     nunca compare n&uacute;meros de punto flotante para conocer si
     son equivalentes. Si realmente necesita una mejor
     precisi&oacute;n, es buena idea que use las <link
     linkend="ref.bc">funciones matem&aacute;ticas de precisi&oacute;n
     arbitraria</link> o las funciones <link
     linkend="ref.gmp">gmp</link> en su lugar.
    </para>
   </warning>

   <sect2 id="language.types.float.casting">
    <title>Conversi&oacute;n a flotante</title>

    <para>
     Para m&aacute;s informaci&oacute;n sobre cu&aacute;ndo y
     c&oacute;mo son convertidas las cadenas a flotantes, vea la
     secci&oacute;n titulada <link
     linkend="language.types.string.conversion">Conversi&oacute;n de
     cadenas a n&uacute;meros</link>. Para valores de otros tipos, la
     conversi&oacute;n es la misma que si el valor hubiese sido
     convertido a entero y luego a flotante. Vea la secci&oacute;n
     <link linkend="language.types.integer.casting">Conversi&oacute;n
     a entero</link> para m&aacute;s informaci&oacute;n. A partir de
     PHP 5, una noticia es generada si intenta convertir un objeto a
     flotante.
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.string">
   <title>Cadenas</title>
   <para>
    Un valor <type>string</type> es una serie de caracteres. En PHP,
    un caracter es lo mismo que un byte, es decir, hay exactamente 256
    tipos de caracteres diferentes. Esto implica tambi&eacute;n que
    PHP no tiene soporte nativo de Unicode. Vea
    <function>utf8_encode</function> y
    <function>utf8_decode</function> para conocer sobre el soporte
    Unicode.
   </para>
   <note>
    <simpara>
     El que una cadena se haga muy grande no es un problema. PHP no
     impone l&iacute;mite pr&aacute;ctico alguno sobre el
     tama&ntilde;o de las cadenas, as&iacute; que no hay ninguna
     raz&oacute;n para preocuparse sobre las cadenas largas.
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>Sintaxis</title>
    <para>
     Un literal de cadena puede especificarse en tres formas
     diferentes.
     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">comillas
        simples</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">comillas
        dobles</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">sintaxis
        heredoc</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>Comillas simples</title>
     <para>
      La forma m&aacute;s simple de especificar una cadena sencilla es
      rodearla de comillas simples (el caracter <literal>'</literal>).
     </para>
     <para>
      Para especificar una comilla sencilla literal, necesita
      escaparla con una barra invertida (<literal>\</literal>), como
      en muchos otros lenguajes. Si una barra invertida necesita
      aparecer antes de una comilla sencilla o al final de la cadena,
      necesitar&aacute; doblarla. Note que si intenta escapar
      cualquier otro caracter, &iexcl;la barra invertida ser&aacute;
      impresa tambi&eacute;n! De modo que, por lo general, no hay
      necesidad de escapar la barra invertida misma.
      <note>
       <simpara>
        En PHP 3, se generar&aacute; una advertencia de nivel
        <literal>E_NOTICE</literal> cuando esto ocurra.
       </simpara>
      </note>
      <note>
       <simpara>
        A diferencia de las otras dos sintaxis, las <link
        linkend="language.variables">variables</link> y secuencias de
        escape para caracteres especiales <emphasis>no</emphasis>
        ser&aacute;n expandidas cuando ocurren al interior de cadenas
        entre comillas sencillas.
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo 'esta es una cadena simple';

echo 'Tambi&eacute;n puede tener saltos de l&iacute;nea embebidos
en las cadenas de esta forma, ya que
es v&aacute;lido';

// Imprime: Arnold dijo una vez: "I'll be back"
echo 'Arnold dijo una vez: "I\'ll be back"';

// Imprime: Ha eliminado C:\*.*?
echo 'Ha eliminado C:\\*.*?';

// Imprime: Ha eliminado C:\*.*?
echo 'Ha eliminado C:\*.*?';

// Imprime: Esto no va a expandirse: \n una nueva linea
echo 'Esto no va a expandirse: \n una nueva linea';

// Imprime: Las variables no se $expanden $tampoco
echo 'Las variables no se $expanden $tampoco';
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>Comillas dobles</title>
     <para>
      Si la cadena se encuentra rodeada de comillas dobles ("), PHP
      entiende m&aacute;s secuencias de escape para caracteres
      especiales:
     </para>
     <table>
      <title>Caracteres escapados</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>secuencia</entry>
         <entry>significado</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>\n</literal></entry>
         <entry>alimentaci&oacute;n de l&iacute;nea (LF o 0x0A (10) en
         ASCII)</entry>
        </row>
        <row>
         <entry><literal>\r</literal></entry>
         <entry>retorno de carro (CR o 0x0D (13) en ASCII)</entry>
        </row>
        <row>
         <entry><literal>\t</literal></entry>
         <entry>tabulaci&oacute;n horizontal (HT o 0x09 (9) en
         ASCII)</entry>
        </row>
        <row>
         <entry><literal>\\</literal></entry>
         <entry>barra invertida</entry>
        </row>
        <row>
         <entry><literal>\$</literal></entry>
         <entry>signo de d&oacute;lar</entry>
        </row>
        <row>
         <entry><literal>\"</literal></entry>
         <entry>comilla-doble</entry>
        </row>
        <row>
         <entry><literal>\[0-7]{1,3}</literal></entry>
         <entry>
          la secuencia de caracteres que coincide con la
          expresi&oacute;n regular es un caracter en notaci&oacute;n
          octal
         </entry>
        </row>
        <row>
         <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
         <entry>
          la secuencia de caracteres que coincide con la
          expresi&oacute;n regular es un caracter en notaci&oacute;n
          hexadecimal
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Nuevamente, si intenta escapar cualquier otro caracter,
      &iexcl;la barra invertida ser&aacute; impresa tambi&eacute;n!
     </para>
     <para>
      Pero la caracter&iacute;stica m&aacute;s importante de las
      cadenas entre comillas dobles es el hecho de que los nombres de
      variables ser&aacute;n expandidos. Vea <link
      linkend="language.types.string.parsing">procesamiento de
      cadenas</link> para m&aacute;s detalles.
     </para>
    </sect3>

    <sect3 id="language.types.string.syntax.heredoc">
     <title>Heredoc</title>
     <simpara>
      Otra forma de delimitar cadenas es mediante el uso de la
      sintaxis heredoc ("&lt;&lt;&lt;"). Debe indicarse un
      identificador despu&eacute;s de la secuencia
      <literal>&lt;&lt;&lt;</literal>, luego la cadena, y luego el
      mismo identificador para cerrar la cita.
     </simpara>
     <simpara>
      El identificador de cierre <emphasis>debe</emphasis> comenzar en
      la primera columna de la l&iacute;nea. Asimismo, el
      identificador usado debe seguir las mismas reglas que cualquier
      otra etiqueta en PHP: debe contener solo caracteres
      alfanum&eacute;ricos y de subrayado, y debe iniciar con un
      caracter no-d&iacute;gito o de subrayado.
     </simpara>

     <warning>
      <simpara>
       Es muy importante notar que la l&iacute;nea con el
       identificador de cierre no contenga otros caracteres, excepto
       <emphasis>quiz&aacute;s</emphasis> por un punto-y-coma
       (<literal>;</literal>). Esto quiere decir en especial que el
       identificador <emphasis>no debe usar sangr&iacute;a</emphasis>,
       y no debe haber espacios o tabuladores antes o despu&eacute;s
       del punto-y-coma. Es importante tambi&eacute;n notar que el
       primer caracter antes del identificador de cierre debe ser un
       salto de l&iacute;nea, tal y como lo defina su sistema
       operativo. Esto quiere decir <literal>\r</literal> en
       Macintosh, por ejemplo.
      </simpara>
      <simpara>
       Si esta regla es rota y el identificador de cierre no es
       "limpio", entonces no se considera un identificador de cierre y
       PHP continuar&aacute; en busca de uno. Si, en tal caso, no se
       encuentra un identificador de cierre apropiado, entonces un
       error del analizador sint&aacute;ctico resultar&aacute; con el
       n&uacute;mero de l&iacute;nea apuntando al final del script.
      </simpara>
      <para>
       No es permitido usar la sintaxis heredoc al inicializar
       miembros de clase. Use otro tipo de sintaxis en su lugar.
       <example>
        <title>Ejemplo inv&aacute;lido</title>
        <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
        </programlisting>
       </example>
      </para>
     </warning>

     <para>
      El texto heredoc se comporta tal como una cadena entre comillas
      dobles, sin las comillas dobles. Esto quiere decir que no
      necesita escapar tales comillas en sus bloques heredoc, pero aun
      puede usar los c&oacute;digos de escape listados
      anteriormente. Las variables son expandidas, aunque debe tenerse
      el mismo cuidado cuando se expresen variables complejas al
      interior de un segmento heredoc, al igual que con otras cadenas.
      <example>
       <title>Ejemplo de uso de una cadena heredoc</title>
       <programlisting role="php">
<![CDATA[
<?php
$cadena = <<<FIN
Ejemplo de una cadena
que se extiende por varias l&iacute;neas
usando la sintaxis heredoc.
FIN;

/* Un ejemplo mas complejo, con variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$nombre = 'MiNombre';

echo <<<FIN
Mi nombre es "$nombre". Estoy imprimiendo algo de $foo->foo.
Ahora, estoy imprimiendo algo de {$foo->bar[1]}.
Esto deber&iacute;a imprimir una letra 'A' may&uacute;scula: \x41
FIN;
?>
]]>
       </programlisting>
      </example>
     </para>
  
     <note>
      <para>
       El soporte heredoc fue agregado en PHP 4.
      </para>
     </note>
    </sect3>

    <sect3 id="language.types.string.parsing">
     <title>Procesamiento de variables</title>
     <simpara>
      Cuando una cadena es especificada en comillas dobles o al
      interior de un bloque heredoc, las <link
      linkend="language.variables">variables</link> son interpretadas
      en su interior.
     </simpara>
     <simpara>
      Existen dos tipos de sintaxis: una <link
      linkend="language.types.string.parsing.simple">simple</link> y
      una <link
      linkend="language.types.string.parsing.complex">compleja</link>. La
      sintaxis simple es la m&aacute;s com&uacute;n y
      conveniente. Esta ofrece una forma de interpretar una variable,
      un valor <type>array</type>, o una propiedad de un
      <type>object</type>.
     </simpara>
     <simpara>
      La sintaxis compleja fue introducida en PHP 4, y puede
      reconocerse por las llaves que rodean la expresi&oacute;n.
     </simpara>

     <sect4 id="language.types.string.parsing.simple">
      <title>Sintaxis simple</title>
      <simpara>
       Si un signo de d&oacute;lar (<literal>$</literal>) es
       encontrado, el analizador sint&aacute;ctico tomar&aacute;
       ambiciosamente tantos lexemas como le sea posible para formar
       un nombre de variable v&aacute;lido. Rodee el nombre de la
       variable de llaves si desea especificar expl&iacute;citamente
       el final del nombre.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$cerveza = 'Heineken';
echo "El sabor de varias $cerveza's es excelente"; // funciona, "'" no es un caracter valido para nombres de variables
echo "Tom&oacute; algunas $cervezas";   // no funciona, 's' es un caracter valido para nombres de variables
echo "Tom&oacute; algunas ${cerveza}s"; // funciona
echo "Tom&oacute; algunas {$cerveza}s"; // funciona
?>
]]>
       </programlisting>
      </informalexample>
      <simpara>
       De forma similar, puede hacer que un &iacute;ndice de un
       <type>array</type> o una propiedad de un <type>object</type>
       sean interpretados. En el caso de los &iacute;ndices de
       matrices, el corchete cuadrado de cierre (<literal>]</literal>)
       marca el final del &iacute;ndice. Para las propiedades de
       objetos, se aplican las mismas reglas de las variables simples,
       aunque con las propiedades de objetos no existe un truco como
       el que existe con las variables.

       <!-- XXX isn't &true; :(, this would be the trick
       Also, the same trick with curly-braces works if you
       want to limit the greediness of parsers.
       -->
      
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Estos ejemplos son especificos al uso de matrices al interior de
// cadenas. Cuando se encuentre por fuera de una cadena, siempre rodee
// de comillas las claves tipo cadena de su matriz, y no use
// {llaves} por fuera de cadenas tampoco.

// Mostremos todos los errores
error_reporting(E_ALL);

$frutas = array('fresa' => 'roja', 'banano' => 'amarillo');

// Funciona pero note que esto trabaja de forma diferente por fuera de
// cadenas entre comillas
echo "Un banano es $frutas[banano].";

// Funciona
echo "Un banano es {$frutas['banano']}.";

// Funciona, pero PHP musca una constante llamada banano primero, como
// se describe mas adelante.
echo "Un banano es {$frutas[banano]}.";

// No funciona, use llaves. Esto resulta en un error de analisis sintactico.
echo "Un banano es $frutas['banano'].";

// Funciona
echo "Un banano es " . $frutas['banano'] . ".";

// Funciona
echo "Este cuadro tiene $cuadro->ancho metros de ancho.";

// No funciona. Para una solucion, vea la sintaxis compleja.
echo "Este cuadro tiene $cuadro->ancho00 cent&iacute;metros de ancho.";
?>
]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
       </programlisting>
      </informalexample>
      <simpara>
       Para cualquier cosa m&aacute;s sofisticada, deber&iacute;a
       usarse la sintaxis compleja.
      </simpara>
     </sect4>

     <sect4 id="language.types.string.parsing.complex">
      <title>Sintaxis compleja (llaves)</title>
      <simpara>
       Esta no es llamada compleja porque la sintaxis sea compleja,
       sino porque es posible incluir expresiones complejas de esta
       forma.
      </simpara>
      <simpara>
       De hecho, de esta forma puede incluir cualquier valor que sea
       parte del espacio de nombres al interior de
       cadenas. Simplemente escriba la expresi&oacute;n en la misma
       forma que lo har&iacute;a si se encontrara por fuera de una
       cadena, y luego la ubica entre { y }. Ya que no es posible
       escapar '{', esta sintaxis ser&aacute; reconocida
       &uacute;nicamente cuando el caracter $ se encuentra
       inmediatamente despu&eacute;s de {. (Use "{\$" o "\{$" para
       obtener una secuencia literal "{$"). Algunos ejemplos para
       aclarar el asunto:
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Mostremos todos los errores
error_reporting(E_ALL);

$genial = 'fant&aacute;stico';

// No funciona, imprime: Esto es { fant&aacute;stico}
echo "Esto es { $genial}";

// Funciona, imprime: Esto es fant&aacute;stico
echo "Esto es {$genial}";
echo "Esto es ${genial}";

// Funciona
echo "Este cuadro tiene {$cuadro->ancho}00 cent&iacute;metros de ancho.";

// Funciona
echo "Esto funciona: {$matriz[4][3]}";

// Esto esta mal por la misma razon por la que $foo[bar] esta mal por
// fuera de una cadena. En otras palabras, aun funciona pero ya que
// PHP busca primero una constante llamada foo, genera un error de
// nivel E_NOTICE (constante indefinida).
echo "Esto esta mal: {$matriz[foo][3]}"; 

// Funciona. Cuando se usan matrices multi-dimensionales, use siempre
// llaves alrededor de las matrices al interior de cadenas
echo "Esto funciona: {$matriz['foo'][3]}";

// Funciona.
echo "Esto funciona: " . $arr['foo'][3];

echo "Puede incluso escribir {$obj->valores[3]->nombre}";

echo "Este es el valor de la variable llamada $nombre: {${$nombre}}";
?>
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>
    
    <sect3 id="language.types.string.substr">
     <title>Acceso a cadenas y modificaci&oacute;n por
     caracter</title>
     <para>
      Los caracteres al interior de una cadena pueden ser consultados
      y modificados al especificar el desplazamiento, comenzando en
      cero, del caracter deseado despu&eacute;s de la cadena entre
      llaves.
     </para>
     <note>
      <simpara>
       Para efectos de compatibilidad con versiones anteriores, aun
       puede usar corchetes tipo matriz para el mismo
       prop&oacute;sito. Sin embargo, esta sintaxis es obsoleta a
       partir de PHP 4.
      </simpara>
     </note>
     <para>
      <example>
       <title>Algunos ejemplos de cadenas</title>
       <programlisting role="php">
<![CDATA[
<?php
// Obtener el primer caracter de una cadena
$cadena = 'Esta es una prueba.';
$primer = $cadena{0};

// Obtener el tercer caracter de una cadena
$tercer = $cadena{2};

// Obtener el ultimo caracter de una cadena.
$cadena = 'Esta es tambien una prueba.';
$ultimo = $cadena{strlen($cadena)-1}; 

// Modificar el ultimo caracter de una cadena
$cadena = 'Observe el mar';
$cadena{strlen($cadena)-1} = 'l';
          
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.string.useful-funcs">
    <title>Funciones y operadores &uacute;tiles</title>
    <para>
     Las cadenas pueden ser concatenadas usando el operador '.'
     (punto). Note que el operador '+' (adici&oacute;n) no funciona
     para este prop&oacute;sito. Por favor refi&eacute;rase a la
     secci&oacute;n <link
     linkend="language.operators.string">Operadores de cadena</link>
     para m&aacute;s informaci&oacute;n.
    </para>
    <para>
     Existen bastantes funciones &uacute;tiles para la
     modificaci&oacute;n de cadenas.
    </para>
    <simpara>
     Vea la <link linkend="ref.strings">secci&oacute;n de funciones de
     cadena</link> para consultar funciones de uso general, o las
     funciones de expresiones regulares para b&uacute;squedas y
     reemplazos avanzados (en dos sabores: <link
     linkend="ref.pcre">Perl</link> y <link linkend="ref.regex">POSIX
     extendido</link>).
    </simpara>
    <simpara>
     Existen tambi&eacute;n <link linkend="ref.url">funciones para
     cadenas tipo URL</link>, y funciones para encriptar/descifrar
     cadenas (<link linkend="ref.mcrypt">mcrypt</link> y <link
     linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Finalmente, si aun no ha encontrado lo que busca, vea
     tambi&eacute;n las <link linkend="ref.ctype">funciones de tipo de
     caracter</link>.
    </simpara>
   </sect2>

   <sect2 id="language.types.string.casting">
    <title>Conversi&oacute;n a cadena</title>

    <para>
     Es posible convertir un valor a una cadena usando el moldeamiento
     <literal>(string)</literal>, o la funci&oacute;n
     <function>strval</function>. La conversi&oacute;n a cadena se
     realiza autom&aacute;ticamente para usted en el contexto de una
     expresi&oacute;n cuando se necesita una cadena. Esto ocurre
     cuando usa las funciones <function>echo</function> o
     <function>print</function>, o cuando compara el valor de una
     variable con una cadena. El contenido de las secciones del manual
     sobre <link linkend="language.types">Tipos</link> y <link
     linkend="language.types.type-juggling">Manipulaci&oacute;n de
     Tipos</link> ayudan a aclarar este hecho. Vea tambi&eacute;n
     <function>settype</function>.
    </para>
    
    <para>
     Un valor <type>boolean</type> &true; es convertido a la cadena
     <literal>"1"</literal>, el valor &false; se representa como
     <literal>""</literal> (una cadena vac&iacute;a). De esta forma,
     usted puede convertir de ida y vuelta entre valores booleanos y
     de cadena.
    </para>
    <para>
     Un n&uacute;mero <type>integer</type> o de punto flotante
     (<type>float</type>) es convertido a una cadena que representa el
     n&uacute;mero con sus d&iacute;gitos (incluyendo la parte del
     exponente para los n&uacute;meros de punto flotante).
    </para>
    <para>
     Las matrices son siempre convertidas a la cadena
     <literal>"Array"</literal>, de modo que no puede volcar los
     contenidos de un valor <type>array</type> con
     <function>echo</function> o <function>print</function> para ver
     lo que se encuentra en su interior. Para ver un elemento, usted
     tendr&iacute;a que hacer algo como <literal>echo
     $arr['foo']</literal>. Vea m&aacute;s adelante algunos consejos
     sobre el volcado/vista del contenido completo.
    </para>
    <para>
     Los objetos son convertidos siempre a la cadena
     <literal>"Object"</literal>. Si quisiera imprimir los valores de
     variables miembro de un <type>object</type> para efectos de
     depuraci&oacute;n, lea los par&aacute;grafos siguientes. Si
     quiere conocer el nombre de clase del cual un objeto dado es
     instancia, use <function>get_class</function>. A partir de PHP 5,
     el m&eacute;todo __toString() es usado si resulta aplicable.
    </para>
    <para>
     Los recursos son siempre convertidos a cadenas con la estructura
     <literal>"Resource id #1"</literal> en donde <literal>1</literal>
     es el n&uacute;mero &uacute;nico del valor <type>resource</type>
     asignado por PHP durante tiempo de ejecuci&oacute;n. Si quisiera
     obtener el tipo del recurso, use
     <function>get_resource_type</function>.
    </para>
    <para>
     &null; se convierte siempre a una cadena vac&iacute;a.
    </para>
    
    <para>
     Como puede apreciar, el imprimir matrices, objetos o recursos no
     le ofroce informaci&oacute;n &uacute;til sobre los valores
     mismos. Consulte las funciones <function>print_r</function> y
     <function>var_dump</function> para conocer mejores formas de
     imprimir valores para depuraci&oacute;n.
    </para>
    
    <para>
     Tambi&eacute;n puede convertir valores PHP a cadenas y
     almacenarlas permanentemente. Este m&eacute;todo es conocido como
     seriaci&oacute;n, y puede ser efectuado con la funci&oacute;n
     <function>serialize</function>. Tambi&eacute;n puede seriar
     valores PHP a estructuras XML, si cuenta con soporte <link
     linkend="ref.wddx">WDDX</link> en su configuraci&oacute;n de PHP.
    </para>
   </sect2>

   <sect2 id="language.types.string.conversion">
    <title>Conversi&oacute;n de cadenas a n&uacute;meros</title>

    <simpara>
     Cuando una cadena es evaluada como un valor num&eacute;rico, el
     valor resultante y su tipo son determinados como sigue.
    </simpara>
    <simpara>
     La cadena ser&aacute; evaluada como un <type>float</type> si
     contiene cualquier caracter entre '.', 'e', o 'E'. De otra forma,
     evaluar&aacute; como un entero.
    </simpara>
    <para>
     El valor es dado por la porci&oacute;n inicial de la cadena. Si
     la cadena comienza con datos num&eacute;ricos v&aacute;lidos,
     &eacute;stos ser&aacute;n el valor usado. De lo contrario, el
     valor ser&aacute; 0 (cero). Un signo opcional es considerado un
     dato num&eacute;rico v&aacute;lido, seguido por uno o m&aacute;s
     d&iacute;gitos (que pueden contener un punto decimal), seguidos
     por un exponente opcional. El exponente es una 'e' o 'E' seguida
     de uno o m&aacute;s d&iacute;gitos.
    </para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo es flotante (11.5)
$foo = 1 + "-1.3e3";              // $foo es flotante (-1299)
$foo = 1 + "bob-1.3e3";           // $foo es entero (1)
$foo = 1 + "bob3";                // $foo es entero (1)
$foo = 1 + "10 Cerditos";         // $foo es entero (11)
$foo = 4 + "10.2 Cerditos";       // $foo es flotante (14.2)
$foo = "10.0 cerdos " + 1;        // $foo es flotante (11)
$foo = "10.0 cerdos " + 1.0;      // $foo es flotante (11)     
?>
]]>
     </programlisting>
    </informalexample>
    <simpara>
     Para m&aacute;s informaci&oacute;n sobre esta conversi&oacute;n,
     vea la p&aacute;gina del manual Unix sobre strtod(3).
    </simpara>
    <para>
     Si quisiera probar cualquiera de los ejemplos presentados en esta
     secci&oacute;n, puede cortar y pegar los ejemplos e insertar la
     siguiente l&iacute;nea para verificar por s&iacute; mismo lo que
     est&aacute; sucediendo:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; tipo es " . gettype ($foo) . "<br />\n";
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     No espere obtener el c&oacute;digo de un caractar
     convirti&eacute;ndolo a un entero (como lo har&iacute;a en C, por
     ejemplo). Use las funciones <function>ord</function> y
     <function>chr</function> para convertir entre c&oacute;digos de
     caracter y caracteres.
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 id="language.types.array">
   <title>Matrices</title>

   <para>
    Una matriz en PHP es en realidad un mapa ordenado. Un mapa es un
    tipo de datos que asocia <emphasis>valores</emphasis> con
    <emphasis>claves</emphasis>. Este tipo es optimizado en varias
    formas, de modo que puede usarlo como una matriz real, o una lista
    (vector), tabla asociativa (caso particular de
    implementaci&oacute;n de un mapa), diccionario, colecci&oacute;n,
    pila, cola y probablemente m&aacute;s. Ya que puede tener otra
    matriz PHP como valor, es realmente f&aacute;cil simular
    &aacute;rboles.
   </para>
   <para>
    Una explicaci&oacute;n sobre tales estructuras de datos se
    encuentra por fuera del prop&oacute;sito de este manual, pero
    encontrar&aacute; al menos un ejemplo de cada uno de ellos. Para
    m&aacute;s informaci&oacute;n, le referimos a literatura externa
    sobre este amplio tema.
   </para>

   <sect2 id="language.types.array.syntax">
    <title>Sintaxis</title>

    <sect3 id="language.types.array.syntax.array-func">
     <title>Especificaci&oacute;n con
     <function>array</function></title>
     <para>
      Un <type>array</type> puede ser creado por la
      construcci&oacute;n de lenguaje
      <function>array</function>. &Eacute;sta toma un cierto
      n&uacute;mero de parejas
      <literal><replaceable>clave</replaceable> =&gt;
      <replaceable>valor</replaceable></literal> separadas con coma.
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>clave</replaceable> =&gt; </optional> <replaceable>valor</replaceable>
     , ...
     )
// <replaceable>clave</replaceable> puede ser un <type>integer</type> o <type>string</type>
// <replaceable>valor</replaceable> puede ser cualquier valor
      </synopsis>
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$matriz = array("foo" => "bar", 12 => true);

echo $matriz["foo"]; // bar
echo $matriz[12];    // 1
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Una <varname>clave</varname> puede ser un
      <literal>integer</literal> o un <type>string</type>. Si una
      clave es la representaci&oacute;n est&aacute;ndar de un
      <type>integer</type>, ser&aacute; interpretada como tal (es
      decir, <literal>"8"</literal> ser&aacute; interpretado como
      <literal>8</literal>, mientras que <literal>"08"</literal>
      ser&aacute; interpretado como <literal>"08"</literal>). Los
      valores flotantes en <varname>clave</varname> ser&aacute;n
      truncados a valores tipo <type>integer</type>. No existen tipos
      diferentes para matrices indexadas y asociativas en PHP;
      s&oacute;lo existe un tipo de matriz, el cual puede contener
      &iacute;ndices tipo entero o cadena.
     </para>
     <para>
      Un valor puede ser de cualquier tipo en PHP.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$matriz = array("unamatriz" => array(6 => 5, 13 => 9, "a" => 42));

echo $matriz["unamatriz"][6];    // 5
echo $matriz["unamatriz"][13];   // 9
echo $matriz["unamatriz"]["a"];  // 42
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Si no especifica una clave para un valor dado, entonces es usado
      el m&aacute;ximo de los &iacute;ndices enteros, y la nueva clave
      ser&aacute; ese valor m&aacute;ximo + 1. Si especifica una clave
      que ya tiene un valor asignado, &eacute;se valor ser&aacute;
      sobrescrito.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Esta matriz es la misma que ...
array(5 => 43, 32, 56, "b" => 12);

// ...esta matriz
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <warning>
      <simpara>
       A partir de PHP 4.3.0, el comportamiento de generaci&oacute;n
       de &iacute;ndices descrito ha cambiado. Ahora, si agrega un
       elemento a una matriz cuya clave m&aacute;xima actual es un
       valor negativo, entonces la siguiente clave creada ser&aacute;
       cero (<literal>0</literal>). Anteriormente, el nuevo
       &iacute;ndice hubiera sido establecido a la clave mayor
       existente + 1, al igual que con los &iacute;ndices positivos.
      </simpara>
     </warning>
     <para>
      Al usar &true; como clave, el valor ser&aacute; evaluado al
      <type>integer</type> <literal>1</literal>. Al usar &false; como
      clave, el valor ser&aacute; evaluado al <type>integer</type>
      <literal>0</literal>. Al usar <literal>NULL</literal> como
      clave, el valor ser&aacute; evaluado a una cadena
      vac&iacute;a. El uso de una cadena vac&iacute;a como clave
      crear&aacute; (o reemplazar&aacute;) una clave con la cadena
      vac&iacute;a y su valor; no es lo mismo que usar corchetes
      vac&iacute;os.
     </para>
     <para>
      No es posible usar matrices u objetos como claves. Al hacerlo se
      producir&aacute; una advertencia: <literal>Illegal offset
      type</literal>.
     </para>
    </sect3>

    <sect3 id="language.types.array.syntax.modifying">
     <title>Creaci&oacute;n/modificaci&oacute;n con sintaxis de
     corchetes cuadrados</title>
     <para>
      Es posible modificar una matriz existente al definir valores
      expl&iacute;citamente en ella.
     </para>
     <para>
      Esto es posible al asignar valores a la matriz al mismo tiempo
      que se especifica la clave entre corchetes. Tambi&eacute;n es
      posible omitir la clave, agregar una pareja vac&iacute;a de
      corchetes ("<literal>[]</literal>") al nombre de la variable en
      ese caso.
      <synopsis>
$matriz[<replaceable>clave</replaceable>] = <replaceable>valor</replaceable>;
$matriz[] = <replaceable>valor</replaceable>;
// <replaceable>clave</replaceable> puede ser un <type>integer</type> o <type>string</type>
// <replaceable>valor</replaceable> puede ser cualquier valor
      </synopsis>
      Si <varname>$matriz</varname> no existe aun, &eacute;sta
      ser&aacute; creada. De modo que esta es tambi&eacute;n una forma
      alternativa de especificar una matriz. Para modificar un cierto
      valor, simplemente asigne un nuevo valor a un elemento
      especificado con su clave. Si desea remover una pareja
      clave/valor, necesita eliminarla mediante
      <function>unset</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$matriz = array(5 => 1, 12 => 2);

$matriz[] = 56;    // Esto es igual que $matriz[13] = 56;
                   // en este punto del script

$matriz["x"] = 42; // Esto agrega un nuevo elemento a la
                   // matriz con la clave "x"
                
unset($matriz[5]); // Esto elimina el elemento de la matriz

unset($matriz);    // Esto elimina la matriz completa
?>
]]> 
       </programlisting>
      </informalexample>
     </para>
     <note>
      <para>
       Como se menciona anteriormente, si provee los corchetes sin
       ninguna clave especificada, entonces se toma el m&aacute;ximo
       de los &iacute;ndices enteros existentes, y la nueva clave
       ser&aacute; ese valor m&aacute;ximo + 1. Si no existen
       &iacute;ndices enteros aun, la clave ser&aacute;
       <literal>0</literal> (cero). Si especifica una clave que ya
       ten&iacute;a un valor asignado, el valor ser&aacute;
       reemplazado.
      </para>
      <para>
       <warning>
        <simpara>
         A partir de PHP 4.3.0, el comportamiento de generaci&oacute;n
         de &iacute;ndices descrito ha cambiado. Ahora, si agrega un
         elemento al final de una matriz en la que la clave
         m&aacute;xima actual es negativa, la siguiente clave creada
         ser&aacute; cero (<literal>0</literal>). Anteriormente, el
         nuevo &iacute;ndice hubiera sido definido como la mayor clave
         + 1, al igual que ocurre con los &iacute;ndices positivos.
        </simpara>
       </warning>
      </para>
      <para>
       Note que la clave entera m&aacute;xima usada para este caso
       <emphasis>no necesita existir actualmente en la
       matriz</emphasis>. Tan solo debe haber existido en la matriz en
       alg&uacute;n punto desde que la matriz haya sido
       re-indexada. El siguiente ejemplo ilustra este caso:
      </para>

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Crear una matriz simple.
$matriz = array(1, 2, 3, 4, 5);
print_r($matriz);

// Ahora eliminar cada item, pero dejar la matriz misma intacta:
foreach ($matriz as $i => $valor) {
    unset($matriz[$i]);
}
print_r($matriz);

// Agregar un item (note que la nueva clave es 5, en lugar de 0 como
// podria esperarse).
$matriz[] = 6;
print_r($matriz);

// Re-indexar:
$matriz = array_values($matriz);
$matriz[] = 7;
print_r($matriz);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
       </screen>
      </informalexample>

     </note>
    </sect3>
   </sect2><!-- end syntax -->

   <sect2 id="language.types.array.useful-funcs">
    <title>Funciones &uacute;tiles</title>
    <para>
     Existe un buen n&uacute;mero de funciones &uacute;tiles para
     trabajar con matrices. Consulte la secci&oacute;n <link
     linkend="ref.array">funciones de matrices</link>.
    </para>
    <note>
     <para>
      La funci&oacute;n <function>unset</function> le permite remover
      la definici&oacute;n de claves de una matriz. Tenga en cuenta
      que la matriz NO es re-indexada. Si s&oacute;lo usa
      "&iacute;ndices enteros comunes" (comenzando desde cero,
      incrementando en uno), puede conseguir el efecto de
      re-indexaci&oacute;n usando <function>array_values</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'uno', 2 => 'dos', 3 => 'tres');
unset($a[2]);
/* producira una matriz que hubiera sido definida como
   $a = array(1 => 'uno', 3 => 'tres');
   y NO
   $a = array(1 => 'uno', 2 =>'tres');
*/

$b = array_values($a);
// Ahora $b es array(0 => 'uno', 1 =>'tres')
?>
]]>
      </programlisting>
     </informalexample>

     </para>
    </note>
    <para>
     La estructura de control <link
     linkend="control-structures.foreach">foreach</link> existe
     espec&iacute;ficamente para las matrices. &Eacute;sta provee una
     manera f&aacute;cil de recorrer una matriz.
    </para>
   </sect2>

   <sect2 id="language.types.array.donts">
    <title>Recomendaciones sobre matrices y cosas a evitar</title>

    <sect3 id="language.types.array.foo-bar">
     <title>&iquest;Porqu&eacute; es incorrecto
     <literal>$foo[bar]</literal>?</title>
     <para>
      Siempre deben usarse comillas alrededor de un &iacute;ndice de
      matriz tipo cadena literal. Por ejemplo, use $foo['bar'] y no
      $foo[bar]. &iquest;Pero qu&eacute; est&aacute; mal en $foo[bar]?
      Es posible que haya visto la siguiente sintaxis en scripts
      viejos:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'enemigo';
echo $foo[bar];
// etc
?>
]]>
       </programlisting>
      </informalexample>
      Esto est&aacute; mal, pero funciona. Entonces,
      &iquest;porqu&eacute; est&aacute; mal? La raz&oacute;n es que
      este c&oacute;digo tiene una constante indefinida (bar) en lugar
      de una cadena ('bar' - note las comillas), y puede que en el
      futuro PHP defina constantes que, desafortunadamente para su
      c&oacute;digo, tengan el mismo nombre. Funciona porque PHP
      autom&aacute;ticamente convierte una <emphasis>cadena
      pura</emphasis> (una cadena sin comillas que no corresponda con
      s&iacute;mbolo conocido alguno) en una cadena que contiene la
      cadena pura. Por ejemplo, si no se ha definido una constante
      llamada <constant>bar</constant>, entonces PHP
      reemplazar&aacute; su valor por la cadena
      <literal>'bar'</literal> y usar&aacute; &eacute;sta
      &uacute;ltima.
     </para>
     <note>
      <simpara>
       Esto no quiere decir que <emphasis>siempre</emphasis> haya que
       usar comillas en la clave. No querr&aacute; usar comillas con
       claves que sean <link
       linkend="language.constants">constantes</link> o <link
       linkend="language.variables">variables</link>, ya que en tal
       caso PHP no podr&aacute; interpretar sus valores.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Matriz simple:
$matriz = array(1, 2);
$conteo = count($matriz);
for ($i = 0; $i < $conteo; $i++) {
    echo "\nRevisando $i: \n";
    echo "Mal: " . $matriz['$i'] . "\n";
    echo "Bien: " . $matriz[$i] . "\n";
    echo "Mal: {$matriz['$i']}\n";
    echo "Bien: {$matriz[$i]}\n";
}
?>
]]>
       </programlisting>
      </informalexample>
      &example.outputs;
      <screen>
<![CDATA[
Revisando 0: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Mal: 
Bien: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Mal: 
Bien: 1

Revisando 1: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Mal: 
Bien: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Mal: 
Bien: 2
]]>
      </screen>
     </note>
     <para>
      M&aacute;s ejemplos para demostrar este hecho:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Mostrar todos los errores
error_reporting(E_ALL);

$matriz = array('fruta' => 'manzana', 'vegetal' => 'zanahoria');

// Correcto
print $matriz['fruta'];   // manzana
print $matriz['vegetal']; // zanahoria

// Incorrecto. Esto funciona pero tambi&eacute;n genera un error de PHP de
// nivel E_NOTICE ya que no hay definida una constante llamada fruta
// 
// Notice: Use of undefined constant fruta - assumed 'fruta' in...
print $matriz[fruta];    // manzana

// Definamos una constante para demostrar lo que pasa. Asignaremos el
// valor 'vegetal' a una constante llamada fruta.
define('fruta', 'vegetal');

// Note la diferencia ahora
print $matriz['fruta'];  // manzana
print $matriz[fruta];    // zanahoria

// Lo siguiente esta bien ya que se encuentra al interior de una
// cadena. Las constantes no son procesadas al interior de
// cadenas, asi que no se produce un error E_NOTICE aqui
print "Hola $matriz[fruta]";  // Hola manzana

// Con una excepcion, los corchetes que rodean las matrices al
// interior de cadenas permiten el uso de constantes
print "Hola {$matriz[fruta]}";    // Hola zanahoria
print "Hola {$matriz['fruta']}";  // Hola manzana

// Esto no funciona, resulta en un error de interprete como:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Esto se aplica tambien al uso de autoglobales en cadenas, por supuesto
print "Hola $matriz['fruta']";
print "Hola $_GET['foo']";

// La concatenacion es otra opcion
print "Hola " . $matriz['fruta']; // Hola manzana
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Cuando habilita <function>error_reporting</function> para
      mostrar errores de nivel <constant>E_NOTICE</constant> (como por
      ejemplo definiendo el valor <constant>E_ALL</constant>)
      ver&aacute; estos errores. Por defecto, <link
      linkend="ini.error-reporting">error_reporting</link> se
      encuentra configurado para no mostrarlos.
     </para>
     <para>
      Tal y como se indica en la secci&oacute;n de <link
      linkend="language.types.array.syntax">sintaxis</link>, debe
      existir una expresi&oacute;n entre los corchetes cuadrados
      ('<literal>[</literal>' y '<literal>]</literal>'). Eso quiere
      decir que puede escribir cosas como esta:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo $matriz[alguna_funcion($bar)];
?>
]]>
       </programlisting>
      </informalexample>
      Este es un ejemplo del uso de un valor devuelto por una
      funci&oacute;n como &iacute;ndice de matriz. PHP tambi&eacute;n
      conoce las constantes, tal y como ha podido apreciar aquellas
      <literal>E_*</literal> antes.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$descripciones_de_error[E_ERROR]   = "Un error fatal ha ocurrido";
$descripciones_de_error[E_WARNING] = "PHP produjo una advertencia";
$descripciones_de_error[E_NOTICE]  = "Esta es una noticia informal";
?>
]]>
       </programlisting>
      </informalexample>
      Note que <literal>E_ERROR</literal> es tambi&eacute;n un
      identificador v&aacute;lido, asi como <literal>bar</literal> en
      el primer ejemplo. Pero el &uacute;ltimo ejemplo es equivalente
      a escribir:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$descripciones_de_error[1] = "Un error fatal ha ocurrido";
$descripciones_de_error[2] = "PHP produjo una advertencia";
$descripciones_de_error[8] = "Esta es una noticia informal";
?>
]]>
       </programlisting>
      </informalexample>
      ya que <literal>E_ERROR</literal> es igual a
      <literal>1</literal>, etc.
     </para>
     <para>
      Tal y como lo hemos explicado en los anteriores ejemplos,
      <literal>$foo[bar]</literal> aun funciona pero est&aacute;
      mal. Funciona, porque debido a su sintaxis, se espera que
      <literal>bar</literal> sea una expresi&oacute;n constante. Sin
      embargo, en este caso no existe una constante con el nombre
      <literal>bar</literal>. PHP asume ahora que usted quiso decir
      <literal>bar</literal> literalmente, como la cadena
      <literal>"bar"</literal>, pero que olvid&oacute; escribir las
      comillas.
     </para>
     <sect4>
      <title>&iquest;Entonces porqu&eacute; est&aacute; mal?</title>
      <para>
       En alg&uacute;n momento en el futuro, el equipo de PHP puede
       querer usar otra constante o palabra clave, o puede que usted
       introduzca otra constante en su aplicaci&oacute;n, y entonces
       se ve en problemas. Por ejemplo, en este momento no puede usar
       las palabras <literal>empty</literal> y
       <literal>default</literal> de esta forma, ya que son <link
       linkend="reserved">palabras clave reservadas</link> especiales.
      </para>
      <note>
       <simpara>
        Reiterando, al interior de un valor <type>string</type> entre
        comillas dobles, es v&aacute;lido no rodear los &iacute;ndices
        de matriz con comillas, as&iacute; que
        <literal>"$foo[bar]"</literal> es v&aacute;lido. Consulte los
        ejemplos anteriores para m&aacute;s detalles sobre el
        porqu&eacute;, asi como la secci&oacute;n sobre <link
        linkend="language.types.string.parsing">procesamiento de
        variables en cadenas</link>.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.casting">
    <title>Conversi&oacute;n a matriz</title>
    
    <para>
     Para cualquiera de los tipos: <type>integer</type>,
     <type>float</type>, <type>string</type>, <type>boolean</type> y
     <type>resource</type>, si convierte un valor a un
     <type>array</type>, obtiene una matriz con un elemento (con
     &iacute;ndice 0), el cual es el valor escalar con el que
     inici&oacute;.
    </para>
    
    <para>
     Si convierte un <type>object</type> a una matriz, obtiene las
     propiedades (variables miembro) de ese objeto como los elementos
     de la matriz. Las claves son los nombres de las variables
     miembro.
    </para>

    <para>
     Si convierte un valor &null; a matriz, obtiene una matriz
     vac&iacute;a.
    </para>
   </sect2>

   <sect2 id="language.types.array.comparing">
    <title>Comparaci&oacute;n</title>
    <para>
     Es posible comparar matrices con <function>array_diff</function>
     y mediante <link linkend="language.operators.array">operadores de
     matriz</link>.
    </para>
   </sect2>

   <sect2 id="language.types.array.examples">
    <title>Ejemplos</title>
    <para>
     El tipo matriz en PHP es bastante vers&aacute;til, as&iacute; que
     aqu&iacute; se presentan algunos ejemplos que demuestran el poder
     completo de las matrices.
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// esto
$a = array( 'color'  => 'rojo',
            'sabor'  => 'dulce',
            'forma'  => 'redonda',
            'nombre' => 'manzana',
                       4        // la clave sera 0
          );

// es completamente equivalente con
$a['color']  = 'rojo';
$a['sabor']  = 'dulce';
$a['forma']  = 'redonda';
$a['nombre'] = 'manzana';
$a[]         = 4;        // la clave sera 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// resultara en la matriz array(0 => 'a' , 1 => 'b' , 2 => 'c'),
// o simplemente array('a', 'b', 'c')
?>
]]>
       </programlisting>
      </informalexample>
     </para>

    <example>
     <title>Uso de array()</title>
     <programlisting role="php">
<![CDATA[
<?php
// Array como mapa de propiedades
$mapa = array( 'version'          => 4,
               'SO'               => 'Linux',
               'idioma            => 'ingles',
               'etiquetas_cortas' => true
            );

// claves estrictamente numericas
$matriz = array( 7,
                 8,
                 0,
                 156,
                 -10
               );
// esto es lo mismo que array(0 => 7, 1 => 8, ...)

$cambios = array(         10, // clave = 0
                  5    =>  6,
                  3    =>  7, 
                  'a'  =>  4,
                          11, // clave = 6 (el indice entero maximo era 5)
                  '8'  =>  2, // clave = 8 (entero!)
                  '02' => 77, // clave = '02'
                  0    => 12  // el valor 10 sera reemplazado por 12
                );

// matriz vacia
$vacio = array();
?>
]]>
<!-- TODO example of
- overwriting keys
- using vars/functions as key/values
- warning about references
-->
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>Colecci&oacute;n</title>
     <programlisting role="php">
<![CDATA[
<?php
$colores = array('rojo', 'azul', 'verde', 'amarillo');

foreach ($colores as $color) {
    echo "&iquest;Le gusta el $color?\n";
}

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
&iquest;Le gusta el rojo?
&iquest;Le gusta el azul?
&iquest;Le gusta el verde?
&iquest;Le gusta el amarillo?
]]>
     </screen>
    </example>

    <para>
     Modificar los valores de la matriz directamente es posible a
     partir de PHP 5, pas&aacute;ndolos por referencia. Las versiones
     anteriores necesitan una soluci&oacute;n alternativa:
     <example id="language.types.array.examples.changeloop">
      <title>Colecci&oacute;n</title>
      <programlisting role="php">
<![CDATA[
<?php
// PHP 5
foreach ($colores as &$color) {
    $color = strtoupper($color);
}
unset($color); /* se asegura de que escrituras subsiguientes a $color
no modifiquen el ultimo elemento de la matriz */

// Alternativa para versiones anteriores
foreach ($colores as $clave => $color) {
    $colores[$clave] = strtoupper($color);
}

print_r($colores);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array
(
    [0] => ROJO
    [1] => AZUL
    [2] => VERDE
    [3] => AMARILLO
)
]]>
      </screen>
     </example>
    </para>
    <para>
     Este ejemplo crea una matriz con base uno.
     <example>
      <title>&Iacute;ndice con base 1</title>
      <programlisting role="php">
<![CDATA[
<?php
$primercuarto  = array(1 => 'Enero', 'Febrero', 'Marzo');
print_r($primercuarto);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array
(
    [1] => 'Enero'
    [2] => 'Febrero'
    [3] => 'Marzo'
)
]]>
      </screen>
     </example>
    </para>
    <example>
     <title>Llenado de una matriz</title>
     <programlisting role="php">
<![CDATA[
<?php
// llenar una matriz con todos los items de un directorio
$gestor = opendir('.');
while (false !== ($archivo = readdir($gestor))) {
    $archivos[] = $archivo;
}
closedir($gestor); 
?>
]]>
     </programlisting>
    </example>
    <para>
     Las matrices son ordenadas. Puede tambi&eacute;n cambiar el orden
     usando varias funciones de ordenamiento. Vea la secci&oacute;n
     sobre <link linkend="ref.array">funciones de matrices</link> para
     m&aacute;s informaci&oacute;n. Puede contar el n&uacute;mero de
     items en una matriz usando la funci&oacute;n
     <function>count</function>.
    </para>
    <example>
     <title>Ordenamiento de una matriz</title>
     <programlisting role="php">
<![CDATA[
<?php
sort($archivos);
print_r($archivos);
?>
]]>
     </programlisting>
    </example>
    <para>
     Dado que el valor de una matriz puede ser cualquier cosa,
     tambi&eacute;n puede ser otra matriz. De esta forma es posible
     crear matrices recursivas y multi-dimensionales.
    </para>
    <example>
     <title>Matrices recursivas y multi-dimensionales</title>
     <programlisting role="php">
<![CDATA[
<?php
$frutas = array ( "frutas"  => array ( "a" => "naranja",
                                       "b" => "banano",
                                       "c" => "manzana"
                                     ),
                  "numeros" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "hoyos"   => array (      "primero",
                                       5 => "segundo",
                                            "tercero"
                                     )
                );

// Algunos ejemplos que hacen referencia a los valores de la matriz anterior
echo $frutas["hoyos"][5];    // imprime "segundo"
echo $frutas["frutas"]["a"]; // imprime "naranja"
unset($frutas["hoyos"][0]);  // elimina "primero"

// Crear una nueva matriz multi-dimensional
$jugos["manzana"]["verde"] = "bien";
?>
]]>
     </programlisting>
    </example>
    <para>
     Debe advertir que la asignaci&oacute;n de matrices siempre
     involucra la copia de valores. Necesita usar el operador de
     referencia para copiar una matriz por referencia.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$matriz1 = array(2, 3);
$matriz2 = $matriz1;
$matriz2[] = 4; // $matriz2 cambia,
                // $matriz1 sigue siendo array(2, 3)

$matriz3 = &$matriz1;
$matriz3[] = 4; // ahora $matriz1 y $matriz3 son iguales
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>Objetos</title>

   <sect2 id="language.types.object.init">
    <title>Inicializaci&oacute;n de Objetos</title>

    <para>
     Para inicializar un objeto, use la sentencia
     <literal>new</literal>, lo que instancia el objeto a una
     variable.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function hacer_foo()
    {
        echo "Haciendo foo."; 
    }
}

$bar = new foo;
$bar->hacer_foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Para una discusi&oacute;n completa, por favor refi&eacute;rase a
     la secci&oacute;n <link linkend="language.oop">Clases y
     Objetos</link>.
    </simpara>
   </sect2>

   <sect2 id="language.types.object.casting">
    <title>Conversi&oacute;n a objeto</title>

    <para>
     Si un objeto es convertido a un objeto, &eacute;ste no es
     modificado. Si un valor de cualquier otro tipo es convertido a
     objeto, una nueva instancia de la clase
     <literal>stdClass</literal> es creada. Si el valor era nulo, la
     nueva instancia ser&aacute; vac&iacute;a. Para cualquier otro
     valor, una variable miembro llamada <literal>scalar</literal>
     contendr&aacute; el valor.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$obj = (object) 'ciao';
echo $obj->scalar;  // imprime 'ciao'
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>

  </sect1>

  <sect1 id="language.types.resource">
   <title>Recurso</title>

    <para>
     Un recurso es una variable especial, que contiene una referencia
     a un recurso externo. Los recursos son creados y usados por
     funciones especiales. Vea el <link
     linkend="resource">ap&eacute;ndice</link> para un listado de
     todas estas funciones y los tipos de recurso correspondientes.
    </para>

    <note>
     <simpara>
      El tipo recurso fue introducido en PHP 4
     </simpara>
    </note>

    <para>
     Vea tambi&eacute;n <function>get_resource_type</function>.
    </para>

   <sect2 id="language.types.resource.casting">
    <title>Conversi&oacute;n a un recurso</title>

    <para>
     Dado que los tipos de recurso contienen gestores especiales a
     archivos abiertos, conexiones con bases de datos, &aacute;reas de
     pintura de im&aacute;genes y cosas por el estilo, no es posible
     convertir cualquier valor a un recurso.
    </para>
   </sect2>

    <sect2 id="language.types.resource.self-destruct">
     <title>Liberaci&oacute;n de recursos</title>

    <para>
     Gracias al sistema de conteo de referencias introducido con el
     Motor Zend de PHP 4, se detecta autom&aacute;ticamente cuando un
     recurso ya no es referenciado (tal como en Java). Cuando este es
     el caso, todos los recursos que fueron usados para &eacute;ste
     recurso se liberan por el recolector de basura. Por esta
     raz&oacute;n, rara vez se necesita liberar la memoria manualmente
     mediante el uso de alguna funci&oacute;n free_result.
     <note>
      <simpara>
       Los enlaces persistentes con bases de datos son especiales,
       ellos <emphasis>no</emphasis> son destruidos por el recolector
       de basura. Vea tambi&eacute;n la secci&oacute;n sobre <link
       linkend="features.persistent-connections">conexiones
       persistentes</link>.
      </simpara>
     </note>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.null">
   <title>NULL</title>

   <para>
    El valor especial &null; representa que una variable no tiene
    valor. &null; es el &uacute;nico valor posible del tipo
    <type>NULL</type>.
   </para>
    <note>
     <simpara>
      El tipo null se introdujo en PHP 4.
     </simpara>
    </note>
    <para>
     Una variable es considerada como &null; si
     <itemizedlist>
      <listitem>
       <para>
        se ha asignado la constante &null; a la variable.
       </para>
      </listitem>
      <listitem>
       <para>
        no ha sido definida con valor alguno.
       </para>
      </listitem>
      <listitem>
       <para>
        ha sido eliminada con <function>unset</function>.
       </para>
      </listitem>
     </itemizedlist>
    </para>

   <sect2 id="language.types.null.syntax">
    <title>Sintaxis</title>
    <para>
     Existe un solo valor de tipo &null;, y ese es la palabra clave
     &null;, insensible a may&uacute;sculas y min&uacute;sculas.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$var = NULL;
?>
]]>
</programlisting>
     </informalexample>
    </para>
    <para>
     Vea tambi&eacute;n <function>is_null</function> y
     <function>unset</function>.
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.pseudo-types">
   <title>Pseudo-tipos usados en esta documentaci&oacute;n</title>

   <sect2 id="language.types.mixed">
    <title>mixed</title>
    <para>
     <literal>mixed</literal> indica que un par&aacute;metro puede
     aceptar m&uacute;ltiples tipos (pero no necesariamente todos).
    </para>
    <para>
     <function>gettype</function> por ejemplo aceptar&aacute; todos
     los tipos PHP, mientras que <function>str_replace</function>
     aceptar&aacute; cadenas y matrices.
    </para>
   </sect2>

   <sect2 id="language.types.number">
    <title>number</title>
    <para>
     <literal>number</literal> indica que un par&aacute;metro puede
     ser <type>integer</type> o <type>float</type>.
    </para>
   </sect2>

   <sect2 id="language.types.callback">
    <title>callback</title>
    <para>
     Algunas funciones como <function>call_user_func</function> o
     <function>usort</function> aceptan llamadas de retorno definidas
     por el usuario como un par&aacute;metro. Las funciones tipo
     llamada de retorno no s&oacute;lo pueden ser funciones simples,
     tambi&eacute;n pueden ser m&eacute;todos de objetos incluyendo
     m&eacute;todos est&aacute;ticos de clase.
    </para>
    <para>
     Una funci&oacute;n de PHP es simplemente pasada usando su nombre
     como una cadena. Puede pasar cualquier funci&oacute;n incorporada
     o definida por el usuario con la excepci&oacute;n de
     <function>array</function>, <function>echo</function>,
     <function>empty</function>, <function>eval</function>,
     <function>exit</function>, <function>isset</function>,
     <function>list</function>, <function>print</function> y
     <function>unset</function>.
    </para>
    <para>
     Un m&eacute;todo de un objeto instanciado es pasado como una
     matriz que contiene un objeto como el elemento con el
     &iacute;ndice 0 y un nombre de m&eacute;todo como el elemento con
     &iacute;ndice 1.
    </para>
    <para>
     Los m&eacute;todos est&aacute;ticos de clase pueden ser pasados
     tambi&eacute;n sin instanciar un objeto de esa clase al pasar el
     nombre de clase en lugar de un objeto como el elemento con
     &iacute;ndice 0.
    </para>

    <para>
     <example>
      <title>
       Ejemplos de funciones tipo llamada de retorno
      </title>
      <programlisting role="php">
<![CDATA[
<?php

// Una llamada de retorno de ejemplo
function mi_llamada_de_retorno() {
    echo '&iexcl;Hola mundo!';
}

// Un m&eacute;todo como llamada de retorno de ejemplo
class MiClase {
    function miMetodoDeRetorno() {
        echo '&iexcl;Hola Mundo!';
    }
}

// Tipo 1: Llamada de retorno simple
call_user_func('mi_llamada_de_retorno');

// Tipo 2: Llamada de metodo estatico de clase
call_user_func(array('MiClase', 'miMetodoDeRetorno'));

// Tipo 3: Llamada a un metodo de objeto
$obj = new MiClase();
call_user_func(array(&$obj, 'miMetodoDeRetorno'));
?>
]]>
      </programlisting>
     </example>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Manipulaci&oacute;n de Tipos</title>

   <simpara>
    PHP no requiere (o soporta) la definici&oacute;n expl&iacute;cita
    de tipos en la declaraci&oacute;n de variables; el tipo de una
    variable es determinado por el contexto en el que la variable es
    usada. Lo que quiere decir que si asigna un valor de cadena a la
    variable <parameter>$var</parameter>, <parameter>$var</parameter>
    se convierte en una cadena. Si luego asigna un valor entero a
    <parameter>$var</parameter>, &eacute;sta se convierte en entera.

   </simpara>
   <para>
    Un ejemplo de la conversi&oacute;n autom&aacute;tica de tipos de
    PHP es el operador de adici&oacute;n '+'. Si cualquiera de los
    operandos es un flotante, entonces todos los operandos son
    evaluados como flotantes, y el resultado ser&aacute; un
    flotante. De otro modo, los operandos ser&aacute;n interpretados
    como enteros, y el resultado ser&aacute; tambi&eacute;n un
    entero. Note que este NO modifica los tipos de los operandos
    mismos; el &uacute;nico cambio est&aacute; en la forma como los
    operandos son evaluados.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = "0";  // $foo es una cadena (ASCII 48)
$foo += 2;   // $foo es ahora un entero (2)
$foo = $foo + 1.3;  // $foo es ahora un flotante (3.3)
$foo = 5 + "10 Cerditos"; // $foo es entero (15)
$foo = 5 + "10 Cerdos";   // $foo es entero (15)
?>
]]>
<!-- bad example, no real operator (must be used with variable, modifies it too)
$foo++;      // $foo is the string "1" (ASCII 49)

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Si los dos &uacute;ltimos ejemplos lucen extra&ntilde;os, consulte
    <link linkend="language.types.string.conversion">Conversi&oacute;n
    de cadenas a n&uacute;meros</link>.
   </simpara>
   <simpara>
    Si desea forzar que una variable sea evaluada como un cierto tipo,
    consulte la secci&oacute;n sobre <link
    linkend="language.types.typecasting">Moldeamiento de
    tipos</link>. Si desea cambiar el tipo de una variable, vea
    <function>settype</function>.
   </simpara>
   <para>
    Si quisiera probar cualquiera de los ejemplos en esta
    secci&oacute;n, puede usar la funci&oacute;n
    <function>var_dump</function>.
   </para>
   <note>
    <para>
     El comportamiento de una conversi&oacute;n autom&aacute;tica a
     matriz no se encuentra definido en el momento.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a = "1";     // $a es una cadena
$a[0] = "f";  // Que hay de las posiciones de cadena? Que sucede?
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Ya que PHP (por razones hist&oacute;ricas) soporta el uso de
     &iacute;ndices en cadenas mediante desplazamientos de
     posici&oacute;n usando la misma sintaxis que la indexaci&oacute;n
     de matrices, el ejemplo anterior lleva a un problema:
     &iquest;deber&iacute;a $a convertirse en una matriz con un primer
     elemento "f", o deber&iacute;a "f" convertirse en el primer
     caracter de la cadena $a?
    </para>
    <para>
     Las versiones recientes de PHP interpretan la segunda
     asignaci&oacute;n como una identificaci&oacute;n de
     desplazamiento de cadena, as&iacute; que $a se convierte en "f",
     sin embargo el resultado de esta conversi&oacute;n
     autom&aacute;tica debe considerarse indefinido. PHP 4 introdujo
     la nueva sintaxis de llaves para acceder a los caracteres de una
     cadena, use esta sintaxis en lugar de la que fue presentada
     anteriormente:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a    = "abc"; // $a es una cadena
$a{1} = "f";   // $a es ahora "afc"
?>
]]>
      </programlisting>
     </informalexample>
     Vea la secci&oacute;n llamada <link
     linkend="language.types.string.substr">Acceso a cadenas por
     caracter</link> para m&aacute;s informaci&oacute;n.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Moldeamiento de Tipos</title>

    <para>
     El moldeamiento de tipos en PHP funciona de forma muy similar a
     como ocurre en C: el nombre del tipo deseado es escrito entre
     par&eacute;ntesis antes de la variable que debe ser moldeada.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;   // $foo es un entero
$bar = (boolean) $foo;   // $bar es un booleano
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Los moldeamiontos permitidos son:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - moldeamiento a entero</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - moldeamiento a booleano</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - moldeamiento a flotante</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - moldeamiento a cadena</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - moldeamiento a matriz</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - moldeamiento a objeto</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Note que las tabulaciones y los espacios son permitidos al
     interior de los par&eacute;ntesis, as&iacute; que las siguientes
     expresiones son funcionalmente equivalentes:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      En lugar de moldear una variable a cadena, puede tambi&eacute;n
      rodear la variable de comillas dobles.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo es un entero
$cad = "$foo";        // $cad es una cadena
$fst = (string) $foo; // $fst es tambien una cadena

// Esto imprime "son lo mismo"
if ($fst === $cad) {
    echo "son lo mismo";
}
?>
]]>
      </programlisting>
     </informalexample>
     </para>
    </note>

    <para>
     Puede que no sea obvio qu&eacute; sucede exactamente cuando se
     moldea entre ciertos tipos. Para m&aacute;s informaci&oacute;n,
     consulte las secciones:
     <itemizedlist>
      <listitem>
       <simpara><link
        linkend="language.types.boolean.casting">Conversi&oacute;n a
        booleano</link></simpara>
      </listitem>
      <listitem>
       <simpara><link
        linkend="language.types.integer.casting">Conversi&oacute;n a
        entero</link></simpara>
      </listitem>
      <listitem>
       <simpara><link
        linkend="language.types.float.casting">Conversi&oacute;n a
        flotante</link></simpara>
      </listitem>
      <listitem>
       <simpara><link
        linkend="language.types.string.casting">Conversi&oacute;n a
        cadena</link></simpara>
      </listitem>
      <listitem>
       <simpara><link
        linkend="language.types.array.casting">Conversi&oacute;n a
        matriz</link></simpara>
      </listitem>
      <listitem>
       <simpara><link
        linkend="language.types.object.casting">Conversi&oacute;n a
        objeto</link></simpara>
      </listitem>
      <listitem>
       <simpara><link
        linkend="language.types.resource.casting">Conversi&oacute;n a
        un recurso</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.null.casting">Converting to 
        &null;</link></simpara>
      </listitem>
      -->
      <listitem>
       <simpara>
        <link linkend="types.comparisons">Las tablas de
        comparaci&oacute;n de tipos</link>
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
