  <chapter id="language.types">
	<title>Types</title>

   <para>
    PHP soporta los siguientes tipos:

   <itemizedlist>
    <listitem>
     <simpara>
      <link linkend="language.types.array">array</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.double">números en punto flotante</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.integer">entero</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.object">objeto</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.string">cadena</link>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>

  <simpara>
   El tipo de una variable normalmente no lo indica el programador;
   en su lugar, lo decide PHP en tiempo de ejecución dependiendo del contexto
   en el que se utilice esa variable.
  </simpara>

  <simpara>
   Si se quisiese obligar a que una variable se convierta a un tipo
   concreto, se podría <link
   linkend="language.types.typecasting">forzar</link> la variable o
   usar la función <function>settype</function> para ello.
  </simpara>

  <simpara>
   Nótese que una variable se puede comportar de formas diferentes en ciertas
   situaciones, dependiendo de qué tipo sea en ese momento. Para más
   información, vea la sección <link
   linkend="language.types.type-juggling">Conversión de Tipos</link>.
  </simpara>

  <sect1 id="language.types.integer">
   <title>Enteros</title>
   <para>
    Los enteros se puede especificar usando una de las siguientes sintaxis:
    <informalexample>
     <programlisting role="php">
$a = 1234; # número decimal
$a = -123; # un número negativo
$a = 0123; # número octal (equivalente al 83 decimal)
$a = 0x12; # número hexadecimal (equivalente al 18 decimal)
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="language.types.double">
   <title>Números en punto flotante</title>
   <para>
    Los números en punto flotante ("double") se pueden especificar utilizando
    cualquiera de las siguientes sintaxis: 
    <informalexample>
     <programlisting role="php"> 
$a = 1.234; $a = 1.2e3;
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="language.types.string">
   <title>Cadenas</title>
   <para>
    Las cadenas de caracteres se pueden especificar usando uno de dos tipos de
    delimitadores.
   </para>
   <para>
    Si la cadena está encerrada entre dobles comillas ("), las variables que
    estén dentro de la cadena serán expandidas (sujetas a ciertas limitaciones
    de interpretación). Como en C y en Perl, el carácter de barra invertida ("\") se
    puede usar para especificar caracteres especiales:
    <table>
     <title>Caracteres protegidos</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>secuencia</entry>
        <entry>significado</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>Nueva línea</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>Retorno de carro</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>Tabulación horizontal</entry>
       </row>
       <row>
        <entry><literal>\\</literal></entry>
        <entry>Barra invertida</entry>
       </row>
       <row>
        <entry><literal>\$</literal></entry>
        <entry>Signo del dólar</entry>
       </row>
       <row>
        <entry><literal>\"</literal></entry>
        <entry>Comillas dobles</entry>
       </row>
       <row>
        <entry><literal>\[0-7]{1,3}</literal></entry>
        <entry>
         la secuencia de caracteres que coincida con la expresión
         regular es un carácter en notación octal
        </entry>
       </row>
       <row>
        <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
        <entry>
         la secuencia de caracteres que coincida con la expresión
         regular es un carácter en notación hexadecimal
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table></para>
   <para>
    Se puede proteger cualquier otro carácter, pero se producirá una
advertencia en el nivel de depuración más alto.
   </para>

   <para>
    La segunda forma de delimitar una cadena de caracteres usa el carácter de 
    comilla simple ("'"). Cuando una cadena va encerrada entre comillas 
    simples, los únicos caracteres de escape que serán comprendidos son "\\" y
    "\'". Esto es por convenio, así que se pueden tener comillas simples y 
    barras invertidas en una cadena entre comillas simples. Las variables 
    <emphasis>no</emphasis> se expandirán dentro de una cadena entre comillas
    simples.
   </para>

   <para>
    Otra forma de delimitar cadenas es usando la sintaxis de documento
incrustado ("&gt;&gt;&gt;").  Se debe proporcionar un identificador después de
    <literal>&gt;&gt;&gt;</literal>, después la cadena, y después el
    mismo identificador para cerrar el entrecomillado.
    <example> 
     <title>He aquí un ejemplo de entrecomillado de cadenas con sintaxis de
documento incrustado</title>
     <programlisting>
$str = &gt;&gt;&gt;EOD
Ejemplo de cadena
Expandiendo múltiples líneas
usando sintaxis de documento incrustado.
EOD;
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     La sintaxis de documento incristado fue añadida en PHP 4.
    </para>
   </note>

   <para>
    Las cadenas se pueden concatenar usando el operador '.' (punto). Nótese
    que el operador '+' (suma) no sirve para esto. Por favor
    mire <link linkend="language.operators.string">Operadores
    de cadena</link> para más información.
   </para>

   <para>
    Se puede acceder a los caracteres dentro de una cadena tratándola
    como un array de caracteres indexado numéricamente, usando una sintaxis
    similar a la de C. Vea un ejemplo más abajo.
   </para>

   <para>
    <example>
     <title>Algumos ejemplos de cadenas</title>
     <programlisting role="php">
&lt;?php
/* Asignando una cadena. */
$str = "Esto es una cadena";

/* Añadiendo a la cadena. */
$str = $str . " con algo más de texto";

/* Otra forma de añadir, incluye un carácter de nueva línea protegido. */
$str .= " Y un carácter de nueva línea al final.\n";

/* Esta cadena terminará siendo '&lt;p&gt;Número: 9&lt;/p&gt;' */
$num = 9;
$str = "&lt;p&gt;Número: $num&lt;/p&gt;";

/* Esta será '&lt;p&gt;Número: $num&lt;/p&gt;' */
$num = 9;
$str = '&lt;p&gt;Número: $num&lt;/p&gt;';

/* Obtener el primer carácter de una cadena  */
$str = 'Esto es una prueba.';
$first = $str[0];

/* Obtener el último carácter de una cadena. */
$str = 'Esto es aún una prueba.';
$last = $str[strlen($str)-1];
?&gt;	  
     </programlisting>
    </example>
   </para>

   <sect2 id="language.types.string.conversion">
    <title>Conversión de cadenas</title>

    <simpara>
     Cuando una cadena se evalúa como un valor numérico, el valor
     resultante y el tipo se determinan como sigue.</simpara>

    <simpara>
     La cadena se evaluará como un doble si contiene cualquiera de los
     caracteres '.', 'e', o 'E'. En caso contrario, se evaluará como un
     entero.</simpara>
     
    <para>
     El valor viene dado por la porción inicial de la cadena. Si la
     cadena comienza con datos de valor numérico, este será el valor
     usado. En caso contrario, el valor será 0 (cero). Los datos 
     numéricos válidos son un signo opcional, seguido por uno o más 
     dígitos (que opcionalmente contengan un punto decimal), seguidos 
     por un exponente opcional. El exponente es una 'e' o una 'E' 
     seguidos por uno o más dígitos.</para>

    <simpara>
     Cuando la primera expresión es una cadena, el tipo de la variable
     dependerá de la segunda expresión.
    </simpara>

    <informalexample>
     <programlisting role="php">
$foo = 1 + "10.5";              // $foo es doble (11.5)
$foo = 1 + "-1.3e3";            // $foo es doble (-1299)
$foo = 1 + "bob-1.3e3";         // $foo es entero (1)
$foo = 1 + "bob3";              // $foo es entero (1)
$foo = 1 + "10 Cerditos";     // $foo es entero (11)
$foo = 1 + "10 Cerditos"; // $foo es entero (11)
$foo = "10.0 cerdos " + 1;        // $foo es entero (11)
$foo = "10.0 cerdos " + 1.0;      // $foo es double (11)     
     </programlisting>
    </informalexample>

    <simpara>
     Para más información sobre esta conversión, mire en la página del 
     manual de Unix strtod(3).
    </simpara>

    <para>
     Si quisiera probar cualquiera de los ejemplos de esta sección,
     puede cortar y pegar los ejemplos e insertar la siguiente línea
     para ver por sí mismo lo que va ocurriendo:
     <informalexample>
      <programlisting role="php">
echo "\$foo==$foo; el tipo es " . gettype( $foo ) . "&lt;br&gt;\n";
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.array">
   <title>Arrays</title>

   <para>
    Los arrays actualmente actúan tanto como tablas hash (arrays 
    asociativos) como arrays indexados (vectores).</para>

   <sect2 id="language.types.array.single-dim">
    <title>Arrays unidimensionales</title>

    <para>
     PHP soporta tanto arrays escalares como asociativos. De hecho, no hay
     diferencias entre los dos.  Se puede crear una array usando
     las funciones <function>list</function> o <function>array</function>,
     o se puede asignar el valor de cada elemento del array de manera explícita.

     <informalexample>
      <programlisting role="php"> 
$a[0] = "abc"; 
$a[1] = "def"; 
$b["foo"] = 13;
      </programlisting>
     </informalexample>
    </para>

    <para>
     También se puede crear un array simplemente añadiendo valores al
     array. Cuando se asigna un valor a una variable array usando corchetes
     vacíos, el valor se añadirá al final del array.

     <informalexample>
      <programlisting role="php"> 
$a[] = "hola"; // $a[2] == "hola"
$a[] = "mundo"; // $a[3] == "mundo" 
      </programlisting>
     </informalexample></para>
    
    <para>
     Los arrays se pueden ordenar usando las funciones 
     <function>asort</function>, <function>arsort</function>, 
     <function>ksort</function>, <function>rsort</function>, 
     <function>sort</function>, <function>uasort</function>, 
     <function>usort</function>, y <function>uksort</function> 
     dependiendo del tipo de ordenación que se desee.</para>

    <para>
     Se puede contar el número de elementos de un array usando la función
     <function>count</function>.</para>

    <para>
      Se puede recorrer un array usando las funciones  <function>next</function>
      y <function>prev</function>.  Otra forma habitual de
      recorrer un array es usando la función <function>each</function>.
    </para>
   </sect2>

   <sect2 id="language.types.array.multi-dim">
    <title>Arrays Multidimensionales</title>

    <para>
     Los arrays multidimensionales son bastante simples actualmente.  Para cada
     dimensión del array, se puede añadir otro valor [clave] al final:

     <informalexample>
      <programlisting role="php"> 
$a[1]      = $f;           # ejemplos de una sola dimensión
$a["foo"]  = $f;   

$a[1][0]     = $f;         # bidimensional
$a["foo"][2] = $f;         # (se pueden mezclar índices numéricos y asociativos)
$a[3]["bar"] = $f;         # (se pueden mezclar índices numéricos y asociativos)

$a["foo"][4]["bar"][0] = $f;   # tetradimensional!
      </programlisting>
     </informalexample></para>

    <para>
     En PHP3 no es posible referirse a arrays multidimensionales
     directamente dentro de cadenas. Por ejemplo, lo siguiente no
     tendrá el resultado deseado:
     <informalexample>
      <programlisting role="php"> 
$a[3]['bar'] = 'Bob';
echo "Esto no va a funcionar: $a[3][bar]";
      </programlisting>
     </informalexample>

     En PHP3, lo anterior tendrá la salida <computeroutput>Esto no va a
     funcionar: Array[bar]</computeroutput>. De todas formas, el operador de
     concatenación de cadenas se puede usar para solucionar esto:
	 
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "Esto no va a funcionar: " . $a[3][bar];
      </programlisting>
     </informalexample>
	  
    </para>

    <para>
     En PHP4, sin embargo, todo el problema se puede circunvenir
     encerrando la referencia al array (dentro de la cadena) entre
     llaves:

     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "Esto va a funcionar: {$a[3][bar]}";
      </programlisting>
     </informalexample>
    </para>

    <para>
     Se pueden "rellenar" arrays multidimensionales de muchas formas, pero la
     más difícil de comprender es cómo usar el comando 
     <function>array</function> para arrays asociativos.  Estos
     dos trozos de código rellenarán el array unidimensional de la
     misma manera:

     <informalexample>
      <programlisting role="php"> 
# Ejemplo 1:

$a["color"]	= "rojo";
$a["sabor"]	= "dulce";
$a["forma"]	= "redondeada";
$a["nombre"]	= "manzana";
$a[3]		= 4;

# Example 2:
$a = array(
     "color" => "rojo",
     "sabor" => "dulce",
     "forma" => "redondeada",
     "nombre"  => "manzana",
     3       => 4
);
      </programlisting>
     </informalexample></para>

    <para>
     La función <function>array</function> se puede anidar para
     arrays multidimensionales:

     <informalexample>
      <programlisting role="php"> 
&lt;?
$a = array(
     "manzana"  => array(
          "color"  => "rojo",
          "sabor"  => "dulce",
          "forma"  => "redondeada"
     ),
     "naranja"  => array(
          "color"  => "naranja",
          "sabor"  => "ácido",
          "forma"  => "redondeada"
     ),
     "plátano"  => array(
          "color"  => "amarillo",
          "sabor"  => "paste-y",
          "forma"  => "aplatanada"
     )
);

echo $a["manzana"]["sabor"];    # devolverá "dulce"
?>
      </programlisting>
     </informalexample></para></sect2></sect1>

  <sect1 id="language.types.object">
   <title>Objetos</title>

   <sect2 id="language.types.object.init">
    <title>Inicialización de Objetos</title>

    <para>
     Para inicializar un objeto, se usa la sentencia new para instanciar
     el objeto a una variable.

     <informalexample>
       <programlisting role="php">
class foo {
    function do_foo () { 
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo();
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Type juggling</title>
repaso
   <simpara>
    PHP no requiere (o soporta) la declaración explícita del tipo en
    la declaración de variables; el tipo de una variable se determina por el
    contexto en el que se usa esa variable. Esto quiere decir que si se
    asigna un valor de cadena a la variable <parameter>var</parameter>,
    <parameter>var</parameter> se convierte en una cadena. Si después se asigna
    un valor entero a la variable <parameter>var</parameter>, se convierte en
    una variable entera.
   </simpara>

   <para>
    Un ejemplo de conversión de tipo automática en PHP3 es el operador
    suma '+'. Si cualquiera de los operandos es un doble, entonces todos
    los operandos se evalúan como dobles, y el resultado será un
    doble. En caso contrario, los operandos se interpretarán como enteros,
    y el resultado será también un entero. Nótese que esto NO
    cambia los tipos de los operandos propiamente dichos; el único cambio
    está en cómo se evalúan los operandos.

    <informalexample>
     <programlisting role="php">
$foo = "0";  // $foo es una cadena (ASCII 48)
$foo++;      // $foo es la cadena "1" (ASCII 49)
$foo += 1;   // $foo ahora es un entero (2)
$foo = $foo + 1.3;  // $foo ahora es un doble (3.3)
$foo = 5 + "10 Cerditos Pequeñitos"; // $foo es entero (15)
$foo = 5 + "10 Cerditos";     // $foo es entero (15)
     </programlisting>
    </informalexample>
   </para>

   <simpara>
    Si los últimos dos ejemplos anteriores parecen confusos, vea <link
    linkend="language.types.string.conversion">Conversión
    de cadenas</link>.
   </simpara>

   <simpara>
    Si se desea obligar a que una variable sea evaluada con un tipo concreto,
    mire la sección <link linkend="language.types.typecasting">Forzado
    de tipos</link>. Si se desea cambiar el tipo de una variable, vea la
    función <function>settype</function>.
   </simpara>

   <para>
    Si quisiese probar cualquiera de los ejemplos de esta sección,
    puede cortar y pegar los ejemplos e insertar la siguiente línea para
    ver por sí mismo lo que va ocurriendo:
    <informalexample>
     <programlisting role="php">
echo "\$foo==$foo; el tipo es " . gettype( $foo ) . "&lt;br&gt;\n";
     </programlisting>
    </informalexample>
   </para>


   <note>
    <para>
     La posibilidad de una conversión automática a array no está definida
     actualmente.
	 
     <informalexample>
      <programlisting role="php">
$a = 1;       // $a es un entero
$a[0] = "f";  // $a se convierte en un array, en el que $a[0] vale "f"
      </programlisting>
     </informalexample>
    </para>

    <para>
     Aunque el ejemplo anterior puede parecer que claramente debería resultar
     en que $a se convierta en un array, el primer elemento del cual es 'f', 
     consideremos esto:

     <informalexample>
      <programlisting role="php">
$a = "1";     // $a es una cadena
$a[0] = "f";  // ¿Qué pasa con los índices de las cadenas? ¿Qué ocurre?
      </programlisting>
     </informalexample>
    </para>

    <para>
     Dado que PHP soporta indexación en las cadenas vía offsets usando la
     misma sintaxis que la indexación de arrays, el ejemplo anterior nos 
     conduce a un problema: ¿debería convertirse $a en un array cuyo primer
     elemento sea "f", o debería convertirse "f" en el primer carácter de la
     cadena $a?
    </para>

    <para>
     Por esta razón, tanto en PHP 3.0.12 como en PHP 4.0b3-RC4, el resultado
     de esta conversión automática se considera que no está definido. Los
     parches se están discutiendo, de todas formas.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Forzado de tipos</title>

    <para>
     El forzado de tipos en PHP funciona como en C: el nombre del tipo
     deseado se escribe entre paréntesis antes de la variable a la que
     se pretende forzar.

     <informalexample>
      <programlisting role="php">
$foo = 10;   // $foo es un entero
$bar = (double) $foo;   // $bar es un doble
      </programlisting>
     </informalexample></para>
    
    <para>
     Los forzados de tipo permitidos son:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - fuerza a entero (integer)</simpara>
      </listitem>
      <listitem>
       <simpara>(real), (double), (float) - fuerza a doble (double)</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - fuerza a cadena (string)</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - fuerza a array (array)</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - fuerza a objeto (object)</simpara>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     Nótese que las tabulaciones y espacios se permiten dentro de los
     paréntesis, así que los siguientes ejemplos son funcionalmente
     equivalentes:

     <informalexample>
      <programlisting role="php">
$foo = (int) $bar;
$foo = ( int ) $bar;
      </programlisting>
     </informalexample>
    </para>

    <para>
     Puede no ser obvio que ocurrirá cuando se fuerce entre
     ciertos tipos. Por ejemplo, lo siguiente debería ser tenido
     en cuenta.
    </para>

    <para>
     Cuando se fuerza el cambio de un escalar o una variable de cadena
     a un array, la variable se convertirá en el primer elemento del
     array:
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$arr = (array) $var;
echo $arr[0];  // produce la salida 'ciao'  
      </programlisting>
     </informalexample>
    </para>

    <para>
     Cuando se fuerza el tipo de una variable escalar o de una cadena
     a un objeto, la variable se convertirá en un atributo del objeto;
     el nombre del atributo será 'scalar':
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$obj = (object) $var;
echo $obj-&gt;scalar;  // produce la salida 'ciao'
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
