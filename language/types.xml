<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.25 $ -->
<!-- EN-Revision: 1.179 Maintainer: lboshell Status: ready -->
 <chapter xml:id="language.types" xmlns="http://docbook.org/ns/docbook">
  <title>Tipos</title>

  <sect1 xml:id="language.types.intro">
  <title>Introducción</title>

  <simpara>
   PHP soporta ocho tipos primitivos.
  </simpara>

  <para>
   Cuatro tipos escalares:
   <itemizedlist>

    <listitem>
     <simpara>
      <type>boolean</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>integer</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>float</type> (número de punto-flotante, también conocido como
      '<type>double</type>')
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>string</type>
     </simpara>
    </listitem>

   </itemizedlist>
   Dos tipos compuestos:
   <itemizedlist>

    <listitem>
     <simpara>
      <type>array</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>object</type>
     </simpara>
    </listitem>

   </itemizedlist>
   Y finalmente dos tipos especiales:
   <itemizedlist>

    <listitem>
     <simpara>
      <type>resource</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>NULL</type>
     </simpara>
    </listitem>

   </itemizedlist>
   Este manual introduce también algunos <link
   linkend="language.pseudo-types">pseudo-tipos</link> por razones de
   legibilidad:
   <itemizedlist>

    <listitem>
     <simpara>
      <type>mixed</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>number</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>callback</type>
     </simpara>
    </listitem>

   </itemizedlist>
   También puede encontrar algunas referencias al tipo "double". Considere
   al tipo double como el mismo que float, los dos nombres existen solo por
   razones históricas.
  </para>

   <simpara>
    El tipo de una variable usualmente no es declarado por el programador;
    en cambio, es decidido en tiempo de compilación por PHP dependiendo del
    contexto en el que es usado la variable.
   </simpara>
   <note>
    <simpara>
     Si desea chequear el tipo y valor de una cierta <link
     linkend="language.expressions">expresión</link>, use
     <function>var_dump</function>.
    </simpara>
    <para>
     Si tan solo desea una representación legible para humanos del tipo para
     propósitos de depuración, use <function>gettype</function>. Para
     chequear por un cierto tipo, <emphasis>no</emphasis> use
     <function>gettype</function>; en su lugar utilice las funciones
     <literal>is_<replaceable>tipo</replaceable></literal>. Algunos
     ejemplos:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$un_bool = TRUE;   // un valor booleano
$un_str  = "foo";  // una cadena
$un_str2 = 'foo';  // una cadena
$un_int  = 12;     // un entero

echo gettype($un_bool); // imprime: boolean
echo gettype($un_str);  // imprime: string

// Si este valor es un entero, incrementarlo en cuatro
if (is_int($un_int)) {
    $un_int += 4;
}

// Si $bool es una cadena, imprimirla
// (no imprime nada)
if (is_string($un_bool)) {
    echo "Cadena: $un_bool";
}
?>
]]>
     </programlisting>
    </informalexample>
    </para>
   </note>
   <simpara>
    Si quisiera forzar la conversión de una variable a cierto tipo, puede
    <link linkend="language.types.typecasting">moldear</link> la variable, o
    usar la función <function>settype</function> sobre ella.
   </simpara>
   <simpara>
    Note que una variable puede ser evaluada con valores diferentes en
    ciertas situaciones, dependiendo del tipo que posee en cada momento.
    Para más información, vea la sección sobre <link
    linkend="language.types.type-juggling">Manipulación de Tipos</link>.
    Asimismo, puede encontrarse interesado en consultar las <link
    linkend="types.comparisons">tablas de comparación de tipos</link>, ya
    que éstas muestran ejemplos de las varias comparaciones relacionadas con
    tipos.
   </simpara>
  </sect1>

  <sect1 xml:id="language.types.boolean">
   <title>Booleanos</title>

   <simpara>
    Este es el tipo más simple. Un <type>boolean</type> expresa un valor de
    verdad. Puede ser &true; or &false;.
   </simpara>

   <note>
    <simpara>
     El tipo booleano fue introducido en PHP 4.
    </simpara>
   </note>

   <sect2 xml:id="language.types.boolean.syntax">
    <title>Sintaxis</title>
    <para>
     Para especificar un literal booleano, use alguna de las palabras clave
     &true; o &false;. Ambas son insensibles a mayúsculas y minúsculas.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = True; // asignar el valor TRUE a $foo
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Usualmente se usa algún tipo de <link
     linkend="language.operators">operador</link> que deuelve un valor
     <type>boolean</type>, y luego éste es pasado a una <link
     linkend="language.control-structures">estructura de control</link>.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// == es un operador que prueba por
// igualdad y devuelve un booleano
if ($accion == "mostrar_version") {
    echo "La versión es 1.23";
}

// esto no es necesario...
if ($mostrar_separadores == TRUE) {
    echo "<hr>\n";
}

// ...porque se puede escribir simplemente
if ($mostrar_separadores) {
    echo "<hr>\n";
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>

   <sect2 xml:id="language.types.boolean.casting">
    <title>Conversión a booleano</title>
    <simpara>
     Para convertir explícitamente un valor a <type>boolean</type>, use el
     moldeamiento <literal>(bool)</literal> o <literal>(boolean)</literal>.
     Sin embargo, en la mayoría de casos no es necesario usar el
     moldeamiento, ya que un valor será convertido automáticamente si un
     operador, función o estructura de control requiere un argumento tipo
     <type>boolean</type>.
    </simpara>
    <simpara>
     Vea también <link linkend="language.types.type-juggling">Manipulación
     de Tipos</link>.
    </simpara>

    <para>
     Cuando se realizan conversiones a <type>boolean</type>, los siguientes
     valores son considerados &false;:
     <itemizedlist>
      <listitem>
       <simpara>el <link
        linkend="language.types.boolean">boolean</link> &false;
        mismo</simpara>
      </listitem>
      <listitem>
       <simpara>el <link
       linkend="language.types.integer">integer</link> 0 (cero)
       </simpara>
      </listitem>
      <listitem>
       <simpara>el <link linkend="language.types.float">float</link>
       0.0 (cero) </simpara>
      </listitem>
      <listitem>
       <simpara>el valor <link
       linkend="language.types.string">string</link> vacío, y
       el <link linkend="language.types.string">string</link>
       "0"</simpara>
      </listitem>
      <listitem>
       <simpara>un <link linkend="language.types.array">array</link>
        con cero elementos</simpara>
      </listitem>
      <listitem>
       <simpara>un <link linkend="language.types.object">object</link>
        con cero variables miembro (sólo en PHP 4)</simpara>
      </listitem>
      <listitem>
       <simpara>el tipo especial <link
       linkend="language.types.null">NULL</link> (incluyendo variables
       no definidas)
       </simpara>
      </listitem>
      <listitem>
       <simpara>objetos <link linkend="ref.simplexml">SimpleXML</link>
       creados desde etiquetas vacías</simpara>
      </listitem>
     </itemizedlist>

     Cualquier otro valor es considerado &true; (incluyendo cualquier
     <link linkend="language.types.resource">resource</link>).
     <warning>
      <simpara>
       ¡<literal>-1</literal> es considerado &true;, como cualquier
       otro número diferente a cero (ya sea negativo o positivo)!
      </simpara>
     </warning>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
var_dump((bool) "");        // bool(false)
var_dump((bool) 1);         // bool(true)
var_dump((bool) -2);        // bool(true)
var_dump((bool) "foo");     // bool(true)
var_dump((bool) 2.3e5);     // bool(true)
var_dump((bool) array(12)); // bool(true)
var_dump((bool) array());   // bool(false)
var_dump((bool) "false");   // bool(true)
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.types.integer">
   <title>Enteros</title>

   <simpara>
    Un <type>integer</type> es un número del conjunto Z = {..., -2,
    -1, 0, 1, 2, ...}.
   </simpara>

   <para>
    Vea también: <link linkend="ref.gmp">Entero de longitud arbitraria /
    GMP</link>, <link linkend="language.types.float">Números de punto
    flotante</link>, y <link linkend="ref.bc">Precisión arbitraria /
    BCMath</link>
   </para>

   <sect2 xml:id="language.types.integer.syntax">
    <title>Sintaxis</title>
    <simpara>
     Los enteros pueden ser especificados en notación decimal (base-10),
     hexadecimal (base-16) u octal (base-8), opcionalmente precedidos por un
     signo (- o +).
    </simpara>
    <para>
     Si usa la notación octal, debe preceder el número con un
     <literal>0</literal> (cero), para usar la notación hexadecimal, preceda
     el número con <literal>0x</literal>.
     <example>
      <title>Literales tipo entero</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 1234; // número decimal
$a = -123; // un número negativo
$a = 0123; // número octal (equivalente al 83 decimal)
$a = 0x1A; // número hexadecimal (equivalente al 26 decimal)
?>
]]>
      </programlisting>
     </example>
     Formalmente, la posible estructura para literales enteros es:
     <informalexample>
      <programlisting>
<![CDATA[
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
]]>
      </programlisting>
     </informalexample>
     El tamaño de un entero es dependiente de la plataforma, aunque un valor
     máximo de aproximadamente dos billones es el valor usual (lo que es un
     valor de 32 bits con signo). PHP no soporta enteros sin signo.  El
     tamaño de un entero puede determinarse a partir de
     <constant>PHP_INT_SIZE</constant>, o el valor máximo de
     <constant>PHP_INT_MAX</constant> a partir de PHP 4.4.0 y PHP 5.0.5.
    </para>
    <warning>
     <para>
      Si un dígito inválido es pasado a un entero octal (p.ej. 8 o 9), el
      resto del número es ignorado.
      <example>
       <title>Curiosidad de valores octales</title>
       <programlisting role="php">
<![CDATA[
<?php
var_dump(01090); // 010 octal = 8 decimal
?>
]]>
       </programlisting>
      </example>
     </para>
    </warning>
   </sect2>

   <sect2 xml:id="language.types.integer.overflow">
    <title>Desbordamiento de enteros</title>
    <para>
     Si especifica un número más allá de los límites del tipo
     <type>integer</type>, será interpretado en su lugar como un
     <type>float</type>. Asimismo, si realiza una operación que resulta en
     un número más allá de los límites del tipo <type>integer</type>, un
     <type>float</type> es retornado en su lugar.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$numero_grande =  2147483647;
var_dump($numero_grande);
// salida: int(2147483647)

$numero_grande =  2147483648;
var_dump($numero_grande);
// salida: float(2147483648)

// también es cierto para enteros hexadecimales especificados entre 2^31 y 2^32-1:
var_dump( 0xffffffff );
// salida: float(4294967295)

// esto no ocurre con los enteros indicados como hexadecimales más allá de 2^32-1:
var_dump( 0x100000000 );
// salida: int(2147483647)

$millon = 1000000;
$numero_grande =  50000 * $millon;
var_dump($numero_grande);
// salida: float(50000000000)
?>
]]>
      </programlisting>
     </informalexample>
     <warning>
      <simpara>
       Desafortunadamente, había un fallo en PHP que provocaba que esto no
       siempre funcionara correctamente cuando se presentaban números
       negativos. Por ejemplo: cuando hace <literal>-50000 *
       $millon</literal>, el resultado será <literal>-429496728</literal>.
       Sin embargo, cuando ambos operandos son positivos no se presenta
       ningún problema.
      </simpara>
      <simpara>
       Este problema fue resuelto en PHP 4.1.0.
      </simpara>
     </warning>
    </para>
    <para>
     No hay un operador de división de enteros en PHP.
     <literal>1/2</literal> produce el <type>float</type>
     <literal>0.5</literal>. Puede moldear el valor a un entero para
     asegurarse de redondearlo hacia abajo, o puede usar la función
     <function>round</function>.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         // float(3.5714285714286)
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4)
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>

   <sect2 xml:id="language.types.integer.casting">
    <title>Conversión a entero</title>
    <simpara>
     Para convertir explícitamente un valor a <type>integer</type>, use
     alguno de los moldeamientos <literal>(int)</literal> o
     <literal>(integer)</literal>. Sin embargo, en la mayoría de casos no
     necesita usar el moldeamiento, ya que un valor será convertido
     automáticamente si un operador, función o estructura de control
     requiere un argumento tipo <type>integer</type>. También puede
     convertir un valor a entero con la función <function>intval</function>.
    </simpara>
    <simpara>
     Vea también <link linkend="language.types.type-juggling">Manipulación
     de Tipos</link>.
    </simpara>

    <sect3 xml:id="language.types.integer.casting.from-boolean">
     <title>Desde <link
     linkend="language.types.boolean">booleans</link></title>
     <simpara>
      &false; producirá <literal>0</literal> (cero), y &true; producirá
      <literal>1</literal> (uno).
     </simpara>
    </sect3>

    <sect3 xml:id="language.types.integer.casting.from-float">
     <title>Desde <link linkend="language.types.float">números de punto
     flotante</link></title>
     <simpara>
      Cuando se realizan conversiones desde un flotante a un entero, el
      número será redondeado <emphasis>hacia cero</emphasis>.
     </simpara>

     <para>
      Si el flotante se encuentra más allá de los límites del entero
      (usualmente <literal>+/- 2.15e+9 = 2^31</literal>), el resultado es
      indefinido, ya que el flotante no tiene suficiente precisión para dar
      un resultado entero exacto. No se producirá una advertencia, ¡ni
      siquiera una noticia en este caso!
     </para>

     <warning>
      <para>
       Nunca moldee una fracción desconocida a <type>integer</type>, ya que
       esto en ocasiones produce resultados inesperados.
       <informalexample>
        <programlisting role="php">
<![CDATA[
<?php
echo (int) ( (0.1+0.7) * 10 ); // imprime 7!
?>
]]>
        </programlisting>
       </informalexample>
       Para más información, consulte la <link
       linkend="warn.float-precision">advertencia sobre
       precisión-flotante</link>.
      </para>
     </warning>
    </sect3>

    <sect3 xml:id="language.types.integer.casting.from-string">
     <title>Desde cadenas</title>
     <simpara>
      Vea <link linkend="language.types.string.conversion">Conversión de
      cadenas a números</link>
     </simpara>
    </sect3>

    <sect3 xml:id="language.types.integer.casting.from-other">
     <title>Desde otros tipos</title>
     <para>
      <caution>
       <simpara>
        El comportamiento de convertir desde entero no es definido para
        otros tipos. Actualmente, el comportamiento es el mismo que si el
        valor fuera antes <link
        linkend="language.types.boolean.casting">convertido a
        booleano</link>. Sin embargo, <emphasis>no</emphasis> confíe en este
        comportamiente, ya que puede ser modificado sin aviso.
       </simpara>
      </caution>
     </para>
    </sect3>
   </sect2>
  </sect1>

  <sect1 xml:id="language.types.float">
   <title>Números de punto flotante</title>
   <para>
    Los números de punto flotante (también conocidos como "flotantes",
    "dobles" o "números reales") pueden ser especificados usando cualquiera
    de las siguientes sintaxis:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1.234;
$b = 1.2e3;
$c = 7E-10;
?>
]]>
     </programlisting>
    </informalexample>
    Formalmente:
    <informalexample>
     <programlisting role="php">
<![CDATA[
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]? {LNUM})
]]>
     </programlisting>
    </informalexample>
    El tamaño de un flotante depende de la plataforma, aunque un valor común
    consiste en un máximo de ~1.8e308 con una precisión de aproximadamente
    14 dígitos decimales (lo que es un valor de 64 bits en formato IEEE).
   </para>

   <warning xml:id="warn.float-precision">
    <title>Precisión del punto flotante</title>
    <para>
     Es bastante común que algunas fracciones decimales simples como
     <literal>0.1</literal> o <literal>0.7</literal> no puedan ser
     convertidas a su representación binaria interna sin perder un poco de
     precisión. Esto puede llevar a resultados confusos: por ejemplo,
     <literal>floor((0.1+0.7)*10)</literal> usualmente devolverá
     <literal>7</literal> en lugar del esperado <literal>8</literal> ya que
     el resultado de la representación interna es en realidad algo como
     <literal>7.9999999999...</literal>.
    </para>
    <para>
     Esto se encuentra relacionado al hecho de que es imposible expresar de
     forma exacta algunas fracciones en notación decimal con un número
     finito de dígitos. Por ejemplo, <literal>1/3</literal> en forma decimal
     se convierte en <literal>0.3333333. . .</literal>.
    </para>
    <para>
     Así que nunca confíe en resultados de números flotantes hasta el último
     dígito, y nunca compare números de punto flotante para conocer si son
     equivalentes. Si realmente necesita una mejor precisión, es buena idea
     que use las <link linkend="ref.bc">funciones matemáticas de precisión
     arbitraria</link> o las funciones <link linkend="ref.gmp">gmp</link> en
     su lugar.
    </para>
   </warning>

   <sect2 xml:id="language.types.float.casting">
    <title>Conversión a flotante</title>

    <para>
     Para más información sobre cuándo y cómo son convertidas las cadenas a
     flotantes, vea la sección titulada <link
     linkend="language.types.string.conversion">Conversión de cadenas a
     números</link>. Para valores de otros tipos, la conversión es la misma
     que si el valor hubiese sido convertido a entero y luego a flotante.
     Vea la sección <link
     linkend="language.types.integer.casting">Conversión a entero</link>
     para más información. A partir de PHP 5, una noticia es generada si
     intenta convertir un objeto a flotante.
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.types.string">
   <title>Cadenas</title>
   <para>
    Un valor <type>string</type> es una serie de caracteres. En PHP, un
    caracter es lo mismo que un byte, es decir, hay exactamente 256 tipos de
    caracteres diferentes. Esto implica también que PHP no tiene soporte
    nativo de Unicode. Vea <function>utf8_encode</function> y
    <function>utf8_decode</function> para conocer sobre el soporte Unicode.
   </para>
   <note>
    <simpara>
     El que una cadena se haga muy grande no es un problema. PHP no impone
     límite práctico alguno sobre el tamaño de las cadenas, así que no hay
     ninguna razón para preocuparse sobre las cadenas largas.
    </simpara>
   </note>
   <sect2 xml:id="language.types.string.syntax">
    <title>Sintaxis</title>
    <para>
     Un literal de cadena puede especificarse en tres formas diferentes.
     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">comillas
        simples</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">comillas
        dobles</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">sintaxis
        heredoc</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>
    <sect3 xml:id="language.types.string.syntax.single">
     <title>Comillas simples</title>
     <para>
      La forma más simple de especificar una cadena sencilla es rodearla de
      comillas simples (el caracter <literal>'</literal>).
     </para>
     <para>
      Para especificar una comilla sencilla literal, necesita escaparla con
      una barra invertida (<literal>\</literal>), como en muchos otros
      lenguajes. Si una barra invertida necesita aparecer antes de una
      comilla sencilla o al final de la cadena, necesitará doblarla. Note
      que si intenta escapar cualquier otro caracter, ¡la barra invertida
      será impresa también! De modo que, por lo general, no hay necesidad de
      escapar la barra invertida misma.
      <note>
       <simpara>
        En PHP 3, se generará una advertencia de nivel
        <literal>E_NOTICE</literal> cuando esto ocurra.
       </simpara>
      </note>
      <note>
       <simpara>
        A diferencia de las otras dos sintaxis, las <link
        linkend="language.variables">variables</link> y secuencias de escape
        para caracteres especiales <emphasis>no</emphasis> serán expandidas
        cuando ocurren al interior de cadenas entre comillas sencillas.
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo 'esta es una cadena simple';

echo 'También puede tener saltos de línea embebidos
en las cadenas de esta forma, ya que
es válido';

// Imprime: Arnold dijo una vez: "I'll be back"
echo 'Arnold dijo una vez: "I\'ll be back"';

// Imprime: Ha eliminado C:\*.*?
echo 'Ha eliminado C:\\*.*?';

// Imprime: Ha eliminado C:\*.*?
echo 'Ha eliminado C:\*.*?';

// Imprime: Esto no va a expandirse: \n una nueva línea
echo 'Esto no va a expandirse: \n una nueva línea';

// Imprime: Las variables no se $expanden $tampoco
echo 'Las variables no se $expanden $tampoco';
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 xml:id="language.types.string.syntax.double">
     <title>Comillas dobles</title>
     <para>
      Si la cadena se encuentra rodeada de comillas dobles ("), PHP entiende
      más secuencias de escape para caracteres especiales:
     </para>
     <table>
      <title>Caracteres escapados</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>secuencia</entry>
         <entry>significado</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>\n</literal></entry>
         <entry>alimentación de línea (LF o 0x0A (10) en
         ASCII)</entry>
        </row>
        <row>
         <entry><literal>\r</literal></entry>
         <entry>retorno de carro (CR o 0x0D (13) en ASCII)</entry>
        </row>
        <row>
         <entry><literal>\t</literal></entry>
         <entry>tabulación horizontal (HT o 0x09 (9) en ASCII)</entry>
        </row>
        <row>
         <entry><literal>\\</literal></entry>
         <entry>barra invertida</entry>
        </row>
        <row>
         <entry><literal>\$</literal></entry>
         <entry>signo de dólar</entry>
        </row>
        <row>
         <entry><literal>\"</literal></entry>
         <entry>comilla-doble</entry>
        </row>
        <row>
         <entry><literal>\[0-7]{1,3}</literal></entry>
         <entry>
          la secuencia de caracteres que coincide con la expresión
          regular es un caracter en notación octal
         </entry>
        </row>
        <row>
         <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
         <entry>
          la secuencia de caracteres que coincide con la expresión regular
          es un caracter en notación hexadecimal
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Nuevamente, si intenta escapar cualquier otro caracter, ¡la barra
      invertida será impresa también!  Antes de PHP 5.1.1, la barra
      invertida en <literal>\{$var}</literal> no venía imprimiéndose.
     </para>
     <para>
      Pero la característica más importante de las cadenas entre comillas
      dobles es el hecho de que los nombres de variables serán expandidos.
      Vea <link linkend="language.types.string.parsing">procesamiento de
      cadenas</link> para más detalles.
     </para>
    </sect3>

    <sect3 xml:id="language.types.string.syntax.heredoc">
     <title>Heredoc</title>
     <simpara>
      Otra forma de delimitar cadenas es mediante el uso de la sintaxis
      heredoc ("&lt;&lt;&lt;"). Debe indicarse un identificador (seguido por
      un salto de línea) después de la secuencia
      <literal>&lt;&lt;&lt;</literal>, luego la cadena, y luego el mismo
      identificador para cerrar la cita.
     </simpara>
     <simpara>
      El identificador de cierre <emphasis>debe</emphasis> comenzar en la
      primera columna de la línea. Asimismo, el identificador usado debe
      seguir las mismas reglas que cualquier otra etiqueta en PHP: debe
      contener solo caracteres alfanuméricos y de subrayado, y debe iniciar
      con un caracter no-dígito o de subrayado.
     </simpara>

     <warning>
      <simpara>
       Es muy importante notar que la línea con el identificador de cierre
       no contenga otros caracteres, excepto <emphasis>quizás</emphasis> por
       un punto-y-coma (<literal>;</literal>). Esto quiere decir en especial
       que el identificador <emphasis>no debe usar sangría</emphasis>, y no
       debe haber espacios o tabuladores antes o después del punto-y-coma.
       Es importante también notar que el primer caracter antes del
       identificador de cierre debe ser un salto de línea, tal y como lo
       defina su sistema operativo. Esto quiere decir <literal>\r</literal>
       en Macintosh, por ejemplo. El delimitador de cierre (posiblemente
       seguido de un punto-y-coma) debe ser seguido también por una nueva
       línea.
      </simpara>
      <simpara>
       Si esta regla es rota y el identificador de cierre no es "limpio",
       entonces no se considera un identificador de cierre y PHP continuará
       en busca de uno. Si, en tal caso, no se encuentra un identificador de
       cierre apropiado, entonces un error del analizador sintáctico
       resultará con el número de línea apuntando al final del script.
      </simpara>
      <para>
       No es permitido usar la sintaxis heredoc al inicializar miembros de
       clase. Use otro tipo de sintaxis en su lugar.
       <example>
        <title>Ejemplo inválido</title>
        <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
        </programlisting>
       </example>
      </para>
     </warning>

     <para>
      El texto heredoc se comporta tal como una cadena entre comillas
      dobles, sin las comillas dobles. Esto quiere decir que no necesita
      escapar tales comillas en sus bloques heredoc, pero aun puede usar los
      códigos de escape listados anteriormente. Las variables son
      expandidas, aunque debe tenerse el mismo cuidado cuando se expresen
      variables complejas al interior de un segmento heredoc, al igual que
      con otras cadenas.
      <example>
       <title>Ejemplo de uso de una cadena heredoc</title>
       <programlisting role="php">
<![CDATA[
<?php
$cadena = <<<FIN
Ejemplo de una cadena
que se extiende por varias líneas
usando la sintaxis heredoc.
FIN;

/* Un ejemplo más complejo, con variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$nombre = 'MiNombre';

echo <<<FIN
Mi nombre es "$nombre". Estoy imprimiendo algo de $foo->foo.
Ahora, estoy imprimiendo algo de {$foo->bar[1]}.
Esto debería imprimir una letra 'A' mayúscula: \x41
FIN;
?>
]]>
       </programlisting>
      </example>
     </para>

     <note>
      <para>
       El soporte heredoc fue agregado en PHP 4.
      </para>
     </note>
    </sect3>

    <sect3 xml:id="language.types.string.parsing">
     <title>Procesamiento de variables</title>
     <simpara>
      Cuando una cadena es especificada en comillas dobles o al interior de
      un bloque heredoc, las <link
      linkend="language.variables">variables</link> son interpretadas en su
      interior.
     </simpara>
     <simpara>
      Existen dos tipos de sintaxis: una <link
      linkend="language.types.string.parsing.simple">simple</link> y una
      <link linkend="language.types.string.parsing.complex">compleja</link>.
      La sintaxis simple es la más común y conveniente. Esta ofrece una
      forma de interpretar una variable, un valor <type>array</type>, o una
      propiedad de un <type>object</type>.
     </simpara>
     <simpara>
      La sintaxis compleja fue introducida en PHP 4, y puede reconocerse por
      las llaves que rodean la expresión.
     </simpara>

     <sect4 xml:id="language.types.string.parsing.simple">
      <title>Sintaxis simple</title>
      <simpara>
       Si un signo de dólar (<literal>$</literal>) es encontrado, el
       analizador sintáctico tomará ambiciosamente tantos lexemas como le
       sea posible para formar un nombre de variable válido. Rodee el nombre
       de la variable de llaves si desea especificar explícitamente el final
       del nombre.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$cerveza = 'Heineken';
echo "El sabor de varias $cerveza's es excelente"; // funciona, "'" no es un caracter válido para nombres de variables
echo "Tomó algunas $cervezas";   // no funciona, 's' es un caracter válido para nombres de variables
echo "Tomó algunas ${cerveza}s"; // funciona
echo "Tomó algunas {$cerveza}s"; // funciona
?>
]]>
       </programlisting>
      </informalexample>
      <simpara>
       De forma similar, puede hacer que un índice de un <type>array</type>
       o una propiedad de un <type>object</type> sean interpretados. En el
       caso de los índices de matrices, el corchete cuadrado de cierre
       (<literal>]</literal>) marca el final del índice. Para las
       propiedades de objetos, se aplican las mismas reglas de las variables
       simples, aunque con las propiedades de objetos no existe un truco
       como el que existe con las variables.

       <!-- XXX isn't &true; :(, this would be the trick
       Also, the same trick with curly-braces works if you
       want to limit the greediness of parsers.
       -->

      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Estos ejemplos son específicos al uso de matrices al interior de
// cadenas. Cuando se encuentre por fuera de una cadena, siempre rodee
// de comillas las claves tipo cadena de su matriz, y no use
// {llaves} por fuera de cadenas tampoco.

// Mostremos todos los errores
error_reporting(E_ALL);

$frutas = array('fresa' => 'roja', 'banano' => 'amarillo');

// Funciona pero note que esto trabaja de forma diferente por fuera de
// cadenas entre comillas
echo "Un banano es $frutas[banano].";

// Funciona
echo "Un banano es {$frutas['banano']}.";

// Funciona, pero PHP busca una constante llamada banano primero, como
// se describe más adelante.
echo "Un banano es {$frutas[banano]}.";

// No funciona, use llaves. Esto resulta en un error de análisis sintáctico.
echo "Un banano es $frutas['banano'].";

// Funciona
echo "Un banano es " . $frutas['banano'] . ".";

// Funciona
echo "Este cuadro tiene $cuadro->ancho metros de ancho.";

// No funciona. Para una solución, vea la sintaxis compleja.
echo "Este cuadro tiene $cuadro->ancho00 centímetros de ancho.";
?>
]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
       </programlisting>
      </informalexample>
      <simpara>
       Para cualquier cosa más sofisticada, debería usarse la sintaxis
       compleja.
      </simpara>
     </sect4>

     <sect4 xml:id="language.types.string.parsing.complex">
      <title>Sintaxis compleja (llaves)</title>
      <simpara>
       Esta no es llamada compleja porque la sintaxis sea compleja, sino
       porque es posible incluir expresiones complejas de esta forma.
      </simpara>
      <simpara>
       De hecho, de esta forma puede incluir cualquier valor que sea parte
       del espacio de nombres al interior de cadenas. Simplemente escriba la
       expresión en la misma forma que lo haría si se encontrara por fuera
       de una cadena, y luego la ubica entre { y }. Ya que no es posible
       escapar '{', esta sintaxis será reconocida únicamente cuando el
       caracter $ se encuentra inmediatamente después de {. (Use "{\$" para
       obtener una secuencia literal "{$"). Algunos ejemplos para aclarar el
       asunto:
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Mostremos todos los errores
error_reporting(E_ALL);

$genial = 'fantástico';

// No funciona, imprime: Esto es { fantástico}
echo "Esto es { $genial}";

// Funciona, imprime: Esto es fantástico
echo "Esto es {$genial}";
echo "Esto es ${genial}";

// Funciona
echo "Este cuadro tiene {$cuadro->ancho}00 centímetros de ancho.";

// Funciona
echo "Esto funciona: {$matriz[4][3]}";

// Esto está mal por la misma razón por la que $foo[bar] está mal por
// fuera de una cadena. En otras palabras, aun funciona pero ya que
// PHP busca primero una constante llamada foo, genera un error de
// nivel E_NOTICE (constante indefinida).
echo "Esto está mal: {$matriz[foo][3]}";

// Funciona. Cuando se usan matrices multi-dimensionales, use siempre
// llaves alrededor de las matrices al interior de cadenas
echo "Esto funciona: {$matriz['foo'][3]}";

// Funciona.
echo "Esto funciona: " . $arr['foo'][3];

echo "Puede incluso escribir {$obj->valores[3]->nombre}";

echo "Este es el valor de la variable llamada $nombre: {${$nombre}}";
?>
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
       </programlisting>
      </informalexample>

      <note>
       <para>
        Las llamadas a funciones y métodos trabajan a partir de PHP 5.
       </para>
      </note>
     </sect4>
    </sect3>

    <sect3 xml:id="language.types.string.substr">
     <title>Acceso a cadenas y modificación por caracter</title>
     <para>
      Los caracteres al interior de una cadena pueden ser consultados y
      modificados al especificar el desplazamiento, comenzando en cero, del
      caracter deseado después de la cadena usando corchetes cuadrados
      tipo-matriz como <varname>$cadena[42]</varname>, así que piense en una
      cadena como un <type>array</type> de caracteres.
     </para>
     <note>
      <simpara>
       También es posible acceder a los caracteres usando llaves como
       <varname>$cadena{42}</varname> para el mismo propósito. Sin embargo,
       se prefiere el uso de corchetes cuadrados ya que el estilo
       {corchetes} es considerado obsoleto a partir de PHP 6.
      </simpara>
     </note>
     <para>
      <example>
       <title>Algunos ejemplos de cadenas</title>
       <programlisting role="php">
<![CDATA[
<?php
// Obtener el primer caracter de una cadena
$cadena = 'Esta es una prueba.';
$primer = $cadena[0];

// Obtener el tercer caracter de una cadena
$tercer = $cadena[2];

// Obtener el último caracter de una cadena.
$cadena = 'Esta es también una prueba.';
$ultimo = $cadena[strlen($cadena)-1];

// Modificar el último caracter de una cadena
$cadena = 'Observe el mar';
$cadena[strlen($cadena)-1] = 'l';

// El método alternativo usando {} es obsoleto desde PHP 6
$tercer = $cadena{2};

?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 xml:id="language.types.string.useful-funcs">
    <title>Funciones y operadores útiles</title>
    <para>
     Las cadenas pueden ser concatenadas usando el operador '.' (punto).
     Note que el operador '+' (adición) no funciona para este propósito. Por
     favor refiérase a la sección <link
     linkend="language.operators.string">Operadores de cadena</link> para
     más información.
    </para>
    <para>
     Existen bastantes funciones útiles para la modificación de cadenas.
    </para>
    <simpara>
     Vea la <link linkend="ref.strings">sección de funciones de
     cadena</link> para consultar funciones de uso general, o las funciones
     de expresiones regulares para búsquedas y reemplazos avanzados (en dos
     sabores: <link linkend="ref.pcre">Perl</link> y <link
     linkend="ref.regex">POSIX extendido</link>).
    </simpara>
    <simpara>
     Existen también <link linkend="ref.url">funciones para cadenas tipo
     URL</link>, y funciones para encriptar/descifrar cadenas (<link
     linkend="ref.mcrypt">mcrypt</link> y <link
     linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Finalmente, si aun no ha encontrado lo que busca, vea también las <link
     linkend="ref.ctype">funciones de tipo de caracter</link>.
    </simpara>
   </sect2>

   <sect2 xml:id="language.types.string.casting">
    <title>Conversión a cadena</title>

    <para>
     Es posible convertir un valor a una cadena usando el moldeamiento
     <literal>(string)</literal>, o la función <function>strval</function>.
     La conversión a cadena se realiza automáticamente para usted en el
     contexto de una expresión cuando se necesita una cadena. Esto ocurre
     cuando usa las funciones <function>echo</function> o
     <function>print</function>, o cuando compara el valor de una variable
     con una cadena. El contenido de las secciones del manual sobre <link
     linkend="language.types">Tipos</link> y <link
     linkend="language.types.type-juggling">Manipulación de Tipos</link>
     ayudan a aclarar este hecho. Vea también <function>settype</function>.
    </para>

    <para>
     Un valor <type>boolean</type> &true; es convertido a la cadena
     <literal>"1"</literal>, el valor &false; se representa como
     <literal>""</literal> (una cadena vacía). De esta forma, usted puede
     convertir de ida y vuelta entre valores booleanos y de cadena.
    </para>
    <para>
     Un número <type>integer</type> o de punto flotante (<type>float</type>)
     es convertido a una cadena que representa el número con sus dígitos
     (incluyendo la parte del exponente para los números de punto flotante).
    </para>
    <note>
     <para>
      El caracter de punto decimal es definido en la localización del script
      (categoría LC_NUMERIC). Vea <function>setlocale</function>.
     </para>
    </note>
    <para>
     Las matrices son siempre convertidas a la cadena
     <literal>"Array"</literal>, de modo que no puede volcar los contenidos
     de un valor <type>array</type> con <function>echo</function> o
     <function>print</function> para ver lo que se encuentra en su interior.
     Para ver un elemento, usted tendría que hacer algo como <literal>echo
     $arr['foo']</literal>. Vea más adelante algunos consejos sobre el
     volcado/vista del contenido completo.
    </para>
    <para>
     Los objetos son convertidos siempre a la cadena
     <literal>"Object"</literal>. Si quisiera imprimir los valores de
     variables miembro de un <type>object</type> para efectos de depuración,
     lea los parágrafos siguientes. Si quiere conocer el nombre de clase del
     cual un objeto dado es instancia, use <function>get_class</function>. A
     partir de PHP 5, el método __toString() es usado si resulta aplicable.
    </para>
    <para>
     Los recursos son siempre convertidos a cadenas con la estructura
     <literal>"Resource id #1"</literal> en donde <literal>1</literal> es el
     número único del valor <type>resource</type> asignado por PHP durante
     tiempo de ejecución. Si quisiera obtener el tipo del recurso, use
     <function>get_resource_type</function>.
    </para>
    <para>
     &null; se convierte siempre a una cadena vacía.
    </para>

    <para>
     Como puede apreciar, el imprimir matrices, objetos o recursos no le
     ofroce información útil sobre los valores mismos. Consulte las
     funciones <function>print_r</function> y <function>var_dump</function>
     para conocer mejores formas de imprimir valores para depuración.
    </para>

    <para>
     También puede convertir valores PHP a cadenas y almacenarlas
     permanentemente. Este método es conocido como seriación, y puede ser
     efectuado con la función <function>serialize</function>. También puede
     seriar valores PHP a estructuras XML, si cuenta con soporte <link
     linkend="ref.wddx">WDDX</link> en su configuración de PHP.
    </para>
   </sect2>

   <sect2 xml:id="language.types.string.conversion">
    <title>Conversión de cadenas a números</title>

    <simpara>
     Cuando una cadena es evaluada como un valor numérico, el valor
     resultante y su tipo son determinados como sigue.
    </simpara>
    <simpara>
     La cadena será evaluada como un <type>float</type> si contiene
     cualquier caracter entre '.', 'e', o 'E'. De otra forma, evaluará como
     un entero.
    </simpara>
    <para>
     El valor es dado por la porción inicial de la cadena. Si la cadena
     comienza con datos numéricos válidos, éstos serán el valor usado. De lo
     contrario, el valor será 0 (cero). Un signo opcional es considerado un
     dato numérico válido, seguido por uno o más dígitos (que pueden
     contener un punto decimal), seguidos por un exponente opcional. El
     exponente es una 'e' o 'E' seguida de uno o más dígitos.
    </para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo es flotante (11.5)
$foo = 1 + "-1.3e3";              // $foo es flotante (-1299)
$foo = 1 + "bob-1.3e3";           // $foo es entero (1)
$foo = 1 + "bob3";                // $foo es entero (1)
$foo = 1 + "10 Cerditos";         // $foo es entero (11)
$foo = 4 + "10.2 Cerditos";       // $foo es flotante (14.2)
$foo = "10.0 cerdos " + 1;        // $foo es flotante (11)
$foo = "10.0 cerdos " + 1.0;      // $foo es flotante (11)
?>
]]>
     </programlisting>
    </informalexample>
    <simpara>
     Para más información sobre esta conversión, vea la página del manual
     Unix sobre strtod(3).
    </simpara>
    <para>
     Si quisiera probar cualquiera de los ejemplos presentados en esta
     sección, puede cortar y pegar los ejemplos e insertar la siguiente
     línea para verificar por sí mismo lo que está sucediendo:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; tipo es " . gettype ($foo) . "<br />\n";
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     No espere obtener el código de un caractar convirtiéndolo a un entero
     (como lo haría en C, por ejemplo). Use las funciones
     <function>ord</function> y <function>chr</function> para convertir
     entre códigos de caracter y caracteres.
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 xml:id="language.types.array">
   <title>Matrices</title>

   <para>
    Una matriz en PHP es en realidad un mapa ordenado. Un mapa es un tipo de
    datos que asocia <emphasis>valores</emphasis> con
    <emphasis>claves</emphasis>. Este tipo es optimizado en varias formas,
    de modo que puede usarlo como una matriz real, o una lista (vector),
    tabla asociativa (caso particular de implementación de un mapa),
    diccionario, colección, pila, cola y probablemente más. Ya que puede
    tener otra matriz PHP como valor, es realmente fácil simular árboles.
   </para>
   <para>
    Una explicación sobre tales estructuras de datos se encuentra por fuera
    del propósito de este manual, pero encontrará al menos un ejemplo de
    cada uno de ellos. Para más información, le referimos a literatura
    externa sobre este amplio tema.
   </para>

   <sect2 xml:id="language.types.array.syntax">
    <title>Sintaxis</title>

    <sect3 xml:id="language.types.array.syntax.array-func">
     <title>Especificación con <function>array</function></title>
     <para>
      Un <type>array</type> puede ser creado por la construcción de lenguaje
      <function>array</function>. Ésta toma un cierto número de parejas
      <literal><replaceable>clave</replaceable> =&gt;
      <replaceable>valor</replaceable></literal> separadas con coma.
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>clave</replaceable> =&gt; </optional> <replaceable>valor</replaceable>
     , ...
     )
// <replaceable>clave</replaceable> puede ser un <type>integer</type> o <type>string</type>
// <replaceable>valor</replaceable> puede ser cualquier valor
      </synopsis>
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$matriz = array("foo" => "bar", 12 => true);

echo $matriz["foo"]; // bar
echo $matriz[12];    // 1
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Una <varname>clave</varname> puede ser un <literal>integer</literal> o
      un <type>string</type>. Si una clave es la representación estándar de
      un <type>integer</type>, será interpretada como tal (es decir,
      <literal>"8"</literal> será interpretado como <literal>8</literal>,
      mientras que <literal>"08"</literal> será interpretado como
      <literal>"08"</literal>). Los valores flotantes en
      <varname>clave</varname> serán truncados a valores tipo
      <type>integer</type>. No existen tipos diferentes para matrices
      indexadas y asociativas en PHP; sólo existe un tipo de matriz, el cual
      puede contener índices tipo entero o cadena.
     </para>
     <para>
      Un valor puede ser de cualquier tipo en PHP.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$matriz = array("unamatriz" => array(6 => 5, 13 => 9, "a" => 42));

echo $matriz["unamatriz"][6];    // 5
echo $matriz["unamatriz"][13];   // 9
echo $matriz["unamatriz"]["a"];  // 42
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Si no especifica una clave para un valor dado, entonces es usado el
      máximo de los índices enteros, y la nueva clave será ese valor máximo
      + 1. Si especifica una clave que ya tiene un valor asignado, ése valor
      será sobrescrito.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Esta matriz es la misma que ...
array(5 => 43, 32, 56, "b" => 12);

// ...esta matriz
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <warning>
      <simpara>
       A partir de PHP 4.3.0, el comportamiento de generación de índices
       descrito ha cambiado. Ahora, si agrega un elemento a una matriz cuya
       clave máxima actual es un valor negativo, entonces la siguiente clave
       creada será cero (<literal>0</literal>). Anteriormente, el nuevo
       índice hubiera sido establecido a la clave mayor existente + 1, al
       igual que con los índices positivos.
      </simpara>
     </warning>
     <para>
      Al usar &true; como clave, el valor será evaluado al
      <type>integer</type> <literal>1</literal>. Al usar &false; como clave,
      el valor será evaluado al <type>integer</type> <literal>0</literal>.
      Al usar <literal>NULL</literal> como clave, el valor será evaluado a
      una cadena vacía. El uso de una cadena vacía como clave creará (o
      reemplazará) una clave con la cadena vacía y su valor; no es lo mismo
      que usar corchetes vacíos.
     </para>
     <para>
      No es posible usar matrices u objetos como claves. Al hacerlo se
      producirá una advertencia: <literal>Illegal offset type</literal>.
     </para>
    </sect3>

    <sect3 xml:id="language.types.array.syntax.modifying">
     <title>Creación/modificación con sintaxis de corchetes
     cuadrados</title>
     <para>
      Es posible modificar una matriz existente al definir valores
      explícitamente en ella.
     </para>
     <para>
      Esto es posible al asignar valores a la matriz al mismo tiempo que se
      especifica la clave entre corchetes. También es posible omitir la
      clave, agregar una pareja vacía de corchetes ("<literal>[]</literal>")
      al nombre de la variable en ese caso.
      <synopsis>
$matriz[<replaceable>clave</replaceable>] = <replaceable>valor</replaceable>;
$matriz[] = <replaceable>valor</replaceable>;
// <replaceable>clave</replaceable> puede ser un <type>integer</type> o <type>string</type>
// <replaceable>valor</replaceable> puede ser cualquier valor
      </synopsis>
      Si <varname>$matriz</varname> no existe aun, ésta será creada. De modo
      que esta es también una forma alternativa de especificar una matriz.
      Para modificar un cierto valor, simplemente asigne un nuevo valor a un
      elemento especificado con su clave. Si desea remover una pareja
      clave/valor, necesita eliminarla mediante <function>unset</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$matriz = array(5 => 1, 12 => 2);

$matriz[] = 56;    // Esto es igual que $matriz[13] = 56;
                   // en este punto del script

$matriz["x"] = 42; // Esto agrega un nuevo elemento a la
                   // matriz con la clave "x"

unset($matriz[5]); // Esto elimina el elemento de la matriz

unset($matriz);    // Esto elimina la matriz completa
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <note>
      <para>
       Como se menciona anteriormente, si provee los corchetes sin ninguna
       clave especificada, entonces se toma el máximo de los índices enteros
       existentes, y la nueva clave será ese valor máximo + 1. Si no existen
       índices enteros aun, la clave será <literal>0</literal> (cero). Si
       especifica una clave que ya tenía un valor asignado, el valor será
       reemplazado.
      </para>
      <para>
       <warning>
        <simpara>
         A partir de PHP 4.3.0, el comportamiento de generación de índices
         descrito ha cambiado. Ahora, si agrega un elemento al final de una
         matriz en la que la clave máxima actual es negativa, la siguiente
         clave creada será cero (<literal>0</literal>). Anteriormente, el
         nuevo índice hubiera sido definido como la mayor clave + 1, al
         igual que ocurre con los índices positivos.
        </simpara>
       </warning>
      </para>
      <para>
       Note que la clave entera máxima usada para este caso <emphasis>no
       necesita existir actualmente en la matriz</emphasis>. Tan solo debe
       haber existido en la matriz en algún punto desde que la matriz haya
       sido re-indexada. El siguiente ejemplo ilustra este caso:
      </para>

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Crear una matriz simple.
$matriz = array(1, 2, 3, 4, 5);
print_r($matriz);

// Ahora eliminar cada ítem, pero dejar la matriz misma intacta:
foreach ($matriz as $i => $valor) {
    unset($matriz[$i]);
}
print_r($matriz);

// Agregar un ítem (note que la nueva clave es 5, en lugar de 0 como
// podría esperarse).
$matriz[] = 6;
print_r($matriz);

// Re-indexar:
$matriz = array_values($matriz);
$matriz[] = 7;
print_r($matriz);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
       </screen>
      </informalexample>

     </note>
    </sect3>
   </sect2><!-- end syntax -->

   <sect2 xml:id="language.types.array.useful-funcs">
    <title>Funciones útiles</title>
    <para>
     Existe un buen número de funciones útiles para trabajar con matrices.
     Consulte la sección <link linkend="ref.array">funciones de
     matrices</link>.
    </para>
    <note>
     <para>
      La función <function>unset</function> le permite remover la definición
      de claves de una matriz. Tenga en cuenta que la matriz NO es
      re-indexada. Si sólo usa "índices enteros comunes" (comenzando desde
      cero, incrementando en uno), puede conseguir el efecto de
      re-indexación usando
      <function>array_values</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'uno', 2 => 'dos', 3 => 'tres');
unset($a[2]);
/* producirá una matriz que hubiera sido definida como
   $a = array(1 => 'uno', 3 => 'tres');
   y NO
   $a = array(1 => 'uno', 2 =>'tres');
*/

$b = array_values($a);
// Ahora $b es array(0 => 'uno', 1 =>'tres')
?>
]]>
      </programlisting>
     </informalexample>

     </para>
    </note>
    <para>
     La estructura de control <link
     linkend="control-structures.foreach">foreach</link> existe
     específicamente para las matrices. Ésta provee una manera fácil de
     recorrer una matriz.
    </para>
   </sect2>

   <sect2 xml:id="language.types.array.donts">
    <title>Recomendaciones sobre matrices y cosas a evitar</title>

    <sect3 xml:id="language.types.array.foo-bar">
     <title>¿Porqué es incorrecto
     <literal>$foo[bar]</literal>?</title>
     <para>
      Siempre deben usarse comillas alrededor de un índice de matriz tipo
      cadena literal. Por ejemplo, use $foo['bar'] y no $foo[bar]. ¿Pero qué
      está mal en $foo[bar]?  Es posible que haya visto la siguiente
      sintaxis en scripts viejos:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'enemigo';
echo $foo[bar];
// etc
?>
]]>
       </programlisting>
      </informalexample>
      Esto está mal, pero funciona. Entonces, ¿porqué está mal? La razón es
      que este código tiene una constante indefinida (bar) en lugar de una
      cadena ('bar' - note las comillas), y puede que en el futuro PHP
      defina constantes que, desafortunadamente para su código, tengan el
      mismo nombre. Funciona porque PHP automáticamente convierte una
      <emphasis>cadena pura</emphasis> (una cadena sin comillas que no
      corresponda con símbolo conocido alguno) en una cadena que contiene la
      cadena pura. Por ejemplo, si no se ha definido una constante llamada
      <constant>bar</constant>, entonces PHP reemplazará su valor por la
      cadena <literal>'bar'</literal> y usará ésta última.
     </para>
     <note>
      <simpara>
       Esto no quiere decir que <emphasis>siempre</emphasis> haya que usar
       comillas en la clave. No querrá usar comillas con claves que sean
       <link linkend="language.constants">constantes</link> o <link
       linkend="language.variables">variables</link>, ya que en tal caso PHP
       no podrá interpretar sus valores.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Matriz simple:
$matriz = array(1, 2);
$conteo = count($matriz);
for ($i = 0; $i < $conteo; $i++) {
    echo "\nRevisando $i: \n";
    echo "Mal: " . $matriz['$i'] . "\n";
    echo "Bien: " . $matriz[$i] . "\n";
    echo "Mal: {$matriz['$i']}\n";
    echo "Bien: {$matriz[$i]}\n";
}
?>
]]>
       </programlisting>
      </informalexample>
      &example.outputs;
      <screen>
<![CDATA[
Revisando 0: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Mal: 
Bien: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Mal: 
Bien: 1

Revisando 1: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Mal: 
Bien: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Mal: 
Bien: 2
]]>
      </screen>
     </note>
     <para>
      Más ejemplos para demostrar este hecho:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Mostrar todos los errores
error_reporting(E_ALL);

$matriz = array('fruta' => 'manzana', 'vegetal' => 'zanahoria');

// Correcto
print $matriz['fruta'];   // manzana
print $matriz['vegetal']; // zanahoria

// Incorrecto. Esto funciona pero también genera un error de PHP de
// nivel E_NOTICE ya que no hay definida una constante llamada fruta
//
// Notice: Use of undefined constant fruta - assumed 'fruta' in...
print $matriz[fruta];    // manzana

// Definamos una constante para demostrar lo que pasa. Asignaremos el
// valor 'vegetal' a una constante llamada fruta.
define('fruta', 'vegetal');

// Note la diferencia ahora
print $matriz['fruta'];  // manzana
print $matriz[fruta];    // zanahoria

// Lo siguiente está bien ya que se encuentra al interior de una
// cadena. Las constantes no son procesadas al interior de
// cadenas, así que no se produce un error E_NOTICE aquí
print "Hola $matriz[fruta]";  // Hola manzana

// Con una excepción, los corchetes que rodean las matrices al
// interior de cadenas permiten el uso de constantes
print "Hola {$matriz[fruta]}";    // Hola zanahoria
print "Hola {$matriz['fruta']}";  // Hola manzana

// Esto no funciona, resulta en un error de intérprete como:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Esto se aplica también al uso de superglobales en cadenas, por supuesto
print "Hola $matriz['fruta']";
print "Hola $_GET['foo']";

// La concatenación es otra opción
print "Hola " . $matriz['fruta']; // Hola manzana
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Cuando habilita <function>error_reporting</function> para mostrar
      errores de nivel <constant>E_NOTICE</constant> (como por ejemplo
      definiendo el valor <constant>E_ALL</constant>) verá estos errores.
      Por defecto, <link
      linkend="ini.error-reporting">error_reporting</link> se encuentra
      configurado para no mostrarlos.
     </para>
     <para>
      Tal y como se indica en la sección de <link
      linkend="language.types.array.syntax">sintaxis</link>, debe existir
      una expresión entre los corchetes cuadrados ('<literal>[</literal>' y
      '<literal>]</literal>'). Eso quiere decir que puede escribir cosas
      como esta:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo $matriz[alguna_funcion($bar)];
?>
]]>
       </programlisting>
      </informalexample>
      Este es un ejemplo del uso de un valor devuelto por una función como
      índice de matriz. PHP también conoce las constantes, tal y como ha
      podido apreciar aquellas <literal>E_*</literal> antes.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$descripciones_de_error[E_ERROR]   = "Un error fatal ha ocurrido";
$descripciones_de_error[E_WARNING] = "PHP produjo una advertencia";
$descripciones_de_error[E_NOTICE]  = "Esta es una noticia informal";
?>
]]>
       </programlisting>
      </informalexample>
      Note que <literal>E_ERROR</literal> es también un identificador
      válido, asi como <literal>bar</literal> en el primer ejemplo. Pero el
      último ejemplo es equivalente a escribir:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$descripciones_de_error[1] = "Un error fatal ha ocurrido";
$descripciones_de_error[2] = "PHP produjo una advertencia";
$descripciones_de_error[8] = "Esta es una noticia informal";
?>
]]>
       </programlisting>
      </informalexample>
      ya que <literal>E_ERROR</literal> es igual a <literal>1</literal>,
      etc.
     </para>
     <para>
      Tal y como lo hemos explicado en los anteriores ejemplos,
      <literal>$foo[bar]</literal> aun funciona pero está mal. Funciona,
      porque debido a su sintaxis, se espera que <literal>bar</literal> sea
      una expresión constante. Sin embargo, en este caso no existe una
      constante con el nombre <literal>bar</literal>. PHP asume ahora que
      usted quiso decir <literal>bar</literal> literalmente, como la cadena
      <literal>"bar"</literal>, pero que olvidó escribir las comillas.
     </para>
     <sect4>
      <title>¿Entonces porqué está mal?</title>
      <para>
       En algún momento en el futuro, el equipo de PHP puede querer usar
       otra constante o palabra clave, o puede que usted introduzca otra
       constante en su aplicación, y entonces se ve en problemas. Por
       ejemplo, en este momento no puede usar las palabras
       <literal>empty</literal> y <literal>default</literal> de esta forma,
       ya que son <link linkend="reserved">palabras clave reservadas</link>
       especiales.
      </para>
      <note>
       <simpara>
        Reiterando, al interior de un valor <type>string</type> entre
        comillas dobles, es válido no rodear los índices de matriz con
        comillas, así que <literal>"$foo[bar]"</literal> es válido. Consulte
        los ejemplos anteriores para más detalles sobre el porqué, asi como
        la sección sobre <link
        linkend="language.types.string.parsing">procesamiento de variables
        en cadenas</link>.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 xml:id="language.types.array.casting">
    <title>Conversión a matriz</title>

    <para>
     Para cualquiera de los tipos: <type>integer</type>, <type>float</type>,
     <type>string</type>, <type>boolean</type> y <type>resource</type>, si
     convierte un valor a un <type>array</type>, obtiene una matriz con un
     elemento (con índice 0), el cual es el valor escalar con el que inició.
    </para>

    <para>
     Si convierte un <type>object</type> a una matriz, obtiene las
     propiedades (variables miembro) de ese objeto como los elementos de la
     matriz. Las claves son los nombres de las variables miembro con algunas
     excepciones notables: las variables privadas tienen el nombre de la
     clase al comienzo del nombre de la variable; las variables protegidas
     tienen un caracter '*' al comienzo del nombre de la variable. Estos
     valores adicionados al inicio tienen bytes nulos a los lados. Esto
     puede resultar en comportamiento inesperado.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php

class A {
	private $A; // Este campo se convertirá en '\0A\0A'
}

class B extends A {
	private $A; // Este campo se convertirá en '\0B\0A'
	public $AA; // Este campo se convertirá en 'AA'
}

var_dump((array) new B());
?>
]]>
       </programlisting>
      </informalexample>

     En el ejemplo anterior parecerá que se tienen dos claves llamadas 'AA',
     aunque en realidad una de ellas se llama '\0A\0A'.
    </para>

    <para>
     Si convierte un valor &null; a matriz, obtiene una matriz vacía.
    </para>
   </sect2>

   <sect2 xml:id="language.types.array.comparing">
    <title>Comparación</title>
    <para>
     Es posible comparar matrices con <function>array_diff</function> y
     mediante <link linkend="language.operators.array">operadores de
     matriz</link>.
    </para>
   </sect2>

   <sect2 xml:id="language.types.array.examples">
    <title>Ejemplos</title>
    <para>
     El tipo matriz en PHP es bastante versátil, así que aquí se presentan
     algunos ejemplos que demuestran el poder completo de las matrices.
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// esto
$a = array( 'color'  => 'rojo',
            'sabor'  => 'dulce',
            'forma'  => 'redonda',
            'nombre' => 'manzana',
                       4        // la clave será 0
          );

// es completamente equivalente a
$a['color']  = 'rojo';
$a['sabor']  = 'dulce';
$a['forma']  = 'redonda';
$a['nombre'] = 'manzana';
$a[]         = 4;        // la clave será 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// resultará en la matriz array(0 => 'a' , 1 => 'b' , 2 => 'c'),
// o simplemente array('a', 'b', 'c')
?>
]]>
       </programlisting>
      </informalexample>
     </para>

    <example>
     <title>Uso de array()</title>
     <programlisting role="php">
<![CDATA[
<?php
// Array como mapa de propiedades
$mapa = array( 'versión'          => 4,
               'SO'               => 'Linux',
               'idioma            => 'inglés',
               'etiquetas_cortas' => true
            );

// claves estrictamente numéricas
$matriz = array( 7,
                 8,
                 0,
                 156,
                 -10
               );
// esto es lo mismo que array(0 => 7, 1 => 8, ...)

$cambios = array(         10, // clave = 0
                  5    =>  6,
                  3    =>  7,
                  'a'  =>  4,
                          11, // clave = 6 (el índice entero máximo era 5)
                  '8'  =>  2, // clave = 8 (¡entero!)
                  '02' => 77, // clave = '02'
                  0    => 12  // el valor 10 será reemplazado por 12
                );

// matriz vacía
$vacio = array();
?>
]]>
<!-- TODO example of
- overwriting keys
- using vars/functions as key/values
- warning about references
-->
     </programlisting>
    </example>

    <example xml:id="language.types.array.examples.loop">
     <title>Colección</title>
     <programlisting role="php">
<![CDATA[
<?php
$colores = array('rojo', 'azul', 'verde', 'amarillo');

foreach ($colores as $color) {
    echo "¿Le gusta el $color?\n";
}

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
¿Le gusta el rojo?
¿Le gusta el azul?
¿Le gusta el verde?
¿Le gusta el amarillo?
]]>
     </screen>
    </example>

    <para>
     Modificar los valores de la matriz directamente es posible a partir de
     PHP 5, pasándolos por referencia. Las versiones anteriores necesitan
     una solución alternativa:
     <example xml:id="language.types.array.examples.changeloop">
      <title>Colección</title>
      <programlisting role="php">
<![CDATA[
<?php
// PHP 5
foreach ($colores as &$color) {
    $color = strtoupper($color);
}
unset($color); /* se asegura de que escrituras subsiguientes a $color
no modifiquen el último elemento de la matriz */

// Alternativa para versiones anteriores
foreach ($colores as $clave => $color) {
    $colores[$clave] = strtoupper($color);
}

print_r($colores);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array
(
    [0] => ROJO
    [1] => AZUL
    [2] => VERDE
    [3] => AMARILLO
)
]]>
      </screen>
     </example>
    </para>
    <para>
     Este ejemplo crea una matriz con base uno.
     <example>
      <title>Índice con base 1</title>
      <programlisting role="php">
<![CDATA[
<?php
$primercuarto  = array(1 => 'Enero', 'Febrero', 'Marzo');
print_r($primercuarto);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array
(
    [1] => 'Enero'
    [2] => 'Febrero'
    [3] => 'Marzo'
)
]]>
      </screen>
     </example>
    </para>
    <example>
     <title>Llenado de una matriz</title>
     <programlisting role="php">
<![CDATA[
<?php
// llenar una matriz con todos los ítems de un directorio
$gestor = opendir('.');
while (false !== ($archivo = readdir($gestor))) {
    $archivos[] = $archivo;
}
closedir($gestor);
?>
]]>
     </programlisting>
    </example>
    <para>
     Las matrices son ordenadas. Puede también cambiar el orden usando
     varias funciones de ordenamiento. Vea la sección sobre <link
     linkend="ref.array">funciones de matrices</link> para más información.
     Puede contar el número de items en una matriz usando la función
     <function>count</function>.
    </para>
    <example>
     <title>Ordenamiento de una matriz</title>
     <programlisting role="php">
<![CDATA[
<?php
sort($archivos);
print_r($archivos);
?>
]]>
     </programlisting>
    </example>
    <para>
     Dado que el valor de una matriz puede ser cualquier cosa, también puede
     ser otra matriz. De esta forma es posible crear matrices recursivas y
     multi-dimensionales.
    </para>
    <example>
     <title>Matrices recursivas y multi-dimensionales</title>
     <programlisting role="php">
<![CDATA[
<?php
$frutas = array ( "frutas"  => array ( "a" => "naranja",
                                       "b" => "banano",
                                       "c" => "manzana"
                                     ),
                  "numeros" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "hoyos"   => array (      "primero",
                                       5 => "segundo",
                                            "tercero"
                                     )
                );

// Algunos ejemplos que hacen referencia a los valores de la matriz anterior
echo $frutas["hoyos"][5];    // imprime "segundo"
echo $frutas["frutas"]["a"]; // imprime "naranja"
unset($frutas["hoyos"][0]);  // elimina "primero"

// Crear una nueva matriz multi-dimensional
$jugos["manzana"]["verde"] = "bien";
?>
]]>
     </programlisting>
    </example>
    <para>
     Debe advertir que la asignación de matrices siempre involucra la copia
     de valores. También quiere decir que el apuntador interno de matriz
     usado por <function>current</function> y otras funciones similares es
     reestablecido. Necesita usar el operador de referencia para copiar una
     matriz por referencia.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$matriz1 = array(2, 3);
$matriz2 = $matriz1;
$matriz2[] = 4; // $matriz2 cambia,
                // $matriz1 sigue siendo array(2, 3)

$matriz3 = &$matriz1;
$matriz3[] = 4; // ahora $matriz1 y $matriz3 son iguales
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.types.object">
   <title>Objetos</title>

   <sect2 xml:id="language.types.object.init">
    <title>Inicialización de Objetos</title>

    <para>
     Para inicializar un objeto, use la sentencia <literal>new</literal>, lo
     que instancia el objeto a una variable.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function hacer_foo()
    {
        echo "Haciendo foo.";
    }
}

$bar = new foo;
$bar->hacer_foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Para una discusión completa, por favor refiérase a la sección <link
     linkend="language.oop">Clases y Objetos</link>.
    </simpara>
   </sect2>

   <sect2 xml:id="language.types.object.casting">
    <title>Conversión a objeto</title>

    <para>
     Si un objeto es convertido a un objeto, éste no es modificado. Si un
     valor de cualquier otro tipo es convertido a objeto, una nueva
     instancia de la clase <literal>stdClass</literal> es creada. Si el
     valor era &null;, la nueva instancia será vacía. Las matrices son
     convertidas a objeto usando las claves de la matriz como nombres de
     propiedades y con sus valores correspondientes. Para cualquier otro
     valor, una variable miembro llamada <literal>scalar</literal> contendrá
     el valor.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$obj = (object) 'ciao';
echo $obj->scalar;  // imprime 'ciao'
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>

  </sect1>

  <sect1 xml:id="language.types.resource">
   <title>Recurso</title>

    <para>
     Un recurso es una variable especial, que contiene una referencia a un
     recurso externo. Los recursos son creados y usados por funciones
     especiales. Vea el <link linkend="resource">apéndice</link> para un
     listado de todas estas funciones y los tipos de recurso
     correspondientes.
    </para>

    <note>
     <simpara>
      El tipo recurso fue introducido en PHP 4
     </simpara>
    </note>

    <para>
     Vea también <function>get_resource_type</function>.
    </para>

   <sect2 xml:id="language.types.resource.casting">
    <title>Conversión a un recurso</title>

    <para>
     Dado que los tipos de recurso contienen gestores especiales a archivos
     abiertos, conexiones con bases de datos, áreas de pintura de imágenes y
     cosas por el estilo, no es posible convertir cualquier valor a un
     recurso.
    </para>
   </sect2>

    <sect2 xml:id="language.types.resource.self-destruct">
     <title>Liberación de recursos</title>

    <para>
     Gracias al sistema de conteo de referencias introducido con el Motor
     Zend de PHP 4, se detecta automáticamente cuando un recurso ya no es
     referenciado (tal como en Java). Cuando este es el caso, todos los
     recursos que fueron usados para éste recurso se liberan por el
     recolector de basura. Por esta razón, rara vez se necesita liberar la
     memoria manualmente mediante el uso de alguna función free_result.
     <note>
      <simpara>
       Los enlaces persistentes con bases de datos son especiales, ellos
       <emphasis>no</emphasis> son destruidos por el recolector de basura.
       Vea también la sección sobre <link
       linkend="features.persistent-connections">conexiones
       persistentes</link>.
      </simpara>
     </note>
    </para>

   </sect2>
  </sect1>

  <sect1 xml:id="language.types.null">
   <title>NULL</title>

   <para>
    El valor especial &null; representa que una variable no tiene valor.
    &null; es el único valor posible del tipo <type>NULL</type>.
   </para>
    <note>
     <simpara>
      El tipo null se introdujo en PHP 4.
     </simpara>
    </note>
    <para>
     Una variable es considerada como &null; si
     <itemizedlist>
      <listitem>
       <para>
        se ha asignado la constante &null; a la variable.
       </para>
      </listitem>
      <listitem>
       <para>
        no ha sido definida con valor alguno.
       </para>
      </listitem>
      <listitem>
       <para>
        ha sido eliminada con <function>unset</function>.
       </para>
      </listitem>
     </itemizedlist>
    </para>

   <sect2 xml:id="language.types.null.syntax">
    <title>Sintaxis</title>
    <para>
     Existe un solo valor de tipo &null;, y ese es la palabra clave &null;,
     insensible a mayúsculas y minúsculas.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$var = NULL;
?>
]]>
</programlisting>
     </informalexample>
    </para>
    <para>
     Vea también <function>is_null</function> y
     <function>unset</function>.
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.pseudo-types">
   <title>Pseudo-tipos usados en esta documentación</title>

   <sect2 xml:id="language.types.mixed">
    <title>mixed</title>
    <para>
     <literal>mixed</literal> indica que un parámetro puede aceptar
     múltiples tipos (pero no necesariamente todos).
    </para>
    <para>
     <function>gettype</function> por ejemplo aceptará todos los tipos PHP,
     mientras que <function>str_replace</function> aceptará cadenas y
     matrices.
    </para>
   </sect2>

   <sect2 xml:id="language.types.number">
    <title>number</title>
    <para>
     <literal>number</literal> indica que un parámetro puede ser
     <type>integer</type> o <type>float</type>.
    </para>
   </sect2>

   <sect2 xml:id="language.types.callback">
    <title>callback</title>
    <para>
     Algunas funciones como <function>call_user_func</function> o
     <function>usort</function> aceptan llamadas de retorno definidas por el
     usuario como un parámetro. Las funciones tipo llamada de retorno no
     sólo pueden ser funciones simples, también pueden ser métodos de
     objetos incluyendo métodos estáticos de clase.
    </para>
    <para>
     Una función de PHP es pasada simplemente usando su nombre como una
     cadena. Puede pasar cualquier función incorporada o definida por el
     usuario con la excepción de <function>array</function>,
     <function>echo</function>, <function>empty</function>,
     <function>eval</function>, <function>exit</function>,
     <function>isset</function>, <function>list</function>,
     <function>print</function> y <function>unset</function>.
    </para>
    <para>
     Un método de un objeto instanciado es pasado como una matriz que
     contiene un objeto como el elemento con el índice 0 y un nombre de
     método como el elemento con índice 1.
    </para>
    <para>
     Los métodos estáticos de clase pueden ser pasados también sin
     instanciar un objeto de esa clase al pasar el nombre de clase en
     lugar de un objeto como el elemento con índice 0.
    </para>
    <para>
     Además de la creación de funciones comunes definidas por el usuario,
     <function>create_function</function> puede ser usada para crear una
     función de llamada de retorno anónima.
    </para>

    <para>
     <example>
      <title>
       Ejemplos de funciones tipo llamada de retorno
      </title>
      <programlisting role="php">
<![CDATA[
<?php

// Una llamada de retorno de ejemplo
function mi_llamada_de_retorno() {
    echo '¡Hola mundo!';
}

// Un método como llamada de retorno de ejemplo
class MiClase {
    function miMetodoDeRetorno() {
        echo '¡Hola Mundo!';
    }
}

// Tipo 1: Llamada de retorno simple
call_user_func('mi_llamada_de_retorno');

// Tipo 2: Llamada de método estático de clase
call_user_func(array('MiClase', 'miMetodoDeRetorno'));

// Tipo 3: Llamada a un metodo de objeto
$obj = new MiClase();
call_user_func(array($obj, 'miMetodoDeRetorno'));
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <simpara>
      En PHP4 es necesario usar una referencia para crear una llamada de
      retorno que apunte al objeto real, y no a una copia de éste. Para más
      detalles, vea <link linkend="language.references">Referencias
      Explicadas</link>.
     </simpara>
    </note>

   </sect2>

   <sect2 xml:id="language.types.void">
    <title>void</title>
    <para>
     <literal>void</literal> como tipo de retorno quiere decir que el valor
     de retorno no tiene utilidad. <literal>void</literal> en una lista de
     parámetros quiere decir que la función no recibe ningún parámetro.
    </para>
   </sect2>

  </sect1>

  <sect1 xml:id="language.types.type-juggling">
   <title>Manipulación de Tipos</title>

   <simpara>
    PHP no requiere (o soporta) la definición explícita de tipos en la
    declaración de variables; el tipo de una variable es determinado por el
    contexto en el que la variable es usada. Lo que quiere decir que si
    asigna un valor de cadena a la variable <parameter>$var</parameter>,
    <parameter>$var</parameter> se convierte en una cadena. Si luego asigna
    un valor entero a <parameter>$var</parameter>, ésta se convierte en
    entera.
   </simpara>
   <para>
    Un ejemplo de la conversión automática de tipos de PHP es el operador de
    adición '+'. Si cualquiera de los operandos es un flotante, entonces
    todos los operandos son evaluados como flotantes, y el resultado será un
    flotante. De otro modo, los operandos serán interpretados como enteros,
    y el resultado será también un entero. Note que este NO modifica los
    tipos de los operandos mismos; el único cambio está en la forma como los
    operandos son evaluados.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = "0";  // $foo es una cadena (ASCII 48)
$foo += 2;   // $foo es ahora un entero (2)
$foo = $foo + 1.3;  // $foo es ahora un flotante (3.3)
$foo = 5 + "10 Cerditos"; // $foo es entero (15)
$foo = 5 + "10 Cerdos";   // $foo es entero (15)
?>
]]>
<!-- bad example, no real operator (must be used with variable, modifies it too)
$foo++;      // $foo is the string "1" (ASCII 49)

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Si los dos últimos ejemplos lucen extraños, consulte <link
    linkend="language.types.string.conversion">Conversión de cadenas a
    números</link>.
   </simpara>
   <simpara>
    Si desea forzar que una variable sea evaluada como un cierto tipo,
    consulte la sección sobre <link
    linkend="language.types.typecasting">Moldeamiento de tipos</link>. Si
    desea cambiar el tipo de una variable, vea <function>settype</function>.
   </simpara>
   <para>
    Si quisiera probar cualquiera de los ejemplos en esta sección, puede
    usar la función <function>var_dump</function>.
   </para>
   <note>
    <para>
     El comportamiento de una conversión automática a matriz no se encuentra
     definido en el momento.
    </para>
    <para>
     Asimismo, ya que PHP soporta el uso de índices en cadenas por medio de
     desplazamientos usando la misma sintaxis que la indexación de matrices,
     el siguiente ejemplo permanece válido para todas las versiones de PHP:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a    = 'carro'; // $a es una cadena
$a[0] = 'b';     // $a sigue siendo una cadena
echo $a;         // barro
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Vea la sección titulada <link
     linkend="language.types.string.substr">Acceso a cadenas por
     caracter</link> para más información.
    </para>
   </note>

   <sect2 xml:id="language.types.typecasting">
    <title>Moldeamiento de Tipos</title>

    <para>
     El moldeamiento de tipos en PHP funciona de forma muy similar a como
     ocurre en C: el nombre del tipo deseado es escrito entre paréntesis
     antes de la variable que debe ser moldeada.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;   // $foo es un entero
$bar = (boolean) $foo;   // $bar es un booleano
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Los moldeamientos permitidos son:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - moldeamiento a entero</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - moldeamiento a booleano</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - moldeamiento a flotante</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - moldeamiento a cadena</simpara>
      </listitem>
      <listitem>
       <simpara>(binary) - moldeamiento a cadena binaria (PHP 6)</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - moldeamiento a matriz</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - moldeamiento a objeto</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     El moldeamiento (binary) y el soporte del prefijo b fueron agregados en
     PHP 5.2.1
    </para>
    <para>
     Note que las tabulaciones y los espacios son permitidos al interior de
     los paréntesis, así que las siguientes expresiones son funcionalmente
     equivalentes:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
      </programlisting>
      <para>
       Moldeamiento de cadenas literales y variables a cadenas binarias:
      </para>
      <programlisting role="php">
<![CDATA[
<?php
$binario = (binary)$cadena;
$binario = b"cadena binaria";
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      En lugar de moldear una variable a cadena, puede también rodear la
      variable de comillas dobles.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo es un entero
$cad = "$foo";        // $cad es una cadena
$fst = (string) $foo; // $fst es también una cadena

// Esto imprime "son lo mismo"
if ($fst === $cad) {
    echo "son lo mismo";
}
?>
]]>
      </programlisting>
     </informalexample>
     </para>
    </note>

    <para>
     Puede que no sea obvio qué sucede exactamente cuando se moldea entre
     ciertos tipos. Para más información, consulte las secciones:
     <itemizedlist>
      <listitem>
       <simpara><link
        linkend="language.types.boolean.casting">Conversión a
        booleano</link></simpara>
      </listitem>
      <listitem>
       <simpara><link
        linkend="language.types.integer.casting">Conversión a
        entero</link></simpara>
      </listitem>
      <listitem>
       <simpara><link
        linkend="language.types.float.casting">Conversión a
        flotante</link></simpara>
      </listitem>
      <listitem>
       <simpara><link
        linkend="language.types.string.casting">Conversión a
        cadena</link></simpara>
      </listitem>
      <listitem>
       <simpara><link
        linkend="language.types.array.casting">Conversión a
        matriz</link></simpara>
      </listitem>
      <listitem>
       <simpara><link
        linkend="language.types.object.casting">Conversión a
        objeto</link></simpara>
      </listitem>
      <listitem>
       <simpara><link
        linkend="language.types.resource.casting">Conversión a
        un recurso</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.null.casting">Converting to 
        &null;</link></simpara>
      </listitem>
      -->
      <listitem>
       <simpara>
        <link linkend="types.comparisons">Las tablas de
        comparación de tipos</link>
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
