<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.2 $ -->
<!-- EN-Revision: 1.9 Maintainer: baoengb Status: ready -->
 <sect1 id="language.oop5.reflection">
  <title>Reflecci&oacute;n</title>
  <sect2 id="language.oop5.reflection.introduction">
   <title>Introduction</title>
   <para>
    PHP 5 viene con un API completa de reflexi&oacute;n que agrega la 
    habilidad de hacer ingenier&iacute;a inversa de clases, interfaces,
    funciones y m&eacute;todos as&iacute; como extensiones. Adicionalmente,
    el API de reflexi&oacute;n tambi&eacute;n ofrece formas de obtener los 
    comentarios de los documentos para funciones, clases y m&eacute;todos.
   </para>
   <para>
    El API de reflexi&oacute;n es una extensi&oacute;n orientada a objetos 
    para el compilador Zend, consistente de las siguientes clases:
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Reflection { }
interface Reflector { }
class ReflectionException extends Exception { }
class ReflectionFunction implements Reflector { }
class ReflectionParameter implements Reflector { }
class ReflectionMethod extends ReflectionFunction { }
class ReflectionClass implements Reflector { }
class ReflectionObject extends ReflectionClass { }
class ReflectionProperty implements Reflector { }
class ReflectionExtension implements Reflector { }
?>
]]>
    </programlisting>
   </informalexample>
   <note>
    <simpara>
     Para detalles de estas clases, de una mirada a los siguientes 
     cap&iacute;tulos.
    </simpara>
   </note>
   <para>
    Si fu&eacute;ramos a ejecutar el c&oacute;digo en el siguiente ejemplo:
    <example>
     <title>Uso b&aacute;sico del API reflexi&oacute;n</title>
     <programlisting role='php'>
<![CDATA[
<?php
Reflection::export(new ReflectionClass('Exception'));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Class [ <internal> class Exception ] {

  - Constants [0] {
  }

  - Static properties [0] {
  }

  - Static methods [0] {
  }

  - Properties [6] {
    Property [ <default> protected $message ]
    Property [ <default> private $string ]
    Property [ <default> protected $code ]
    Property [ <default> protected $file ]
    Property [ <default> protected $line ]
    Property [ <default> private $trace ]
  }

  - Methods [9] {
    Method [ <internal> final private method __clone ] {
    }

    Method [ <internal> <ctor> public method __construct ] {

      - Parameters [2] {
        Parameter #0 [ <required> $message ]
        Parameter #1 [ <required> $code ]
      }
    }

    Method [ <internal> final public method getMessage ] {
    }

    Method [ <internal> final public method getCode ] {
    }

    Method [ <internal> final public method getFile ] {
    }

    Method [ <internal> final public method getLine ] {
    }

    Method [ <internal> final public method getTrace ] {
    }

    Method [ <internal> final public method getTraceAsString ] {
    }

    Method [ <internal> public method __toString ] {
    }
  }
}
]]>
     </screen>
    </example>
   </para>
  </sect2>

  <sect2 id="language.oop5.reflection.reflectionfunction">
   <title><classname>ReflectionFunction</classname></title>
   <para>
    La clase <classname>ReflectionFunction</classname> te permite funciones 
    de ingenier&iacute; inversa.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionFunction implements Reflector
{
    final private __clone()
    public object __construct(string name)
    public string __toString()
    public static string export()
    public string getName()
    public bool isInternal()
    public bool isUserDefined()
    public string getFileName()
    public int getStartLine()
    public int getEndLine()
    public string getDocComment()
    public array getStaticVariables()
    public mixed invoke(mixed* args)
    public mixed invokeArgs(array args)
    public bool returnsReference()
    public ReflectionParameter[] getParameters()
    public int getNumberOfParameters()
    public int getNumberOfRequiredParameters()
}
?>
]]>
    </programlisting>
   </informalexample>
   <note>
    <simpara>
     <function>invokeArgs</function> fue agregado en PHP 5.1.0.
    </simpara>
   </note>
   <para>
    Para entender directamente una funci&oacute;n, primero tiene que crear
    una isntancia de la clase <classname>ReflectionFunction</classname>. 
    Hasta entonces puede llamar cualquier de los m&eacute;todos anteriores en
    esta instancia.
   </para>
   <example>
    <title>Usando la clase <classname>ReflectionFunction</classname></title>
    <programlisting role='php'>
<![CDATA[
<?php
/**
 * A simple counter
 *
 * @return    int
 */
function counter() 
{
    static $c = 0;
    return $c++;
}

// Create an instance of the Reflection_Function class
$func = new ReflectionFunction('counter');

// Print out basic information
printf(
    "===> The %s function '%s'\n".
    "     declared in %s\n".
    "     lines %d to %d\n",
    $func->isInternal() ? 'internal' : 'user-defined',
    $func->getName(),
    $func->getFileName(),
    $func->getStartLine(),
    $func->getEndline()
);

// Print documentation comment
printf("---> Documentation:\n %s\n", var_export($func->getDocComment(), 1));

// Print static variables if existant
if ($statics = $func->getStaticVariables())
{
    printf("---> Static variables: %s\n", var_export($statics, 1));
}

// Invoke the function
printf("---> Invokation results in: ");
var_dump($func->invoke());


// you may prefer to use the export() method
echo "\nReflectionFunction::export() results:\n";
echo ReflectionFunction::export('counter');
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     El m&eacute;todo <function>invoke</function> acepta un n&uacute;mero de
     variable de argumentos los cuales son pasados a la funci&oacute;n tal 
     y como se hace en <function>call_user_func</function>.
    </simpara>
   </note>
  </sect2>

  <sect2 id="language.oop5.reflection.reflectionparameter">
   <title><classname>ReflectionParameter</classname></title>
   <para>
    La case <classname>ReflectionParameter</classname> obtiene 
    informaci&oacute;n acerca de los par&aacute;metros de una funci&oacute;n
    o un m&eacute;todo.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionParameter implements Reflector
{
    final private __clone()
    public object __construct(string name)
    public string __toString()
    public static string export()
    public string getName()
    public bool isPassedByReference()
    public ReflectionClass getClass()
    public bool allowsNull()
    public bool isOptional()
    public bool isDefaultValueAvailable()
    public mixed getDefaultValue()
}
?>
]]>
    </programlisting>
   </informalexample>
   <note>
    <para>
     <function>getDefaultValue</function>,
     <function>isDefaultValueAvailable</function>,
     <function>isOptional</function> fueron agregados en PHP 5.1.0.
    </para>
   </note>
   <para>
    Para entender los par&aacute;metros de la funci&oacute;n, tendr&aacute; 
    primero que crear una instancia de la clase 
    <classname>ReflectionFunction</classname> o de la clase
    <classname>ReflectionMethod</classname> y entonces usar sus m&eacute;todo
    <function>getParameters</function> para obtener una matriz de 
    par&aacute;metros.
   </para>
   <example>
    <title>Usando la clase <classname>ReflectionParameter</classname></title>
    <programlisting role='php'>
<![CDATA[
<?php
function foo($a, $b, $c) { }
function bar(Exception $a, &$b, $c) { }
function baz(ReflectionFunction $a, $b = 1, $c = null) { }
function abc() { }

// Create an instance of Reflection_Function with the
// parameter given from the command line.    
$reflect = new ReflectionFunction($argv[1]);

echo $reflect;

foreach ($reflect->getParameters() as $i => $param) {
    printf(
        "-- Parameter #%d: %s {\n".
        "   Class: %s\n".
        "   Allows NULL: %s\n".
        "   Passed to by reference: %s\n".
        "   Is optional?: %s\n".
        "}\n",
        $i, 
        $param->getName(),
        var_export($param->getClass(), 1),
        var_export($param->allowsNull(), 1),
        var_export($param->isPassedByReference(), 1),
        $param->isOptional() ? 'yes' : 'no'
    );
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 id="language.oop5.reflection.reflectionclass">
   <title><classname>ReflectionClass</classname></title>
   <para>
    La clase <classname>ReflectionClass</classname> te permite hacer
    ingenier&iacute;a inversa de clases.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionClass implements Reflector
{
    final private __clone()
    public object __construct(string name)
    public string __toString()
    public static string export()
    public string getName()
    public bool isInternal()
    public bool isUserDefined()
    public bool isInstantiable()
    public bool hasConstant(string name)
    public bool hasProperty(string name)
    public bool hasMethod(string name)
    public string getFileName()
    public int getStartLine()
    public int getEndLine()
    public string getDocComment()
    public ReflectionMethod getConstructor()
    public ReflectionMethod getMethod(string name)
    public ReflectionMethod[] getMethods()
    public ReflectionProperty getProperty(string name)
    public ReflectionProperty[] getProperties()
    public array getConstants()
    public mixed getConstant(string name)
    public ReflectionClass[] getInterfaces()
    public bool isInterface()
    public bool isAbstract()
    public bool isFinal()
    public int getModifiers()
    public bool isInstance(stdclass object)
    public stdclass newInstance(mixed* args)
    public ReflectionClass getParentClass()
    public bool isSubclassOf(ReflectionClass class)
    public array getStaticProperties()
    public array getDefaultProperties()
    public bool isIterateable()
    public bool implementsInterface(string name)
    public ReflectionExtension getExtension()
    public string getExtensionName()
}
?>
]]>
    </programlisting>
   </informalexample>
   <note>
    <simpara>
     <function>hasConstant</function>, <function>hasMethod</function>,
     <function>hasProperty</function> fueron agregados en PHP 5.1.0.
    </simpara>
   </note>
   <para>
    Para entender una clase, primero tendr&aacute; que crear una instancia
    de la clase <classname>ReflectionClass</classname>. Entonces puede 
    llamar cualquier de los m&eacute;todos anteriores en esta instancia.
   </para>
   <example>
    <title>Usando la clase <classname>ReflectionClass</classname></title>
    <programlisting role='php'>
<![CDATA[
<?php
interface Serializable
{
    // ...
}

class Object
{
    // ...
}

/**
 * A counter class
 */
class Counter extends Object implements Serializable 
{
    const START = 0;
    private static $c = Counter::START;

    /**
     * Invoke counter
     *
     * @access  public
     * @return  int
     */
    public function count() {
        return self::$c++;
    }
}

// Create an instance of the ReflectionClass class
$class = new ReflectionClass('Counter');

// Print out basic information
printf(
    "===> The %s%s%s %s '%s' [extends %s]\n" .
    "     declared in %s\n" .
    "     lines %d to %d\n" .
    "     having the modifiers %d [%s]\n",
        $class->isInternal() ? 'internal' : 'user-defined',
        $class->isAbstract() ? ' abstract' : '',
        $class->isFinal() ? ' final' : '',
        $class->isInterface() ? 'interface' : 'class',
        $class->getName(),
        var_export($class->getParentClass(), 1),
        $class->getFileName(),
        $class->getStartLine(),
        $class->getEndline(),
        $class->getModifiers(),
        implode(' ', Reflection::getModifierNames($class->getModifiers()))
);

// Print documentation comment
printf("---> Documentation:\n %s\n", var_export($class->getDocComment(), 1));

// Print which interfaces are implemented by this class
printf("---> Implements:\n %s\n", var_export($class->getInterfaces(), 1));

// Print class constants
printf("---> Constants: %s\n", var_export($class->getConstants(), 1));

// Print class properties
printf("---> Properties: %s\n", var_export($class->getProperties(), 1));

// Print class methods
printf("---> Methods: %s\n", var_export($class->getMethods(), 1));

// If this class is instantiable, create an instance
if ($class->isInstantiable()) {
    $counter = $class->newInstance();

    echo '---> $counter is instance? '; 
    echo $class->isInstance($counter) ? 'yes' : 'no';

    echo "\n---> new Object() is instance? ";
    echo $class->isInstance(new Object()) ? 'yes' : 'no';
}
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     El m&eacute;todo <function>newInstance</function> acepta un n&uacute;mero
     variable de argumentos los cuales son pasados a la funci&oacute;n tal y 
     como si se usara <function>call_user_func</function>.
    </simpara>
   </note>
   <note>
    <simpara>
     <literal>$class = new ReflectionClass('Foo'); $class-&gt;isInstance($arg)</literal>
     es equivalente a <literal>$arg instanceof Foo</literal> o 
     <literal>is_a($arg, 'Foo')</literal>.
    </simpara>
   </note>
  </sect2>

  <sect2 id="language.oop5.reflection.reflectionmethod">
   <title><classname>ReflectionMethod</classname></title>
   <para>
    La clase <classname>ReflectionMethod</classname> te permite hacer 
    ingenieria inversa de los m&eacute;todos de la clase.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionMethod extends ReflectionFunction
{
    public __construct(mixed class, string name)
    public string __toString()
    public static string export()
    public mixed invoke(stdclass object, mixed* args)
    public moxed invokeArgs(stdclass object, array args)
    public bool isFinal()
    public bool isAbstract()
    public bool isPublic()
    public bool isPrivate()
    public bool isProtected()
    public bool isStatic()
    public bool isConstructor()
    public bool isDestructor()
    public int getModifiers()
    public ReflectionClass getDeclaringClass()

    // Inherited from ReflectionFunction
    final private __clone()
    public string getName()
    public bool isInternal()
    public bool isUserDefined()
    public string getFileName()
    public int getStartLine()
    public int getEndLine()
    public string getDocComment()
    public array getStaticVariables()
    public bool returnsReference()
    public ReflectionParameter[] getParameters()
    public int getNumberOfParameters()
    public int getNumberOfRequiredParameters()
}
?>
]]>
    </programlisting>
   </informalexample>
   <para>
    Para entender los m&eacute;todos, primero tendr&aacute; que crear una 
    instancia de la clase <classname>ReflectionMethod</classname>. Puede 
    entonces llamar cualquiera de los m&eacute;todos anteriores en esta 
    instancia.
   </para>
   <example>
    <title>Usando la clase <classname>ReflectionMethod</classname></title>
    <programlisting role='php'>
<![CDATA[
<?php
class Counter
{
    private static $c = 0;

    /**
     * Increment counter
     *
     * @final
     * @static
     * @access  public
     * @return  int
     */
    final public static function increment()
    {
        return ++self::$c;
    }
}

// Create an instance of the Reflection_Method class
$method = new ReflectionMethod('Counter', 'increment');

// Print out basic information
printf(
    "===> The %s%s%s%s%s%s%s method '%s' (which is %s)\n" .
    "     declared in %s\n" .
    "     lines %d to %d\n" .
    "     having the modifiers %d[%s]\n",
        $method->isInternal() ? 'internal' : 'user-defined',
        $method->isAbstract() ? ' abstract' : '',
        $method->isFinal() ? ' final' : '',
        $method->isPublic() ? ' public' : '',
        $method->isPrivate() ? ' private' : '',
        $method->isProtected() ? ' protected' : '',
        $method->isStatic() ? ' static' : '',
        $method->getName(),
        $method->isConstructor() ? 'the constructor' : 'a regular method',
        $method->getFileName(),
        $method->getStartLine(),
        $method->getEndline(),
        $method->getModifiers(),
        implode(' ', Reflection::getModifierNames($method->getModifiers()))
);

// Print documentation comment
printf("---> Documentation:\n %s\n", var_export($method->getDocComment(), 1));

// Print static variables if existant
if ($statics= $method->getStaticVariables()) {
    printf("---> Static variables: %s\n", var_export($statics, 1));
}

// Invoke the method
printf("---> Invokation results in: ");
var_dump($method->invoke(NULL));
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Tratar de invocar m&eacute;todos private, protected o abstract
     resultar&aacute; en una excepci&oacute;n siendo arrojada del 
     m&eacute;todo <function>invoke</function>.
    </simpara>
   </note>
   <note>
    <simpara>
     Para m&eacute;todos static como se vi&oacute; anteriormente, se debe 
     a <function>invoke</function> se debe pasar NULL como primer argumento.
     Para m&eacute;todos no est&aacute;ticos, se pasa una instancia de la clase.
    </simpara>
   </note>
  </sect2>

  <sect2 id="language.oop5.reflection.reflectionproperty">
   <title><classname>ReflectionProperty</classname></title>
   <para>
    La clase <classname>ReflectionProperty</classname> te permite 
    hacer ingenier&iacute;a inversa a las propiedades de la clase.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionProperty implements Reflector
{
    final private __clone()
    public __construct(mixed class, string name)
    public string __toString()
    public static string export()
    public string getName()
    public bool isPublic()
    public bool isPrivate()
    public bool isProtected()
    public bool isStatic()
    public bool isDefault()
    public int getModifiers()
    public mixed getValue(stdclass object)
    public void setValue(stdclass object, mixed value)
    public ReflectionClass getDeclaringClass()
}
?>
]]>
    </programlisting>
   </informalexample>
   <para>
    Para entender las propiedades, se debe primero crear una instancia 
    de la clase <classname>ReflectionProperty</classname>. Y entonces 
    puede llamar cualquiera de los m&eacute;todos anteriores sobre esta 
    instancia.
   </para>
   <example>
    <title>Usando la clase <classname>ReflectionProperty</classname></title>
    <programlisting role='php'>
<![CDATA[
<?php
class String
{
    public $length  = 5;
}

// Create an instance of the ReflectionProperty class
$prop = new ReflectionProperty('String', 'length');

// Print out basic information
printf(
    "===> The%s%s%s%s property '%s' (which was %s)\n" .
    "     having the modifiers %s\n",
        $prop->isPublic() ? ' public' : '',
        $prop->isPrivate() ? ' private' : '',
        $prop->isProtected() ? ' protected' : '',
        $prop->isStatic() ? ' static' : '',
        $prop->getName(),
        $prop->isDefault() ? 'declared at compile-time' : 'created at run-time',
        var_export(Reflection::getModifierNames($prop->getModifiers()), 1)
);

// Create an instance of String
$obj= new String();

// Get current value
printf("---> Value is: ");
var_dump($prop->getValue($obj));

// Change value
$prop->setValue($obj, 10);
printf("---> Setting value to 10, new value is: ");
var_dump($prop->getValue($obj));

// Dump object
var_dump($obj);
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Trying to get or set private or protected class property's values
     will result in an exception being thrown.
    </simpara>
   </note>
  </sect2>

  <sect2 id="language.oop5.reflection.reflectionextension">
   <title><classname>ReflectionExtension</classname></title>
   <para>
    La clase <classname>ReflectionExtension</classname> te permite hacer 
    ingenier&iacute;a inversa a extensiones. Puede obtener todas las 
    extensiones cargadas en tiempo de ejecuci&oacute;n usando 
    <function>get_loaded_extensions</function>.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionExtension implements Reflector {
    final private __clone()
    public __construct(string name)
    public string __toString()
    public static string export()
    public string getName()
    public string getVersion()
    public ReflectionFunction[] getFunctions()
    public array getConstants()
    public array getINIEntries()
    public ReflectionClass[] getClasses()
    public array getClassNames()
}
?>
]]>
    </programlisting>
   </informalexample>
   <para>
    Para entender una extensi&oacute;n, primero se tiene que crear una 
    instancia de la clase <classname>ReflectionExtension</classname>. Y
    entonces puede llamarse a cualquiera de los &eacute;todos mencionados 
    arriba sobre esa instancia.
   </para>
   <example>
    <title>Usando la clase <classname>ReflectionExtension</classname></title>
    <programlisting role='php'>
<![CDATA[
<?php
// Create an instance of the ReflectionProperty class
$ext = new ReflectionExtension('standard');

// Print out basic information
printf(
    "Name        : %s\n" .
    "Version     : %s\n" .
    "Functions   : [%d] %s\n" .
    "Constants   : [%d] %s\n" .
    "INI entries : [%d] %s\n" .
    "Classes     : [%d] %s\n",
        $ext->getName(),
        $ext->getVersion() ? $ext->getVersion() : 'NO_VERSION',
        sizeof($ext->getFunctions()),
        var_export($ext->getFunctions(), 1),

        sizeof($ext->getConstants()),
        var_export($ext->getConstants(), 1),

        sizeof($ext->getINIEntries()),
        var_export($ext->getINIEntries(), 1),

        sizeof($ext->getClassNames()),
        var_export($ext->getClassNames(), 1)
);
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 id="language.oop5.reflection.extending">
   <title>Extendiendo las clases de reflexi&oacute;n</title>
   <para>
    EN caso de que se quiera crear una versi&oacute;n especializada de las
    clases integradas (es decir, para crear HTML con colores cuando se 
    exporta, tener f&aacute;cil acceso a las variables de los miembros en 
    lugar de los m&eacute;todos o tener m&eacute;todos de utiler&iacute;a),
    se puede simplemente extenderlos.
   </para>
   <example>
    <title>Extendiendo las clase integradas</title>
    <programlisting role='php'>
<![CDATA[
<?php
/**
 * My Reflection_Method class
 */
class My_Reflection_Method extends ReflectionMethod
{
    public $visibility = '';

    public function __construct($o, $m)
    {
        parent::__construct($o, $m);
        $this->visibility= Reflection::getModifierNames($this->getModifiers());
    }
}

/**
 * Demo class #1
 *
 */
class T {
    protected function x() {}
}

/**
 * Demo class #2
 *
 */
class U extends T {
    function x() {}
}

// Print out information
var_dump(new My_Reflection_Method('U', 'x'));
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Precauci&oacute;n: Si se desea sobreescribir el constructor, recuerde
     llamar el constructor padre _antes_ que cualquier otro c&oacute;digo
     que se inserte. El no hacerlo as&iacute; resultar&aacute; en:
     <literal>
      Fatal error: Internal error: Failed to retrieve the reflection object
     </literal>
    </simpara>
   </note>
  </sect2>
 </sect1>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
