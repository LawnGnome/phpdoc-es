<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 297028 Maintainer: chuso Status: ready -->
 <sect1 xml:id="language.oop5.late-static-bindings" xmlns="http://docbook.org/ns/docbook">
  <title>Enlace estático en tiempo de ejecución</title>
  <para>
   Desde PHP 5.3.0, PHP incorpora una nueva funcionalidad llamada enlace estático
   en tiempo de ejecución que permite hacer referencias a la clase en uso dentro
   de un contexto de herencia estática.
  </para>

  <para>
   Se le ha llamado "enlace estático en tiempo de ejecución" teniendo en cuenta
   un punto de vista interno. "Enlace en tiempo de ejecución" viene del hecho de que
   <literal>static::</literal> ya no resolverá a la clase en la que se definió el
   método, sino que en su lugar se resolverá utilizando información en tiempo
   de ejecución
   
   Debido a que se puede utilizar (entre otras cosas) para las llamadas
   de métodos estáticos, se le llamó también "enlace estático".
  </para>

  <sect2 xml:id="language.oop5.late-static-bindings.self">
   <title>Limitaciones de <literal>self::</literal></title>
   <para>
    Las referencias estáticas que hay dentro de la clase en uso,
    como <literal>self::</literal> o <literal>__CLASS__</literal>,
    se resuelven empleando el nombre de la clase a la que pertenece la
    función:
   </para>
   <example>
    <title>Uso de <literal>self::</literal></title>
    <programlisting role="php">
<![CDATA[
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        self::who();
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
A
]]>
    </screen>
   </example>

  </sect2>

  <sect2 xml:id="language.oop5.late-static-bindings.usage">
   <title>Uso de Enlace Estático en Tiempo de ejecución</title>

   <para>
    Los enlaces estáticos en tiempo tratan de resolver estas limitaciones
    empleando una palabra clave que haga referencia a la clase que realizó
    la llamada en tiempo de ejecución. Es decir, una palabra clave que en 
    el ejemplo anterior permita hacer referencia desde <literal>test()</literal>
    a <literal>B</literal>. Se decidió no crear una nueva palabra clave, por
    lo que en su lugar se ha utilizado la palabra reservada
    <litearal>static</literal>.
   </para>

   <example>
    <title>Uso básico de <literal>static::</literal></title>
    <programlisting role="php">
<![CDATA[
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        static::who(); // Here comes Late Static Bindings
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
B
]]>
    </screen>
   </example>
   <note>
    <para>
     ¡<literal>static::</literal> no se comporta como <literal>$this</literal> en
     los métodos estáticos! Mientras que <literal>$this-></literal> aplica
     herencia, <literal>static::</literal> no lo hace. Más adelante se detalla
     esta diferencia.
    </para>
   </note>
   <example>
    <title>Uso de <literal>static::</literal> en un contexto no estático</title>
    <programlisting role="php">
<![CDATA[
<?php
class TestChild extends TestParent {
    public function __construct() {
        static::who();
    }

    public function test() {
        $o = new TestParent();
    }

    public static function who() {
        echo __CLASS__."\n";
    }
}

class TestParent {
    public function __construct() {
        static::who();
    }

    public static function who() {
        echo __CLASS__."\n";
    }
}
$o = new TestChild;
$o->test();

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
TestChild
TestParent
]]>
    </screen>
   </example>
   <note>
    <para>
     En una llamada que se resuelva como estática, la resolución de enlaces estáticos
     en tiempo de ejecución se dentendrá sin propagarse. Por otra parte, las
     llamadas estáticas que utilicen palabras clave como
     <literal>parent::</literal> o <literal>self::</literal> sí propagarán la
     información.
    </para>
    <example>
     <title>Llamadas que propagan y que no propagan</title>
     <programlisting role="php">
<![CDATA[
<?php
class A {
    public static function foo() {
        static::who();
    }

    public static function who() {
        echo __CLASS__."\n";
    }
}

class B extends A {
    public static function test() {
        A::foo();
        parent::foo();
        self::foo();
    }

    public static function who() {
        echo __CLASS__."\n";
    }
}
class C extends B {
    public static function who() {
        echo __CLASS__."\n";
    }
}

C::test();
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
A
C
C
]]>
     </screen>
    </example>
   </note>
  </sect2>
  <sect2 xml:id="language.oop5.late-static-bindings.edge-cases">
   <title>Casos extremos</title>
   <para>
    Existen numerosos métodos para lanzar la ejecución de un método en PHP,
    como devoluciones de llamada o métodos mágicos. Dado que los enlaces
    estáticos en tiempo de ejecución se resuelven utilizando información
    disponible en tiempo de ejecución, puede provocar resultados inesperados.
   </para>
   <example>
    <title>Enlaces estáticos en tiempo de ejecución dentro de métodos mágicos</title>
    <programlisting role="php">
<![CDATA[
<?php
class A {

   protected static function who() {
        echo __CLASS__."\n";
   }

   public function __get($var) {
       return static::who();
   }
}

class B extends A {

   protected static function who() {
        echo __CLASS__."\n";
   }
}

$b = new B;
$b->foo;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
B
]]>
    </screen>
   </example>
  </sect2>
 </sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
