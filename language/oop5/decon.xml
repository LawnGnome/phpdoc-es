<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 301474 Maintainer: x1v4nx Status: ready -->
<!-- Reviewed: no -->

 <sect1 xml:id="language.oop5.decon" xmlns="http://docbook.org/ns/docbook">
  <title>Constructores y Destructores</title>

  <sect2 xml:id="language.oop5.decon.constructor">
   <title>Constructor</title>
   <methodsynopsis>
    <type>void</type><methodname>__construct</methodname>
    <methodparam choice="opt"><type>mixed</type><parameter>args</parameter><initializer>null</initializer></methodparam>
    <methodparam choice="opt"><parameter>...</parameter><initializer>null</initializer></methodparam>
   </methodsynopsis>
   <para>
    PHP 5 permite a los desarrolladores declarar métodos constructores para las
    clases. Aquellas que tengan un método constructor lo invocarán en cada nuevo
    objeto creado, lo que lo hace idóneo para cualquier inicialización que
    el objeto pueda necesitar antes de ser usado.
   </para>
   <note>
    <simpara>
     Constructores parent no son llamados implícitamente si la clase child define
     un constructor. Para ejecutar un constructor parent, se requiere invocar a
     <function>parent::__construct</function> desde el constructor child.
    </simpara>
   </note>
   <example>
    <title>Utilización de nuevos constructores unificados</title>
    <programlisting role="php">
<![CDATA[
<?php
class BaseClass {
   function __construct() {
       print "En el constructor de BaseClass\n";
   }
}

class SubClass extends BaseClass {
   function __construct() {
       parent::__construct();
       print "En el constructor de SubClass\n";
   }
}

$obj = new BaseClass();
$obj = new SubClass();
?> 
]]>
    </programlisting>
   </example>
   <para>
    Por motivos de compatibilidad, si PHP 5 no puede encontrar una función
    <function>__construct</function> para una determinada clase, buscará
    el viejo estilo de la función constructora, mediante el nombre de la clase.
    Efectivamente, esto significa que en el único caso en el que se tendría
    compatibilidad es si la clase tiene un método llamado
    <function>__construct</function> que fuese utilizado para diferentes propósitos.
   </para>
   <para>
    A diferencia con otros métodos, PHP no generará un mensaje de error a
    nivel de <constant>E_STRICT</constant> cuando <function>__construct</function>
    es sobrescrita con diferentes parámetros que los que tiene el
    <function>__construct</function> parent.
   </para>
   <para>
    A partir de PHP 5.3.3, los métodos con el mismo nombre que el último
    elemento de una clase en un nombre de espacios no serán más tratados
    como un constructor. Este cambio no afecta a clases sin espacio de nombres.
   </para>
   <example>
    <title>Constructores en clases pertenecientes a un nombre de espacios</title>
    <programlisting role="php">
<![CDATA[
<?php
namespace Foo;
class Bar {
    public function Bar() {
        // Tratado como constructor en PHP 5.3.0 - 5.3.2
        // Tratado como método regular a partir de PHP 5.3.3
    }
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.decon.destructor">
   <title>Destructor</title>
   <methodsynopsis>
    <type>void</type><methodname>__destruct</methodname>
    <void />
   </methodsynopsis>
   <para>
    PHP 5 introduce un concepto de destructor similar al de otros
    lenguajes orientados a objetos, tal como C++. El método destructor será
    llamado tan pronto como todas las referencias a un objeto en particular
    sean removidas, cuando es explícitamente destruido o en cualquier otra
    circunstancia de finalización.
   </para>
   <example>
    <title>Ejemplo de Destructor</title>
    <programlisting role="php">
<![CDATA[
<?php
class MyDestructableClass {
   function __construct() {
       print "En el constructor\n";
       $this->name = "MyDestructableClass";
   }

   function __destruct() {
       print "Destruyendo " . $this->name . "\n";
   }
}

$obj = new MyDestructableClass();
?>
]]>
    </programlisting>
   </example>
   <para>
    Como los constructores, los destructores parent no serán llamados
    implícitamente por el motor. Para ejecutar un destructor parent, se
    deberá explicitar un llamada a <function>parent::__destruct</function>
    en el interior del destructor.
   </para>
   <para>
    El destructor será invocado aún si la ejecución del script es detenida
    usando <function>exit</function>. Llamar a <function>exit</function> en un
    destructor evitará que se ejecuten las rutinas restantes de finalización.
   </para>
   <note>
    <para>
     Los destructores invocados durante la finalización del script tienen
     los headers HTTP ya enviados. El directorio de trabajo en la fase de
     finalización del script puede ser diferente con algunos SAPIs (por ej., Apache).
    </para>
   </note>
   <note>
    <para>
     Intentar arrojar una excepción desde un destructor (invocado en la finalización
     del script) causa un error fatal.
    </para>
   </note>
  </sect2>

 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
