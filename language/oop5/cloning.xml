<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.2 $ -->
<!-- EN-Revision: 1.4 Maintainer: baoengb Status: ready -->
 <sect1 id="language.oop5.cloning">
  <title>Clonado de Objetos</title>
  
  <para>
   Crear una copia de un objeto con una replica de todas sus propiedades 
   no es siempre lo que se desea hacer. Un buen ejemplo de la necesidad de
   copiar los constructores, es si se tiene un objeto el cual representa 
   una ventana GTK y el objeto contiene los recursos de esta ventana GTK,
   cuando se crea un duplicado, puede quererse crear una nueva ventana 
   con las mismas propiedades y hacer que el nuevo objeto tenga los 
   recursos de la ventana nueva. Otro ejemplo es si su objeto 
   tiene la referencia a otro objeto el cual usa, y cuando se duplica 
   el objeto padre, quiere crear una nueva instancia de este otro objeto 
   as&iacute; que la replica tiene su propia copia.
  </para>

  <para>
   Una copia de un objeto es creada usando la palabra 'clone' (la cual 
   llama el m&eacute;todo __clone() del objeto, si es posible). Un 
   m&eacute;todo __clone() de un objeto no puede ser llamado directamente.
  </para>

  <informalexample>
   <programlisting>
<![CDATA[
$copy_of_object = clone $object;
]]>
   </programlisting>
  </informalexample>

  <para>
   Cuando un objeto es clonado, PHP 5 informar&aacute; una copia baja de
   todas las propiedades del objeto. Cualquier propiedad que sean
   referencias a otras variables, permanecer&aacute;n siendo referencias.
   Si un m&eacute;todo __clone() es definido, entonces el m&eacute;todo 
   __clone() del nuevo objeto creado ser&aacute; llamado, para permitir 
   cualquier propiedad que tenga que ser cambiada.
  </para>

  <example>
   <title>Clonando un objeto</title>
   <programlisting role="php">
<![CDATA[
<?php
class SubObject
{
    static $instances = 0;
    public $instance;

    public function __construct() {
        $this->instance = ++self::$instances;
    }

    public function __clone() {
        $this->instance = ++self::$instances;
    }
}

class MyCloneable
{
    public $object1;
    public $object2;

    function __clone()
    {
        // Force a copy of this->object, otherwise
        // it will point to same object.
        $this->object1 = clone($this->object1);
    }
}

$obj = new MyCloneable();

$obj->object1 = new SubObject();
$obj->object2 = new SubObject();

$obj2 = clone $obj;


print("Original Object:\n");
print_r($obj);

print("Cloned Object:\n");
print_r($obj2);

?> 
]]>
   </programlisting>
   &example.outputs;
   <screen role="php">
<![CDATA[
Original Object:
MyCloneable Object
(
    [object1] => SubObject Object
        (
            [instance] => 1
        )

    [object2] => SubObject Object
        (
            [instance] => 2
        )

)
Cloned Object:
MyCloneable Object
(
    [object1] => SubObject Object
        (
            [instance] => 3
        )

    [object2] => SubObject Object
        (
            [instance] => 2
        )

)
]]>

   </screen>

  </example>

 </sect1>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
