  <chapter id="control-structures">
   <title>Estructuras de Control</title>

   <simpara>
    Todo archivo de comandos PHP se compone de una serie de sentencias.
    Una sentencia puede ser una asignación, una llamada a función, un bucle,
    una sentencia condicional e incluso una sentencia que no haga nada 
    (una sentencia vacía). Las sentencias normalmente acaban con punto y
    coma. Además, las sentencias se pueden agrupar en grupos de sentencias
    encapsulando un grupo de sentencias con llaves. Un grupo de sentencias
    es también una sentencia. En este capítulo se describen los diferentes
    tipos de sentencias.</simpara>

   <sect1 id="control-structures.if">
    <title><literal>if</literal></title>
    <para>
     La construcción <literal>if</literal> es una de las más importantes
     características de muchos lenguajes, incluido PHP. Permite la ejecución
     condicional de fragmentos de código. PHP caracteriza una estructura 
     <literal>if</literal> que es similar a la de C:
     <informalexample>
      <programlisting>
 if (expr)
     sentencia
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Como se describe en la sección sobre expresiones, expr se evalúa
     a su valor condicional. Si <replaceable>expr</replaceable>
     se evalúa como <literal>TRUE</literal>, PHP ejecutará la sentencia,
     y si se evalúa como <literal>FALSE</literal> - la ignorará.
    </simpara>
    <para>
     El siguiente ejemplo mostraría <computeroutput>a es mayor
     que b</computeroutput> si <replaceable>$a</replaceable> fuera mayor
     que <replaceable>$b</replaceable>:
     <informalexample>
      <programlisting role="php">
 if ($a > $b)
     print "a es mayor que b";
      </programlisting>
     </informalexample>
    </para>
    <para>
     A menudo, se desea tener más de una sentencia ejecutada de forma
     condicional. Por supuesto, no hay necesidad de encerrar cada sentencia
     con una cláusula <literal>if</literal>. En vez de eso, se pueden agrupar
     varias sentencias en un grupo de sentencias.
     Por ejemplo, este código mostraría <computeroutput>a es mayor que
     b</computeroutput> si <replaceable>$a</replaceable> fuera mayor que
     <replaceable>$b</replaceable>, y entonces asignaría el valor de
     <replaceable>$a</replaceable> a <replaceable>$b</replaceable>:
     <informalexample>
      <programlisting role="php">
 if ($a > $b) {
     print "a es mayor que b";
     $b = $a;
 }
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Las sentencias if se pueden anidar indefinidamente dentro de otras
     sentencias <literal>if</literal>, lo cual proporciona una flexibilidad
     completa para ejecuciones condicionales en las diferentes partes de
     tu programa.
    </simpara>
   </sect1>
 
   <sect1 id="control-structures.else">
    <title><literal>else</literal></title>
    <para>
     A menudo queremos ejecutar una sentencia si se cumple una cierta
     condicion, y una sentencia distinta si la condición no se cumple.
     Esto es para lo que sirve <literal>else</literal>.
     <literal>else</literal> extiende una sentencia <literal>if</literal>
     para ejecutar una sentencia en caso de que la expresión en la sentencia
     <literal>if</literal> se evalúe como <literal>FALSE</literal>.  Por
     ejemplo, el siguiente código mostraría <computeroutput>a es mayor que
     b</computeroutput> si <replaceable>$a</replaceable> fuera mayor que
     <replaceable>$b</replaceable>, y <computeroutput>a NO es mayor que b
     </computeroutput> en cualquier otro caso:
     <informalexample>
      <programlisting role="php">
 if ($a > $b) {
     print "a es mayor que b";
 } else {
     print "a NO es mayor que b";
 }
      </programlisting>
     </informalexample>
 
     La sentencia <literal>else</literal> se ejecuta solamente si la
     expresión <literal>if</literal> se evalúa como <literal>FALSE</literal>,
     y si hubiera alguna expresión <literal>elseif</literal> - sólo si se
     evaluaron también a <literal>FALSE</literal> (Ver <link
     linkend="control-structures.elseif">elseif</link>).
     </para>
    </sect1>
 
   <sect1 id="control-structures.elseif">
    <title><literal>elseif</literal></title>
 
    <para>
     <literal>elseif</literal>, como su nombre sugiere, es una combinación
     de <literal>if</literal> y <literal>else</literal>.  Como
     <literal>else</literal>, extiende una sentencia <literal>if</literal>
     para ejecutar una sentencia diferente en caso de que la expresión
     <literal>if</literal> original se evalúa como <literal>FALSE</literal>.
     No obstante, a diferencia de <literal>else</literal>, ejecutará
     esa expresión alternativa solamente si la expresión condicional
     <literal>elseif</literal> se evalúa como <literal>TRUE</literal>.
     Por ejemplo, el siguiente código mostraría <computeroutput>a es
     mayor que b</computeroutput>, <computeroutput>a es igual a b
     </computeroutput> o <computeroutput>a es menor que b</computeroutput>:
     <informalexample>
      <programlisting role="php">
 if ($a > $b) {
     print "a es mayor que b";
 } elseif ($a == $b) {
     print "a es igual que b";
 } else {
     print "a es mayor que b";
 }
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Puede haber varios <literal>elseif</literal>s dentro de la misma
     sentencia <literal>if</literal>.  La primera expresión 
     <literal>elseif</literal> (si hay alguna) que se evalúe como
     <literal>true</literal> se ejecutaría.  En PHP, tambi&eacute;n se puede
     escribir 'else if' (con dos palabras) y el comportamiento sería
     id&eacute;ntico al de un 'elseif' (una sola palabra). El significado
     sintáctico es ligeramente distinto (si estas familiarizado con C,
     es el mismo comportamiento) pero la línea básica es que
     ambos resultarían tener exactamente el mismo comportamiento.
    </simpara> 
    <simpara>
     La sentencia <literal>elseif</literal> se ejecuta sólo si la expresión
     <literal>if</literal> precedente y cualquier expresión
     <literal>elseif</literal> precedente se evalúan como
     <literal>FALSE</literal>, y la expresión
     <literal>elseif</literal> actual se evalúa como <literal>TRUE</literal>.
    </simpara>
   </sect1>
 
   <sect1 id="control-structures.alternative-syntax">
    <title>Sintaxis Alternativa de Estructuras de Control</title>
   <para>
	PHP ofrece una sintaxis altenativa para alguna de sus estructuras
        de control; a saber, <literal>if</literal>,
	<literal>while</literal>, <literal>for</literal>, y
	<literal>switch</literal>.  En cada caso, la forma básica de la
	sintaxis alternativa es cambiar abrir-llave por dos puntos (:) y
	cerrar-llave por <literal>endif;</literal>,
	<literal>endwhile;</literal>, <literal>endfor;</literal>, or
	<literal>endswitch;</literal>, respectivamente.
      <informalexample>
       <programlisting role="php">
 &lt;?php if ($a==5): ?&gt;
 A es igual a 5
 &lt;?php endif; ?&gt;
       </programlisting>
      </informalexample>
    </para>
     <simpara>
      En el ejemplo de arriba, el bloque HTML "A = 5" se anida dentro de una
      sentencia <literal>if</literal> escrita en la sintaxis alternativa.
      El bloque HTML se mostraría solamente si $a fuera igual a 5.
     </simpara>
     <para>
      La sintaxis alternativa se aplica a <literal>else</literal>
      y tambi&eacute;n a <literal>elseif</literal>.  La siguiente es una
      estructura <literal>if</literal> con <literal>elseif</literal>
      y <literal>else</literal> en el formato alternativo:
      <informalexample>
       <programlisting role="php">
 if ($a == 5):
     print "a es igual a 5";
     print "...";
 elseif ($a == 6):
     print "a es igual a 6";
     print "!!!";
 else:
     print "a no es ni 5 ni 6";
 endif;
       </programlisting>
      </informalexample>
   </para>
   <para>
	Mirar tambi&eacute;n <link linkend="control-structures.while">while</link>,
	<link linkend="control-structures.for">for</link>, e <link
	 linkend="control-structures.if">if</link> para más ejemplos.
   </para>
  </sect1>
 
   <sect1 id="control-structures.while">
    <title><literal>while</literal></title>
    <para>
     Los bucles <literal>while</literal> son los tipos de bucle más simples
     en PHP. Se comportan como su contrapartida en C.  La forma básica de
     una sentencia <literal>while</literal> es:
     <informalexample>
      <programlisting>
 while (expr) sentencia
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     El significado de una sentencia <literal>while</literal> es simple.
     Le dice a PHP que ejecute la(s) sentencia(s) anidada(s) repetidamente,
     mientras la expresión <literal>while</literal> se evalúe como
     <literal>TRUE</literal>.  El valor de la expresión es
     comprobado cada vez al principio del bucle, así que incluso si este
     valor cambia durante la ejecución de la(s) sentencia(s) anidada(s),
     la ejecución no parará hasta el fin de la iteración (cada vez que
     PHP ejecuta las sentencias en el bucle es una iteración).
     A veces, si la expresión <literal>while</literal> se evalúa como
     <literal>FALSE</literal> desde el principio de todo, la(s) sentencia(s)
     anidada(s) no se ejecutarán ni siquiera una vez.
    </simpara>
    <para>
     Como con la sentencia <literal>if</literal>, se pueden agrupar
     multiples sentencias dentro del mismo bucle <literal>while</literal>
     encerrando un grupo de sentencias con llaves, o usando la sintaxis
     alternativa:
     <informalexample>
      <programlisting>
 while (expr): sentencia ... endwhile;
      </programlisting>
     </informalexample>
    </para>
    <para>
      Los siguientes ejemplos son id&eacute;nticos, y ambos imprimen números del
      1 al 10:
     <informalexample>
      <programlisting>
 /* ejemplo 1 */
 
 $i = 1;
 while ($i <= 10) {
     print $i++;  /* el valor impreso sería
                     $i antes del incremento
                     (post-incremento) */
 }
 
 /* ejemplo 2 */
 
 $i = 1;
 while ($i <= 10):
     print $i;
     $i++;
 endwhile;
      </programlisting>
     </informalexample>
    </para>
   </sect1>
 
 
   <sect1 id="control-structures.do.while">
    <title><literal>do..while</literal></title>
 
    <simpara>
     Los bucles <literal>do..while</literal> son muy similares a los
     bucles <literal>while</literal>, excepto que las condiciones se
     comprueban al final de cada iteración en vez de al principio.
     La principal diferencia frente a los bucles regulares 
     <literal>while</literal> es que se garantiza la ejecución de la
     primera iteración de un bucle <literal>do..while</literal>
     (la condición se comprueba sólo al final de la iteración),
     mientras que puede no ser necesariamente ejecutada con un bucle
     <literal>while</literal> regular (la condición se comprueba
     al principio de cada iteración, si esta se evalúa como
     <literal>FALSE</literal> desde el principio la ejecución del bucle
     finalizará inmediatamente).
    </simpara>
    <para>
     Hay una sola sintaxis para los bucles <literal>do..while</literal>:
 
     <informalexample>
      <programlisting role="php">
 $i = 0;
 do {
     print $i;
 } while ($i>0);
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     El bucle de arriba se ejecutaría exactamente una sola vez, despu&eacute;s
     de la primera iteración, cuando la condición se comprueba,
     se evalúa como <literal>FALSE</literal> ($i no es más grande que 0)
     y la ejecución del bucle finaliza.
    </simpara>
    <para>
     Los usuarios avanzados de C pueden estar familiarizados con un uso
     distinto del bucle <literal>do..while</literal>, para permitir parar
     la ejecución en medio de los bloques de código, encapsulandolos con
     <literal>do..while</literal>(0), y usando la sentencia
     <link linkend="control-structures.break"><literal>break</literal></link>.
     El siguiente fragmento de código demuestra esto:
     <informalexample>
      <programlisting role="php">
 do {
     if ($i < 5) {
         print "i no es lo suficientemente grande";
         break;
     }
     $i *= $factor;
     if ($i < $minimum_limit) {
         break;
     }
     print "i es correcto";
     ...procesa i...
 } while(0);
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     No se preocupes si no entiende esto completamente o en absoluto.
     Se pueden codificar archivos de comandos e incluso archivos de
     comandos potentes sin usar esta 'propiedad'.
    </simpara>
   </sect1>
 
   <sect1 id="control-structures.for">
    <title><literal>for</literal></title>
    <para>
     Los bucles <literal>for</literal> son los bucles más complejos en
     PHP.  Se comportan como su contrapartida en C.  La sintaxis de un
     bucle <literal>for</literal> es:
     <informalexample>
      <programlisting>
for (expr1; expr2; expr3) sentencia
      </programlisting>
     </informalexample>
   </para>
   <simpara>
     La primera expresión (<replaceable>expr1</replaceable>) se evalúa
     (ejecuta) incondicionalmente una vez al principio del bucle.
   </simpara>
   <simpara>
     Al comienzo de cada iteración, se evalúa <replaceable>expr2
     </replaceable>.  Si se evalúa como <literal>TRUE</literal>, el
     bucle continúa y las sentencias anidadas se ejecutan. Si se evalúa
     como <literal>FALSE</literal>, la ejecución del bucle finaliza.
   </simpara>
   <simpara>
     Al final de cada iteración, se evalúa (ejecuta)
     <replaceable>expr3</replaceable>.
   </simpara>
    <simpara>
     Cada una de las expresiones puede estar vacía.
     Que <replaceable>expr2</replaceable> est&eacute; vacía significa
     que el bucle debería correr indefinidamente (PHP implicitamente
     lo considera como <literal>TRUE</literal>, al igual que C).
     Esto puede que no sea tan inútil como se podría pensar, puesto
     que a menudo se quiere salir de un bucle usando una sentencia
     <link linkend="control-structures.break"><literal>break</literal></link> 
     condicional en vez de usar la condición de <literal>for</literal>.
    </simpara>
    <para>
     Considera los siguientes ejemplos.  Todos ellos muestran números del
     1 al 10:
 
     <informalexample>
      <programlisting role="php">
 /* ejemplo 1 */
 
 for ($i = 1; $i <= 10; $i++) {
     print $i;
 }
 
 /* ejemplo 2 */
 
 for ($i = 1;;$i++) {
     if ($i > 10) {
         break;
     }
     print $i;
 }
 
 /* ejemplo 3 */
 
 $i = 1;
 for (;;) {
     if ($i > 10) {
         break;
     }
     print $i;
     $i++;
 }
 
 /* ejemplo 4 */
 
 for ($i = 1; $i <= 10; print $i, $i++) ;
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Por supuesto, el primer ejemplo parece ser el mas elegante (o quizás
     el cuarto), pero uno puede descubrir que ser capaz de usar expresiones
     vacías en bucles <literal>for</literal> resulta útil en muchas
     ocasiones.
    </simpara>
    <para>
     PHP también soporta la "sintaxis de dos puntos" alternativa para
     bucles <literal>for</literal>.
     <informalexample>
      <programlisting>
 for (expr1; expr2; expr3): sentencia; ...; endfor;
      </programlisting>
     </informalexample>
   </para>
   <para>
    Otros lenguajes poseen una sentencia <literal>foreach</literal> para
    traducir un array o una tabla hash. PHP3 no posee tal construcción;
    PHP4 sí (ver <link linkend="control-structures.foreach">foreach</link>).
    En PHP3, se puede combinar <link linkend="control-structures.while">while</link>
    con las funciones <function>list</function> y <function>each</function>
    para conseguir el mismo efecto. Mirar la documentación de estas funciones
    para ver un ejemplo.
   </para>
  </sect1>

  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    PHP4 (PHP3 no) incluye una construcción <literal>foreach</literal>,
    tal como perl y algunos otros lenguajes. Esto simplemente da un
    modo fácil de iterar sobre arrays. Hay dos sintaxis; la segunda es
    una extensión menor, pero útil de la primera:
    <informalexample>
     <programlisting>
foreach(expresion_array as $value) sentencia
foreach(expresion_array as $key => $value) sentencia
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    La primera forma recorre el array dado por
    <literal>expresion_array</literal>. En cada iteración, el valor del
    elemento actual se asigna a <literal>$value</literal> y
    el puntero interno del array se avanza en una unidad (así en el siguiente
    paso, se estará mirando el elemento siguiente).
   </simpara>
   <simpara>
    La segunda manera hace lo mismo, salvo que la clave del elemento
    actual será asignada a la variable <literal>$key</literal> en cada
    iteración.
   </simpara>
   <para>
    <note>
     <para>
    Cuando <literal>foreach</literal> comienza su primera ejecución,
    el puntero interno a la lista (array) se reinicia automáticamente al primer
    elemento del array. Esto significa que no se necesita llamar a
    <function>reset</function> antes de un bucle <literal>foreach</literal>.
     </para>
    </note>
   </para>
   <para>
    <note>
         <para>
           Hay que tener en cuanta que<literal>foreach</literal> con una
           copia de la lista (array) especificada y no la lista en si, por
           ello el puntero de la lista no es modificado como en la construcción 
           each.
         </para>
    </note>
   </para>
   <para>
    Puede haber observado que las siguientes son funcionalidades idénticas:
    <informalexample>
     <programlisting role="php">
reset( $arr );
while( list( , $value ) = each( $arr ) ) {
   echo "Valor: $value&lt;br&gt;\n";
}

foreach( $arr as $value ) {
   echo "Valor: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
    Las siguientes también son funcionalidades idénticas:
    <informalexample>
     <programlisting role="php">
reset( $arr );
while( list( $key, $value ) = each( $arr ) ) {
   echo "Key: $key; Valor: $value&lt;br&gt;\n";
}

foreach( $arr as $key => $value ) {
   echo "Key: $key; Valor: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    Algunos ejemplos más para demostrar su uso:
    <informalexample>
     <programlisting role="php">
/* foreach ejemplo 1: sólo valor*/
$a = array(1, 2, 3, 17);

foreach($a as $v) {
   print "Valor actual de \$a: $v.\n";
}

/* foreach ejemplo 2: valor (con clave impresa para ilustrar) */
$a = array(1, 2, 3, 17);

$i = 0; /* sólo para propósitos demostrativos */

foreach($a as $v) {
   print "\$a[$i] => $k.\n";
}

/* foreach ejemplo 3: clave y valor */
$a = array(
   "uno" => 1,
   "dos" => 2,
   "tres" => 3,
   "diecisiete" => 17
);

foreach($a as $k => $v) {
   print "\$a[$k] => $v.\n";
}
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.break">
    <title><literal>break</literal></title> 
    <simpara>
     <literal>break</literal> escapa de la estructuras de control 
     iterante (bucle) actuales <literal>for</literal>, <literal>while</literal>, o
    <literal>switch</literal>.
    </simpara>
    <simpara>
    <literal>break</literal> accepta un parámetro opcional, el cual determina 
    cuantas estructuras de control hay que escapar.
   </simpara>
   <para>
     <informalexample>
      <programlisting role="php">
$arr = array ('one', 'two', 'three', 'four', 'stop', 'five');
while (list (, $val) = each ($arr)) {
    if ($val == 'stop') {
        break;    /* You could also write 'break 1;' here. */
    }
    echo "$val&lt;br&gt;\n";
}

/* Using the optional argument. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "At 5&lt;br&gt;\n";
        break 1;  /* Exit only the switch. */
    case 10:
        echo "At 10; quitting&lt;br&gt;\n";
        break 2;  /* Exit the switch and the while. */
    default:
        break;
    }
}
      </programlisting>
     </informalexample>
    </para>
   </sect1>
 
   <sect1 id="control-structures.continue">
    <title><literal>continue</literal></title>
 
    <simpara>
     <literal>continue</literal> se usa dentro de la estructura del bucle
     para saltar el resto de la iteración actual del bucle y continuar
     la ejecución al comienzo de la siguiente iteración.
    </simpara>
   <simpara>
    <literal>continue</literal> accepta un parámetro opcional, el cual determina 
    cuantos niveles (bluces) hay que saltar antes de continuar con la ejecución.
   </simpara>
   <para>
     <informalexample>
      <programlisting role="php">
 while (list($key,$value) = each($arr)) {
     if ($key % 2) { // salta los miembros impares
         continue;
     }
     do_something_odd ($value);
 }
$i = 0;
while ($i++ &lt; 5) {
    echo "Outer&lt;br&gt;\n";
    while (1) {
        echo "&nbsp;&nbsp;Middle&lt;br&gt;\n";
        while (1) {
            echo "&nbsp;&nbsp;Inner&lt;br&gt;\n";
            continue 3;
        }
        echo "This never gets output.&lt;br&gt;\n";
    }
    echo "Neither does this.&lt;br&gt;\n";
}
      </programlisting>
     </informalexample>
    </para>
   </sect1>
 
   <sect1 id="control-structures.switch">
    <title><literal>switch</literal></title>
 
    <simpara>
     La sentencia <literal>switch</literal> es similar a una serie de
     sentencias IF en la misma expresión.  En muchas ocasiones,
     se quiere comparar la misma variable (o expresión) con
     nuchos valores diferentes, y ejecutar una parte de código distinta
     dependiendo de a qu&eacute; valor es igual.
     Para ello sirve la sentencia <literal>switch</literal>.
    </simpara>
    <para>
     Los siguientes dos ejemplos son dos modos distintos de escribir la
     misma cosa, uno usa una serie de sentencias <literal>if</literal>,
     y el otro usa la sentencia <literal>switch</literal>:
     <informalexample>
      <programlisting role="php">
 if ($i == 0) {
     print "i es igual a 0";
 }
 if ($i == 1) {
     print "i es igual a 1";
 }
 if ($i == 2) {
     print "i es igual a 2";
 }
 
 switch ($i) {
     case 0:
         print "i es igual a 0";
         break;
     case 1:
         print "i es igual a 1";
         break;
     case 2:
         print "i es igual a 2";
         break;
 }
      </programlisting>
     </informalexample>
    </para>
    <para>
     Es importante entender cómo se ejecuta la sentencia 
     <literal>switch</literal> para evitar errores. La
     sentencia <literal>switch</literal> ejecuta línea por línea (realmente,
     sentencia a sentencia).  Al comienzo, no se ejecuta código.
     Sólo cuando se encuentra una sentencia <literal>case</literal> con un
     valor que coincide con el valor de la expresión <literal>switch</literal>
     PHP comienza a ejecutar las sentencias.  PHP continúa ejecutando las
     sentencias hasta el final del bloque <literal>switch</literal>,
     o la primera vez que vea una sentencia <literal>break</literal>.
     Si no se escribe una sentencia <literal>break</literal> al final
     de una lista de sentencias case, PHP seguirá ejecutando las sentencias
     del siguiente case.  Por ejemplo:
     <informalexample>
      <programlisting role="php">
 switch ($i) {
     case 0:
         print "i es igual a 0";
     case 1:
         print "i es igual a 1";
     case 2:
         print "i es igual a 2";
 }
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Aquí, si $i es igual a 0, ¡PHP ejecutaría todas las sentecias print!
     Si $i es igual a 1, PHP ejecutaría las últimas dos sentencias print
     y sólo si $i es igual a 2, se obtendría la conducta 'esperada' 
     y solamente se mostraría 'i es igual a 2'.  Así, es importante no
     olvidar las sentencias <literal>break</literal>
     (incluso aunque pueda querer evitar escribirlas intencionadamente
     en ciertas circunstancias).
   </simpara>
   <simpara>
	En una sentencia <literal>switch</literal>, la condición se
	evalúa sólo una vez  y el resultado se compara a cada sentencia
	<literal>case</literal>.  En una sentencia <literal>elseif</literal>,
	la condición se evalúa otra vez.  Si tu condición es más complicada
        que una comparación simple y/o está en un bucle estrecho,
	un <literal>switch</literal> puede ser más rápido.
   </simpara>
   <para>
     La lista de sentencias de un case puede tambi&eacute;n estar vacía, lo cual
     simplemente pasa el control a la lista de sentencias del siguiente case.
     <informalexample>
      <programlisting role="php">
 switch ($i) {
     case 0:
     case 1:
     case 2:
         print "i es menor que 3, pero no negativo";
         break;
     case 3:
         print "i es 3";
 }
      </programlisting>
     </informalexample>
    </para>
    <para>
     Un case especial es el default case.  Este case coincide con
     todo lo que no coincidan los otros case. Por ejemplo:
     <informalexample>
      <programlisting role="php">
 switch ($i) {
     case 0:
         print "i es igual a 0";
         break;
     case 1:
         print "i es igual a 1";
         break;
     case 2:
         print "i es igual a 2";
         break;
     default:
         print "i no es igual a 0, 1 o 2";
 }
      </programlisting>
     </informalexample>
   </para>
    <para>
     La expresión <literal>case</literal> puede ser cualquier expresión
     que se evalúe a un tipo simple, es decir, números enteros o de punto
     flotante y cadenas de texto.  No se pueden usar aquí ni arrays ni
     objetos a menos que se conviertan a un tipo simple.
   </para>
   <para>
	La sintaxis alternativa para las estructuras de control está también
	soportada con switch. Para más información, ver <link
	 linkend="control-structures.alternative-syntax">Sintaxis alternativa
	 para estructuras de control</link>.
     <informalexample>
      <programlisting role="php">
switch ($i):
     case 0:
         print "i es igual 0";
         break;
     case 1:
         print "i es igual a 1";
         break;
     case 2:
         print "i es igual a 2";
         break;
     default:
         print "i no es igual a 0, 1 o 2";
 endswitch;
      </programlisting>
     </informalexample>
  </para>
  </sect1>
 
  <sect1 id="function.require">
   <title><function>require</function></title>
   <simpara>
	La sentencia <function>require</function> se sustituye a sí misma con
	el archivo especificado, tal y como funciona la directiva
	<literal>#include</literal> de C.
   </simpara>
   <simpara>
	Un punto importante sobre su funcionamiento es que cuando un archivo se
	incluye con <function>include</function> o se requiere con 
	<function>require</function>), el int&eacute;rprete sale del modo PHP 
	y entra en modo HTML al principio del archivo referenciado, 
	y vuelve de nuevo al modo PHP al final. Por esta razón, cualquier 
	código dentro del archivo referenciado que debiera ser ejecutado 
	como código PHP debe ser encerrado dentro de <link
	linkend="language.basic-syntax.phpmode"> etiquetas válidas de 
	comienzo y fin de PHP</link>.
   </simpara>
   <simpara>
	<function>require</function> no es en realidad una función de PHP;
	es más una construcción del lenguaje. Está sujeta a algunas reglas
        distintas de las de funciones. Por ejemplo,
	<function>require</function> no esta sujeto a ninguna estructura de
        control contenedora. Por otro lado, no devuelve ningún valor; 
	intentar leer un valor de retorno de una llamada a un
	<function>require</function> resulta en un error del intérprete.
   </simpara>
   <simpara>
	A diferencia de <function>include</function>, <function>require</function>
	<emphasis>siempre</emphasis> leerá el archivo referenciado,
	<emphasis>incluso si la línea en que está no se ejecuta
        nunca</emphasis>. Si se quiere incluir condicionalmente un archivo, se
	usa <function>include</function>. La sentencia conditional no
	afecta a <function>require</function>. No obstante, si la línea
	en la cual aparece el <function>require</function> no se ejecuta,
	tampoco se ejecutará el código del archivo referenciado.
   </simpara>
   <simpara>
	De forma similar, las estructuras de bucle no afectan la conducta de
	<function>require</function>. Aunque el código contenido en el
	archivo referenciado está todavía sujeto al bucle, el propio
	<function>require</function> sólo ocurre una vez.
   </simpara>
   <para>
	Esto significa que no se puede poner una sentencia 
	<function>require</function> dentro de una estructura de bucle y 
	esperar que incluya el contenido de un archivo distinto en cada
	iteración. Para hacer esto, usa una sentencia 
	<function>include</function>.
     <informalexample>
      <programlisting role="php">
require( 'header.inc' );
      </programlisting>
     </informalexample>
   </para>
   <simpara>
    When a file is <function>require</function>ed, the code it
    contains inherits the variable scope of the line on which the
    <function>require</function> occurs. Any variables available at
    that line in the calling file will be available within the called
    file. If the <function>require</function> occurs inside a
    function within the calling file, then all of the code contained
    in the called file will behave as though it had been defined
    inside that function.
   </simpara>
   <para>
    If the <function>require</function>ed file is called via HTTP
    using the fopen wrappers, and if the target server interprets the
    target file as PHP code, variables may be passed to the
    <function>require</function>ed file using an URL request string as
    used with HTTP GET. This is not strictly speaking the same thing
    as <function>require</function>ing the file and having it inherit
    the parent file's variable scope; the script is actually being run
    on the remote server and the result is then being included into
    the local script.
    <informalexample>
     <programlisting role="php">
/* This example assumes that someserver is configured to parse .php
 * files and not .txt files. Also, 'works' here means that the variables 
 * $varone and $vartwo are available within the require()ed file. */

/* Won't work; file.txt wasn't handled by someserver. */
require ("http://someserver/file.txt?varone=1&amp;vartwo=2");

/* Won't work; looks for a file named 'file.php?varone=1&amp;vartwo=2'
 * on the local filesystem. */
require ("file.php?varone=1&amp;vartwo=2");               

/* Works. */
require ("http://someserver/file.php?varone=1&amp;vartwo=2"); 

$varone = 1;
$vartwo = 2;
require ("file.txt");  /* Works. */
require ("file.php");  /* Works. */
     </programlisting>
    </informalexample>
   </para>
   <simpara>
	En PHP3, es posible ejecutar una sentencia <literal>return</literal>
	dentro de un archivo referenciado con <function>require</function>,
        en tanto en cuanto esa sentencia aparezca en el ámbito global del
	archivo requerido (<function>require</function>). No puede aparecer
        dentro de ningún bloque (lo que siginifica dentro de llaves({})).
	En PHP4, no obstante, esta capacidad ha sido desestimada.
	Si se necesita esta funcionalidad, véase <function>include</function>.
   </simpara>
   <simpara>
    Ver tambien <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
     y <function>virtual</function>.
   </simpara>
  </sect1>
 
  <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
	La sentencia <function>include</function> incluye y evalúa 
	el archivo especificado.
   </simpara>
   <simpara>
    Si "URL fopen wrappers" esta activada en PHP (como está en la
    configuración inicial), se puede especificar el fichero que se 
    va a incluir usando una URL en vez de un fichero local (con su Path)
    Ver <link linkend="features.remote-files">Ficheros remotos</link> 
    y <function>fopen</function> para más información.
   </simpara>
   <simpara>
	Un punto importante sobre su funcionamiento es que cuando un archivo
	se incluye con <function>include</function> o se requiere con
	<function>require</function>, el int&eacute;rprete sale del modo PHP
	y entra en modo HTML al principio del archivo referenciado, 
	y vuelve de nuevo al modo PHP al final. Por esta razón, cualquier 
	código dentro del archivo referenciado que debiera ser ejecutado 
	como código PHP debe ser encerrado dentro de <link 
	linkend="language.basic-syntax.phpmode"> etiquetas válidas de 
	comienzo y fin de PHP</link>.
   </simpara>
    <para>
     Esto sucede cada vez que se encuentra la sentencia
     <function>include</function>, así que se puede usar una sentencia
     <function>include</function> dentro de una estructura de bucle para
     incluir un número de archivos diferentes.
 
	<informalexample>
	 <programlisting role="php">
$archivos = array ('primero.inc', 'segundo.inc', 'tercero.inc');
for ($i = 0; $i < count($archivos); $i++) {
    include $archivos[$i];
}
	 </programlisting>
	</informalexample>
   </para>
   <para>
	<function>include</function> difiere de
	<function>require</function> en que la sentencia include se
	re-evalúa cada vez que se encuentra (y sólo cuando está siendo
	ejecutada), mientras que la sentencia <function>require</function>
	se reemplaza por el archivo referenciado cuando se encuentra por
	primera vez, se vaya a evaluar el contenido del archivo o no
	(por ejemplo, si está dentro de una sentencia <link
	linkend="control-structures.if">if</link> cuya condición evaluada
	es falsa).
   </para>
   <para>
	Debido a que <function>include</function> es una construcción especial
	del lenguaje, se debe encerrar dentro de un bloque de sentencias si
	está dentro de un bloque condicional.
	<informalexample>
	 <programlisting role="php">
 /* Esto es ERRÓNEO y no funcionará como se desea. */
 
 if ($condicion)
     include($archivo);
 else
     include($otro);
 
 /* Esto es CORRECTO. */
 
 if ($condicion) {
     include($archivo);
 } else {
     include($otro);
 }
	 </programlisting>
	</informalexample>
   </para>
   <simpara>
	En ambos, PHP3 y PHP4, es posible ejecutar una sentencia
	<literal>return</literal> dentro de un archivo incluido con
	<function>include</function>, para terminar el procesado de ese
	archivo y volver al archivo de comandos que lo llamó.
	Existen algunas diferencias en el modo en que esto funciona,
	no obstante. La primera es que en PHP3, <literal>return</literal> 
	no puede aparecer dentro de un bloque a menos que sea un bloque de
	función, en el cual <literal>return</literal> se aplica a esa función
	y no al archivo completo. En PHP4, no obstante, esta restricción no
	existe. Tambi&eacute;n, PHP4 permite devolver valores desde archivos 
        incluidos con <function>include</function>. Se puede capturar el valor de la
	llamada a <function>include</function> como se haría con una
	función normal. Esto genera un error de intérprete en PHP3.
   </simpara>
   <example>
	<title><function>include</function> en PHP3 y PHP4</title>
	<para>
	 Asumamos la existencia del siguiente archivo (llamado
	 <filename>test.inc</filename>) en el mismo directorio que el
	 archivo principal:
	 <programlisting role="php">
&lt?php
echo "Antes del return &lt;br&gt;\n";
if ( 1 ) {
   return 27;
}
echo "Despu&eacute;s del return &lt;br&gt;\n";
?&gt;
	 </programlisting>
	</para>
	<para>
	 Asumamos que el archivo principal (<filename>main.html</filename>)
	 contiene lo siguiente:
	 <programlisting role="php">
&lt?php
$retval = include( 'test.inc' );
echo "El archivo devolvió: '$retval'&lt;br&gt;\n";
?&gt;
	 </programlisting>
	</para>
	<para>
	 Cuando se llama a <filename>main.html</filename> en PHP3,
	 generará un error del int&eacute;rprete en la linea 2; no se puede
	 capturar el valor de un <function>include</function> en PHP3.
	 En PHP4, no obstante, el resultado será:
	 <screen>
Antes del return
El archivo devolvió: '27'
	 </screen>
	</para>
	<para>
	 Ahora, asumamos que se ha modificado <filename>main.html</filename>
	 para que contenga lo siguiente:
	 <programlisting role="php">
&lt?php
include( 'test.inc' );
echo "De vuelta en main.html&lt;br&gt;\n";
?&gt;
	 </programlisting>
	</para>
	<para>
	 En PHP4, la salida será:
	 <screen>
Antes del return
De vuelta en main.html
	 </screen>
	 No obstante, PHP3 dará la siguiente salida:
	 <screen>
Antes del return
27De vuelta en main.html

Parse error: parse error in /home/torben/public_html/phptest/main.html on line 5
	 </screen>
	</para>
	<para>
	 El error del intérprete es resultado del hecho de que la sentencia
	 <literal>return</literal> está encerrada en un bloque de no-función
	 dentro de <filename>test.inc</filename>. Cuando el return se mueve
	 fuera del bloque, la salida es:
	 <screen>
Antes del return
27De vuelta en main.html
	 </screen>
	</para>
	<para>
	 El '27' espúreo se debe al hecho de que PHP3 no soporta devolver
	 valores con <literal>return</literal> desde archivos como ese. 
	</para>
   </example>
   <simpara>
    When a file is <function>include</function>ed, the code it
    contains inherits the variable scope of the line on which the
    <function>include</function> occurs. Any variables available at
    that line in the calling file will be available within the called
    file. If the <function>include</function> occurs inside a
    function within the calling file, then all of the code contained
    in the called file will behave as though it had been defined
    inside that function.
   </simpara>
   <para>
    If the <function>include</function>ed file is called via HTTP
    using the fopen wrappers, and if the target server interprets the
    target file as PHP code, variables may be passed to the
    <function>include</function>ed file using an URL request string as
    used with HTTP GET. This is not strictly speaking the same thing
    as <function>include</function>ing the file and having it inherit
    the parent file's variable scope; the script is actually being run
    on the remote server and the result is then being included into
    the local script.
    <informalexample>
     <programlisting role="php">
/* This example assumes that someserver is configured to parse .php
 * files and not .txt files. Also, 'works' here means that the variables 
 * $varone and $vartwo are available within the include()ed file. */

/* Won't work; file.txt wasn't handled by someserver. */
include ("http://someserver/file.txt?varone=1&amp;vartwo=2");

/* Won't work; looks for a file named 'file.php?varone=1&amp;vartwo=2'
 * on the local filesystem. */
include ("file.php?varone=1&amp;vartwo=2");               

/* Works. */
include ("http://someserver/file.php?varone=1&amp;vartwo=2"); 

$varone = 1;
$vartwo = 2;
include ("file.txt");  /* Works. */
include ("file.php");  /* Works. */
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    See also <function>require</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
        and <function>virtual</function>.
   </simpara>
  </sect1>
 
  <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    The <function>require_once</function> statement replaces
    itself with the specified file, much like the C preprocessor's
    <literal>#include</literal> works, and in that respect is
        similar to the <function>require</function> statement. The main
        difference is that in an inclusion chain, the use of
        <function>require_once</function> will assure that the code is
        added to your script only once, and avoid clashes with variable
        values or function names that can happen.
   </para>
   <para>
     For example, if you create the following 2 include files
         <literal>utils.inc</literal> and <literal>foolib.inc</literal>
         <example>
         <title>utils.inc</title>
         <programlisting role="php">
&lt;?php
define(PHPVERSION, floor(phpversion()));
echo "GLOBALS ARE NICE\n";
function goodTea() {
        return "Oolong tea tastes good!";
}
?&gt;
         </programlisting>
         </example>
         <example>
         <title>foolib.inc</title>
         <programlisting role="php">
&lt;?php
require ("utils.inc");
function showVar($var) {
        if (PHPVERSION == 4) {
                print_r($var);
        } else {
                dump_var($var);
        }
}

// bunch of other functions ...
?&gt;
         </programlisting>
         </example>
         And then you write a script <literal>cause_error_require.php</literal>
         <example>
         <title>cause_error_require.php</title>
         <programlisting role="php">
&lt;?php
require("foolib.inc");
/* the following will generate an error */
require("utils.inc");
$foo = array("1",array("complex","quaternion"));
echo "this is requiring utils.inc again which is also\n";
echo "required in foolib.inc\n";
echo "Running goodTea: ".goodTea()."\n";
echo "Printing foo: \n";
showVar($foo);
?&gt;
         </programlisting>
         </example>
         When you try running the latter one, the resulting ouptut will be (using
         PHP 4.01pl2):
         <informalexample>
         <programlisting>
GLOBALS ARE NICE
GLOBALS ARE NICE

Fatal error:  Cannot redeclare causeerror() in utils.inc on line 5
         </programlisting>
         </informalexample>
         By modifying <literal>foolib.inc</literal> and
         <literal>cause_errror_require.php</literal> 
         to use <function>require_once</function>
         instead of <function>require</function> and renaming the
         last one to <literal>avoid_error_require_once.php</literal>, we have:
         <example>
         <title>foolib.inc (fixed)</title>
         <programlisting role="php">
...
require_once("utils.inc");
function showVar($var) {
...
         </programlisting>
         </example>
         <example>
         <title>avoid_error_require_once.php</title>
         <programlisting role="php">
...
require_once("foolib.inc");
require_once("utils.inc");
$foo = array("1",array("complex","quaternion"));
...
         </programlisting>
         </example>
         And when running the latter, the output will be (using PHP 4.0.1pl2):
         <informalexample>
         <programlisting>
GLOBALS ARE NICE
this is requiring globals.inc again which is also
required in foolib.inc
Running goodTea: Oolong tea tastes good!
Printing foo:
Array
(
    [0] =&gt; 1
    [1] =&gt; Array
        (
            [0] =&gt; complex
            [1] =&gt; quaternion
        )

)
         </programlisting>
         </informalexample>
   </para>
   <para>
     Also note that, analogous to the behavior of the
         <literal>#include</literal> of the C preprocessor, this statement
         acts at "compile time", e.g. when the script is parsed and before it
         is executed, and should not be used for parts of the script that need
         to be inserted dynamically during its execution. You should use
         <function>include_once</function> or <function>include</function>
         for that purpose.
   </para>
   <para>
     For more examples on using <function>require_once</function> and 
         <function>include_once</function>, look at the PEAR code included in
         the latest PHP source code distributions.
   </para>
   <para>
    See also: <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
        and <function>virtual</function>.
   </para>
  </sect1>
  
  <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    The <function>include_once</function> statement includes and evaluates
    the specified file during the execution of the script.
        This is a behavior similar to the <function>include</function> statement,
        with the important difference that if the code from a file has already
        been included, it will not be included again.
   </para>
   <para>
    As mentioned in the <function>require_once</function> description, the
        <function>include_once</function> should be used in the cases in which
        the same file might be included and evaluated more than once during a
        particular execution of a script, and you want to be sure that it is
        included exactly once to avoid problems with function redefinitions,
        variable value reassignments, etc.
   </para>
   <para>
     For more examples on using <function>require_once</function> and 
         <function>include_once</function>, look at the PEAR code included in
         the latest PHP source code distributions.
   </para>
   <para>
    See also: <function>require</function>,
    <function>include</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
        and <function>virtual</function>.
   </para>
  </sect1>
 
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
