<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.12 $ -->
<!-- EN-Revision: 1.68 Maintainer: lboshell Status: ready -->
 <chapter id="language.operators">
  <title>Operadores</title>
  <simpara>
   Un operador es algo a lo que usted entrega uno o m&aacute;s valores
   (o expresiones, en jerga de programaci&oacute;n) y produce otro
   valor (de modo que la construcci&oacute;n misma se convierte en una
   expresi&oacute;n). As&iacute; que puede pensar sobre las funciones
   o construcciones que devuelven un valor (como print) como
   operadores, y en aquellas que no devuelven nada (como echo) como
   cualquier otra cosa.
  </simpara>
  <para>
   Existen tres tipos de operadores. En primer lugar se encuentra el
   operador unario, el cual opera sobre un &uacute;nico valor, por
   ejemplo ! (el operador de negaci&oacute;n) o ++ (el operador de
   incremento). El segundo grupo se conoce como operadores binarios;
   &eacute;ste grupo contiene la mayor&iacute;a de operadores que
   soporta PHP, y una lista se encuentra disponible m&aacute;s
   adelante en la secci&oacute;n <link
   linkend="language.operators.precedence">Precedencia de
   Operadores</link>.
  </para>
  <para>
   El tercer grupo consiste del operador ternario: ?:. &Eacute;ste
   debe ser usado para seleccionar entre dos expresiones, en base a
   una tercera, en lugar de seleccionar dos sentencias o rutas de
   ejecuci&oacute;n. Rodear las expresiones ternarias con
   par&eacute;ntesis es una muy buena idea.
  </para>
  
  <sect1 id="language.operators.precedence">
   <title>Precedencia de Operadores</title>
   <para>
    La precedencia de un operador indica qu&eacute; tan "cerca" se
    agrupan dos expresiones. Por ejemplo, en la
    expresi&oacute;n <literal>1 + 5 * 3</literal>, la respuesta
    es <literal>16</literal> y no
    <literal>18</literal>, ya que el operador de multiplicaci&oacute;n
    ("*") tiene una mayor precedencia que el operador de
    adici&oacute;n ("+"). Los par&eacute;ntesis pueden ser usados para
    marcar la precedencia, si resulta necesario. Por
    ejemplo: <literal>(1 + 5) * 3</literal> eval&uacute;a
    a <literal>18</literal>.
   </para>
   <para>
    La siguiente tabla lista la precedencia de los operadores, con
    aquellos de mayor precedencia listados de primeros.
    <table>
     <title>Precedencia de Operadores</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Asociatividad</entry>
        <entry>Operadores</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>no-asociativo</entry>
        <entry>new</entry>
       </row>
       <row>
        <entry>derecha</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>derecha</entry>
        <entry>! ~ ++ -- (int) (float) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>no-asociativos</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>no-asociativos</entry>
        <entry>== != === !==</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>derecha</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=
        </entry>
       </row>
       <row>
        <entry>derecha</entry>
        <entry>print</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>,</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <note>
    <para>
     Aunque <literal>!</literal> tiene una mayor precedencia
     que <literal>=</literal>, PHP permitir&aacute; aun expresionas
     similares a la siguiente: <literal>if (!$a = foo())</literal>, en
     cuyo caso la salida de <literal>foo()</literal> va a dar
     a <varname>$a</varname>.
    </para>
   </note>
  </sect1>

  <sect1 id="language.operators.arithmetic">
   <title>Operadores de Aritm&eacute;tica</title>
   <simpara>
    &iquest;Recuerda la aritm&eacute;tica b&aacute;sica del colegio?
    &Eacute;stos operadores funcionan tal como aqu&eacute;llos.
   </simpara>
   <table>
    <title>Operadores de Aritm&eacute;tica</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Adici&oacute;n</entry>
       <entry>Suma de $a y $b.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Substracci&oacute;n</entry>
       <entry>Diferencia entre $a y $b.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Multiplicaci&oacute;n</entry>
       <entry>Producto de $a y $b.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>Divisi&oacute;n</entry>
       <entry>Cociente de $a y $b.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>M&oacute;dulo</entry>
       <entry>Resto de $a dividido por $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    El operador de divisi&oacute;n ("/") devuelve un valor flotante en
    todos los casos, incluso si los dos operandos son enteros (o
    cadenas que son convertidas a enteros).
   </simpara>
   <simpara>
    Vea tambi&eacute;n la p&aacute;gina del manual sobre
    <link linkend="ref.math">Funciones matem&aacute;ticas</link>. 
   </simpara>

   <!--
   <simpara>
    The division operator ("/") returns an integer value (the result
    of an integer division) if the two operands are integers (or
    strings that get converted to integers) and the quotient is an
    integer. If either operand is a floating-point value, or the
    operation results in a non-integer value, a floating-point value
    is returned.
   </simpara>
   -->
  </sect1>
  
  <sect1 id="language.operators.assignment">
   <title>Operadores de Asignaci&oacute;n</title>
   <simpara>
    El operador b&aacute;sico de asignaci&oacute;n es "=". A primera
    vista, usted podr&iacute;a pensar en &eacute;l como "es igual
    a". No lo haga. Lo que quiere decir en realidad es que el operando
    de la izquierda recibe el valor de la expresi&oacute;n a la
    derecha (es decir, "se define a").
   </simpara>
   <para>
    El valor de una expresi&oacute;n de asignaci&oacute;n es el valor
    que se asigna. Es decir, el valor de "$a = 3" es 3. Esto le
    permite hacer una que otra cosa curiosa:
    <informalexample>
     <programlisting role="php"> 
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a es igual a 9 ahora, y $b ha sido definido a 4.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    En conjunto con el operador b&aacute;sico de asignaci&oacute;n,
    existen "operadores combinados" para todas las operaciones
    de <link linkend="language.operators">aritm&eacute;tica
    binaria</link> y de cadenas, que le permiten usar un valor en una
    expresi&oacute;n y luego definir su valor como el resultado de esa
    expresi&oacute;n. Por ejemplo:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // define $a como 8, como si hubiesemos dicho: $a = $a + 5;
$b = "&iexcl;Hola ";
$b .= "a todos!"; // define $b como "&iexcl;Hola a todos!", tal como $b = $b . "a todos!";

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Note que la asignaci&oacute;n copia la variable original en la
    nueva (asignaci&oacute;n por valor), de modo que cualquier cambio
    a una no afecta a la otra. Esto puede resultar de importancia si
    necesita copiar algo como una matriz de gran tama&ntilde;o al
    interior de un ciclo reducido. PHP4 soporta la asignaci&oacute;n
    por referencia, usando la sintaxis <computeroutput>$var =
    &amp;$otra_var;</computeroutput>, pero esto no es posible en
    PHP3. 'Asignaci&oacute;n por referencia' quiere decir que ambas
    variables terminan apuntando a los mismos datos y que nada es
    realmente copiado. Para aprender m&aacute;s sobre las referencias,
    por favor refi&eacute;rase a <link
    linkend="language.references">las Referencias explicadas</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.bitwise">
   <title>Operadores Bit a Bit</title>
   <simpara>
    Los operadores bit a bit le permiten activar o desactivar bits
    individuales de un entero. Si los par&aacute;metros tanto a la
    izquierda y a la derecha son cadenas, el operador bit a bit
    trabajar&aacute; sobre los valores ASCII de los caracteres.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Imprime '5'

echo "12" ^ "9"; // Imprime el caracter Backspace (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Imprime los valores ascii #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4
?>
]]>
     </programlisting>
    </informalexample> 
   </para>

   <table>
    <title>Operadores Bit a Bit</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
        <entry>$a &amp; $b</entry>
       <entry>Y</entry>
       <entry>Los bits que est&aacute;n activos tanto en $a como en $b
       son activados.</entry>
      </row>
      <row>
       <entry>$a | $b</entry>
       <entry>O</entry>
       <entry>Los bits que est&aacute;n activos ya sea en $a o en $b
       son activados.</entry>
      </row>
      <row>
       <entry>$a ^ $b</entry>
       <entry>O exclusivo (Xor)</entry>
       <entry>
        Los bitos que est&eacute;n activos en $a o $b, pero no en
        ambos, son activados.
       </entry>
      </row>
      <row>
       <entry>~ $a</entry>
       <entry>No</entry>
       <entry>
        Los bits que est&eacute;n activos en $a son desactivados, y
        vice-versa.
       </entry>
      </row>
      <row>
       <entry>$a &lt;&lt; $b</entry>
       <entry>Desplazamiento a izquierda</entry>
       <entry>
        Desplaza los bits de $a, $b pasos a la izquierda (cada paso
        quiere decir "multiplicar por dos")
       </entry>
      </row>
      <row>
       <entry>$a &gt;&gt; $b</entry>
       <entry>Desplazamiento a derecha</entry>
       <entry>
        Desplaza los bits de $a, $b pasos a la derecha (cada paso
        quiere decir "dividir por dos")
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect1>

  <sect1 id="language.operators.comparison">
   <title>Operadores de Comparaci&oacute;n</title>
   <simpara>
    Los operadores de comparaci&oacute;n, como su nombre indica, le
    permiten comparar dos valores. Puede que tambi&eacute;n se
    encuentre interesado en consultar las
    <link linkend="types.comparisons">tablas de comparaci&oacute;n de
    tipos</link>, ya que &eacute;stas muestran ejemplos de varios
    tipos de comparaciones relacionadas con tipos.
   </simpara>
   <table>
    <title>Operadores de Comparaci&oacute;n</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Igual</entry>
       <entry>&true; si $a es igual a $b.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Id&eacute;ntico</entry>
       <entry>
        &true; si $a es igual a $b, y son del mismo tipo. (S&oacute;lo
        en PHP 4)
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Diferente</entry>
       <entry>&true; si $a no es igual a $b.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Diferente</entry>
       <entry>&true; si $a no es igual a $b.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>No id&eacute;nticos</entry>
       <entry>
        &true; si $a no es igual a $b, o si no son del mismo
        tipo. (S&oacute;lo en PHP 4)
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Menor que</entry>
       <entry>&true; si $a es escrictamente menor que $b.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Mayor que</entry>
       <entry>&true; si $a es estrictamente mayor que $b.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Menor o igual que</entry>
       <entry>&true; si $a es menor o igual que $b.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Mayor o igual que</entry>
       <entry>&true; si $a es mayor o igual que $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Otro operador condicional es el operador "?:" (o ternario).
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Ejemplo de uso de: el Operador Ternario
$accion = (empty($_POST['accion'])) ? 'predeterminada' : $_POST['accion'];

// La sentencia anterior es identica a este bloque if/else
if (empty($_POST['accion'])) {
    $accion = 'predeterminada';
} else {
    $accion = $_POST['accion'];
}
?>
]]>
     </programlisting>
    </informalexample>
    La expresi&oacute;n <literal>(expr1) ? (expr2) : (expr3)</literal>
    eval&uacute;a a <replaceable>expr2</replaceable> si
    <replaceable>expr1</replaceable> eval&uacute;a a &true;, y
    <replaceable>expr3</replaceable> si
    <replaceable>expr1</replaceable> eval&uacute;a a &false;.
   </para>
   <para>
    Vea tambi&eacute;n <function>strcasecmp</function>,
    <function>strcmp</function>,
    <link linkend="language.operators.array">Operadores de
    matriz</link>, y la secci&oacute;n del manual sobre
    <link linkend="language.types">Tipos</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.errorcontrol">
   <title>Operadores de Control de Errores</title>
   <simpara>
    PHP ofrece soporte para un operador de control de errores: el
    signo de arroba (@). Cuando es colocado al comienzo de una
    expresi&oacute;n en PHP, cualquier mensaje de error que pudiera
    generarse a causa de esa expresi&oacute;n ser&aacute; ignorado.
   </simpara>
   <simpara>
    Si la caracter&iacute;stica <link
    linkend="ini.track-errors"><option>track_errors</option></link>
    est&aacute; habilitada, cualquier mensaje de error generado por la
    expresi&oacute;n ser&aacute; almacenado en la variable <link
    linkend="reserved.variables.phperrormsg">$php_errormsg</link>. La
    variable ser&aacute; sobrescrita en cada instancia de error,
    as&iacute; que realice sus chequeos de forma temprana si quiere
    usarla.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Error intencional de archivo */
$mi_archivo = @file ('archivo_que_no_existe') or
    die ("La apertura de archivo ha fallado: el error fue '$php_errormsg'");

// esto funciona con cualquier expresion, no solo con funciones:
$valor = @$cache[$llave];
// no producira una anotacion si el indice $llave no existe.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     El operador @ trabaja s&oacute;lo sobre
     <link linkend="language.expressions">expresiones</link>. Una
     simple regla de oro es: si usted puede tomar el valor de algo,
     entonces puede usar el operador @ sobre ese algo. Por ejemplo,
     puede usarlo al inicio de variables, llamadas a funciones y
     sencencias <function>include</function>, constantes, y as&iacute;
     sucesivamente. No puede usarlo sobre definiciones de
     funci&oacute;n o clase, ni sobre estructuras condicionales
     como <literal>if</literal> y
     <literal>foreach</literal>, y as&iacute; sucesivamente.
    </simpara>
   </note>
   <simpara>
    Vea tambi&eacute;n <function>error_reporting</function> y la
    secci&oacute;n del manual sobre <link
    linkend="ref.errorfunc">funciones de Gesti&oacute;n de Errores y
    Registros</link>.
   </simpara>
   <note>
    <para>
     El operador de prefijo "@" para control de errores no
     deshabilitar&aacute; los mensajes que son resultado de errores en
     la fase de an&aacute;lisis sint&aacute;ctico.
    </para>
   </note>
   <warning>
    <para>
     En la actualidad, el operador de prefijo "@" para control de
     errores deshabilitar&aacute; incluso el reporte de errores en
     casos de fallos cr&iacute;ticos que terminar&aacute;n la
     ejecuci&oacute;n del script. Entre otras cosas, esto quiere decir
     que si usa "@" para eliminar los errores de una cierta
     funci&oacute;n, y &eacute;sta no se encuentra disponible o ha
     sido escrita de forma incorrecta, el script se detendr&aacute; en
     ese punto sin dar indicaci&oacute;n alguna del motivo.
    </para>
   </warning>
  </sect1>
  
  <sect1 id="language.operators.execution">
   <title>Operadores de ejecuci&oacute;n</title>
   <para>
    PHP soporta un operador de ejecuci&oacute;n: las comillas
    invertidas (``). &iexcl;Note que no se trata de comillas
    sencillas! PHP intentar&aacute; ejecutar el contenido entre las
    comillas como si se tratara de un comando del int&eacute;rprete de
    comandos; su salida ser&aacute; devuelta (es decir, no ser&aacute;
    simplemente volcada como salida; puede ser asignada a una
    variable). El uso del operador de comillas invertidas es
    id&eacute;ntico al de <function>shell_exec</function>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$salida = `ls -al`;
echo "<pre>$salida</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     El operador de comillas invertidas es deshabilitado cuando se
     encuentra activo &safemode; o cuando se
     deshabilita <function>shell_exec</function>.
    </para>
   </note>
   <para>
    Vea tambi&eacute;n la secci&oacute;n del manual sobre <link
    linkend="ref.exec">funciones de Ejecuci&oacute;n de
    Programas</link>, <function>popen</function>
    <function>proc_open</function>, y
    <link linkend="features.commandline">Uso de PHP desde la
    l&iacute;nea de comandos</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.increment">
   <title>Operadores de Incremento/Decremento</title>
   <para>
    PHP ofrece soporte de operadores de pre- y post-incremento y
    decremento, estilo-C.
   </para>
   <table>
    <title>Operadores de Incremento/decremento</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Efecto</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Pre-incremento</entry>
       <entry>Incrementa $a en uno, y luego devuelve $a.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Post-incremento</entry>
       <entry>Devuelve $a, y luego incrementa $a en uno.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Pre-decremento</entry>
       <entry>Decrementa $a en uno, luego devuelve $a.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Post-decremento</entry>
       <entry>Devuelve $a, luego decrementa $a en uno.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Aqu&iacute; hay un script sencillo de ejemplo:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Postincremento</h3>";
$a = 5;
echo "Debe ser 5: " . $a++ . "<br />\n";
echo "Debe ser 6: " . $a . "<br />\n";

echo "<h3>Preincremento</h3>";
$a = 5;
echo "Debe ser 6: " . ++$a . "<br />\n";
echo "Debe ser 6: " . $a . "<br />\n";

echo "<h3>Postdecremento</h3>";
$a = 5;
echo "Debe ser 5: " . $a-- . "<br />\n";
echo "Debe ser 4: " . $a . "<br />\n";

echo "<h3>Predecremento</h3>";
$a = 5;
echo "Debe ser 4: " . --$a . "<br />\n";
echo "Debe ser 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    PHP sigue la convenci&oacute;n de Perl cuando trabaja con
    operaciones aritm&eacute;ticas sobre variables de caracter, y no
    la convenci&oacute;n de C. Por ejemplo, en Perl 'Z'+1 se convierte
    en 'AA', mientras que en C 'Z'+1 se convierte en '[' ( ord('Z') ==
    90, ord('[') == 91 ). Note que las variables de caracter pueden
    ser incrementadas pero no decrementadas.
    <example>
     <title>Operaciones Aritm&eacute;ticas sobre Variables de
     Caracter</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for($n=0; $n<6; $n++)
  echo ++$i . "\n";

/*
  Produce una salida similar a la siguiente:

X
Y
Z
AA
AB
AC

*/
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>

  <sect1 id="language.operators.logical">
   <title>Operadores de L&oacute;gica</title>

   <table>
    <title>Operadores de L&oacute;gica</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>Y</entry>
       <entry>&true; si tanto $a como $b son &true;.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>O</entry>
       <entry>&true; si cualquiera de $a o $b es &true;.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>O exclusivo (Xor)</entry>
       <entry>&true; si $a o $b es &true;, pero no ambos.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>No</entry>
       <entry>&true; si $a no es &true;.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>Y</entry>
       <entry>&true; si tanto $a como $b son &true;.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>O</entry>
       <entry>&true; si cualquiera de $a o $b es &true;.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    La raz&oacute;n para tener las dos variaciones diferentes de los
    operadores "and" y "or" es que ellos operan con precedencias
    diferentes. (Vea
    <link linkend="language.operators.precedence">Precedencia de
    Operadores</link>.)
   </simpara>
  </sect1>

  <sect1 id="language.operators.string">
   <title>Operadores de Cadena</title>
   <simpara>
    Existen dos operadores para datos tipo <type>string</type>. El
    primero es el operador de concatenaci&oacute;n ('.'), el cual
    devuelve el resultado de concatenar sus argumentas a lado derecho
    e izquierdo. El segundo es el operador de asignaci&oacute;n sobre
    concatenaci&oacute;n ('.='), el cual adiciona el argumento del
    lado derecho al argumento en el lado izquierdo. Por favor
    consulte <link linkend="language.operators.assignment">Operadores
    de Asignaci&oacute;n</link> para m&aacute;s informaci&oacute;n.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "&iexcl;Hola ";
$b = $a . "Mundo!"; // ahora $b contiene "&iexcl;Hola Mundo!"

$a = "&iexcl;Hola ";
$a .= "Mundo!";     // ahora $a contiene "&iexcl;Hola Mundo!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Vea tambi&eacute;n las secciones del manual sobre
    <link linkend="language.types.string">el tipo String</link> y las
    <link linkend="ref.strings">funciones de Cadenas</link>.
   </para>
  </sect1>
  
  <sect1 id="language.operators.array">
   <title>Operadores de Matrices</title>
   <table>
    <title>Operadores de Matrices</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Uni&oacute;n</entry>
       <entry>Uni&oacute;n de $a y $b.</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>Igualdad</entry>
       <entry>&true; si $a y $b tienen los mismos elementos.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identidad</entry>
       <entry>&true; si $a y $b tienen los mismos elementos en el
       mismo orden.</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>No-igualdad</entry>
       <entry>&true; si $a no es igual a $b.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>No-igualdad</entry>
       <entry>&true; si $a no es igual a $b.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>No-identidad</entry>
       <entry>&true; si $a no es id&eacute;ntico a $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    El operador <literal>+</literal> adiciona la matriz del lado
    derecho a aqu&eacute;l al lado izquierdo, al mismo tiempo que
    cualquier llave duplicada NO es sobrescrita.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "manzana", "b" => "banano");
$b = array("a" => "pera", "b" => "fresa", "c" => "cereza");

$c = $a + $b; // Union de $a y $b
echo "Uni&oacute;n de \$a y \$b: \n";
var_dump($c);

$c = $b + $a; // Union de $b y $a
echo "Uni&oacute;n de \$b y \$a: \n";
var_dump($c);
?>
]]>
     </programlisting>
    </informalexample>
    Cuando sea ejecutado, este script producir&aacute; la siguiente
    salida:
    <screen role="php">
<![CDATA[
Uni&oacute;n de $a y $b:
array(3) {
  ["a"]=>
  string(7) "manzana"
  ["b"]=>
  string(6) "banano"
  ["c"]=>
  string(6) "cereza"
}
Uni&oacute;n de $b y $a:
array(3) {
  ["a"]=>
  string(4) "pera"
  ["b"]=>
  string(5) "fresa"
  ["c"]=>
  string(6) "cereza"
}
]]>
    </screen>
   </para>
   <para>
    Los elementos de las matrices son considerados equivalentes en la
    comparaci&oacute;n si &eacute;stos tienen la misma clave y valor.
   </para>
   <para>
    <example>
     <title>Comparaci&oacute;n de matrices</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("manzana", "banano");
$b = array(1 => "banano", "0" => "manzana");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Vea tambi&eacute;n las secciones del manual sobre
    <link linkend="language.types.array">el tipo Array</link> y
    <link linkend="ref.array">funciones de Matrices</link>.
   </para>
  </sect1>
  <sect1 id="language.operators.type">
   <title>Operadores de Tipo</title>
   <para>
    PHP tiene un operador &uacute;nico de
    tipo: <literal>instanceof</literal>. <literal>instanceof</literal>
    es usado para determinar si un objeto dado es de una <link
    linkend="language.oop">clase de objeto</link> especificada.
   </para>
   <simpara>
    El operador <literal>instanceof</literal> fue introducido en PHP
    5. Antes de esta versi&oacute;n, <function>is_a</function> era
    utilizado, pero <function>is_a</function> ha sido marcado como
    obsoleto desde entonces en favor de <literal>instanceof</literal>.
   </simpara>
   <informalexample>
    <programlisting>
<![CDATA[
<?php
class A { }
class B { }

$cosa = new A;

if ($cosa instanceof A) {
    echo 'A';
}
if ($cosa instanceof B) {
    echo 'B';
}
?>
]]>
    </programlisting>
    <simpara>
     Dado que <varname>$cosa</varname> es un <type>object</type> de
     tipo A, pero no de tipo B, s&oacute;lo el bloque dependiente del
     tipo A ser&aacute; ejecutado:
    </simpara>
    <screen>A</screen>
   </informalexample>
   <para>
    Vea tambi&eacute;n <function>get_class</function> e
    <function>is_a</function>.
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
