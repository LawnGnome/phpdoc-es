<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.32 $ -->
<!-- EN-Revision: 1.113 Maintainer: lboshell Status: ready -->
 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>Operadores</title>
  <simpara>
   Un operador es algo a lo que usted entrega uno o más valores (o
   expresiones, en jerga de programación) y produce otro valor (de modo que
   la construcción misma se convierte en una expresión). Así que puede
   pensar sobre las funciones o construcciones que devuelven un valor (como
   print) como operadores, y en aquellas que no devuelven nada (como echo)
   como cualquier otra cosa.
  </simpara>
  <para>
   Existen tres tipos de operadores. En primer lugar se encuentra el
   operador unario, el cual opera sobre un único valor, por ejemplo !  (el
   operador de negación) o ++ (el operador de incremento). El segundo grupo
   se conoce como operadores binarios; este grupo contiene la mayoría de
   operadores que soporta PHP, y una lista se encuentra disponible más
   adelante en la sección <link
   linkend="language.operators.precedence">Precedencia de Operadores</link>.
  </para>
  <para>
   El tercer grupo consiste del operador ternario: ?:. Éste debe ser usado
   para seleccionar entre dos expresiones, en base a una tercera, en lugar
   de seleccionar dos sentencias o rutas de ejecución. Rodear las
   expresiones ternarias con paréntesis es una muy buena idea.
  </para>

  <sect1 xml:id="language.operators.precedence">
   <title>Precedencia de Operadores</title>
   <para>
    La precedencia de un operador indica qué tan "cerca" se agrupan dos
    expresiones. Por ejemplo, en la expresión <literal>1 + 5 * 3</literal>,
    la respuesta es <literal>16</literal> y no <literal>18</literal>, ya que
    el operador de multiplicación ("*") tiene una mayor precedencia que el
    operador de adición ("+"). Los paréntesis pueden ser usados para marcar
    la precedencia, si resulta necesario. Por ejemplo: <literal>(1 + 5) *
    3</literal> evalúa a <literal>18</literal>. Si la precedencia de los
    operadores es la misma, se utiliza una asociación de izquierda a
    derecha.
   </para>
   <para>
    La siguiente tabla lista la precedencia de los operadores, con aquellos
    de mayor precedencia listados al comienzo de la tabla. Los operadores en
    la misma línea tienen la misma precedencia, en cuyo caso su
    asociatividad decide el orden para evaluarlos.
    <table>
     <title>Precedencia de Operadores</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Asociatividad</entry>
        <entry>Operadores</entry>
        <entry>Información Adicional</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>no-asociativo</entry>
        <entry>new</entry>
        <entry><link
        linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>[</entry>
        <entry><function>array</function></entry>
       </row>
       <row>
        <entry>no-asociativos</entry>
        <entry>++ --</entry>
        <entry>
         <link
         linkend="language.operators.increment">incremento/decremento</link>
        </entry>
       </row>
       <row>
        <entry>no-asociativos</entry>
        <entry>~ - (int) (float) (string) (array) (object) @</entry>
        <entry>
         <link linkend="language.types">tipos</link>
        </entry>
       </row>
       <row>
        <entry>no-asociativos</entry>
        <entry>instanceof</entry>
        <entry>
         <link linkend="language.types">tipos</link>
        </entry>
       </row>
       <row>
        <entry>derecha</entry>
        <entry>!</entry>
        <entry>
         <link linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>* / %</entry>
        <entry>
         <link
         linkend="language.operators.arithmetic">aritmética</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>+ - .</entry>
        <entry>
         <link
         linkend="language.operators.arithmetic">aritmética</link>&listendand;
         <link linkend="language.operators.string">cadena</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
        <entry>
         <link linkend="language.operators.bitwise">manejo de bits</link>
        </entry>
       </row>
       <row>
        <entry>no-asociativos</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
        <entry>
         <link
         linkend="language.operators.comparison">comparación</link>
        </entry>
       </row>
       <row>
        <entry>no-asociativos</entry>
        <entry>== != === !==</entry>
        <entry>
         <link
         linkend="language.operators.comparison">comparación</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>&amp;</entry>
        <entry>
         <link linkend="language.operators.bitwise">manejo de
         bits</link>&listendand; <link
         linkend="language.references">referencias</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>^</entry>
        <entry>
         <link linkend="language.operators.bitwise">manejo de
         bits</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>|</entry>
        <entry>
         <link linkend="language.operators.bitwise">manejo de
         bits</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>&amp;&amp;</entry>
        <entry>
         <link
         linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>||</entry>
        <entry>
         <link
         linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>? :</entry>
        <entry>
         <link
         linkend="language.operators.comparison.ternary">ternario</link>
        </entry>
       </row>
       <row>
        <entry>derecha</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=
        </entry>
        <entry>
         <link
         linkend="language.operators.assignment">asignación</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>and</entry>
        <entry>
         <link
         linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>xor</entry>
        <entry>
         <link
         linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>or</entry>
        <entry>
         <link
         linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>,</entry>
        <entry>varios usos</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    La asociatividad de izquierda quiere decir que la expresión es evaluada
    desde la izquierda a la derecha, la asociatividad de derecha quiere
    decir lo contrario.
    <example>
     <title>Asociatividad</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
    Use paréntesis para incrementar la legibilidad del código.
   </para>
   <note>
    <para>
     Aunque <literal>=</literal> tiene una menor precedencia que la mayoría
     de los demás operadores, PHP aun permite expresiones similares a la
     siguiente: <literal>if (!$a = foo())</literal>, en cuyo caso el valor
     de retorno de <literal>foo()</literal> va a dar a
     <varname>$a</varname>.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="language.operators.arithmetic">
   <title>Operadores de Aritmética</title>
   <simpara>
    ¿Recuerda la aritmética básica del colegio?  Éstos operadores funcionan
    tal como aquéllos.
   </simpara>
   <table>
    <title>Operadores de Aritmética</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-$a</entry>
       <entry>Negación</entry>
       <entry>El opuesto de $a.</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>Adición</entry>
       <entry>Suma de $a y $b.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Substracción</entry>
       <entry>Diferencia entre $a y $b.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Multiplicación</entry>
       <entry>Producto de $a y $b.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>División</entry>
       <entry>Cociente de $a y $b.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Módulo</entry>
       <entry>Resto de $a dividido por $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    El operador de división ("/") devuelve un valor flotante en todos los
    casos, incluso si los dos operandos son enteros (o cadenas que son
    convertidas a enteros).
   </simpara>
   <note>
    <simpara>
     El resto de <literal>$a % $b</literal> es negativo para valores
     negativos de <literal>$a</literal>.
    </simpara>
   </note>
   <simpara>
    Vea también la página del manual sobre <link
    linkend="ref.math">Funciones mateméticas</link>.
   </simpara>

   <!--
   <simpara>
    The division operator ("/") returns an integer value (the result
    of an integer division) if the two operands are integers (or
    strings that get converted to integers) and the quotient is an
    integer. If either operand is a floating-point value, or the
    operation results in a non-integer value, a floating-point value
    is returned.
   </simpara>
   -->
  </sect1>

  <sect1 xml:id="language.operators.assignment">
   <title>Operadores de Asignación</title>
   <simpara>
    El operador básico de asignación es "=". A primera vista, usted podría
    pensar en él como "es igual a". No lo haga. Lo que quiere decir en
    realidad es que el operando de la izquierda recibe el valor de la
    expresión a la derecha (es decir, "se define a").
   </simpara>
   <para>
    El valor de una expresión de asignación es el valor que se asigna. Es
    decir, el valor de "$a = 3" es 3. Esto le permite hacer una que otra
    cosa curiosa:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a es igual a 9 ahora, y $b ha sido definido a 4.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    En conjunto con el operador básico de asignación, existen "operadores
    combinados" para todos los operadores de <link
    linkend="language.operators">aritmética binaria</link>, unión de
    matrices y de cadenas, que le permiten usar un valor en una expresión y
    luego definir su valor como el resultado de esa expresión. Por ejemplo:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // define $a como 8, como si hubiésemos dicho: $a = $a + 5;
$b = "¡Hola ";
$b .= "a todos!"; // define $b como "¡Hola a todos!", tal como $b = $b . "a todos!";

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Note que la asignación copia la variable original en la nueva
    (asignación por valor), de modo que cualquier cambio a una no afecta a
    la otra. Esto puede resultar de importancia si necesita copiar algo como
    una matriz de gran tamaño al interior de un ciclo reducido. A partir de
    PHP4, es soportada la asignación por referencia, usando la sintaxis
    <computeroutput>$var = &amp;$otra_var;</computeroutput>, pero esto no es
    posible en PHP3. 'Asignación por referencia' quiere decir que ambas
    variables terminan apuntando a los mismos datos y que nada es realmente
    copiado. Para aprender más sobre las referencias, por favor refiérase a
    <link linkend="language.references">las Referencias explicadas</link>. A
    partir de PHP 5 los objetos son asignados por referencia a menos que
    explícitamente se diga lo contrario con la nueva palabra clave <link
    linkend="language.oop5.cloning">clone</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>Operadores Bit a Bit</title>
   <simpara>
    Los operadores bit a bit le permiten activar o desactivar bits
    individuales de un entero. Si los parámetros tanto a la izquierda y a la
    derecha son cadenas, el operador bit a bit trabajará sobre los valores
    ASCII de los caracteres.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Imprime '5'

echo "12" ^ "9"; // Imprime el caracter Backspace (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Imprime los valores ascii #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <table>
    <title>Operadores Bit a Bit</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
        <entry>$a &amp; $b</entry>
       <entry>Y</entry>
       <entry>Los bits que están activos tanto en $a como en $b son
       activados.</entry>
      </row>
      <row>
       <entry>$a | $b</entry>
       <entry>O</entry>
       <entry>Los bits que están activos ya sea en $a o en $b son
       activados.</entry>
      </row>
      <row>
       <entry>$a ^ $b</entry>
       <entry>O exclusivo (Xor)</entry>
       <entry>
        Los bits que estén activos en $a o $b, pero no en ambos, son
        activados.
       </entry>
      </row>
      <row>
       <entry>~ $a</entry>
       <entry>No</entry>
       <entry>
        Los bits que estén activos en $a son desactivados, y
        vice-versa.
       </entry>
      </row>
      <row>
       <entry>$a &lt;&lt; $b</entry>
       <entry>Desplazamiento a izquierda</entry>
       <entry>
        Desplaza los bits de $a, $b pasos a la izquierda (cada paso
        quiere decir "multiplicar por dos")
       </entry>
      </row>
      <row>
       <entry>$a &gt;&gt; $b</entry>
       <entry>Desplazamiento a derecha</entry>
       <entry>
        Desplaza los bits de $a, $b pasos a la derecha (cada paso
        quiere decir "dividir por dos")
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <warning>
    <para>
     No realice desplazamientos a derecha para más de 32 bits en sistemas de
     32 bits. No realice desplazamientos a izquierda en caso de que resulte
     en un número de más de 32 bits.
    </para>
   </warning>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>Operadores de Comparación</title>
   <simpara>
    Los operadores de comparación, como su nombre indica, le permiten
    comparar dos valores. Puede que también se encuentre interesado en
    consultar las <link linkend="types.comparisons">tablas de comparación de
    tipos</link>, ya que éstas muestran ejemplos de varios tipos de
    comparaciones relacionadas con tipos.
   </simpara>
   <table>
    <title>Operadores de Comparación</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Igual</entry>
       <entry>&true; si $a es igual a $b.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Idéntico</entry>
       <entry>
        &true; si $a es igual a $b, y son del mismo tipo. (A partir de PHP
        4)
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Diferente</entry>
       <entry>&true; si $a no es igual a $b.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Diferente</entry>
       <entry>&true; si $a no es igual a $b.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>No idénticos</entry>
       <entry>
        &true; si $a no es igual a $b, o si no son del mismo
        tipo. (A partir de PHP 4)
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Menor que</entry>
       <entry>&true; si $a es escrictamente menor que $b.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Mayor que</entry>
       <entry>&true; si $a es estrictamente mayor que $b.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Menor o igual que</entry>
       <entry>&true; si $a es menor o igual que $b.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Mayor o igual que</entry>
       <entry>&true; si $a es mayor o igual que $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Si compara un entero con una cadena, la cadena es <link
    linkend="language.types.string.conversion">convertida a un
    número</link>. Si compara dos cadenas numéricas, ellas son comparadas
    como enteros. Estas reglas también se aplican a la sentencia <link
    linkend="control-structures.switch">switch</link>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // nunca se ejecuta ya que "a" ya ha coincidido con 0
    echo "a";
    break;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Para varios tipos, la comparación se realiza de acuerdo con la siguient
    tabla (en orden).
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>Comparaci&oacute;n con Varios Tipos</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Tipo del Operando 1</entry>
       <entry>Tipo del Operando 2</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> o <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>Convertir &null; a "", comparación numérica o de
       léxico</entry>
      </row>
      <row>
       <entry><type>bool</type> o <type>null</type></entry>
       <entry>cualquiera</entry>
       <entry>Convertir a <type>bool</type>, &false; &lt;
       &true;</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>
        Las clases internas pueden definir su propia comparación, clases
        diferentes son incomparables, la misma clase - comparan propiedades
        en la misma forma que las matrices (PHP 4), PHP 5 tiene su propia
        <link linkend="language.oop5.object-comparison">explicación</link>
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type> o <type>number</type></entry>
       <entry><type>string</type>, <type>resource</type> o <type>number</type></entry>
       <entry>Traducir las cadenas y recursos a números, matemática
       usual</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>
        Una matriz con menos elementos es menor, si una clave del operando 1
        no se encuentra en el operando 2 entonces las matrices son
        incomparables, de otra forma - comparar valor por valor (vea el
        siguiente ejemplo)
       </entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>cualquiera</entry>
       <entry><type>array</type> es siempre mayor</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>cualquiera</entry>
       <entry><type>object</type> es siempre mayor</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <example>
     <title>Transcripción de la comparación de matrices
     estándar</title>
     <programlisting role="php">
<![CDATA[
<?php
// Las matrices son comparadas de esta forma con los operadores de comparación estándar
function comparacion_matrices_estandar($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $clave => $val) {
        if (!array_key_exists($clave, $op2)) {
            return null; // incomparable
        } elseif ($val < $op2[$clave]) {
            return -1;
        } elseif ($val > $op2[$clave]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Vea también <function>strcasecmp</function>,
    <function>strcmp</function>, <link
    linkend="language.operators.array">Operadores de matriz</link>, y la
    sección del manual sobre <link linkend="language.types">Tipos</link>.
   </para>

   <sect2 xml:id="language.operators.comparison.ternary">
    <title>Operador Ternario</title>
    <para>
     Otro operador condicional es el operador "?:" (o ternario).
     <example>
      <title>Asignación de un valor predeterminado</title>
      <programlisting role="php">
<![CDATA[
<?php
// Ejemplo de uso de: el Operador Ternario
$accion = (empty($_POST['accion'])) ? 'predeterminada' : $_POST['accion'];

// La línea anterior es idéntica a esta sentencia if/else
if (empty($_POST['accion'])) {
    $accion = 'predeterminada';
} else {
    $accion = $_POST['accion'];
}

?>
]]>
      </programlisting>
     </example>
     La expresión <literal>(expr1) ? (expr2) : (expr3)</literal> evalúa a
     <replaceable>expr2</replaceable> si <replaceable>expr1</replaceable>
     evalúa a &true;, y <replaceable>expr3</replaceable> si
     <replaceable>expr1</replaceable> evalúa a &false;.
    </para>
    <note>
     <simpara>
      Por favor note que el operador ternario es una sentencia, y que no
      evalúa a una variable, sino al resultado de una sentencia. Es
      importante saber esto si se desea devolver una variable por
      referencia. La sentencia <literal>return $var == 42 ? $a :
      $b;</literal> en una función con retorno-por-referencia no funcionará
      por lo que se ha mencionado y una advertencia es generada en versiones
      posteriores de PHP.
     </simpara>
    </note>
    <note>
     <para>
      Es recomendable que evite "apilar" las expresiones ternarias. El
      comportamiente de PHP cuando se usa más de un operador ternario al
      interior de una sentencia no es obvio:
      <example>
       <title>Comportamiento Ternario No-Obvio</title>
       <programlisting role="php">
<![CDATA[
<?php
// a primera vista, lo siguiente parece imprimir 'true'
echo (true?'true':false?'t':'f');

// sin embargo, la salida real de la línea anterior es 't'
// esto se debe a que las expresiones ternarias son evaluadas de izquierda a
// derecha

// la siguiente es una versión más obvia del código presentado anteriormente
echo ((true ? 'true' : 'false') ? 't' : 'f');

// aquí puede ver que la primera expresión es evaluada como 'true', la cual
// en su lugar evalúa a (bool)true, devolviendo por lo tanto la rama de
// verdad de la segunda expresión ternaria.
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>

  </sect1>

  <sect1 xml:id="language.operators.errorcontrol">
   <title>Operadores de Control de Errores</title>
   <simpara>
    PHP ofrece soporte para un operador de control de errores: el signo de
    arroba (@). Cuando es colocado al comienzo de una expresión en PHP,
    cualquier mensaje de error que pudiera generarse a causa de esa
    expresión será ignorado.
   </simpara>
   <simpara>
    Si la característica <link
    linkend="ini.track-errors"><option>track_errors</option></link> está
    habilitada, cualquier mensaje de error generado por la expresión será
    almacenado en la variable <link
    linkend="reserved.variables.phperrormsg">$php_errormsg</link>. La
    variable será sobrescrita en cada instancia de error, así que realice
    sus chequeos de forma temprana si quiere usarla.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Error intencional de archivo */
$mi_archivo = @file ('archivo_que_no_existe') or
    die ("La apertura de archivo ha fallado: el error fue '$php_errormsg'");

// esto funciona con cualquier expresión, no solo con funciones:
$valor = @$cache[$llave];
// no producirá una anotación si el índice $llave no existe.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     El operador @ trabaja sólo sobre <link
     linkend="language.expressions">expresiones</link>. Una simple regla de
     oro es: si usted puede tomar el valor de algo, entonces puede usar el
     operador @ sobre ese algo. Por ejemplo, puede usarlo al inicio de
     variables, llamadas a funciones y sencencias
     <function>include</function>, constantes, y así sucesivamente. No puede
     usarlo sobre definiciones de función o clase, ni sobre estructuras
     condicionales como <literal>if</literal> y <literal>foreach</literal>,
     y así sucesivamente.
    </simpara>
   </note>
   <simpara>
    Vea también <function>error_reporting</function> y la sección del manual
    sobre <link linkend="ref.errorfunc">funciones de Gestión de Errores y
    Registros</link>.
   </simpara>
   <warning>
    <para>
     En la actualidad, el operador de prefijo "@" para control de errores
     deshabilitará incluso el reporte de errores en casos de fallos críticos
     que terminarán la ejecución del script. Entre otras cosas, esto quiere
     decir que si usa "@" para eliminar los errores de una cierta función, y
     ésta no se encuentra disponible o ha sido escrita de forma incorrecta,
     el script se detendrá en ese punto sin dar indicación alguna del
     motivo.
    </para>
   </warning>
  </sect1>

  <sect1 xml:id="language.operators.execution">
   <title>Operadores de ejecución</title>
   <para>
    PHP soporta un operador de ejecución: las comillas invertidas (``).
    ¡Note que no se trata de comillas sencillas! PHP intentará ejecutar el
    contenido entre las comillas como si se tratara de un comando del
    intérprete de comandos; su salida será devuelta (es decir, no será
    simplemente volcada como salida; puede ser asignada a una variable). El
    uso del operador de comillas invertidas es idéntico al de
    <function>shell_exec</function>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$salida = `ls -al`;
echo "<pre>$salida</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     El operador de comillas invertidas es deshabilitado cuando se encuentra
     activo &safemode; o cuando se deshabilita
     <function>shell_exec</function>.
    </para>
   </note>
   <para>
    Vea también la sección del manual sobre <link
    linkend="ref.exec">funciones de Ejecución de Programas</link>,
    <function>popen</function> <function>proc_open</function>, y <link
    linkend="features.commandline">Uso de PHP desde la línea de
    comandos</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.increment">
   <title>Operadores de Incremento/Decremento</title>
   <para>
    PHP ofrece soporte de operadores de pre- y post-incremento y decremento,
    estilo-C.
   </para>
   <note>
    <simpara>
     Los operadores de incremento/decremento no afectan a los valores
     booleanos. Decrementar valores &null; tampoco tiene efecto, aunque
     incrementarlos resulta en <literal>1</literal>.
    </simpara>
   </note>
   <table>
    <title>Operadores de Incremento/decremento</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Efecto</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Pre-incremento</entry>
       <entry>Incrementa $a en uno, y luego devuelve $a.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Post-incremento</entry>
       <entry>Devuelve $a, y luego incrementa $a en uno.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Pre-decremento</entry>
       <entry>Decrementa $a en uno, luego devuelve $a.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Post-decremento</entry>
       <entry>Devuelve $a, luego decrementa $a en uno.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Aquí hay un script sencillo de ejemplo:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Postincremento</h3>";
$a = 5;
echo "Debe ser 5: " . $a++ . "<br />\n";
echo "Debe ser 6: " . $a . "<br />\n";

echo "<h3>Preincremento</h3>";
$a = 5;
echo "Debe ser 6: " . ++$a . "<br />\n";
echo "Debe ser 6: " . $a . "<br />\n";

echo "<h3>Postdecremento</h3>";
$a = 5;
echo "Debe ser 5: " . $a-- . "<br />\n";
echo "Debe ser 4: " . $a . "<br />\n";

echo "<h3>Predecremento</h3>";
$a = 5;
echo "Debe ser 4: " . --$a . "<br />\n";
echo "Debe ser 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    PHP sigue la convención de Perl cuando trabaja con operaciones
    aritméticas sobre variables de caracter, y no la convención de C. Por
    ejemplo, en Perl 'Z'+1 se convierte en 'AA', mientras que en C 'Z'+1 se
    convierte en '[' ( ord('Z') == 90, ord('[') == 91). Note que las
    variables de caracter pueden ser incrementadas pero no decrementadas, y
    aun así solo son soportados los caracteres ASCII planos (a-z y A-Z).
    <example>
     <title>Operaciones Aritméticas sobre Variables de Caracter</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$i . "\n";
}
?>
]]>
     </programlisting>
     &example.outputs;
    <screen>
<![CDATA[
X
Y
Z
AA
AB
AC
]]>
     </screen>
    </example>
   </para>
   <para>
    Incrementar o decrementar valores booleanos no tiene efecto.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.logical">
   <title>Operadores de Lógica</title>

   <table>
    <title>Operadores de Lógica</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>Y</entry>
       <entry>&true; si tanto $a como $b son &true;.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>O</entry>
       <entry>&true; si cualquiera de $a o $b es &true;.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>O exclusivo (Xor)</entry>
       <entry>&true; si $a o $b es &true;, pero no ambos.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>No</entry>
       <entry>&true; si $a no es &true;.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>Y</entry>
       <entry>&true; si tanto $a como $b son &true;.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>O</entry>
       <entry>&true; si cualquiera de $a o $b es &true;.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    La razón para tener las dos variaciones diferentes de los operadores
    "and" y "or" es que ellos operan con precedencias diferentes. (Vea <link
    linkend="language.operators.precedence">Precedencia de
    Operadores</link>.)
   </simpara>
   <example>
    <title>Ilustración de los operadores lógicos</title>
    <programlisting role="php">
<![CDATA[
<?php

// foo() nunca será llamada ya que esos operadores trabajan en modo corto-circuito
$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// "||" tiene una precedencia mayor que "or"
$e = false || true; // $e será definido como (false || true) lo cual es true
$f = false or true; // $f será definido como false
var_dump($e, $f);

// "&&" tiene una precedencia mayor que "and"
$g = true && false;  // $g será definido como (true && false) lo que es false
$h = true and false; // $h será definido como true
var_dump($g, $h);
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>
  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>Operadores de Cadena</title>
   <simpara>
    Existen dos operadores para datos tipo <type>string</type>. El primero
    es el operador de concatenación ('.'), el cual devuelve el resultado de
    concatenar sus argumentas a lado derecho e izquierdo. El segundo es el
    operador de asignación sobre concatenación ('.='), el cual adiciona el
    argumento del lado derecho al argumento en el lado izquierdo. Por favor
    consulte <link linkend="language.operators.assignment">Operadores de
    Asignación</link> para más información.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "¡Hola ";
$b = $a . "Mundo!"; // ahora $b contiene "¡Hola Mundo!"

$a = "¡Hola ";
$a .= "Mundo!";     // ahora $a contiene "¡Hola Mundo!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Vea también las secciones del manual sobre <link
    linkend="language.types.string">el tipo String</link> y las <link
    linkend="ref.strings">funciones de Cadenas</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.array">
   <title>Operadores de Matrices</title>
   <table>
    <title>Operadores de Matrices</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Unión</entry>
       <entry>Unión de $a y $b.</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>Igualdad</entry>
       <entry>&true; si $a y $b tienen las mismas parejas
       llave/valor.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identidad</entry>
       <entry>&true; si $a y $b tienen las mismas parejas llave/valor
       en el mismo orden y de los mismos tipos.</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>No-igualdad</entry>
       <entry>&true; si $a no es igual a $b.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>No-igualdad</entry>
       <entry>&true; si $a no es igual a $b.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>No-identidad</entry>
       <entry>&true; si $a no es idéntico a $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    El operador <literal>+</literal> adiciona la matriz del lado derecho a
    aquél al lado izquierdo, al mismo tiempo que cualquier llave duplicada
    NO es sobrescrita.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "manzana", "b" => "banano");
$b = array("a" => "pera", "b" => "fresa", "c" => "cereza");

$c = $a + $b; // Unión de $a y $b
echo "Unión de \$a y \$b: \n";
var_dump($c);

$c = $b + $a; // Unión de $b y $a
echo "Unión de \$b y \$a: \n";
var_dump($c);
?>
]]>
     </programlisting>
    </informalexample>
    Cuando sea ejecutado, este script producirá la siguiente salida:
    <screen role="php">
<![CDATA[
Unión de $a y $b:
array(3) {
  ["a"]=>
  string(7) "manzana"
  ["b"]=>
  string(6) "banano"
  ["c"]=>
  string(6) "cereza"
}
Unión de $b y $a:
array(3) {
  ["a"]=>
  string(4) "pera"
  ["b"]=>
  string(5) "fresa"
  ["c"]=>
  string(6) "cereza"
}
]]>
    </screen>
   </para>
   <para>
    Los elementos de las matrices son considerados equivalentes en la
    comparación si éstos tienen la misma clave y valor.
   </para>
   <para>
    <example>
     <title>Comparación de matrices</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("manzana", "banano");
$b = array(1 => "banano", "0" => "manzana");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Vea también las secciones del manual sobre <link
    linkend="language.types.array">el tipo Array</link> y <link
    linkend="ref.array">funciones de Matrices</link>.
   </para>
  </sect1>
  <sect1 xml:id="language.operators.type">
   <title>Operadores de Tipo</title>
   <para>
    <literal>instanceof</literal> es usado para determinar si una variable
    PHP es una instancia de objeto de cierta <link
    linkend="language.oop5.basic.class">clase</link>:
    <example>
     <title>Uso de instanceof con clases</title>
     <programlisting role="php">
     <![CDATA[
<?php
class MiClase
{
}
class NoMiClase
{
}
$a = new MiClase;

var_dump($a instanceof MiClase);
var_dump($a instanceof NoMiClase);
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
    <literal>instanceof</literal> puede ser usado también para determinar si
    una variable es una instancia de objeto de una clase que hereda de una
    clase padre:
    <example>
     <title>Uso de instanceof con clases heredadas</title>
     <programlisting role="php">
     <![CDATA[
<?php
class ClasePadre
{
}
class MiClase extends ClasePadre
{
}
$a = new MiClase;

var_dump($a instanceof MiClase);
var_dump($a instanceof ClasePadre);
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
    Por último, <literal>instanceof</literal> puede ser usado también para
    determinar si una variable es una instancia de objeto de una clase que
    implementa una <link linkend="language.oop5.interfaces">interfaz</link>:
    <example>
     <title>Uso de instanceof para una clase</title>
     <programlisting role="php">
     <![CDATA[
<?php
interface MiInterfaz
{
}
class MiClase implements MiInterfaz
{
}
$a = new MiClase;

var_dump($a instanceof MiClase);
var_dump($a instanceof MiInterfaz);
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Aunque <literal>instanceof</literal> es usado por lo general con un
    nombre de clase literal, también puede usarse con otro objeto o una
    variable tipo cadena:
    <example>
     <title>Uso de instanceof con otras variables</title>
     <programlisting role="php">
     <![CDATA[
<?php
interface MiInterfaz
{
}
class MiClase implements MiInterfaz
{
}
$a = new MiClase;
$b = new MiClase;
$c = 'MiClase';
$d = 'NoMiClase';
var_dump($a instanceof $b); // $b es un objeto de la clase MiClase
var_dump($a instanceof $c); // $c es una cadena 'MiClase'
var_dump($a instanceof $d); // $d es una cadena 'NoMiClase'
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    Hay algunas trampas comunes de las que hay que tener cuidado. En
    versiones anteriores a PHP 5.1.0,
    <literal>instanceof</literal> llamaría <link
    linkend="language.oop5.autoload">__autoload()</link> si el nombre de
    clase no existía. Adicionalmente, si la clase no estaba cargada,
    ocurriría un error fatal. Esto puede ser evitado usando una
    <literal>referencia dinámica de clase</literal>, o una variable tipo
    cadena que contenga el nombre de clase:
    <example>
     <title>Evitar búsquedas de nombres de clase y errores fatales con
     instanceof en PHP 5.0</title>
     <programlisting role="php">
     <![CDATA[
<?php
$d = 'NoMiClase';
var_dump($a instanceof $d); // no acurre un error fatal aquí
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    El operador <literal>instanceof</literal> fue introducido en PHP 5.
    Anteriormente <function>is_a</function> era usado, pero desde entonces
    <function>is_a</function> ha sido marcada como función obsoleta,
    prefiriéndose el uso de <literal>instanceof</literal>.
   </simpara>
   <para>
    Vea también <function>get_class</function> e <function>is_a</function>.
   </para>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
