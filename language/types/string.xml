<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.1 $ -->
<!-- EN-Revision: 1.10 Maintainer: lboshell Status: ready -->
<sect1 xml:id="language.types.string">
 <title>Cadenas</title>

 <para>
  Un valor <type>string</type> es una serie de caracteres. Antes de PHP 6,
  un caracter es lo mismo que un byte, es decir, hay exactamente 256 tipos
  de caracteres diferentes. Esto implica también que PHP no tiene soporte
  nativo de Unicode. Vea <function>utf8_encode</function> y
  <function>utf8_decode</function> para conocer sobre una funcionalidad
  básica para Unicode.
 </para>

 <note>
  <simpara>
   El que una cadena se haga muy grande no es un problema. PHP no impone
   límite práctico alguno sobre el tamaño de las cadenas; el único límite es
   la memoria disponible en la máquina en la que PHP esté corriendo.
  </simpara>
 </note>

 <sect2 xml:id="language.types.string.syntax">
  <title>Sintaxis</title>

  <para>
   Un literal tipo <type>string</type> puede especificarse en cuatro formas
   diferentes.
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">comillas
     simples</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">comillas
     dobles</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">sintaxis
     heredoc</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.nowdoc">sintaxis
     nowdoc</link> (a partir de PHP 5.3.0)
    </simpara>
   </listitem>
  </itemizedlist>

  <sect3 xml:id="language.types.string.syntax.single">
   <title>Comillas simples</title>

   <para>
    La forma más simple de especificar un <type>string</type> es rodearla de
    comillas simples (el caracter <literal>'</literal>).
   </para>

   <para>
    Para especificar una comilla sencilla literal, necesita escaparla con
    una barra invertida (<literal>\</literal>). Para especificar una barra
    invertida literal antes de una comilla sencilla, o al final de la
    cadena, dóblela (<literal>\\</literal>). Note que intentar escapar
    cualquier otro caracter imprimirá la barra invertida también.
   </para>

   <note>
    <simpara>
     A diferencia de las otras dos sintaxis, las <link
     linkend="language.variables">variables</link> y secuencias de escape
     para caracteres especiales <emphasis>no</emphasis> serán expandidas
     cuando ocurren al interior de cadenas entre comillas sencillas.
    </simpara>
   </note>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo 'esta es una cadena simple';

echo 'También puede tener saltos de línea embebidos
en las cadenas de esta forma, ya que
es válido';

// Imprime: Arnold dijo una vez: "I'll be back"
echo 'Arnold dijo una vez: "I\'ll be back"';

// Imprime: Ha eliminado C:\*.*?
echo 'Ha eliminado C:\\*.*?';

// Imprime: Ha eliminado C:\*.*?
echo 'Ha eliminado C:\*.*?';

// Imprime: Esto no va a expandirse: \n una nueva línea
echo 'Esto no va a expandirse: \n una nueva línea';

// Imprime: Las variables no se $expanden $tampoco
echo 'Las variables no se $expanden $tampoco';
?>
]]>
    </programlisting>
   </informalexample>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.double">
   <title>Comillas dobles</title>

   <para>
    Si el valor <type>string</type> se encuentra rodeado de comillas dobles
    ("), PHP interpretará más secuencias de escape para caracteres
    especiales:
   </para>

   <table>
    <title>Caracteres escapados</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Secuencia</entry>
       <entry>Significado</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>alimentación de línea (LF o 0x0A (10) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>retorno de carro (CR o 0x0D (13) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>tabulación horizontal (HT o 0x09 (9) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>tabulación vertical (VT o 0x0B (11) en ASCII) (desde PHP
       5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>alimentación de forma (FF o 0x0C (12) en ASCII) (a partir de
       PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>barra invertida</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>signo de dólar</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>comilla-doble</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        la secuencia de caracteres que coincide con la expresión regular es
        un caracter en notación octal
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        la secuencia de caracteres que coincide con la expresión regular es
        un caracter en notación hexadecimal
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Como ocurre con las cadenas entre comillas sencillas, escapar cualquier
    otro caracter resultará en que la barra invertida sea impresa también.
    Antes de PHP 5.1.1, la barra invertida en <literal>\{$var}</literal> no
    venía imprimiéndose.
   </para>

   <para>
    La característica más importante de las cadenas entre comillas dobles es
    el hecho de que los nombres de variables serán expandidos.  Vea <link
    linkend="language.types.string.parsing">procesamiento de cadenas</link>
    para más detalles.
   </para>
  </sect3>

  <sect3 xml:id="language.types.string.syntax.heredoc">
   <title>Heredoc</title>

   <simpara>
    Una tercera forma de delimitar valores <type>string</type> es mediante
    el uso de la sintaxis heredoc: <literal>&lt;&lt;&lt;</literal>. Después
    de este operador debe indicarse un identificador, luego un salto de
    línea. La cadena sigue a continuación y luego el mismo identificador de
    nuevo para cerrar el bloque.
   </simpara>

   <simpara>
    El identificador de cierre <emphasis>debe</emphasis> comenzar en la
    primera columna de la línea. Asimismo, el identificador usado debe
    seguir las mismas reglas que cualquier otra etiqueta en PHP: debe
    contener solo caracteres alfanuméricos y de subrayado, y debe iniciar
    con un caracter no-dígito o de subrayado.
   </simpara>

   <warning>
    <simpara>
     Es muy importante notar que la línea con el identificador de cierre no
     contenga otros caracteres, excepto <emphasis>quizás</emphasis> por un
     punto-y-coma (<literal>;</literal>). Esto quiere decir en especial que
     el identificador <emphasis>no debe usar sangría</emphasis>, y no debe
     haber espacios o tabuladores antes o después del punto-y-coma.  Es
     importante notar también que el primer caracter antes del identificador
     de cierre debe ser un salto de línea, tal y como lo defina su sistema
     operativo. Esto quiere decir <literal>\n</literal> en sistemas UNIX,
     incluyendo Mac OS X.  El delimitador de cierre (posiblemente seguido de
     un punto-y-coma) debe ser seguido también por una nueva línea.
    </simpara>

    <simpara>
     Si esta regla es rota y el identificador de cierre no es "limpio",
     entonces no se considera un identificador de cierre y PHP continuará en
     busca de uno. Si no se encuentra un identificador de cierre antes del
     final del archivo actual, un error del analizador sintáctico se
     producirá en la última línea.
    </simpara>

    <para>
     No es posible usar la sintaxis heredoc para inicializar miembros de
     clase. Use <link
     linkend="language.types.string.syntax.nowdoc">nowdocs</link> en su
     lugar.
    </para>

    <example>
     <title>Ejemplo inválido</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </warning>

   <para>
    El texto heredoc se comporta tal como una cadena entre comillas dobles,
    sin las comillas dobles. Esto quiere decir que no necesita escapar tales
    comillas en sus bloques heredoc, pero aun puede usar los códigos de
    escape listados anteriormente. Las variables son expandidas, aunque debe
    tenerse el mismo cuidado cuando se expresen variables complejas al
    interior de un segmento heredoc, al igual que con otras cadenas.
   </para>

   <example>
    <title>Ejemplo de uso de una cadena heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
$cadena = <<<FIN
Ejemplo de una cadena
que se extiende por varias líneas
usando la sintaxis heredoc.
FIN;

/* Un ejemplo más complejo, con variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$nombre = 'MiNombre';

echo <<<FIN
Mi nombre es "$nombre". Estoy imprimiendo algo de $foo->foo.
Ahora, estoy imprimiendo algo de {$foo->bar[1]}.
Esto debería imprimir una letra 'A' mayúscula: \x41
FIN;
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
<![CDATA[
Mi nombre es "MiNombre". Estoy imprimiendo algo de Foo.
Ahora, estoy imprimiendo algo de Bar2.
Esto debería imprimir una letra 'A' mayúscula: A]]></screen>

   <note>
    <para>
     El soporte heredoc fue agregado en PHP 4.
    </para>
   </note>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.nowdoc">
   <title>Nowdoc</title>

   <para>
    Nowdocs es para las cadenas en comillas sencillas lo que heredocs es
    para las cadenas en comillas dobles. Un nowdoc es especificado de forma
    similar a heredoc, pero <emphasis>no se realiza ningún
    procesamiento</emphasis> al interior de un nowdoc. Esta construcción es
    ideal para embeber código PHP u otros bloques grandes de texto sin la
    necesidad de escaparlo. Comparte algunas características en común con la
    construcción de SGML <literal>&lt;![CDATA[ ]]&gt;</literal>, en el
    sentido de que declara un bloque de texto que no debe ser procesado.
   </para>

   <para>
    Un nowdoc es identificado con la misma secuencia
    <literal>&lt;&lt;&lt;</literal> usada para heredocs, pero el
    identificador que sigue a continuación debe ser rodeado de comillas
    sencillas, p.ej.
    <literal>&lt;&lt;&lt;'FIN'</literal>. Todas las reglas para los
    identificadores heredoc también se aplican a los identificadores nowdoc,
    especialmente aquellas relacionadas con la apariencia del identificador
    de cierre.
   </para>

   <example>
    <title>Ejemplo de uso de una cadena nowdoc</title>
    <programlisting role="php">
<![CDATA[
<?php
$cadena = <<<'FIN'
Ejemplo de una cadena
que se extiende por varias líneas
usando la sintaxis nowdoc.
FIN;

/* Un ejemplo más complejo, con variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$nombre = 'MiNombre';

echo <<<'FIN'
Mi nombre es "$nombre". Estoy imprimiendo algo de $foo->foo.
Ahora, estoy imprimiendo algo de {$foo->bar[1]}.
Esto no debería imprimir una letra 'A' mayúscula: \x41
FIN;
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
<![CDATA[
Mi nombre es "$nombre". Estoy imprimiendo algo de $foo->foo.
Ahora, estoy imprimiendo algo de {$foo->bar[1]}.
Esto no debería imprimir una letra 'A' mayúscula: \x41]]></screen>

   <note>
    <para>
     A diferencia de los bloques heredoc, nowdocs pueden ser usados en
     cualquier contexto de datos estáticos. El ejemplo típico es la
     inicialización de miembros o constantes de clase:
    </para>

    <example>
     <title>Ejemplo de datos estáticos</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </note>

   <note>
    <para>
     El soporte para nowdoc fue agregado en PHP 5.3.0.
    </para>
   </note>

  </sect3>

  <sect3 xml:id="language.types.string.parsing">
   <title>Procesamiento de variables</title>

   <simpara>
    Cuando un valor <type>string</type> es especificado en comillas dobles o
    al interior de un bloque heredoc, las <link
    linkend="language.variables">variables</link> son interpretadas en su
    interior.
   </simpara>

   <simpara>
    Existen dos tipos de sintaxis: una <link
    linkend="language.types.string.parsing.simple">simple</link> y una <link
    linkend="language.types.string.parsing.complex">compleja</link>. La
    sintaxis simple es la más común y conveniente. Ésta ofrece una forma de
    interpretar una variable, un valor <type>array</type>, o una propiedad
    de un objeto al interior de una cadena con un mínimo de esfuerzo.
   </simpara>

   <simpara>
    La sintaxis compleja fue introducida en PHP 4, y puede reconocerse por
    las llaves que rodean la expresión.
   </simpara>

   <sect4 xml:id="language.types.string.parsing.simple">
    <title>Sintaxis simple</title>

    <simpara>
     Si un signo de dólar (<literal>$</literal>) es encontrado, el
     analizador sintáctico tomará ambiciosamente tantos lexemas como le sea
     posible para formar un nombre de variable válido. Rodee el nombre de la
     variable de llaves si desea especificar explícitamente el final del
     nombre.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$cerveza = 'Heineken';
echo "El sabor de varias $cerveza's es excelente"; // funciona, "'" no es un caracter válido para nombres de variables
echo "Tomó algunas $cervezas";   // no funciona, 's' es un caracter válido para nombres de variables
echo "Tomó algunas ${cerveza}s"; // funciona
echo "Tomó algunas {$cerveza}s"; // funciona
?>
]]>
     </programlisting>
    </informalexample>

    <simpara>
     De forma similar, el índice de un <type>array</type> o una propiedad de
     un <type>object</type> pueden ser interpretados. En el caso de los
     índices de matrices, el corchete cuadrado de cierre
     (<literal>]</literal>) marca el final del índice. Las mismas reglas
     usadas con variables simples se aplican a las propiedades de objetos.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Estos ejemplos son específicos al uso de matrices al interior de
// cadenas. Cuando se encuentre por fuera de una cadena, siempre rodee
// de comillas las claves tipo cadena de su matriz, y no use {llaves}.

// Mostrar todos los errores
error_reporting(E_ALL);

$frutas = array('fresa' => 'roja', 'banano' => 'amarillo');

// Funciona pero note que esto trabaja de forma diferente por fuera de
// cadenas entre comillas
echo "Un banano es $frutas[banano].";

// Funciona
echo "Un banano es {$frutas['banano']}.";

// Funciona, pero PHP busca una constante llamada banano primero, como
// se describe más adelante.
echo "Un banano es {$frutas[banano]}.";

// No funciona, use llaves. Esto resulta en un error de análisis sintáctico.
echo "Un banano es $frutas['banano'].";

// Funciona
echo "Un banano es " . $frutas['banano'] . ".";

// Funciona
echo "Este cuadro tiene $cuadro->ancho metros de ancho.";

// No funciona. Para una solución, vea la sintaxis compleja.
echo "Este cuadro tiene $cuadro->ancho00 centímetros de ancho.";
?>
]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
     </programlisting>
    </informalexample>

    <simpara>
     Para cualquier cosa más sofisticada, debería usarse la sintaxis
     compleja.
    </simpara>
   </sect4>

   <sect4 xml:id="language.types.string.parsing.complex">
    <title>Sintaxis compleja (llaves)</title>

    <simpara>
     Esta no es llamada compleja porque la sintaxis sea compleja, sino
     porque es posible incluir expresiones complejas de esta forma.
    </simpara>

    <simpara>
     De hecho, cualquier valor que sea parte del espacio de nombres puede
     ser incluido en una cadena con esta sintaxis.  Simplemente escriba la
     expresión en la misma forma que lo haría si se encontrara por fuera de
     una cadena, y luego la ubica entre <literal>{</literal> y
     <literal>}</literal>. Ya que no es posible escapar
     <literal>{</literal>, esta sintaxis será reconocida únicamente cuando
     el caracter <literal>$</literal> se encuentra inmediatamente después de
     <literal>{</literal>. Use <literal>{\$</literal> para obtener una
     secuencia literal <literal>{$</literal>. Algunos ejemplos para aclarar
     el asunto:
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Mostrar todos los errores
error_reporting(E_ALL);

$genial = 'fantástico';

// No funciona, imprime: Esto es { fantástico}
echo "Esto es { $genial}";

// Funciona, imprime: Esto es fantástico
echo "Esto es {$genial}";
echo "Esto es ${genial}";

// Funciona
echo "Este cuadro tiene {$cuadro->ancho}00 centímetros de ancho.";

// Funciona
echo "Esto funciona: {$matriz[4][3]}";

// Esto está mal por la misma razón por la que $foo[bar] está mal por
// fuera de una cadena. En otras palabras, aun funciona pero sólo porque
// PHP busca primero una constante llamada foo; genera un error de
// nivel E_NOTICE (constante indefinida).
echo "Esto está mal: {$matriz[foo][3]}";

// Funciona. Cuando se usan matrices multi-dimensionales, use siempre
// llaves alrededor de las matrices al interior de cadenas
echo "Esto funciona: {$matriz['foo'][3]}";

// Funciona.
echo "Esto funciona: " . $arr['foo'][3];

echo "Esto funciona también: {$obj->valores[3]->nombre}";

echo "Este es el valor de la variable llamada $nombre: {${$nombre}}";

echo "Este es el valor de la variable llamada por el valor devuelto por getName(): {${getName()}}";

echo "Este es el valor de la variable llamada por el valor devuelto por \$objeto->getName(): {${$objeto->getName()}}";
?>
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
     </programlisting>
    </informalexample>

    <note>
     <para>
      Las llamadas a funciones y métodos al interior de
      <literal>{$}</literal> trabajan a partir de PHP 5.
     </para>
    </note>

   </sect4>
  </sect3>

  <sect3 xml:id="language.types.string.substr">
   <title>Acceso a cadenas y modificación por caracter</title>

   <para>
    Los caracteres al interior de una cadena pueden ser consultados y
    modificados al especificar el desplazamiento, comenzando en cero, del
    caracter deseado después de la cadena usando corchetes cuadrados
    tipo-matriz como <varname>$cadena[42]</varname>. Para este propósito,
    piense en un valor <type>string</type> como un <type>array</type> de
    caracteres.
   </para>

   <note>
    <simpara>
     Las cadenas son accesibles también usando llaves, como en
     <varname>$cadena{42}</varname>, para el mismo propósito. Sin embargo,
     esta sintaxis ha sido marcada como obsoleta en PHP 6. Use los corchetes
     cuadrados en su lugar.
    </simpara>
   </note>

   <example>
    <title>Algunos ejemplos de cadenas</title>
    <programlisting role="php">
<![CDATA[
<?php
// Obtener el primer caracter de una cadena
$cadena = 'Esta es una prueba.';
$primer = $cadena[0];

// Obtener el tercer caracter de una cadena
$tercer = $cadena[2];

// Obtener el último caracter de una cadena.
$cadena = 'Esta es también una prueba.';
$ultimo = $cadena[strlen($cadena)-1];

// Modificar el último caracter de una cadena
$cadena = 'Observe el mar';
$cadena[strlen($cadena)-1] = 'l';

?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     Al accesar variables de otros tipos mediante <literal>[]</literal> o
     <literal>{}</literal> se devuelve silenciosamente &null;.
    </para>
   </note>

  </sect3>
 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.string.useful-funcs">
  <title>Funciones y operadores útiles</title>

  <para>
   Las cadenas pueden ser concatenadas usando el operador '.' (punto).  Note
   que el operador '+' (adición) <emphasis>no</emphasis> funciona para este
   propósito. Por favor refiérase a la sección <link
   linkend="language.operators.string">Operadores de cadena</link> para más
   información.
  </para>

  <para>
   Existen bastantes funciones útiles para la modificación de valores
   <type>string</type>.
  </para>

  <simpara>
   Vea la <link linkend="ref.strings">sección de funciones de cadena</link>
   para consultar funciones de uso general, y las <link
   linkend="ref.regex">funciones de expresiones regulares</link> o las <link
   linkend="ref.pcre">funciones de expresiones regulares compatibles con
   Perl</link> para funcionalidad avanzada de búsquedas y reemplazos.
  </simpara>

  <simpara>
   Existen también <link linkend="ref.url">funciones para cadenas tipo
   URL</link>, y funciones para encriptar/descifrar cadenas (<link
   linkend="ref.mcrypt">mcrypt</link> y <link
   linkend="ref.mhash">mhash</link>).
  </simpara>

  <simpara>
   Finalmente, vea también las <link linkend="ref.ctype">funciones de tipo
   de caracter</link>.
  </simpara>
 </sect2>

 <sect2 xml:id="language.types.string.casting">
  <title>Conversión a cadena</title>

  <para>
   Un valor puede ser convertido a <type>string</type> usando el
   moldeamiento <literal>(string)</literal> o la función
   <function>strval</function>.  La conversión a cadena se realiza
   automáticamente en el ámbito de una expresión cuando se necesita una
   cadena. Esto ocurre cuando usa las funciones <function>echo</function> o
   <function>print</function>, o cuando una variable es comparada con una
   cadena. El contenido de las secciones del manual sobre <link
   linkend="language.types">Tipos</link> y <link
   linkend="language.types.type-juggling">Manipulación de Tipos</link>
   ayudan a aclarar el contenido presentado a continuación. Vea también la
   función <function>settype</function>.
  </para>

  <para>
   Un valor <type>boolean</type> &true; es convertido a la cadena
   <literal>"1"</literal>, el valor &false; se representa como
   <literal>""</literal> (la cadena vacía). De esta forma, usted puede
   convertir de ida y vuelta entre valores booleanos y de cadena.
  </para>

  <para>
   Un número <type>integer</type> o de punto flotante (<type>float</type>)
   es convertido a una cadena que representa el número textualmente
   (incluyendo la parte del exponente para los números de punto flotante).
   Los números de punto flotante pueden ser convertidos usando la notación
   exponencial (<literal>4.1E+6</literal>).
  </para>

  <note>
   <para>
    El caracter de punto decimal es definido en la localización del script
    (categoría LC_NUMERIC). Vea la función <function>setlocale</function>.
   </para>
  </note>

  <para>
   Las matrices son siempre convertidas a la cadena
   <literal>"Array"</literal>; por esta razón, <function>echo</function> y
   <function>print</function> no pueden por su cuenta mostrar los contenidos
   de un valor <type>array</type>.  Para ver un elemento sencillo, use una
   construcción como <literal>echo $arr['foo']</literal>. Vea más adelante
   algunos consejos sobre el volcado/vista del contenido completo.
  </para>

  <para>
   Los objetos en PHP 4 son convertidos siempre a la cadena
   <literal>"Object"</literal>. Para imprimir los valores de miembros de un
   objeto para efectos de depuración, lea los parágrafos siguientes. Para
   obtener el nombre de la clase de un objeto, use la función
   <function>get_class</function>. A partir de PHP 5, el método <link
   linkend="language.oop5.magic">__toString</link> es usado si resulta
   aplicable.
  </para>

  <para>
   Los recursos son siempre convertidos a cadenas con la estructura
   <literal>"Resource id #1"</literal> en donde <literal>1</literal> es el
   número único del valor <type>resource</type> asignado por PHP en tiempo
   de ejecución. No escriba código que dependa de esta estructura; está
   sujeta a cambios. Para obtener el tipo del recurso, use la función
   <function>get_resource_type</function>.
  </para>

  <para>
   &null; se convierte siempre a una cadena vacía.
  </para>

  <para>
   Como se ha indicado anteriormente , convertir directamente un valor tipo
   <type>array</type>, <type>object</type>, o <type>resource</type> a un
   <type>string</type> no ofrece información útil sobre los valores más allá
   de su tipo. Consulte las funciones <function>print_r</function> y
   <function>var_dump</function> para conocer mejores formas de inspeccionar
   los contenidos de estos tipos.
  </para>

  <para>
   La mayoría de valores PHP pueden ser convertidos también a
   <type>string</type> para su almacenamiento permanentemente. Este método
   es conocido como seriación, y es efectuado por la función
   <function>serialize</function>. Si el motor PHP fue compilado con soporte
   <link linkend="ref.wddx">WDDX</link>, los valores PHP pueden ser seriados
   también como texto XML correctamente formado.
  </para>

 </sect2>

 <sect2 xml:id="language.types.string.conversion">
  <title>Conversión de cadenas a números</title>

  <simpara>
   Cuando una cadena es evaluada en un ámbito numérico, el valor resultante
   y su tipo son determinados como sigue.
  </simpara>

  <simpara>
   El valor <type>string</type> será evaluado como un <type>float</type> si
   contiene cualquier caracter entre '.', 'e', o 'E'. De otra forma, será
   evaluado como un <type>integer</type>.
  </simpara>

  <para>
   El valor es dado por la porción inicial de la cadena. Si la cadena
   comienza con datos numéricos válidos, éstos serán el valor usado. De lo
   contrario, el valor será 0 (cero). Un dato numérico válido consiste de un
   signo opcional, seguido por uno o más dígitos (que pueden contener un
   punto decimal), seguidos por un exponente opcional. El exponente es una
   'e' o 'E' seguida de uno o más dígitos.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo es flotante (11.5)
$foo = 1 + "-1.3e3";              // $foo es flotante (-1299)
$foo = 1 + "bob-1.3e3";           // $foo es entero (1)
$foo = 1 + "bob3";                // $foo es entero (1)
$foo = 1 + "10 Cerditos";         // $foo es entero (11)
$foo = 4 + "10.2 Cerditos";       // $foo es flotante (14.2)
$foo = "10.0 cerdos " + 1;        // $foo es flotante (11)
$foo = "10.0 cerdos " + 1.0;      // $foo es flotante (11)
?>
]]>
   </programlisting>
  </informalexample>

  <simpara>
   Para más información sobre esta conversión, vea la página del manual Unix
   sobre strtod(3).
  </simpara>

  <para>
   Si quisiera probar cualquiera de los ejemplos presentados en esta
   sección, puede cortar y pegar los ejemplos e insertar la siguiente línea
   para verificar por sí mismo lo que está sucediendo:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; tipo es " . gettype ($foo) . "<br />\n";
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   No espere obtener el código de un caractar convirtiéndolo a un entero,
   como se hace en C. Use las funciones <function>ord</function> y
   <function>chr</function> para convertir entre códigos ASCII y caracteres.
  </para>

 </sect2>
</sect1><!-- end string -->

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
