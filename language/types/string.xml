<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 302165 Maintainer: gerardocdc Status: ready -->
<sect1 xml:id="language.types.string">
 <title>Cadenas</title>
 
 <!-- FIXME PHP_6 Likely unicode support will alter this -->
 <para>
  Un <type>string</type> es una serie de caracteres, y por lo tanto, un caracter es 
  lo mismo que un byte. Es decir, hay exactamente 256 diferentes caracteres 
  posibles. Esto implica tambien que PHP no tiene soporte nativo para Unicode. Consulte
  <function>utf8_encode</function> y <function>utf8_decode</function> para informarse de
  la funcionalidad básica de Unicode.
 </para>
 
 <note>
  <simpara>
   No existe problema alguno para que un <type>string</type> sea muy grande. PHP no impone
   ningún límite para el tamaño de un <type>string</type>; el único límite es la memoria
   disponible en el ordenador donde se está ejecutando PHP.
  </simpara>
 </note>
 
 <sect2 xml:id="language.types.string.syntax">
  <title>Sintaxis</title>
  
  <para>
   Un <type>string</type> literal puede ser especificado de cuatro formas diferentes:
  </para>
  
  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">comillas simples</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">comillas dobles</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">sintaxis heredoc</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.nowdoc">sintaxis nowdoc</link>
     (desde PHP 5.3.0)
    </simpara>
   </listitem>
  </itemizedlist>
  
  <sect3 xml:id="language.types.string.syntax.single">
   <title>Comillas simples</title>
   
   <para>
    La manera más sencilla de especificar un <type>string</type> es encerrarlo entre comillas
    simples (el caracter <literal>'</literal>).
   </para>
   
   <para>
    Para especificar una comilla simple literal, escápela mediante una barra invertida
    (<literal>\</literal>). Para especificar una barra invertida literal antes de una comilla
    simple, o al final de un <type>string</type>, se debe indicar de forma doble
    (<literal>\\</literal>). Tenga en cuenta que intentar escapar cualquier otro caracter
    tambien mostrará la barra invertida.
   </para>
   
   <note>
    <simpara>
     A diferencia de las sintaxis <link linkend="language.types.string.syntax.double">double-quoted</link>
     y <link linkend="language.types.string.syntax.heredoc">heredoc</link>, las
     <link linkend="language.variables">variables</link> y las sentencias de escape
     para caracteres especiales <emphasis>no</emphasis> se expandirán cuando están
     incluidas dentro de <type>string</type>s con comillas simples.
    </simpara>
   </note>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo 'Esto es una cadena sencilla';

echo 'Tambien puede incluir nuevas líneas en 
cadenas de esta forma ya que es
correcto hacerlo así';

// Resultado: Arnold una vez dijo: "I'll be back"
echo 'Arnold una vez dijo: "I\'ll be back"';

// Resultado: Ha borrado C:\*.*?
echo 'Ha borrado C:\\*.*?';

// Resultado: Ha borrado C:\*.*?
echo 'Ha borrado C:\*.*?';

// Resultado: Esto no se expandirá: \n una nueva línea
echo 'Esto no se expandirá: \n una nueva línea';

// Resultado: Las variables $tampoco se $expandiran
echo 'Las variables $tampoco se $expandiran';
?>
]]>
    </programlisting>
   </informalexample>
   
  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.double">
   <title>Comillas dobles</title>
   
   <para>
    Si un <type>string</type> está encerrado entre comillas dobles ("), PHP 
    interpretará más sentencias de escape como caracteres especiales:
   </para>
   
   <table>
    <title>Caracteres escapados</title>
    
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Sentencia</entry>
       <entry>Significado</entry>
      </row>
     </thead>
     
     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>avance de línea (LF o 0x0A (10) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>retorno de carro (CR o 0x0D (13) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>tabulador horizontal (HT o 0x09 (9) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>tabulador vertical (VT o 0x0B (11) en ASCII) (desde PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>avance de página (FF o 0x0C (12) en ASCII) (desde PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>barra invertida</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>signo del dólar</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>comillas dobles</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        la secuencia de caracteres que coincida con la expresión regular 
        es un caracter en notación octal
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        la secuencia de caracteres que coincida con la expresión regular 
        es un caracter en notación hexadecimal
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
   <para>
    Al igual que en la delimitación de <type>string</type>s mediante
    comillas simples, escapar cualquier otro caracter puede dar lugar
    a que se muestre tambien la barra invertida. Antes de PHP 5.1.1, 
    la barra invertida en <literal>\{$var}</literal> no se mostraba.
   </para>
   
   <para>
    La característica más importante de entrecomillar <type>string</type>s
    mediante comillas dobles es el hecho que los nombres de las variables
    son expandidos. Consulte <link linkend="language.types.string.parsing">string parsing</link>
    para más detalles.
   </para>
  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.heredoc">
   <title>Heredoc</title>
   
   <simpara>
    Una tercera forma de delimitar <type>string</type>s es mediante la sintaxis heredoc:
    <literal>&lt;&lt;&lt;</literal>. Después de este operador, se deberá ofrecer un
    identificador y después una nueva línea. A continuación va el propio <type>string</type>,
    y para cerrar la notación se pone el mismo identificador.
   </simpara>
   
   <simpara>
    El identificador de cierre <emphasis>debe</emphasis> empezar en la primera columna
    de la nueva línea. Asimismo, el identificador debe seguir las mismas reglas de
    nomenclatura de las etiquetas en PHP: debe contener solo caracteres alfanuméricos y 
    guiones bajos, y debe empezar con un caracter alfabético o un guión bajo.
   </simpara>
   
   <warning>
    <simpara>
     Es muy importante señalar que la línea con el identificador de cierre no debe contener 
     ningún caracter, excepto <emphasis>posiblemente</emphasis> un
     punto y coma (<literal>;</literal>). Esto significa en particular que el identificador
     <emphasis>no debe usar sangría</emphasis>, y que no deben existir ningún espacio
     ni tabulación antes o después del punto y coma. Es muy importante darse cuenta que
     el primer caracter antes del identificador de cierre debe ser un salto de línea 
     definida por el sistema operativo local. En los sistemas UNIX sería <literal>\n</literal>,
     al igual que en Max OS X. El delimitador de cierre (posiblemente seguido de un
     punto y coma) también debe ser seguido de un salto de línea.
    </simpara>
    
    <simpara>
     Se se rompe esta regla y el identificador de cierre no está "limpio", no será
     considerado como un identificador de cierre, y PHP continuará buscando uno. Si no se
     encuentra ningún identificador de cierre antes del final del fichero, se 
     producirá un error de análisis en la última línea.
    </simpara>
    
    <para>
     Heredocs tampoco pueden ser empleados para inicializar las propiedades de una clase.
     Desde PHP 5.3, esta limitación solo concierne a los heredocs conteniendo variables.
    </para>
    
    <example>
     <title>Ejemplo no válido</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </warning>
   
   <para>
    El texto heredoc se comporta como un <type>string</type> entre comillas dobles,
    pero sin tener comillas dobles. Esto significa que las comillas en Heredoc no 
    necesitan ser escapadas, pero los caracteres escapados indicados arriba se pueden
    seguir empleando. Las variables son expandidas, y se debe tener el mismo cuidado dentro
    de un Heredoc cuando se quieren expresar variables complejas, al igual que en 
    los <type>string</type>s.
   </para>
   
   <example> 
    <title>Ejemplo de Heredoc string quoting example</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Ejemplo de una cadena
expandida en varias líneas
empleando la sintaxis heredoc.
EOD;

/* Un ejemplo más complejo con variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MiNombre';

echo <<<EOT
Mi nombre es "$name". Estoy escribiendo un poco de $foo->foo.
Ahora, estoy escribiendo un poco de {$foo->bar[1]}.
Esto debe mostrar una 'A' mayúscula: \x41
EOT;
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
<![CDATA[
Mi nombre es "MiNombre". Estoy escribiendo un poco de Foo.
Ahora, estoy escribiendo un poco de Bar2.
Esto debe mostrar una 'A' mayúscula: A]]>
   </screen>
   
   <para>
    Tambien se puede emplear la sintaxis Heredoc para pasar datos como 
    argumento de una función:
   </para>
   
   <example> 
    <title>Ejemplo de Heredoc como argumentos</title>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(array(<<<EOD
foobar!
EOD
));
?>
]]>
    </programlisting>
   </example>
   
   <para>
    Desde PHP 5.3.0 es posible inicializar variables estáticas y propiedades/constantes
    de clase mediante la sintaxis Heredoc:
   </para>
   
   <example> 
    <title>Usando Heredoc para inicializar valores estáticos</title>
    <programlisting role="php">
<![CDATA[
<?php
// Variables estáticas
function foo()
{
    static $bar = <<<LABEL
Nada aqui dentro...
LABEL;
}

// Propiedades/Constantes de clase
class foo
{
    const BAR = <<<FOOBAR
Ejemplo de constante
FOOBAR;

    public $baz = <<<FOOBAR
Ejemplo de propiedad
FOOBAR;
}
?>
]]>
    </programlisting>
   </example>
   
   <para>
    PHP 5.3.0 tambien introdujo la posibilidad en Heredoc de emplear las comillas
    dobles en declaraciones:
   </para>
   
   <example> 
    <title>Empleando comillas dobles en Heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<"FOOBAR"
Hola Mundo!
FOOBAR;
?>
]]>
    </programlisting>
   </example>
   
   <note>
    <para>
     El soporte para Heredoc se añadió en PHP 4.
    </para>
   </note>
   
  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.nowdoc">
   <title>Nowdoc</title>
   
   <para>
    Nowdocs son a las cadenas con comillas simples lo mismo que Heredoc lo es a las 
    comillas dobles. Una cadena nowdoc se especifica de forma análoga a la heredoc, pero
    <emphasis>no se realiza ningún análisis</emphasis> dentro de nowdoc. Esta construcción 
    es ideal para embeber codigo PHP o grandes fragmentos de texto sin necesidad de
    escaparlo. Comparte algunas características comunes con la construcción SGML
    <literal>&lt;![CDATA[ ]]&gt;</literal>, donde se declara un fragmento de texto 
    que no debe ser analizado.
   </para>
   
   <para>
    Una cadena nowdoc se identifica con la misma sintaxis <literal>&lt;&lt;&lt;</literal> 
    usada para heredocs, pero el identificar que le sigue esta encerrado entre
    comillas simples, por ejemplo <literal>&lt;&lt;&lt;'EOT'</literal>. Todas las reglas
    para los identificadores heredoc también son apicables a los identificadores 
    nowdoc, especialmente aquellas que se refieren al empleo del identificador de cierre.
   </para>
   
   <example>
    <title>Ejemplo de entrecomillado de cadenas Nowdoc</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<'EOD'
Ejemplo de una cadena
expandida en varias líneas
empleando la sintaxis nowdoc.
EOD;

/* Un ejemplo más complejo con variables. */
class foo
{
    public $foo;
    public $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MiNombre';

echo <<<'EOT'
Mi nombre es "$name". Estoy escribiendo un poco de $foo->foo.
Ahora, estoy escribiendo un poco de {$foo->bar[1]}.
Esto debe mostrar una 'A' mayúscula: \x41
EOT;
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
<![CDATA[
Mi nombre es "$name". Estoy escribiendo un poco de $foo->foo.
Ahora, estoy escribiendo un poco de {$foo->bar[1]}.
Esto debe mostrar una 'A' mayúscula: \x41]]></screen>
   
   <note>
    <para>
     A diferencia de heredocs, nowdocs pueden ser usados en cuaquier contexto de
     datos estáticos. Un ejemplo típica es la inicialización de 
     propiedades o constantes en una clase:
    </para>
    
    <example>
     <title>Ejemplo de datos estáticos</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </note>
   
   <note>
    <para>
     El soporte de Nowdoc se añadió en PHP 5.3.0.
    </para>
   </note>
   
  </sect3>
  
  <sect3 xml:id="language.types.string.parsing">
   <title>Análisis de variables</title>
   
   <simpara>
    Cuando un <type>string</type> es especificado mediante comillas dobles o mediante
    sintaxis heredoc, las <link linkend="language.variables">variables</link> dentro 
    de dicha cadena son analizadas.
   </simpara>
   
   <simpara>
    Existen dos tipos de sintaxis: una <link linkend="language.types.string.parsing.simple">simple</link>
    y otra <link linkend="language.types.string.parsing.complex">compleja</link>. La 
    sintaxis simple es la más empleada y conveniente. Proporciona una forma de incluir
    una variable, un valor de un <type>array</type> o una propiedad de un <type>object</type>
    dentro de un <type>string</type> con el mínimo esfuerzo.
   </simpara>
   
   <simpara>
    La sintaxis compleja fue introducida en PHP 4, y puede ser reconocida por las
    llaves que encierran la expresión.
   </simpara>
   
   <sect4 xml:id="language.types.string.parsing.simple">
    <title>Sintaxis simple</title>
    
    <simpara>
     Si se encuentra un signo de dólar (<literal>$</literal>), el analizador ávidamente 
     cogerá el mayor número de símbolos para formar un nombre de variable válido.
     Encerrar el nombre de la variable entre llaves permite especificar explícitamente 
     el final del nombre.
    </simpara>
    
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$cerveza = 'Heineken';
echo "El sabor de '$cerveza' es genial"; // funciona; "'" es un caracter inválido para el nombre de una variable
echo "Bebió algunas $cervezas";   // no funciona; 's' es un caracter válido para un nombre de variable pero la variable es "$cerveza"
echo "Bebió algunas ${cerveza}s"; // funciona
echo "Bebió algunas {$cerveza}s"; // funciona
?>
]]>
     </programlisting>
    </informalexample>
    
    <simpara>
     De forma parecida, el índice de un <type>array</type> o la propiedad de un
     <type>object</type> puede ser analizado. Con los índices de los arrays, el 
     corchete de cierre (<literal>]</literal>) marca el final del índice. La misma
     regla se puede aplicar a las propiedades de los objetos y a las variables simples.
    </simpara>
    
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Estos ejemplos son específicos sobre el uso de arrays dentro de cadenas.
// Siempre entrecomille las cadenas de las claves de los arrays cuando se 
// encuentre fuera de una cadena, y no emplee {llaves}.

// Muestra todos los errores
error_reporting(E_ALL);

$frutas = array('fresa' => 'rojo', 'platano' => 'amarillo');

// Funciona, pero nótese que funcionará diferente fuera de una cadena
echo "Un plátano es $fruits[platano].";

// Funciona
echo "Un plátano es {$frutas['platano']}.";

// Funciona, pero PHP busca primero una constante llamada platano, como se describe posteriormente.
echo "Un plátano es {$frutas[platano]}.";

// No funciona, use llaves. Da como resultado un error de análisis.
echo "Un plátano es $frutas['platano'].";

// Funciona
echo "Un plátano es " . $frutas['platano'] . ".";

// Funciona
echo "Este cuadrado tiene $square->width metros de lado.";

// No funciona. Como solución emplee la sintaxis compleja.
echo "Este cuadrado tiene $square->width00 centímetros de lado.";
?>
]]>
      <!-- XXX this won't work:
      echo "This square is $square->{width}00 centimeters broad."; 
      // XXX: php developers: it would be consequent to make this work.
      // XXX: like the $obj->{expr} syntax outside a string works, 
      // XXX: analogously to the ${expr} syntax for variable var's.
      -->
     </programlisting>
    </informalexample>
    
    <simpara>
     Para casos más complejos se debe emplear la sintaxis compleja.
    </simpara>
   </sect4>
   
   <sect4 xml:id="language.types.string.parsing.complex">
    <title>Sintaxis compleja (llaves)</title>
    
    <simpara>
     Esta sintaxis no se llama compleja poque sea compleja de aplicar, sino porque
     permite el empleo de expresiones complejas.
    </simpara>
    
    <simpara>
     De hecho, cualquier valor en el espacio de nombre puede ser incluido
     en un <type>string</type> mediante esta sintaxis. Simplemente, escriba la expresión
     de la misma forma que lo haría fuera de un <type>string</type>, y despues encierrela
     entre <literal>{</literal> y <literal>}</literal>. Como <literal>{</literal>
     no puede ser escapado, esta sintaxis solo puede ser reconocida cuando 
     despues de <literal>{</literal> sigue <literal>$</literal>. Emplee 
     <literal>{\$</literal> para obtener un <literal>{$</literal> literal. Unos ejemplos
     para clarificar:
    </simpara>
    
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Muestra todos los errores
error_reporting(E_ALL);

$great = 'fantastico';

// No funciona, resultado: Esto es { fantastico}
echo "Esto es { $great}";

// Funciona, resultado: Esto es fantastico
echo "Esto es {$great}";
echo "Esto es ${great}";

// Funciona
echo "Este cuadrado tiene {$square->width}00 centímetros de lado."; 

// Funciona
echo "Funciona: {$arr[4][3]}";

// No funciona por la misma razón que $foo[bar] es incorrecto fuera de una cadena.
// En otras palabras, funcionaría pero solo porque PHP primero busca por una constante
// llamada foo; un error del nivel E_NOTICE (constante no definida) puede ser lanzado.
echo "No funciona: {$arr[foo][3]}"; 

// Funciona. Cuando se usan arrays multidimensionales, siempre emplee llaves encerrando 
// los arrays cuando se encuentre dentro de una cadena
echo "Funciona: {$arr['foo'][3]}";

// Funciona.
echo "Funciona: " . $arr['foo'][3];

echo "Tambien funciona: {$obj->values[3]->name}";

echo "Este es el valor de la variable llamada $name: {${$name}}";

echo "Este es el valor de la variable llamada por el valor de retorno de getName(): {${getName()}}";

echo "Este es el valor de la variable llamada por el valor de retorno de \$object->getName(): {${$object->getName()}}";
?>
]]>
      <!-- maybe it's better to leave this out?? 
      // this works, but i disencourage its use, since this is NOT 
      // involving functions, rather than mere variables, arrays and objects.
      $beer = 'Heineken';
      echo "I'd like to have another {${ strrev('reeb') }}, hips";
      -->
     </programlisting>
    </informalexample>
    
    <para>
     Tambien es posible acceder a las propiedades de una clase empleando 
     variables dentro de cadenas empleando esta sintaxis.
    </para>
    
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    var $bar = 'Soy bar.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo "{$foo->$bar}\n";
echo "{$foo->$baz[1]}\n";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
      Soy bar.
      Soy bar.
     </screen>
    </informalexample>
    
    <note>
     <para>
      Funciones, llamadas a métodos, variables estáticas de clases y constantes de 
      clases dentro de <literal>{$}</literal> funcionan desde PHP 5. Sin embargo,
      el valor accedido puede ser interpretado como el nombre de la variable en el 
      ámbito en el que la cadena está definida. Empleando llaves simples
      (<literal>{}</literal>) no servirá para acceder al valor de retorno de 
      las funciones o métodos, constantes o variables estáticas de clases.
     </para>
    </note>
    
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Muestra todos los errores.
error_reporting(E_ALL);

class beers {
    const softdrink = 'rootbeer';
    public static $ale = 'ipa';
}

$rootbeer = 'A & W';
$ipa = 'Alexander Keith\'s';

// Funciona; resultado: Me gusta una A & W
echo "Me gusta una {${beers::softdrink}}\n";

// Tambien funciona; resultado: Me gusta una Alexander Keith's
echo "Me gusta una {${beers::$ale}}\n";
?>
]]>
     </programlisting>
    </informalexample>
    
   </sect4>
  </sect3>
  
  <sect3 xml:id="language.types.string.substr">
   <title>Acceso a cadenas y modificacion por caracteres</title>
   
   <para>
    Los caracteres dentro de <type>string</type>s puede ser accedidos y modificados
    especificando la posición de caracter deseado (en base a la posición cero del primer 
    caracter del <type>string</type>) empleando los corchetes de <type>array</type>,
    como en <varname>$str[42]</varname>. Piense en este caso que un <type>string</type>
    se comporta como un <type>array</type> de caracteres. Las funciones
    <function>substr</function> y <function>substr_replace</function>
    pueden ser empleados para extraer y reemplazar más de un caracter.
   </para>
   
   <note>
    <simpara>
     Los <type>string</type>s tambien pueden ser accedidos mediante llaves, como 
     en <varname>$str{42}</varname>, con el mismo fin. Sin embargo, la sintaxis ha 
     sido deprecada desde PHP 5.3.0. Emplee corchetes en su lugar, como en 
     <varname>$str[42]</varname>.
    </simpara>
   </note>
   
   <warning>
    <simpara>
     Escribir fuera del rango es compensado rellenando la cadena con espacios.
     Los tipos distintos de enteros son convertidos a enteros. Las compensaciones fuera
     de rango emiten <constant>E_NOTICE</constant>. Las compensaciones negativas
     emiten <constant>E_NOTICE</constant> en la escritura pero en la lectura obtienen
     una cadena vacía. Solo se emplea el primer caracter de una cadena asignada. La
     asignación de una cadena vacía asigna un bye NUL.
    </simpara>
   </warning>
   
   <example>
    <title>Algunos ejemplos de cadenas</title>
    <programlisting role="php">
<![CDATA[
<?php
// Obtención del primer caracter de una cadena
$str = 'Esto es un test.';
$first = $str[0];

// Obtención del tercer caracter de una cadena
$third = $str[2];

// Obtención del último caracter de una cadena
$str = 'Esto sigue siendo un test.';
$last = $str[strlen($str)-1]; 

// Modificación del último caracter de una cadena
$str = 'Mira el mar';
$str[strlen($str)-1] = 'e';

?>
]]>
    </programlisting>
   </example>
   
   <note>
    <para>
     El acceso a variables de otros tipos usando <literal>[]</literal> o
     <literal>{}</literal> devuelve de forma silenciosa &null;.
    </para>
   </note>
   
  </sect3>
 </sect2><!-- end syntax -->
 
 <sect2 xml:id="language.types.string.useful-funcs">
  <title>Funciones y operadores útiles</title>
  
  <para>
   Los <type>string</type>s pueden ser concatenados empleando el operador '.' (punto).
   Fíjese que el operador '+' (suma) <emphasis>no</emphasis> servirá para concatenar.
   Consulte <link linkend="language.operators.string">String operators</link> para 
   más información.
  </para>
  
  <para>
   Hay una serie de funciones útiles para la manipulación de <type>string</type>.
  </para>
  
  <simpara>
   Consulte la <link linkend="ref.strings">sección de funciones de cadena</link>
   para funciones generales, y las <link linkend="ref.regex">funciones de expresiones
   regulares</link> o las <link linkend="ref.pcre">funciones de expresiones regulares
   compatibles con Perl</link> para funcionalidades avanzadas de búsqueda y sustitución.
  </simpara>
  
  <simpara>
   Tambien existen <link linkend="ref.url">funciones para cadenas URL</link>, y
   funciones para encriptar/desencriptar cadenas (<link linkend="ref.mcrypt">mcrypt</link>
   y <link linkend="ref.mhash">mhash</link>).
  </simpara>
  
  <simpara>
   Finalmente, tambien existen las <link linkend="ref.ctype">funciones para el tipo 
   caracter</link>.
  </simpara>
 </sect2>
 
 <sect2 xml:id="language.types.string.casting">
  <title>Conversión a cadena</title>
  
  <para>
   Un valor puede convertirse a una <type>string</type> mediante el forzado
   <literal>(string)</literal> o la función <function>strval</function>.
   La conversión automática a <type>string</type> tiene lugar en el contexto de
   una expresióin que necesita un <type>string</type>. Esto ocurre cuando se utilizan
   las funciones <function>echo</function> o <function>print</function>, o cuando 
   una variables es comparada con un <type>string</type>. Las secciones sobre 
   <link linkend="language.types">tipos</link> y
   <link linkend="language.types.type-juggling">Manipulación de tipos</link> pueden ayudarle 
   a enterderlo con más claridad. Consulte tambien la función <function>settype</function>.
  </para>
  
  <para>
   El valor &true; del tipo <type>boolean</type> es convertido en el 
   <type>string</type> <literal>"1"</literal>. El valor &false; del tipo
   <type>boolean</type> es convertido en el <type>string</type> <literal>""</literal>
   (la cadena vacía). Esto permite la conversión en ambos sentidos entre los valores de 
   los tipos <type>boolean</type> y <type>string</type>.
  </para>
  
  <para> 
   Un <type>integer</type> o <type>float</type> es convertido en un 
   <type>string</type> representando textualmente el número (incluyendo 
   la parte exponencial para los <type>float</type>s. Los números de 
   punto flotante pueden ser convertidos mediante la notación exponencial
   (<literal>4.1E+6</literal>).
  </para>
  
  <note>
   <para>
    El caracter para el punto decimal se define en el script de configuración
    regional (categoría LC_NUMERIC). Consulte la función <function>setlocale</function>.
   </para>
  </note>
  
  <para>
   Los <type>array</type>s siempre se convierten en un <type>string</type>
   <literal>"Array"</literal>. Debido a esto, tanto <function>echo</function> y
   <function>print</function> no pueden pos si mismo mostrar el contenido de un 
   <type>array</type>. Para ver un elemento individualmente, utilice una
   construcción como <literal>echo $arr['foo']</literal>. Mire los trucos en la parte
   inferior para mostrar el contenido por completo.
  </para>
  
  <para>
   Los <type>object</type>s en PHP 4 siempre se convierten en un <type>string</type>
   <literal>"Object"</literal>. Para mostrar los valores de las propiedades de un
   objeto para depuración, mire los parrafos siguientes. Para obtener el nombre de 
   la clase del objeto emplée la función <function>get_class</function>. A partir
   de PHP 5 se puede emplear el método <link linkend="language.oop5.magic">__toString</link>.
  </para>
  
  <para>
   Los <type>resource</type>s siempre se convierten en <type>string</type>s mediante
   la estructura <literal>"Resource id #1"</literal>, donde <literal>1</literal> es 
   el número único asignado al <type>resource</type> por PHP en tiempo de ejecución. 
   No debe confiar en esta estructura, ya que está sujeto a cambios. Para obtener
   el tipo del <type>resource</type> emplee la función <function>get_resource_type</function>.
  </para>
  
  <para>
   &null; siempre es convertido a una cadena vacía.
  </para>
  
  <para>
   Como se ha indicada anteriormente, la conversión directa de un <type>array</type>,
   <type>object</type> o <type>resource</type> a un <type>string</type> no proporciona
   información útil acerca del valor, más alla de su tipo. Consulte las funciones
   <function>print_r</function> y <function>var_dump</function> para obtener maneras
   más efectivas de inspeccionar el contenido de estos tipos.
  </para>
  
  <para>
   La mayoría de los valores de PHP pueden ser convertidos a <type>string</type>s para
   su almacenamiento permanente. Este método se denomina serialización, y es realizado 
   mediante la función <function>serialize</function>. Si la máquina PHP está contruida con
   soporte de <link linkend="ref.wddx">WDDX</link>, los valores de PHP tambien pueden
   ser serializacos como texto XML correctamente formateado.
  </para>
  
 </sect2>
 
 <sect2 xml:id="language.types.string.conversion">
  <title>Conversión de cadenas a números</title>
  
  <simpara>
   Cuando una <type>string</type> es evaluada en un contexto numérico, el valor
   resultante y el tipo se determina como se explica a continuación.
  </simpara>
  
  <simpara>
   Si el <type>string</type> no contiene ninguno de los caracteres '.', 'e',
   o 'E' y el valor numérico está entre los límites del tipo entero (como se
   define en <constant>PHP_INT_MAX</constant>), la <type>string</type> será 
   evaluada como un <type>integer</type>. En todos los demas casos será
   evaluado como un <type>float</type>.
  </simpara>
  
  <para>
   El valor es dado por la parte inicial del <type>string</type>. Si el 
   <type>string</type> empieza con un número válido, éste será el valor usado. De 
   otra forma, el valor será 0 (cero). Se considera número válido a un sigo
   opcional, seguido de uno o mñas digitos (opcionalmente puede contener un
   punto decimal), seguido de un exponente opcional El exponente es una 'e' o
   'E' seguido de uno o más dígitos.
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo es float (11.5)
$foo = 1 + "-1.3e3";              // $foo es float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo es integer (1)
$foo = 1 + "bob3";                // $foo es integer (1)
$foo = 1 + "10 Small Pigs";       // $foo es integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo es float (14.2)
$foo = "10.0 pigs " + 1;          // $foo es float (11)
$foo = "10.0 pigs " + 1.0;        // $foo es float (11)     
?>
]]>
   </programlisting>
  </informalexample>
  
  <simpara>
   Para más información sobre esta conversión, consulte la página del manual UNIX 
   correspondiente a strtod(3).
  </simpara>
  
  <para>
   Para probar cualquiera de los ejemplos en esta sección, copie y pegue los ejemplos e
   incluya la siguiente línea para ver que está ocurriendo:
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; tipo es " . gettype ($foo) . "<br />\n";
?>
]]>
   </programlisting>
  </informalexample>
  
  <para>
   No espere obtener el código de un caracter convirtiendolo a un entero,
   como ocurre en C. Emplee las funciones <function>ord</function> y
   <function>chr</function> para convertir entre código ASCII y caracteres.
  </para>
  
 </sect2>
</sect1><!-- end string -->

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
