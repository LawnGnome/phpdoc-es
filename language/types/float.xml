<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 301112 Maintainer: yago Status: ready -->
<sect1 xml:id="language.types.float">
 <title>Números de punto flotante</title>

 <para>
  Los números de punto flotante (también conocidos como "flotantes",
  "dobles" o "números reales") pueden ser especificados usando cualquiera de las siguientes sintaxis:
 </para>

 <informalexample>
  <programlisting role="php">
<![CDATA[
<?php
$a = 1.234; 
$b = 1.2e3; 
$c = 7E-10;
?>
]]>
  </programlisting>
 </informalexample>

 <para>
  Formalmente:
 </para>

 <informalexample>
  <programlisting>
<![CDATA[
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM [+-]?(({LNUM} | {DNUM}) [eE][+-]? {LNUM})
]]>
  </programlisting>
 </informalexample>

 <para>
  El tamaño de un flotante depende de la plataforma, aunque un valor común
  consiste en un máximo de ~1.8e308 con una precisión de aproximadamente 14
  dígitos decimales (lo que es un valor de 64 bits en formato IEEE).
 </para>

 <warning xml:id="warn.float-precision">
  <title>Precisión del punto flotante</title>

  <para>
   Es bastante común que algunas fracciones decimales simples como
   <literal>0.1</literal> o <literal>0.7</literal> no puedan ser convertidas
   a su representación binaria interna sin perder un poco de precisión. Esto
   puede llevar a resultados confusos: por ejemplo,
   <literal>floor((0.1+0.7)*10)</literal> usualmente devolverá
   <literal>7</literal> en lugar del esperado <literal>8</literal> ya que el
   resultado de la representación interna es en realidad algo como
   <literal role="infdec">7.9</literal>.
  </para>

  <para>
   Esto se debe a que es imposible expresar de forma exacta algunas
   fracciones en notación decimal con un número finito de dígitos. Por
   ejemplo, <literal>1/3</literal> en forma decimal se convierte en
   <literal role="infdec">0.3</literal>.
  </para>

  <para>
   Así que nunca confíe en resultados de números flotantes hasta el último
   dígito, y nunca compare números de punto flotante para conocer si son
   equivalentes. Si realmente necesita una mejor precisión, las <link
   linkend="ref.bc">funciones matemáticas de precisión arbitraria</link> y
   las funciones <link linkend="ref.gmp">gmp</link> están disponibles.
  </para>
 </warning>

 <sect2 xml:id="language.types.float.casting">
  <title>Conversión a flotante</title>
  
  <para>
   Para más información sobre las conversiones de <type>string</type> a
   <type>float</type>, vea <link
   linkend="language.types.string.conversion">Conversión de cadenas a
   números</link>. Para valores de otros tipos, la conversión es la misma
   que si el valor hubiese sido convertido a <type>integer</type>  y luego 
   a <type>float</type>.  Vea
   <link linkend="language.types.integer.casting">Conversión a entero</link>
   para más información. A partir de PHP 5, una noticia es generada si
   intenta convertir un objeto a <type>float</type>.
  </para>

 </sect2>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
