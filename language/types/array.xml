<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: n/a Maintainer: lboshell Status: ready -->
<sect1 xml:id="language.types.array">
 <title>Matrices</title>

 <para>
  Una valor <type>array</type> en PHP es en realidad un mapa ordenado. Un
  mapa es un tipo de datos que asocia <emphasis>valores</emphasis> con
  <emphasis>claves</emphasis>. Este tipo es optimizado para varios usos
  diferentes; puede ser usado como una matriz real, una lista (vector),
  tabla asociativa (caso particular de implementación de un mapa),
  diccionario, colección, pila, cola y probablemente más. Ya que los valores
  de una matriz pueden ser otras matrices, también es posible crear árboles
  y matrices multidimensionales.
 </para>

 <para>
  Una explicación sobre tales estructuras de datos se encuentra por fuera
  del propósito de este manual, pero encontrará al menos un ejemplo de cada
  uno de ellos. Para más información, consulte la extensa literatura que
  existe sobre este amplio tema.
 </para>

 <sect2 xml:id="language.types.array.syntax">
  <title>Sintaxis</title>

  <sect3 xml:id="language.types.array.syntax.array-func">
   <title>Especificación con <function>array</function></title>

   <para>
    Un valor <type>array</type> puede ser creado por la construcción de
    lenguaje <function>array</function>. Ésta toma un cierto número de
    parejas <literal><replaceable>clave</replaceable> =&gt;
    <replaceable>valor</replaceable></literal> separadas con coma.
   </para>

   <synopsis>
array( <optional> <replaceable>clave</replaceable> =&gt; </optional> <replaceable>valor</replaceable>
     , ...
     )
// <replaceable>clave</replaceable> puede ser un <type>integer</type> o <type>string</type>
// <replaceable>valor</replaceable> puede ser cualquier valor</synopsis>
   <!-- Do not fix the whitespace for the synopsis end element. A limitation of PhD prevents proper trimming -->

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$matriz = array("foo" => "bar", 12 => true);

echo $matriz["foo"]; // bar
echo $matriz[12];    // 1
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Una <varname>clave</varname> puede ser un <type>integer</type> o un
    <type>string</type>. Si una clave es la representación estándar de un
    <type>integer</type>, será interpretada como tal (es decir,
    <literal>"8"</literal> será interpretado como <literal>8</literal>,
    mientras que <literal>"08"</literal> será interpretado como
    <literal>"08"</literal>). Los valores <type>float</type> en
    <varname>clave</varname> serán truncados a valores tipo
    <type>integer</type>. Las matrices indexadas y las asociativas son el
    mismo tipo en PHP, el cual puede contener índices tipo entero o cadena.
   </para>

   <para>
    Un valor puede ser de cualquier tipo en PHP.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$matriz = array("unamatriz" => array(6 => 5, 13 => 9, "a" => 42));

echo $matriz["unamatriz"][6];    // 5
echo $matriz["unamatriz"][13];   // 9
echo $matriz["unamatriz"]["a"];  // 42
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Si no especifica una clave para un valor dado, entonces es usado el
    máximo de los índices enteros, y la nueva clave será ese valor máximo
    más 1. Si se especifica una clave que ya tiene un valor asignado, ése
    valor será sobrescrito.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// Esta matriz es la misma que ...
array(5 => 43, 32, 56, "b" => 12);

// ...esta matriz
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
    </programlisting>
   </informalexample>

   <warning>
    <simpara>
     Antes de PHP 4.3.0, agregar un elemento a una matriz cuya clave máxima
     actual es un valor negativo creaba una nueva clave como se ha descrito
     anteriormente. A partir de PHP 4.3.0, la nueva clave será
     <literal>0</literal>.
    </simpara>
   </warning>

   <para>
    Al usar &true; como <varname>clave</varname>, el valor será evaluado al
    <type>integer</type> <literal>1</literal>. Al usar &false; como
    <varname>clave</varname>, el valor será evaluado al <type>integer</type>
    <literal>0</literal>. Al usar &null; como clave, el valor será evaluado
    a una cadena vacía. El uso de una cadena vacía como clave creará (o
    reemplazará) una clave con la cadena vacía y su valor;
    <emphasis>no</emphasis> es lo mismo que usar corchetes vacíos.
   </para>

   <para>
    Las matrices y los objetos no pueden ser usados como claves. Al hacerlo
    se producirá una advertencia: <literal>Illegal offset type</literal>.
   </para>

  </sect3>

  <sect3 xml:id="language.types.array.syntax.modifying">
   <title>Creación/modificación con sintaxis de corchetes cuadrados</title>

   <para>
    Es posible modificar una matriz existente al definir valores
    explícitamente en ella.
   </para>

   <para>
    Esto es posible al asignar valores a la matriz al mismo tiempo que se
    especifica la clave entre corchetes. También es posible omitir la clave,
    lo que resulta en una pareja de corchetes vacíos
    (<literal>[]</literal>).
   </para>

   <synopsis>
$matriz[<replaceable>clave</replaceable>] = <replaceable>valor</replaceable>;
$matriz[] = <replaceable>valor</replaceable>;
// <replaceable>clave</replaceable> puede ser un <type>integer</type> o <type>string</type>
// <replaceable>valor</replaceable> puede ser cualquier valor</synopsis>

   <para>
    Si <varname>$matriz</varname> no existe aun, será creada, así que ésta
    es también una forma alternativa de crear una matriz.  Para modificar un
    cierto valor, simplemente asigne un nuevo valor a un elemento usando su
    clave. Para remover una pareja clave/valor, use la función
    <function>unset</function> sobre ella.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$matriz = array(5 => 1, 12 => 2);

$matriz[] = 56;    // Esto es igual que $matriz[13] = 56;
                   // en este punto del script

$matriz["x"] = 42; // Esto agrega un nuevo elemento a la
                   // matriz con la clave "x"

unset($matriz[5]); // Esto elimina el elemento de la matriz

unset($matriz);    // Esto elimina la matriz completa
***
?>
]]>
    </programlisting>
   </informalexample>

   <note>
    <para>
     Como se menciona anteriormente, si no se especifica una clave, entonces
     se toma el máximo de los índices enteros existentes, y la nueva clave
     será ese valor máximo más 1. Si no existen índices enteros aun, la
     clave será <literal>0</literal> (cero). Si se especifica una clave que
     ya tenía un valor asignado, el valor será reemplazado.
    </para>

    <para>
     Note que la clave entera máxima usada para este caso <emphasis>no
     necesita existir actualmente en la matriz</emphasis>. Tan solo debe
     haber existido en la matriz en algún punto desde que la matriz haya
     sido re-indexada. El siguiente ejemplo ilustra este caso:
    </para>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Crear una matriz simple.
$matriz = array(1, 2, 3, 4, 5);
print_r($matriz);

// Ahora eliminar cada ítem, pero dejar la matriz misma intacta:
foreach ($matriz as $i => $valor) {
    unset($matriz[$i]);
}
print_r($matriz);

// Agregar un ítem (note que la nueva clave es 5, en lugar de 0).
$matriz[] = 6;
print_r($matriz);

// Re-indexar:
$matriz = array_values($matriz);
$matriz[] = 7;
print_r($matriz);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
     </screen>
    </informalexample>

   </note>

  </sect3>
 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.array.useful-funcs">
  <title>Funciones útiles</title>

  <para>
   Existe un buen número de funciones útiles para trabajar con matrices.
   Consulte la sección <link linkend="ref.array">funciones de
   matrices</link>.
  </para>

  <note>
   <para>
    La función <function>unset</function> le permite remover claves de una
    matriz. Tenga en cuenta que la matriz <emphasis>no</emphasis> es
    re-indexada. Si desea el comportamiento real de "eliminar y desplazar",
    la matriz puede ser re-indexada usando la función
    <function>array_values</function>.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'uno', 2 => 'dos', 3 => 'tres');
unset($a[2]);
/* producirá una matriz que hubiera sido definida como
   $a = array(1 => 'uno', 3 => 'tres');
   y NO
   $a = array(1 => 'uno', 2 =>'tres');
*/

$b = array_values($a);
// Ahora $b es array(0 => 'uno', 1 =>'tres')
?>
]]>
    </programlisting>
   </informalexample>
  </note>

  <para>
   La estructura de control <link
   linkend="control-structures.foreach">foreach</link> existe
   específicamente para las matrices. Ésta provee una manera fácil de
   recorrer una matriz.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.donts">
  <title>Recomendaciones sobre matrices y cosas a evitar</title>

  <sect3 xml:id="language.types.array.foo-bar">
   <title>¿Porqué es incorrecto <literal>$foo[bar]</literal>?</title>

   <para>
    Siempre deben usarse comillas alrededor de un índice de matriz tipo
    cadena literal. Por ejemplo, <literal>$foo['bar']</literal> es correcto,
    mientras que <literal>$foo[bar]</literal> no lo es. ¿Pero porqué? Es
    común encontrar este tipo de sintaxis en scripts viejos:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'enemigo';
echo $foo[bar];
// etc
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Esto está mal, pero funciona. La razón es que este código tiene una
    constante indefinida (bar) en lugar de un valor <type>string</type>
    ('bar' - note las comillas). Puede que en el futuro PHP defina
    constantes que, desafortunadamente para tal tipo de código, tengan el
    mismo nombre. Funciona porque PHP automáticamente convierte una
    <emphasis>cadena pura</emphasis> (una cadena sin comillas que no
    corresponda con símbolo conocido alguno) en una cadena que contiene la
    cadena pura. Por ejemplo, si no se ha definido una constante llamada
    <constant>bar</constant>, entonces PHP reemplazará su valor por la
    cadena <literal>'bar'</literal> y usará ésta última.
   </para>

   <note>
    <simpara>
     Esto no quiere decir que <emphasis>siempre</emphasis> haya que usar
     comillas en la clave. No use comillas con claves que sean <link
     linkend="language.constants">constantes</link> o <link
     linkend="language.variables">variables</link>, ya que en tal caso PHP
     no podrá interpretar sus valores.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Matriz simple:
$matriz = array(1, 2);
$conteo = count($matriz);
for ($i = 0; $i < $conteo; $i++) {
    echo "\nRevisando $i: \n";
    echo "Mal: " . $matriz['$i'] . "\n";
    echo "Bien: " . $matriz[$i] . "\n";
    echo "Mal: {$matriz['$i']}\n";
    echo "Bien: {$matriz[$i]}\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    &example.outputs;
    <screen>
<![CDATA[
Revisando 0: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Mal: 
Bien: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Mal: 
Bien: 1

Revisando 1: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Mal: 
Bien: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Mal: 
Bien: 2
***
]]>
    </screen>
   </note>

   <para>
    Más ejemplos para demostrar este comportamiento:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// Mostrar todos los errores
error_reporting(E_ALL);

$matriz = array('fruta' => 'manzana', 'vegetal' => 'zanahoria');

// Correcto
print $matriz['fruta'];   // manzana
print $matriz['vegetal']; // zanahoria

// Incorrecto. Esto funciona pero también genera un error de PHP de
// nivel E_NOTICE ya que no hay definida una constante llamada fruta
//
// Notice: Use of undefined constant fruta - assumed 'fruta' in...
print $matriz[fruta];    // manzana

// Esto define una constante para demostrar lo que pasa. El valor 'vegetal'
// es asignado a una constante llamada fruta.
define('fruta', 'vegetal');

// Note la diferencia ahora
print $matriz['fruta'];  // manzana
print $matriz[fruta];    // zanahoria

// Lo siguiente está bien ya que se encuentra al interior de una
// cadena. Las constantes no son procesadas al interior de
// cadenas, así que no se produce un error E_NOTICE aquí
print "Hola $matriz[fruta]";  // Hola manzana

// Con una excepción, los corchetes que rodean las matrices al
// interior de cadenas permiten el uso de constantes
print "Hola {$matriz[fruta]}";    // Hola zanahoria
print "Hola {$matriz['fruta']}";  // Hola manzana

// Esto no funciona, resulta en un error de intérprete como:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Esto por supuesto se aplica también al uso de superglobales en cadenas
print "Hola $matriz['fruta']";
print "Hola $_GET['foo']";

// La concatenación es otra opción
print "Hola " . $matriz['fruta']; // Hola manzana
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Cuando se habilita <function>error_reporting</function> para mostrar
    errores de nivel <constant>E_NOTICE</constant> (como por ejemplo
    definiendo el valor <constant>E_ALL</constant>), este tipo de usos serán
    inmediatamente visibles. Por omisión, <link
    linkend="ini.error-reporting">error_reporting</link> se encuentra
    configurado para no mostrarlos.
   </para>

   <para>
    Tal y como se indica en la sección de <link
    linkend="language.types.array.syntax">sintaxis</link>, lo que existe
    entre los corchetes cuadrados ('<literal>[</literal>' y
    '<literal>]</literal>') debe ser una expresión. Esto quiere decir que
    código como el siguiente funciona:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo $matriz[alguna_funcion($bar)];
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Este es un ejemplo del uso de un valor devuelto por una función como
    índice de matriz. PHP también conoce las constantes:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$descripciones_de_error[E_ERROR]   = "Un error fatal ha ocurrido";
$descripciones_de_error[E_WARNING] = "PHP produjo una advertencia";
$descripciones_de_error[E_NOTICE]  = "Esta es una noticia informal";
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Note que <literal>E_ERROR</literal> es también un identificador válido,
    asi como <literal>bar</literal> en el primer ejemplo. Pero el último
    ejemplo es equivalente a escribir:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$descripciones_de_error[1] = "Un error fatal ha ocurrido";
$descripciones_de_error[2] = "PHP produjo una advertencia";
$descripciones_de_error[8] = "Esta es una noticia informal";
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    ya que <literal>E_ERROR</literal> es igual a <literal>1</literal>, etc.
   </para>

   <sect4 xml:id="language.types.array.foo-bar.why">
    <title>¿Entonces porqué está mal?</title>

    <para>
     En algún momento en el futuro, puede que el equipo de PHP quiera usar
     otra constante o palabra clave, o una constante proveniente de otro
     código puede interferir.  Por ejemplo, en este momento no puede usar
     las palabras <literal>empty</literal> y <literal>default</literal> de
     esta forma, ya que son <link linkend="reserved">palabras clave
     reservadas</link>.
    </para>

    <note>
     <simpara>
      Reiterando, al interior de un valor <type>string</type> entre comillas
      dobles, es válido no rodear los índices de matriz con comillas, así
      que <literal>"$foo[bar]"</literal> es válido. Consulte los ejemplos
      anteriores para más detalles sobre el porqué, así como la sección
      sobre <link linkend="language.types.string.parsing">procesamiento de
      variables en cadenas</link>.
     </simpara>
    </note>

   </sect4>
  </sect3>
 </sect2>

 <sect2 xml:id="language.types.array.casting">
  <title>Conversión a matriz</title>

  <para>
   Para cualquiera de los tipos: <type>integer</type>, <type>float</type>,
   <type>string</type>, <type>boolean</type> y <type>resource</type>,
   convertir un valor a un <type>array</type> resulta en una matriz con un
   solo elemento, con índice 0, y el valor del escalar que fue convertido.
   En otras palabras, <literal>(array)$valorEscalar</literal> es exactamente
   lo mismo que <literal>array($valorEscalar)</literal>.
  </para>

  <para>
   Si convierte un <type>object</type> a un <type>array</type>, el resultado
   es una matriz cuyos elementos son las propiedados del objeto. Las claves
   son los nombres de las variables miembro, con algunas excepciones
   notables: las variables privadas tienen el nombre de la clase al comienzo
   del nombre de la variable; las variables protegidas tienen un caracter
   '*' al comienzo del nombre de la variable. Estos valores adicionados al
   inicio tienen bytes nulos a los lados. Esto puede resultar en algunos
   comportamientos inesperados:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

class A {
    private $A; // Este campo se convertirá en '\0A\0A'
}

class B extends A {
    private $A; // Este campo se convertirá en '\0B\0A'
    public $AA; // Este campo se convertirá en 'AA'
}

var_dump((array) new B());
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   En el ejemplo anterior parecerá que se tienen dos claves llamadas 'AA',
   aunque en realidad una de ellas se llama '\0A\0A'.
  </para>

  <para>
   Si convierte un valor &null; a matriz, obtiene una matriz vacía.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.comparing">
  <title>Comparación</title>

  <para>
   Es posible comparar matrices con la función
   <function>array_diff</function> y mediante <link
   linkend="language.operators.array">operadores de matriz</link>.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.examples">
  <title>Ejemplos</title>

  <para>
   El tipo matriz en PHP es bastante versátil. Aquí hay algunos ejempos:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
// esto
$a = array( 'color'  => 'rojo',
            'sabor'  => 'dulce',
            'forma'  => 'redonda',
            'nombre' => 'manzana',
                       4        // la clave será 0
          );

// es completamente equivalente a
$a['color']  = 'rojo';
$a['sabor']  = 'dulce';
$a['forma']  = 'redonda';
$a['nombre'] = 'manzana';
$a[]         = 4;        // la clave será 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// resultará en la matriz array(0 => 'a' , 1 => 'b' , 2 => 'c'),
// o simplemente array('a', 'b', 'c')
?>
]]>
   </programlisting>
  </informalexample>

  <example>
   <title>Uso de array()</title>
   <programlisting role="php">
<![CDATA[
<?php
// Array como mapa de propiedades
$mapa = array( 'versión'          => 4,
               'SO'               => 'Linux',
               'idioma'           => 'inglés',
               'etiquetas_cortas' => true
            );

// claves estrictamente numéricas
$matriz = array( 7,
                 8,
                 0,
                 156,
                 -10
               );
// esto es lo mismo que array(0 => 7, 1 => 8, ...)

$cambios = array(         10, // clave = 0
                  5    =>  6,
                  3    =>  7,
                  'a'  =>  4,
                          11, // clave = 6 (el índice entero máximo era 5)
                  '8'  =>  2, // clave = 8 (¡entero!)
                  '02' => 77, // clave = '02'
                  0    => 12  // el valor 10 será reemplazado por 12
                );

// matriz vacía
$vacio = array();
?>
]]>
<!-- TODO example of
- overwriting keys
- using vars/functions as key/values
- warning about references
-->
   </programlisting>
  </example>

  <example xml:id="language.types.array.examples.loop">
   <title>Colección</title>
   <programlisting role="php">
<![CDATA[
<?php
$colores = array('rojo', 'azul', 'verde', 'amarillo');

foreach ($colores as $color) {
    echo "¿Le gusta el $color?\n";
}

?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
¿Le gusta el rojo?
¿Le gusta el azul?
¿Le gusta el verde?
¿Le gusta el amarillo?
]]>
   </screen>
  </example>

  <para>
   Modificar los valores de la matriz directamente es posible a partir de
   PHP 5, pasándolos por referencia. Las versiones anteriores necesitan una
   solución alternativa:
  </para>

  <example xml:id="language.types.array.examples.changeloop">
   <title>Colección</title>
   <programlisting role="php">
<![CDATA[
<?php
// PHP 5
foreach ($colores as &$color) {
    $color = strtoupper($color);
}
unset($color); /* se asegura de que escrituras subsiguientes a $color
no modifiquen el último elemento de la matriz */

// Alternativa para versiones anteriores
foreach ($colores as $clave => $color) {
    $colores[$clave] = strtoupper($color);
}

print_r($colores);
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => ROJO
    [1] => AZUL
    [2] => VERDE
    [3] => AMARILLO
)
]]>
   </screen>
  </example>

  <para>
   Este ejemplo crea una matriz con base uno.
  </para>

  <example>
   <title>Índice con base 1</title>
   <programlisting role="php">
<![CDATA[
<?php
$primercuarto  = array(1 => 'Enero', 'Febrero', 'Marzo');
print_r($primercuarto);
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [1] => 'Enero'
    [2] => 'Febrero'
    [3] => 'Marzo'
)
]]>
   </screen>
  </example>

  <example>
   <title>Llenado de una matriz</title>
   <programlisting role="php">
<![CDATA[
<?php
// llenar una matriz con todos los ítems de un directorio
$gestor = opendir('.');
while (false !== ($archivo = readdir($gestor))) {
    $archivos[] = $archivo;
}
closedir($gestor);
?>
]]>
   </programlisting>
  </example>

  <para>
   Las matrices son ordenadas. El orden puede ser modificado usando varias
   funciones de ordenamiento. Vea la sección sobre <link
   linkend="ref.array">funciones de matrices</link> para más información.
   La función <function>count</function> puede ser usada para contar el
   número de elementos en una matriz.
  </para>

  <example>
   <title>Ordenamiento de una matriz</title>
   <programlisting role="php">
<![CDATA[
<?php
sort($archivos);
print_r($archivos);
?>
]]>
   </programlisting>
  </example>

  <para>
   Dado que el valor de una matriz puede ser cualquier cosa, también puede
   ser otra matriz. De esta forma es posible crear matrices recursivas y
   multi-dimensionales.
  </para>

  <example>
   <title>Matrices recursivas y multi-dimensionales</title>
   <programlisting role="php">
<![CDATA[
<?php
$frutas = array ( "frutas"  => array ( "a" => "naranja",
                                       "b" => "banano",
                                       "c" => "manzana"
                                     ),
                  "números" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "hoyos"   => array (      "primero",
                                       5 => "segundo",
                                            "tercero"
                                     )
                );

// Algunos ejemplos que hacen referencia a los valores de la matriz anterior
echo $frutas["hoyos"][5];    // imprime "segundo"
echo $frutas["frutas"]["a"]; // imprime "naranja"
unset($frutas["hoyos"][0]);  // elimina "primero"

// Crear una nueva matriz multi-dimensional
$jugos["manzana"]["verde"] = "bien";
?>
]]>
   </programlisting>
  </example>

  <para>
   La asignación de matrices siempre involucra la copia de valores. También
   quiere decir que el apuntador interno de matriz usado por
   <function>current</function> y otras funciones similares es
   reestablecido. Use el <link linkend="language.operators">operador de
   referencia</link> para copiar una matriz por referencia.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$matriz1 = array(2, 3);
$matriz2 = $matriz1;
$matriz2[] = 4; // $matriz2 cambia,
                // $matriz1 sigue siendo array(2, 3)

$matriz3 = &$matriz1;
$matriz3[] = 4; // ahora $matriz1 y $matriz3 son iguales
?>
]]>
   </programlisting>
  </informalexample>

 </sect2>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
