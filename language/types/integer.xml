<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 336939 Maintainer: seros Status: ready -->
<!-- Reviewed: yes Maintainer: seros -->
<sect1 xml:id="language.types.integer">
 <title>Enteros (Integers)</title>
 
 <simpara>
  Un entero (o <type>integer</type>) es un número del conjunto
  &#8484; = {..., -2, -1, 0, 1, 2, ...}.
 </simpara>
 
 <para>
  Ver también:
 </para>
 
 <itemizedlist>
  <listitem>
   <simpara>
    <link linkend="ref.gmp">Enteros de longitud arbitraria / GMP</link>
   </simpara>
  </listitem>
  <listitem>
   <simpara>
    <link linkend="language.types.float">Números de punto flotante</link>
   </simpara>
  </listitem>
  <listitem>
   <simpara>
    <link linkend="ref.bc">Precisión arbitraria / BCMath</link>
   </simpara>
  </listitem>
 </itemizedlist>
 
 <sect2 xml:id="language.types.integer.syntax">
  <title>Sintaxis</title>
  
  <simpara>
   Los <type>integer</type> pueden especificarse mediante notación decimal
   (base 10), hexadecimal (base 16), octal (base 8) o binaria (base 2), opcionalmente
   precedidos por un signo (- o +).
  </simpara>
  
  <para>
   Los literales <type>integer</type> binarios están disponibles desde PHP 5.4.0.
  </para>
  
  <para>
   Para utilizar la notación octal, se antepone al número un <literal>0</literal> (cero).
   Para utilizar la notación hexadecimal, se antepone al número <literal>0x</literal>.
   Para utilizar la notación binaria, se antepone al número <literal>0b</literal>.
  </para>
  
  <example>
   <title>Enteros literales</title>
   <programlisting role="php">
<![CDATA[
<?php
$a = 1234; // número decimal
$a = -123; // un número negativo
$a = 0123; // número octal (equivalente a 83 decimal)
$a = 0x1A; // número hexadecimal (equivalente a 26 decimal)
$a = 0b11111111; // número binario (equivalente al 255 decimal)
?>
]]>
   </programlisting>
  </example>
  
  <para>
   Formalmente, la estructura de los <type>integer</type> literales es:
  </para>
  
  <informalexample>
   <programlisting>
<![CDATA[
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

binario     : 0b[01]+

entero      : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
            | [+-]?binary
]]>
   </programlisting>
  </informalexample>
  
  <para>
   El tamaño de un <type>integer</type> depende de la plataforma, aunque el valor usual
   es un valor máximo de aproximadamente dos mil millones (esto es, 32 bits con signo).
   Las plataformas de 64 bit normalmente tienen un valor máximo de aproximadamente 9E18,
   excepto para Windows, que siempre es de 32 bit. PHP no tiene soporte para <type>integer</type>
   sin signo. El tamaño de un <type>integer</type> se puede determinar mediante
   la constante <constant>PHP_INT_SIZE</constant>, y el valor máximo mediante la
   constante <constant>PHP_INT_MAX</constant> desde PHP 4.4.0 y PHP 5.0.5.
  </para>
  
  <warning>
   <para>
    Si a un <type>integer</type> octal se le proporciona un dígito incorrecto (p.ej., 8 o 9),
    el resto del número se ignora.
   </para>
   
   <example>
    <title>Rareza de los octales</title>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(01090); // 010 octal = 8 decimal
?>
]]>
    </programlisting>
   </example>
  </warning>
 </sect2>
 
 <sect2 xml:id="language.types.integer.overflow">
  <title>Desbordamiento de enteros</title>
  
  <para>
   Si PHP encuentra un número fuera de los límites de un <type>integer</type>,
   se interpretará en su lugar como un <type>float</type>. También, una
   operación cuyo resultado sea un número fuera de los límites de un
   <type>integer</type> devolverá en su lugar un <type>float</type>.
  </para>
  
  <example>
   <title>Desbordamiento de enteros en sistemas 32 bit</title>
   <programlisting role="php">
<![CDATA[
<?php
$número_grande = 2147483647;
var_dump($número_grande);                    // int(2147483647)

$número_grande = 2147483648;
var_dump($número_grande);                    // float(2147483648)

$millón = 1000000;
$número_grande =  50000 * $millón;
var_dump($número_grande);                    // float(50000000000)
?>
]]>
   </programlisting>
  </example>
  
  <example>
   <title>Desbordamiento de enteros en sistemas 64 bit</title>
   <programlisting role="php">
<![CDATA[
<?php
$número_grande = 9223372036854775807;
var_dump($número_grande);                    // int(9223372036854775807)

$número_grande = 9223372036854775808;
var_dump($número_grande);                    // float(9.2233720368548E+18)

$millón = 1000000;
$número_grande =  50000000000000 * $millón;
var_dump($número_grande);                    // float(5.0E+19)
?>
]]>
   </programlisting>
  </example>
  
  <para>
   No existe el operador de división de <type>integer</type> en PHP.
   <literal>1/2</literal> produce el <type>float</type> <literal>0.5</literal>.
   El valor puede ser convertido a un <type>integer</type> redondeándolo a cero, o 
   mediante la función <function>round</function> que permite un mayor control sobre el redondeo.
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         // float(3.5714285714286) 
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4) 
?>
]]>
   </programlisting>
  </informalexample>
 </sect2>
 
 <sect2 xml:id="language.types.integer.casting">
  <title>Conversión a enteros</title>
  
  <simpara>
   Para convertir explícitamente un valor al tipo <type>integer</type>, se puede emplear 
   tanto <literal>(int)</literal> como <literal>(integer)</literal>. Sin embargo,
   la mayoría de las veces la conversión no es necesaria, ya que un valor es convertido
   de forma automática cuando un operador, función o estructura de control requiera un
   argumento de tipo <type>integer</type>. Un valor también puede ser convertido al
   tipo <type>integer</type> mediante la función <function>intval</function>.
  </simpara>
  
  <simpara>
   Si un <type>resource</type> es convertido a un <type>integer</type>,
   el resultado será el número de recurso único asignado al
   <type>resource</type> por PHP en tiempo de ejecución.
  </simpara>
  
  <simpara>
   Consulte también la <link linkend="language.types.type-juggling">Manipulación de tipos</link>.
  </simpara>
  
  <sect3 xml:id="language.types.integer.casting.from-boolean">
   <title>Desde <link linkend="language.types.boolean">booleanos</link></title>
   
   <simpara>
    &false; producirá <literal>0</literal> (cero), y &true; producirá
    <literal>1</literal> (uno).
   </simpara>
  </sect3>
  
  <sect3 xml:id="language.types.integer.casting.from-float">
   <title>
    Desde <link linkend="language.types.float">números de punto flotante</link>
   </title> 
   
   <simpara>
    Cuando se convierte un <type>float</type> a un <type>integer</type>, el número
    será redondeado <emphasis>hacia cero</emphasis>.
   </simpara>
   
   <para>
    Si el float esta por debajo de los límites de un <type>integer</type> (normalmente
    <literal>+/- 2.15e+9 = 2^31</literal> en plataformas de 32 bits y 
    <literal>+/- 9.22e+18 = 2^63</literal> en plataformas de 64 bits distintas de
    Windows), el resultado es indefinido, debido a que <type>float</type> no tiene
    la precisión suficiente para ofrecer el resultado como un <type>integer</type> exacto.
    No se mostrará ninguna advertencia, ni siquiera un aviso cuando esto ocurra.
   </para>
   
   <warning>
    <para>
     Nunca se debe convertir una fracción desconocida a un <type>integer</type>, ya que
     a veces puede conducir a resultados inesperados.
    </para>
    
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo (int) ( (0.1+0.7) * 10 ); // muestra 7!
?>
]]>
     </programlisting>
    </informalexample>
    
    <para>
     Consulte también la <link linkend="warn.float-precision">advertencia sobre la precisión de
     float</link>
    </para>
   </warning>
  </sect3>
  
  <sect3 xml:id="language.types.integer.casting.from-string">
   <title>Desde string</title>
   
   <simpara>
    Consulte <link linkend="language.types.string.conversion">Conversión de string a
    números</link>
   </simpara>
  </sect3>
  
  <sect3 xml:id="language.types.integer.casting.from-other">
   <title>Desde otros tipos</title>
   
   <caution>
    <simpara>
     El comportamiento de la conversión de <type>integer</type> a otros tipos es indefinido.
     <emphasis>No</emphasis> confíe en ningún comportamiento observado, ya que puede 
     cambiar sin previo aviso.
    </simpara>
   </caution>
  </sect3>
  
 </sect2>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
