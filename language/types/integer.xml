<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 288721 Maintainer: lboshell Status: ready -->
<sect1 xml:id="language.types.integer">
 <title>Enteros</title>

 <simpara>
  Un <type>integer</type> es un número del conjunto Z = {..., -2, -1, 0, 1,
  2, ...}.
 </simpara>

 <para>
  Vea también:
 </para>

 <itemizedlist>
  <listitem>
   <simpara>
    <link linkend="ref.gmp">Entero de longitud arbitraria / GMP</link>
   </simpara>
  </listitem>
  <listitem>
   <simpara>
    <link linkend="language.types.float">Números de punto flotante</link>
   </simpara>
  </listitem>
  <listitem>
   <simpara>
    <link linkend="ref.bc">Precisión arbitraria / BCMath</link>
   </simpara>
  </listitem>
 </itemizedlist>

 <sect2 xml:id="language.types.integer.syntax">
  <title>Sintaxis</title>

  <simpara>
   Los enteros pueden ser especificados en notación decimal (base 10),
   hexadecimal (base 16) u octal (base 8), opcionalmente precedidos por un
   signo (- o +).
  </simpara>

  <para>
   Para usar la notación octal, debe preceder el número con un
   <literal>0</literal> (cero). Para usar la notación hexadecimal, preceda
   el número con <literal>0x</literal>.
  </para>

  <example>
   <title>Literales tipo entero</title>
   <programlisting role="php">
<![CDATA[
<?php
$a = 1234; // número decimal
$a = -123; // un número negativo
$a = 0123; // número octal (equivalente al 83 decimal)
$a = 0x1A; // número hexadecimal (equivalente al 26 decimal)
?>
]]>
   </programlisting>
  </example>

  <para>
   Formalmente, la posible estructura para literales <type>integer</type>
   es:
  </para>

  <informalexample>
   <programlisting>
<![CDATA[
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
]]>
   </programlisting>
  </informalexample>

  <para>
   El tamaño de un <type>integer</type> depende de la plataforma, aunque un
   valor máximo de aproximadamente dos billones es el valor usual (lo que es
   un valor de 32 bits con signo). PHP no soporta enteros sin signo. El
   tamaño de un entero puede determinarse usando la constante
   <constant>PHP_INT_SIZE</constant>, y el valor máximo usando la constante
   <constant>PHP_INT_MAX</constant> a partir de PHP 4.4.0 y PHP 5.0.5.
  </para>

  <warning>
   <para>
    Si un dígito inválido es pasado a un <type>integer</type> octal (p.ej. 8
    o 9), el resto del número es ignorado.
   </para>

   <example>
    <title>Curiosidad de valores octales</title>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(01090); // 010 octal = 8 decimal
?>
]]>
    </programlisting>
   </example>
  </warning>
 </sect2>

 <sect2 xml:id="language.types.integer.overflow">
  <title>Desbordamiento de enteros</title>

  <para>
   Si PHP encuentra un número más allá de los límites del tipo
   <type>integer</type>, será interpretado en su lugar como un
   <type>float</type>. Asimismo, si realiza una operación que resulta en un
   número más allá de los límites del tipo <type>integer</type>, un
   <type>float</type> es retornado en su lugar.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$numero_grande =  2147483647;
var_dump($numero_grande);
// salida: int(2147483647)

$numero_grande =  2147483648;
var_dump($numero_grande);
// salida: float(2147483648)

// también es cierto para enteros hexadecimales especificados entre 2^31 y 2^32-1:
var_dump( 0xffffffff );
// salida: float(4294967295)

// esto no ocurre con los enteros indicados como hexadecimales más allá de 2^32-1:
var_dump( 0x100000000 );
// salida: int(2147483647)

$millon = 1000000;
$numero_grande =  50000 * $millon;
var_dump($numero_grande);
// salida: float(50000000000)
?>
]]>
   </programlisting>
  </informalexample>

  <warning>
   <simpara>
    Desafortunadamente, había un fallo en PHP que provocaba que esto no
    siempre funcionara correctamente cuando se presentaban números
    negativos. Por ejemplo, el resultado de <literal>-50000 *
    $millon</literal> es <literal>-429496728</literal>.  Sin embargo, cuando
    ambos operandos eran positivos no había ningún problema.
   </simpara>

   <simpara>
    Este problema fue resuelto en PHP 4.1.0.
   </simpara>
  </warning>

  <para>
   No hay un operador de división de enteros en PHP. <literal>1/2</literal>
   produce el <type>float</type> <literal>0.5</literal>. Puede moldear el
   valor a un <type>integer</type> para redondearlo hacia abajo, o la
   función <function>round</function> ofrece mayor control sobre la
   operación de redondeo.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         // float(3.5714285714286)
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4)
?>
]]>
   </programlisting>
  </informalexample>
 </sect2>

 <sect2 xml:id="language.types.integer.casting">
  <title>Conversión a entero</title>

  <simpara>
   Para convertir explícitamente un valor a <type>integer</type>, use alguno
   de los moldeamientos <literal>(int)</literal> o
   <literal>(integer)</literal>. Sin embargo, en la mayoría de casos no
   necesita usar el moldeamiento, ya que un valor será convertido
   automáticamente si un operador, función o estructura de control requiere
   un argumento tipo <type>integer</type>. También puede convertir un valor
   a entero con la función <function>intval</function>.
  </simpara>

  <simpara>
   Vea también <link linkend="language.types.type-juggling">Manipulación de
   Tipos</link>.
  </simpara>

  <sect3 xml:id="language.types.integer.casting.from-boolean">
   <title>Desde <link
   linkend="language.types.boolean">booleanos</link></title>

   <simpara>
    &false; producirá <literal>0</literal> (cero), y &true; producirá
    <literal>1</literal> (uno).
   </simpara>
  </sect3>

  <sect3 xml:id="language.types.integer.casting.from-float">
   <title>Desde <link linkend="language.types.float">números de punto
   flotante</link></title>

   <simpara>
    Cuando se realizan conversiones desde <type>float</type> a
    <type>integer</type>, el número será redondeado <emphasis>hacia
    cero</emphasis>.
   </simpara>

   <para>
    Si el flotante se encuentra más allá de los límites del entero
    (usualmente <literal>+/- 2.15e+9 = 2^31</literal>), el resultado es
    indefinido, ya que el flotante no tiene suficiente precisión para dar un
    resultado entero exacto. No se producirá una advertencia, ¡ni siquiera
    una noticia en este caso!
   </para>

   <warning>
    <para>
     Nunca moldee una fracción desconocida a <type>integer</type>, ya que
     esto en ocasiones produce resultados inesperados.
    </para>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo (int) ( (0.1+0.7) * 10 ); // ¡imprime 7!
?>
]]>
     </programlisting>
    </informalexample>

    <para>
     Para más información, consulte la <link
     linkend="warn.float-precision">advertencia sobre
     precisión-flotante</link>.
    </para>
   </warning>
  </sect3>

  <sect3 xml:id="language.types.integer.casting.from-string">
   <title>Desde cadenas</title>

   <simpara>
    Vea <link linkend="language.types.string.conversion">Conversión de
    cadenas a números</link>
   </simpara>
  </sect3>

  <sect3 xml:id="language.types.integer.casting.from-other">
   <title>Desde otros tipos</title>

   <caution>
    <simpara>
     El comportamiento de convertir desde entero no es definido para otros
     tipos. <emphasis>No</emphasis> confíe en cualquier comportamiento
     observado, ya que puede ser modificado sin aviso.
    </simpara>
   </caution>
  </sect3>

 </sect2>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
