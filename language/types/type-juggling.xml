<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.1 $ -->
<!-- EN-Revision: 1.4 Maintainer: lboshell Status: ready -->
<sect1 xml:id="language.types.type-juggling">
 <title>Manipulación de Tipos</title>

 <simpara>
  PHP no requiere (o soporta) la definición explícita de tipos en la
  declaración de variables; el tipo de una variable es determinado por el
  contexto en el que la variable es usada. Lo que quiere decir que si asigna
  un valor tipo <type>string</type> a la variable
  <parameter>$var</parameter>, <parameter>$var</parameter> se convierte en
  una cadena. Si luego asigna un valor <type>integer</type> a
  <parameter>$var</parameter>, ésta se convierte en un entero.
 </simpara>

 <para>
  Un ejemplo de la conversión automática de tipos de PHP es el operador de
  adición '+'. Si cualquiera de los operandos es un valor
  <type>float</type>, entonces ambos operandos son evaluados como flotantes,
  y el resultado será un flotante. De lo contrario, los operandos serán
  interpretados como enteros, y el resultado será también un entero. Note
  que esto <emphasis>no</emphasis> modifica los tipos de los operandos como
  tal; el único cambio está en la forma como los operandos son evaluados y
  en el tipo de la expresión misma.
 </para>

 <informalexample>
  <programlisting role="php">
<![CDATA[
<?php
$foo = "0";  // $foo es una cadena (ASCII 48)
$foo += 2;   // $foo es ahora un entero (2)
$foo = $foo + 1.3;  // $foo es ahora un flotante (3.3)
$foo = 5 + "10 Cerditos"; // $foo es entero (15)
$foo = 5 + "10 Cerdos";   // $foo es entero (15)
?>
]]>
<!-- bad example, no real operator (must be used with variable, modifies it too)
$foo++;      // $foo is the string "1" (ASCII 49)

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
  </programlisting>
 </informalexample>

 <simpara>
  Si los dos últimos ejemplos lucen extraños, consulte <link
  linkend="language.types.string.conversion">Conversión de cadenas a
  números</link>.
 </simpara>

 <simpara>
  Para forzar a que una variable sea evaluada como de cierto tipo, consulte
  la sección sobre <link linkend="language.types.typecasting">Moldeamiento
  de tipos</link>. Si desea cambiar el tipo de una variable, vea la función
  <function>settype</function>.
 </simpara>

 <para>
  Para probar cualquiera de los ejemplos en esta sección, use la función
  <function>var_dump</function>.
 </para>

 <note>
  <para>
   El comportamiento de una conversión automática a matriz no se encuentra
   definido en el momento.
  </para>

  <para>
   Asimismo, ya que PHP soporta el uso de índices en cadenas por medio de
   desplazamientos usando la misma sintaxis que la indexación de matrices,
   el siguiente ejemplo permanece válido para todas las versiones de PHP:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$a    = 'carro'; // $a es una cadena
$a[0] = 'b';     // $a sigue siendo una cadena
echo $a;         // barro
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   Vea la sección titulada <link
   linkend="language.types.string.substr">Acceso a cadenas por
   caracter</link> para más información.
  </para>
 </note>

 <sect2 xml:id="language.types.typecasting">
  <title>Moldeamiento de Tipos</title>

  <para>
   El moldeamiento de tipos en PHP funciona de forma muy similar a como
   ocurre en C: el nombre del tipo deseado es escrito entre paréntesis antes
   de la variable a ser moldeada.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = 10;   // $foo es un entero
$bar = (boolean) $foo;   // $bar es un booleano
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   Los moldeamientos permitidos son:
  </para>

  <itemizedlist>
   <listitem>
    <simpara>(int), (integer) - moldeamiento a <type>integer</type></simpara>
   </listitem>
   <listitem>
    <simpara>(bool), (boolean) - moldeamiento a <type>boolean</type></simpara>
   </listitem>
   <listitem>
    <simpara>(float), (double), (real) - moldeamiento a <type>float</type></simpara>
   </listitem>
   <listitem>
    <simpara>(string) - moldeamiento a <type>string</type></simpara>
   </listitem>
   <listitem>
    <simpara>(binary) - moldeamiento a <type>string</type> binario (PHP 6)</simpara>
   </listitem>
   <listitem>
    <simpara>(array) - moldeamiento a <type>array</type></simpara>
   </listitem>
   <listitem>
    <simpara>(object) - moldeamiento a <type>object</type></simpara>
   </listitem>
  </itemizedlist>

  <para>
   El moldeamiento (binary) y el soporte del prefijo b fueron agregados en
   PHP 5.2.1
  </para>

  <para>
   Note que las tabulaciones y los espacios son permitidos al interior de
   los paréntesis, así que las siguientes expresiones son funcionalmente
   equivalentes:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
   </programlisting>

   <para>
    Moldeamiento de cadenas literales y variables a cadenas binarias:
   </para>

   <programlisting role="php">
<![CDATA[
<?php
$binario = (binary)$cadena;
$binario = b"cadena binaria";
?>
]]>
   </programlisting>
  </informalexample>

  <note>
   <para>
    En lugar de moldear una variable a cadena, puede también rodear la
    variable con comillas dobles.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo es un entero
$cad = "$foo";        // $cad es una cadena
$fst = (string) $foo; // $fst es también una cadena

// Esto imprime "son lo mismo"
if ($fst === $cad) {
    echo "son lo mismo";
}
?>
]]>
    </programlisting>
   </informalexample>
  </note>

  <para>
   Puede que no sea obvio qué sucede exactamente cuando se moldea entre
   ciertos tipos. Para más información, consulte las secciones:

  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.boolean.casting">Conversión a booleano</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.integer.casting">Conversión a entero</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.float.casting">Conversión a flotante</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.casting">Conversión a cadena</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.array.casting">Conversión a matriz</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.object.casting">Conversión a objeto</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.resource.casting">Conversión a recurso</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="types.comparisons">Las tablas de comparación de tipos</link>
    </simpara>
   </listitem>
  </itemizedlist>

 </sect2>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
