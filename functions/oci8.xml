<?xml version="1.0" encoding="iso-8859-1"?>
 <reference id="ref.oci8">
  <title>Funciones de Oracle 8</title>
  <titleabbrev>OCI8</titleabbrev>
  <partintro>
   <simpara>
    Estas funciones permiten acceder a bases de datos Oracle8 y Oracle7. Estas
    usan la Oracle8 Call-Interface (OCI8). Necesitará las librerías clientes de Oracle8
    para usar esta extensión.
   </simpara>
   <simpara>
    Esta extensión es más flexible que las estándar de Oracle.
    Soporta el enlace de variables locales y globales de PHP con 
    placeholders de Oracle, tiene soporte completo para LOB, FILE y ROWID
    y le permiten usar las variables definidas por el usuario.
   </simpara>
  </partintro>
    
<!--
OCIBindByName
OCIDefineByName
OCIColumnIsNULL
OCIColumnName
OCIColumnSize
OCIColumnType
OCIExecute
OCIFetch
OCIFetchInto
OCIFetchStatement
OCIInternalDebug
OCILogoff
OCILogon
OCIPLogon
OCINLogon
OCIError
OCICommit
OCIRollback
OCINewCursor
OCINewDescriptor
OCIRowCount
OCINumCols
OCIParse
OCIResult
OCIServerVersion
OCIStatementType
OCIFreeStatement
OCIFreeCursor
-->

  <refentry id="function.ocidefinebyname">
   <refnamediv>
    <refname>OCIDefineByName</refname>
    <refpurpose>
     Usa una variable de PHP para el define-step durante una sentencia SELECT
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIDefineByName</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>string <parameter>Column-Name</parameter></paramdef>
      <paramdef>mixed &amp;<parameter>variable</parameter></paramdef>
      <paramdef>int <parameter><optional>type</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIDefineByName</function> busca el valor de las Columnas-SQL
     dentro de variables PHP definidas por el usuario. Cuidado que Oracle nombra todas
     las columnas en MAYUSCULAS, mientras que en su select puede usar también minúsculas
     write lower-case. <function>OCIDefineByName</function> espera que
     <parameter>Column-Name</parameter> esté en mayúsculas. Si define una variable
     que no existe en la sentecia SELECT, no se producirá ningún error.
    </para>
    <para>
     Si necesita definir un tipo de dato abstracto (LOB/ROWID/BFILE) tendrá que alojarlo
     primero usando la función <function>OCINewDescriptor</function> function. Vea también 
     la función <function>OCIBindByName</function>.
    </para>
     <example>
      <title>OCIDefineByName</title>
      <programlisting>
&lt;?php
/* OCIDefineByPos example thies@digicol.de (980219) */

$conn = OCILogon("scott","tiger");

$stmt = OCIParse($conn,"select empno, ename from emp");

/* la definición DEBE hacerse ANTES del ociexecute! */

OCIDefineByName($stmt,"EMPNO",&amp;$empno);
OCIDefineByName($stmt,"ENAME",&amp;$ename);

OCIExecute($stmt);

while (OCIFetch($stmt)) {
    echo "empno:".$empno."\n";
    echo "ename:".$ename."\n";
}

OCIFreeStatement($stmt);
OCILogoff($conn);
?>
     </programlisting>
    </example>
   </refsect1>
  </refentry>

  <refentry id="function.ocibindbyname">
   <refnamediv>
    <refname>OCIBindByName</refname>
    <refpurpose>Enlaza una variable PHP a un Placeholder de Oracle</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIBindByName</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>string <parameter>ph_name</parameter></paramdef>
      <paramdef>mixed &amp;<parameter>variable</parameter></paramdef>
      <paramdef>int<parameter>length</parameter></paramdef>
      <paramdef>int <parameter><optional>type</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIBindByName</function> enlaza la variable PHP  
     <parameter>variable</parameter> a un placeholder de Oracle
     <parameter>ph_name</parameter>.  Si esta será usada para entrada o salida 
     se determinará en tiempo de ejecución, y sera resevado el espacio necesario de
     almacenamiento. El parámetro <parameter>length</parameter> establece el tamaño máximo
     del enlace. Si establece <parameter>length</parameter> a -1
     <function>OCIBindByName</function> usará el tamaño de la
     <parameter>variable</parameter> para establecer el tamaño máximo.
    </para>
    <para>
     Si necesita enlazar tipos de datos abstractos (LOB/ROWID/BFILE) necesitará primero
     reservar la memoria con la función <function>OCINewDescriptor</function>.
     <parameter>length</parameter> no se usa para tipos de datos abstractos y
     debería establecerse a -1. La variable <parameter>type</parameter> le informa a
     Oracle, que tipo de descriptor queremos usar. Los valores posibles son:
     OCI_B_FILE (Binary-File), OCI_B_CFILE (Character-File),
     OCI_B_CLOB (Character-LOB), OCI_B_BLOB (Binary-LOB) and OCI_B_ROWID (ROWID).
    </para>
    <example>
     <title>OCIDefineByName</title>
     <programlisting>
&lt;?php
/* OCIBindByPos example thies@digicol.de (980221)

  inserts 3 resords into emp, and uses the ROWID for updating the 
  records just after the insert.
*/

$conn = OCILogon("scott","tiger");

$stmt = OCIParse($conn,"insert into emp (empno, ename) ".
                       "values (:empno,:ename) ".
                       "returning ROWID into :rid");

$data = array(1111 => "Larry", 2222 => "Bill", 3333 => "Jim");

$rowid = OCINewDescriptor($conn,OCI_D_ROWID);

OCIBindByName($stmt,":empno",&amp;$empno,32);
OCIBindByName($stmt,":ename",&amp;$ename,32);
OCIBindByName($stmt,":rid",&amp;$rowid,-1,OCI_B_ROWID);

$update = OCIParse($conn,"update emp set sal = :sal where ROWID = :rid");
OCIBindByName($update,":rid",&amp;$rowid,-1,OCI_B_ROWID);
OCIBindByName($update,":sal",&amp;$sal,32);

$sal = 10000;

while (list($empno,$ename) = each($data)) {
    OCIExecute($stmt);
    OCIExecute($update);
} 

$rowid->free();

OCIFreeStatement($update);
OCIFreeStatement($stmt);

$stmt = OCIParse($conn,"select * from emp where empno in (1111,2222,3333)");
OCIExecute($stmt);
while (OCIFetchInto($stmt,&amp;$arr,OCI_ASSOC)) {
    var_dump($arr);
}
OCIFreeStatement($stmt);

/* delete our "junk" from the emp table.... */
$stmt = OCIParse($conn,"delete from emp where empno in (1111,2222,3333)");
OCIExecute($stmt);
OCIFreeStatement($stmt);

OCILogoff($conn);
?>
     </programlisting>
    </example>
   </refsect1>
  </refentry>
  
  <refentry id="function.ocilogon">
   <refnamediv>
    <refname>OCILogon</refname>
    <refpurpose>Establece la conexión con Oracle</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCILogon</function></funcdef>
      <paramdef>string <parameter>username</parameter></paramdef>
      <paramdef>string <parameter>password</parameter></paramdef>
      <paramdef>string <parameter><optional>db</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCILogon</function> devuelve el identificador de conexión 
     necesario en la mayoria de las funciones OCI. El tercer parámetro, que
     es opcional, puede contener el nombre de la instancia a Oracle o el nombre 
     dado en el fichero tnsnames.ora de la base de datos a la que nos queremos
     conectar. Si este parámetro no se especifica, PHP usa la variable de entorno
     ORACLE_SID (Oracle instance) o TWO_TASK (tnsnames.ora) para determinar la base
     de datos con la que queremos conectar.
    </para>
    <para>Las conexiones son compartidas a nivel de página cuando usemos
     <function>OCILogon</function>.  Lo cual significa que los "commits" y
     "rollbacks" son aplicadas a todas las transacciones abiertas en la página, incluso
     si usted ha creado conexiones múltiples.
    </para>
    <para>
     Este ejemplo demuestra como son compartidas las conexiones.
     <example>
      <title>OCILogon</title>
      <programlisting>
&lt;?php
print "&lt;HTML>&lt;PRE>";
$db = "";

$c1 = ocilogon("scott","tiger",$db);
$c2 = ocilogon("scott","tiger",$db);

function create_table($conn)
{ $stmt = ociparse($conn,"create table scott.hallo (test varchar2(64))");
  ociexecute($stmt);
  echo $conn." created table\n\n";
}

function drop_table($conn)
{ $stmt = ociparse($conn,"drop table scott.hallo");
  ociexecute($stmt);
  echo $conn." dropped table\n\n";
}

function insert_data($conn)
{ $stmt = ociparse($conn,"insert into scott.hallo 
            values('$conn' || ' ' || to_char(sysdate,'DD-MON-YY HH24:MI:SS'))");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn." inserted hallo\n\n";
}

function delete_data($conn)
{ $stmt = ociparse($conn,"delete from scott.hallo");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn." deleted hallo\n\n";
}

function commit($conn)
{ ocicommit($conn);
  echo $conn." commited\n\n";
}

function rollback($conn)
{ ocirollback($conn);
  echo $conn." rollback\n\n";
}

function select_data($conn)
{ $stmt = ociparse($conn,"select * from scott.hallo");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn."----selecting\n\n";
  while (ocifetch($stmt))
    echo $conn." &lt;".ociresult($stmt,"TEST").">\n\n";
  echo $conn."----done\n\n";
}

create_table($c1);
insert_data($c1);   // Insert a row using c1
insert_data($c2);   // Insert a row using c2

select_data($c1);   // Results of both inserts are returned
select_data($c2);   

rollback($c1);      // Rollback using c1

select_data($c1);   // Both inserts have been rolled back
select_data($c2);   

insert_data($c2);   // Insert a row using c2
commit($c2);        // commit using c2

select_data($c1);   // result of c2 insert is returned

delete_data($c1);   // delete all rows in table using c1
select_data($c1);   // no rows returned
select_data($c2);   // no rows returned
commit($c1);        // commit using c1

select_data($c1);   // no rows returned
select_data($c2);   // no rows returned


drop_table($c1);
print "&lt;/PRE>&lt;/HTML>";
?></programlisting></example></para>
    <simpara>
     See also <function>OCIPLogon</function> and
     <function>OCINLogon</function>.</simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ociplogon">
   <refnamediv>
    <refname>OCIPLogon</refname>
    <refpurpose>Conecta con una base de datos Oracle usando una conexión persistente. 
    Devuelve una nueva sesión.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIPLogon</function></funcdef>
      <paramdef>string <parameter>username</parameter></paramdef>
      <paramdef>string <parameter>password</parameter></paramdef>
      <paramdef>string <parameter><optional>db</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIPLogon</function> crea una conexión persistente con
     una base de datos Oracle 8.  El tercer parámetro, que es opcional, puede
     contener el nombre de la instancia a Oracle o el nombre dado en el fichero 
     tnsnames.ora de la base de datos a la que nos queremos conectar. 
     Si este parámetro no se especifica, PHP usa la variable de entorno
     ORACLE_SID (Oracle instance) o TWO_TASK (tnsnames.ora) para determinar la base
     de datos con la que queremos conectar.
    </para>
    <simpara>
     Vea también <function>OCILogon</function> y
     <function>OCINLogon</function>.</simpara>
   </refsect1></refentry>

  <refentry id="function.ocinlogon">
   <refnamediv>
    <refname>OCINLogon</refname>
    <refpurpose>Conecta con una base de datos Oracle usando una nueva conexión. 
    Devuelve una nueva sesión.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCINLogon</function></funcdef>
      <paramdef>string <parameter>username</parameter></paramdef>
      <paramdef>string <parameter>password</parameter></paramdef>
      <paramdef>string <parameter><optional>db</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCINLogon</function> crea una nueva conexión con una
     base de datos Oracle 8. El tercer parámetro, que es opcional, puede
     contener el nombre de la instancia a Oracle o el nombre dado en el fichero 
     tnsnames.ora de la base de datos a la que nos queremos conectar. 
     Si este parámetro no se especifica, PHP usa la variable de entorno
     ORACLE_SID (Oracle instance) o TWO_TASK (tnsnames.ora) para determinar la base
     de datos con la que queremos conectar.
   </para>
    <para>
     <function>OCINLogon</function> fuerza una nueva conexión. Se debe usar si
     necesita aislar un conjunto de transacciones.  Por defecto, las conexiones
     son compartidas a nivel de página si usa <function>OCILogon</function> o
     a nivel del proceso del servidor web si usa <function>OCIPLogon</function>.
     Si posee múltiples conexiones abiertas usando <function>OCINLogon</function>,
     todos los "commits" y "rollbacks" se aplican sólo a la conexion especificada.
    </para>
    <para>
     Este ejemplo demuestra como las conexiones están separadas.
     <example>
      <title>OCINLogon</title>
      <programlisting>
&lt;?php
print "&lt;HTML>&lt;PRE>";
$db = "";

$c1 = ocilogon("scott","tiger",$db);
$c2 = ocinlogon("scott","tiger",$db);

function create_table($conn)
{ $stmt = ociparse($conn,"create table scott.hallo (test
varchar2(64))");
  ociexecute($stmt);
  echo $conn." created table\n\n";
}

function drop_table($conn)
{ $stmt = ociparse($conn,"drop table scott.hallo");
  ociexecute($stmt);
  echo $conn." dropped table\n\n";
}

function insert_data($conn)
{ $stmt = ociparse($conn,"insert into scott.hallo 
            values('$conn' || ' ' || to_char(sysdate,'DD-MON-YY HH24:MI:SS'))");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn." inserted hallo\n\n";
}

function delete_data($conn)
{ $stmt = ociparse($conn,"delete from scott.hallo");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn." deleted hallo\n\n";
}
function commit($conn)
{ ocicommit($conn);
  echo $conn." commited\n\n";
}

function rollback($conn)
{ ocirollback($conn);
  echo $conn." rollback\n\n";
}

function select_data($conn)
{ $stmt = ociparse($conn,"select * from scott.hallo");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn."----selecting\n\n";
  while (ocifetch($stmt))
    echo $conn." &lt;".ociresult($stmt,"TEST").">\n\n";
  echo $conn."----done\n\n";
}

create_table($c1);
insert_data($c1);

select_data($c1);   
select_data($c2);   

rollback($c1);      

select_data($c1);   
select_data($c2);   

insert_data($c2);   
commit($c2);        

select_data($c1);   

delete_data($c1);   
select_data($c1);   
select_data($c2);   
commit($c1);        

select_data($c1);
select_data($c2);


drop_table($c1);
print "&lt;/PRE>&lt;/HTML>";
?></programlisting></example></para>
    <simpara>
     See also <function>OCILogon</function> and
     <function>OCIPLogon</function>.</simpara>
   </refsect1></refentry>

  <refentry id="function.ocilogoff">
   <refnamediv>
    <refname>OCILogOff</refname>
    <refpurpose>Termina la conexion con Oracle</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCILogOff</function></funcdef>
      <paramdef>int <parameter>connection</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCILogOff</function> cierra una conexión con Oracle.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ociexecute">
   <refnamediv>
    <refname>OCIExecute</refname>
    <refpurpose>Ejecuta una sentencia</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIExecute</function></funcdef>
      <paramdef>int <parameter>statement</parameter></paramdef>
      <paramdef>int <parameter><optional>mode</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIExecute</function> ejecuta una sentencia previamente analizada. 
     (see <function>OCIParse</function>). El parámetro opcional <parameter>mode</parameter>
     le permite especificar el modo de ejecución (default is OCI_COMMIT_ON_SUCCESS). 
     Si no desea que las sentencias se confirmen automaticamente, especifique OCI_DEFAULT como 
     su modo.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocicommit">
   <refnamediv>
    <refname>OCICommit</refname>
    <refpurpose>Confirma transacciones pendientes</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCICommit</function></funcdef>
      <paramdef>int <parameter>connection</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCICommit</function> confirma todas las sentencias pendientes para la conexión
     con Oracle <parameter>connection</parameter>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocirollback">
   <refnamediv>
    <refname>OCIRollback</refname>
    <refpurpose>Restablece todas las transaciones sin confirmar</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIRollback</function></funcdef>
      <paramdef>int <parameter>connection</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIRollback</function> restablece todas las transacciones sin confirmar
     para la conexión Oracle <parameter>connection</parameter>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocinewdescriptor">
   <refnamediv>
    <refname>OCINewDescriptor</refname>
    <refpurpose>Inicializa un nuevo descriptor vacío LOB/FILE (LOB por defecto)</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>OCINewDescriptor</function></funcdef>
      <paramdef>int <parameter>connection</parameter></paramdef>
      <paramdef>int <parameter><optional>type</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCINewDescriptor</function> Reserva espacio para mantener descriptores o
     localizadores LOB. Los valores válidos para el tipo 
     <parameter>type</parameter> son OCI_D_FILE, OCI_D_LOB, OCI_D_ROWID.
     Para descriptores LOB, los métodos load, save, y savefile están asociados 
     con el descriptor, para BFILE sólo el método load existe. 
     Vea el segundo ejemplo.
    </para>
    <example>
     <title>OCINewDescriptor</title>
     <programlisting>
&lt;?php   
    /* This script is designed to be called from a HTML form.
     * It expects $user, $password, $table, $where, and $commitsize
     * to be passed in from the form.  The script then deletes
     * the selected rows using the ROWID and commits after each
     * set of $commitsize rows. (Use with care, there is no rollback)
     */
    $conn = OCILogon($user, $password);
    $stmt = OCIParse($conn,"select rowid from $table $where");
    $rowid = OCINewDescriptor($conn,OCI_D_ROWID);
    OCIDefineByName($stmt,"ROWID",&amp;$rowid);   
    OCIExecute($stmt);
    while ( OCIFetch($stmt) ) {      
       $nrows = OCIRowCount($stmt);
       $delete = OCIParse($conn,"delete from $table where ROWID = :rid");
       OCIBindByName($delete,":rid",&amp;$rowid,-1,OCI_B_ROWID);
       OCIExecute($delete);      
       print "$nrows\n";
       if ( ($nrows % $commitsize) == 0 ) {
           OCICommit($conn);      
       }   
    }
    $nrows = OCIRowCount($stmt);   
    print "$nrows deleted...\n";
    OCIFreeStatement($stmt);  
    OCILogoff($conn);
?>  
     </programlisting>
     <programlisting>
&lt;?php
    /* This script demonstrates file upload to LOB columns
     * The formfield used for this example looks like this
     * &lt;form action="upload.php3" method="post" enctype="multipart/form-data">
     * &lt;input type="file" name="lob_upload">
     * ...
     */
  if(!isset($lob_upload) || $lob_upload == 'none'){
?>
&lt;form action="upload.php3" method="post" enctype="multipart/form-data">
Upload file: &lt;input type="file" name="lob_upload">&lt;br>
&lt;input type="submit" value="Upload"> - &lt;input type="reset">
&lt;/form>
&lt;?php
  } else {
     // $lob_upload contains the temporary filename of the uploaded file
     $conn = OCILogon($user, $password);
     $lob = OCINewDescriptor($conn, OCI_D_LOB);
     $stmt = OCIParse($conn,"insert into $table (id, the_blob) 
               values(my_seq.NEXTVAL, EMPTY_BLOB()) returning the_blob into :the_blob");
     OCIBindByName($stmt, ':the_blob', &amp;$lob, -1, OCI_B_BLOB);
     OCIExecute($stmt);
     if($lob->savefile($lob_upload)){
        OCICommit($conn);
        echo "Blob successfully uploaded\n";
     }else{
        echo "Couldn't upload Blob\n";
     }
     OCIFreeDescriptor($lob);
     OCIFreeStatement($stmt);
     OCILogoff($conn);
  }
?>
     </programlisting>
    </example>
   </refsect1>
  </refentry>
  <refentry id="function.ocirowcount">
   <refnamediv>
    <refname>OCIRowCount</refname>
    <refpurpose>Obtiene el número de filas afectadas</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIRowCount</function></funcdef>
      <paramdef>int <parameter>statement</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIRowCount</function> devuelve el número de filas afectadas, por ej. en 
         sentencias de actualización. !Esta función no indicará el número de de filas que
     devuelve una sentencia SELECT!</para>
    <para>
     <example>
      <title>OCIRowCount</title>
      <programlisting>
&lt;?php
    print "&lt;HTML>&lt;PRE>";
    $conn = OCILogon("scott","tiger");
    $stmt = OCIParse($conn,"create table emp2 as select * from emp");
    OCIExecute($stmt);
    print OCIRowCount($stmt) . " rows inserted.&lt;BR>";
    OCIFreeStatement($stmt);
    $stmt = OCIParse($conn,"delete from emp2");
    OCIExecute($stmt);
    print OCIRowCount($stmt) . " rows deleted.&lt;BR>";
    OCICommit($conn);
    OCIFreeStatement($stmt);
    $stmt = OCIParse($conn,"drop table emp2");
    OCIExecute($stmt);
    OCIFreeStatement($stmt);
    OCILogOff($conn);
    print "&lt;/PRE>&lt;/HTML>";
?> </programlisting></example></para>
 
   </refsect1>
  </refentry>

  <refentry id="function.ocinumcols">
   <refnamediv>
    <refname>OCINumCols</refname>
    <refpurpose>Devuelve el número de columnas resultantes en una sentencia</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCINumCols</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCINumCols</function> devuelve el número de columnas en una sentencia
    </para>
    <example>
     <title>OCINumCols</title>
     <programlisting>
&lt;?php   
    print "&lt;HTML>&lt;PRE>\n";   
    $conn = OCILogon("scott", "tiger");
    $stmt = OCIParse($conn,"select * from emp");
    OCIExecute($stmt);
    while ( OCIFetch($stmt) ) {
        print "\n";   
        $ncols = OCINumCols($stmt);
        for ( $i = 1; $i &lt;= $ncols; $i++ ) {
            $column_name  = OCIColumnName($stmt,$i);
            $column_value = OCIResult($stmt,$i);
            print $column_name . ': ' . $column_value . "\n";
        }
        print "\n";
    }
    OCIFreeStatement($stmt);  
    OCILogoff($conn);   
    print "&lt;/PRE>";
    print "&lt;/HTML>\n"; 
?>   
     </programlisting>
    </example>
   </refsect1>
  </refentry>
 
  <refentry id="function.ociresult">
   <refnamediv>
    <refname>OCIResult</refname>
    <refpurpose>Devuelve el valor de una columna en la fila buscada</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>OCIResult</function></funcdef>
      <paramdef>int <parameter>statement</parameter></paramdef>
      <paramdef>mixed <parameter>column</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIResult</function> devuelve el valor de la columna 
     <parameter>column</parameter> de la fila actual (vea 
     <function>OCIFetch</function>).<function>OCIResult</function> devolverá
     todo como una cadena excepto para los tipo de datos abstractos
     (ROWIDs, LOBs and FILEs).
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifetch">
   <refnamediv>
    <refname>OCIFetch</refname>
    <refpurpose>Busca la siguiente fila en el result-buffer</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFetch</function></funcdef>
      <paramdef>int <parameter>statement</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFetch</function> Busca la siguiente fila (para sentencias SELECT)
     dentro del result-buffer interno.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifetchinto">
   <refnamediv>
    <refname>OCIFetchInto</refname>
    <refpurpose>Busca la siguiente fila dentro del result-array</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFetchInto</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>array &amp;<parameter>result</parameter></paramdef>
      <paramdef>int <parameter><optional>mode</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFetchInto</function> busca la siguiente fila (for SELECT statements)
     dentro del array <parameter>result</parameter>. <function>OCIFetchInto</function>
     sobreescribirá el contenido previo de <parameter>result</parameter>. Por defecto 
     <parameter>result</parameter> contendrá un array basado en todas las columnas que
     no son &null;.
    </para>
    <para>
     El parámetro <parameter>mode</parameter> le permite cambiar el comportamineto por 
     defecto. Puede especificar más de una flag simplemente añadiendolas 
     (ej. OCI_ASSOC+OCI_RETURN_NULLS). Las flags son:

     <simplelist>
      <member><literal>OCI_ASSOC</literal> Devuelve un array asociativo.</member>
      <member><literal>OCI_NUM</literal> Devuelve un array numerado empezando en 1.
      (POR DEFECTO)</member>
      <member><literal>OCI_RETURN_NULLS</literal> Devuelve columnas vacias.</member>
      <member><literal>OCI_RETURN_LOBS</literal> Devuelve el valor de un LOB en vez de
      el descriptor.</member>
     </simplelist>

    </para>
    <para>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifetchstatement">
   <refnamediv>
    <refname>OCIFetchStatement</refname>
    <refpurpose>Busca todas la filas de un resultset dentro de un array.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFetchStatement</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>array &amp;<parameter>variable</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFetchStatement</function> busca todas las filas de un resultset 
     dentro de un array definido por el usuario. <function>OCIFetchStatement</function> 
     devuelve el numero de filas buscadas. 
    </para>
     <example>
      <title>OCIFetchStatement</title>
      <programlisting>
&lt;?php
/* OCIFetchStatement example mbritton@verinet.com (990624) */

$conn = OCILogon("scott","tiger");

$stmt = OCIParse($conn,"select * from emp");

OCIExecute($stmt);

$nrows = OCIFetchStatement($stmt,$results);
if ( $nrows > 0 ) {
   print "&lt;TABLE BORDER=\"1\">\n";
   print "&lt;TR>\n";
   while ( list( $key, $val ) = each( $results ) ) {
      print "&lt;TH>$key&lt;/TH>\n";
   }
   print "&lt;/TR>\n";
   
   for ( $i = 0; $i &lt; $nrows; $i++ ) {
      reset($results);
      print "&lt;TR>\n";
      while ( $column = each($results) ) {   
         $data = $column['value'];
         print "&lt;TD>$data[$i]&lt;/TD>\n";
      }
      print "&lt;/TR>\n";
   }
   print "&lt;/TABLE>\n";
} else {
   echo "No data found&lt;BR>\n";
}      
print "$nrows Records Selected&lt;BR>\n";
 
OCIFreeStatement($stmt);
OCILogoff($conn);

?></programlisting></example>

   </refsect1>
  </refentry>
  <refentry id="function.ocicolumnisnull">
   <refnamediv>
    <refname>OCIColumnIsNULL</refname>
    <refpurpose>comprueba si una una columna es &null;</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIColumnIsNULL</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>mixed <parameter>column</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIColumnIsNULL</function> devuelve vedadero si la columna devuelta
     <parameter>column</parameter> en el resultset de la sentencia <parameter>stmt</parameter>
     es &null;. Puede usar el número de la columna (1-Based) o el nombre de la columa 
     indicado por el parámetro <parameter>col</parameter>.
    </para>
   </refsect1>
  </refentry>


  <refentry id="function.ocicolumnsize">
   <refnamediv>
    <refname>OCIColumnSize</refname>
    <refpurpose>devuelve el tamaño de la columna</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIColumnSize</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>mixed <parameter>column</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIColumnSize</function> devuelve el tamaño de la columna indicada por Oracle
         Puede utilizar el número de la columna (1-Based) o el nombre indicado en el parámetro 
     <parameter>col</parameter>.
    </para>
    <para>
     <example>
      <title>OCIColumnSize</title>
      <programlisting>
&lt;?php   
    print "&lt;HTML>&lt;PRE>\n";   
    $conn = OCILogon("scott", "tiger");
    $stmt = OCIParse($conn,"select * from emp");
    OCIExecute($stmt);
    print "&lt;TABLE BORDER=\"1\">";
    print "&lt;TR>";
    print "&lt;TH>Name&lt;/TH>";
    print "&lt;TH>Type&lt;/TH>";
    print "&lt;TH>Length&lt;/TH>";
    print "&lt;/TR>";
    $ncols = OCINumCols($stmt);
    for ( $i = 1; $i &lt;= $ncols; $i++ ) {
        $column_name  = OCIColumnName($stmt,$i);
        $column_type  = OCIColumnType($stmt,$i);
        $column_size  = OCIColumnSize($stmt,$i);
        print "&lt;TR>";
        print "&lt;TD>$column_name&lt;/TD>";
        print "&lt;TD>$column_type&lt;/TD>";
        print "&lt;TD>$column_size&lt;/TD>";
        print "&lt;/TR>";
    }
    print "&lt;/TABLE>";
    OCIFreeStatement($stmt);  
    OCILogoff($conn);   
    print "&lt;/PRE>";
    print "&lt;/HTML>\n"; 
?>   
      </programlisting>
     </example>
    </para>
    <simpara>
     Vea también <function>OCINumCols</function>, <function>OCIColumnName</function>, 
     y <function>OCIColumnSize</function>.</simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ociserverversion">
   <refnamediv>
    <refname>OCIServerVersion</refname>
    <refpurpose>Devuelve una cadena conteniendo información a cerca de la version del servidor.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>OCIServerVersion</function></funcdef>
      <paramdef>int <parameter>conn</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <example>
      <title>OCIServerVersion</title>
      <programlisting>
&lt;?php
   $conn = OCILogon("scott","tiger");
   print "Server Version: " . OCIServerVersion($conn);
   OCILogOff($conn);
?></programlisting></example></para>

   </refsect1>
  </refentry>

  <refentry id="function.ocistatementtype">
   <refnamediv>
    <refname>OCIStatementType</refname>
    <refpurpose>Devuelve el tipo de una sentencia OCI.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>OCIStatementType</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIStatementType</function> devuelve uno de los siguiente valores:
     <orderedlist>
      <listitem><simpara>           "SELECT"</simpara></listitem>
      <listitem><simpara>           "UPDATE"</simpara></listitem>
      <listitem><simpara>           "DELETE"</simpara></listitem>
      <listitem><simpara>           "INSERT"</simpara></listitem>
      <listitem><simpara>           "CREATE"</simpara></listitem>
      <listitem><simpara>           "DROP"</simpara></listitem>
      <listitem><simpara>           "ALTER"</simpara></listitem>
      <listitem><simpara>           "BEGIN"</simpara></listitem>
      <listitem><simpara>           "DECLARE"</simpara></listitem>
      <listitem><simpara>           "UNKNOWN"</simpara></listitem>
     </orderedlist></para>
    <para>
     <example>
      <title>Code examples</title>
      <programlisting>
&lt;?php
    print "&lt;HTML>&lt;PRE>";
    $conn = OCILogon("scott","tiger");
    $sql  = "delete from emp where deptno = 10";
   
    $stmt = OCIParse($conn,$sql);
    if ( OCIStatementType($stmt) == "DELETE" ) {
        die "You are not allowed to delete from this table&lt;BR>";
    }
   
    OCILogoff($conn);
    print "&lt;/PRE>&lt;/HTML>";
?>
</programlisting></example></para>

   </refsect1>
  </refentry>

  <refentry id="function.ocinewcursor">
   <refnamediv>
    <refname>OCINewCursor</refname>
    <refpurpose>devuelve un cursor nuevo (Statement-Handle) - use esto para enlazar
    ref-cursors!</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCINewCursor</function></funcdef>
      <paramdef>int <parameter>conn</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCINewCursor</function> allocates a new statement handle on the specified
     connection.
    </para>
    <para>
     <example>
      <title>Usando un REF CURSOR de un procedimiento almacenado</title>
      <programlisting>
&lt;?php   
// suppose your stored procedure info.output returns a ref cursor in :data

$conn = OCILogon("scott","tiger");
$curs = OCINewCursor($conn);
$stmt = OCIParse($conn,"begin info.output(:data); end;");

ocibindbyname($stmt,"data",&amp;$curs,-1,OCI_B_CURSOR);
ociexecute($stmt);
ociexecute($curs);

while (OCIFetchInto($curs,&amp;$data)) {
    var_dump($data);
}
 
OCIFreeCursor($stmt);
OCIFreeStatement($curs);
OCILogoff($conn);
?>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Usando un REF CURSOR en una sentencia select</title>
      <programlisting>
&lt;?php   
print "&lt;HTML>&lt;BODY>";
$conn = OCILogon("scott","tiger");
$count_cursor = "CURSOR(select count(empno) num_emps from emp " .
                "where emp.deptno = dept.deptno) as EMPCNT from dept";
$stmt = OCIParse($conn,"select deptno,dname,$count_cursor");

ociexecute($stmt);
print "&lt;TABLE BORDER=\"1\">";
print "&lt;TR>";
print "&lt;TH>DEPT NAME&lt;/TH>";
print "&lt;TH>DEPT #&lt;/TH>";
print "&lt;TH># EMPLOYEES&lt;/TH>";
print "&lt;/TR>";

while (OCIFetchInto($stmt,&amp;$data,OCI_ASSOC)) {
    print "&lt;TR>";
    $dname  = $data["DNAME"];
    $deptno = $data["DEPTNO"];
    print "&lt;TD>$dname&lt;/TD>";
    print "&lt;TD>$deptno&lt;/TD>";
    ociexecute($data[ "EMPCNT" ]);
    while (OCIFetchInto($data[ "EMPCNT" ],&amp;$subdata,OCI_ASSOC)) {
        $num_emps = $subdata["NUM_EMPS"];
        print  "&lt;TD>$num_emps&lt;/TD>";
    }
    print "&lt;/TR>";
}
print "&lt;/TABLE>";
print "&lt;/BODY>&lt;/HTML>";
OCIFreeStatement($stmt);
OCILogoff($conn);
?>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifreestatement">
   <refnamediv>
    <refname>OCIFreeStatement</refname>
    <refpurpose>Libera todos los recursos asociados con una sentencia.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFreeStatement</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFreeStatement</function> devuelve cierto si la operacion se lleva a cabo, 
     o falso en caso contrario.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifreecursor">
   <refnamediv>
    <refname>OCIFreeCursor</refname>
    <refpurpose>Libera todos los recursos asociados con cursor.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFreeCursor</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFreeCursor</function> devuelve cierto si la operacion se lleva a cabo,
     o falso en caso contrario.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocicolumnname">
   <refnamediv>
    <refname>OCIColumnName</refname>
    <refpurpose>Devuelve el nombre de una columna.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>OCIColumnName</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>int <parameter>col</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     <function>OCIColumnName</function> Devuelve el nombre de la columna 
      correspondiente al número de la columna (1-based) que es pasado.
    </simpara>
    <para>
     <example>
      <title>OCIColumnName</title>
      <programlisting>
&lt;?php   
    print "&lt;HTML>&lt;PRE>\n";   
    $conn = OCILogon("scott", "tiger");
    $stmt = OCIParse($conn,"select * from emp");
    OCIExecute($stmt);
    print "&lt;TABLE BORDER=\"1\">";
    print "&lt;TR>";
    print "&lt;TH>Name&lt;/TH>";
    print "&lt;TH>Type&lt;/TH>";
    print "&lt;TH>Length&lt;/TH>";
    print "&lt;/TR>";
    $ncols = OCINumCols($stmt);
    for ( $i = 1; $i &lt;= $ncols; $i++ ) {
        $column_name  = OCIColumnName($stmt,$i);
        $column_type  = OCIColumnType($stmt,$i);
        $column_size  = OCIColumnSize($stmt,$i);
        print "&lt;TR>";
        print "&lt;TD>$column_name&lt;/TD>";
        print "&lt;TD>$column_type&lt;/TD>";
        print "&lt;TD>$column_size&lt;/TD>";
        print "&lt;/TR>";
    }
    OCIFreeStatement($stmt);  
    OCILogoff($conn);   
    print "&lt;/PRE>";
    print "&lt;/HTML>\n"; 
?>   
      </programlisting>
     </example>
    </para>
    <simpara>
     Vea también <function>OCINumCols</function>, <function>OCIColumnType</function>, 
     y <function>OCIColumnSize</function>.</simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ocicolumntype">
   <refnamediv>
    <refname>OCIColumnType</refname>
    <refpurpose>Devuelve el tipo de dato de una columna.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>OCIColumnType</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>int <parameter>col</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     <function>OCIColumnType</function> devuelve el tipo de dato de una columna 
      correspondiente al número de la columna (1-based) que es pasado.</simpara>

    <para>
     <example>
      <title>OCIColumnType</title>
      <programlisting>
&lt;?php   
    print "&lt;HTML>&lt;PRE>\n";   
    $conn = OCILogon("scott", "tiger");
    $stmt = OCIParse($conn,"select * from emp");
    OCIExecute($stmt);
    print "&lt;TABLE BORDER=\"1\">";
    print "&lt;TR>";
    print "&lt;TH>Name&lt;/TH>";
    print "&lt;TH>Type&lt;/TH>";
    print "&lt;TH>Length&lt;/TH>";
    print "&lt;/TR>";
    $ncols = OCINumCols($stmt);
    for ( $i = 1; $i &lt;= $ncols; $i++ ) {
        $column_name  = OCIColumnName($stmt,$i);
        $column_type  = OCIColumnType($stmt,$i);
        $column_size  = OCIColumnSize($stmt,$i);
        print "&lt;TR>";
        print "&lt;TD>$column_name&lt;/TD>";
        print "&lt;TD>$column_type&lt;/TD>";
        print "&lt;TD>$column_size&lt;/TD>";
        print "&lt;/TR>";
    }
    OCIFreeStatement($stmt);  
    OCILogoff($conn);   
    print "&lt;/PRE>";
    print "&lt;/HTML>\n"; 
?>   
      </programlisting>
     </example>
    </para>
    <simpara>
     Vea también <function>OCINumCols</function>, <function>OCIColumnName</function>, 
     y <function>OCIColumnSize</function>.</simpara>

   </refsect1>
  </refentry>
  <refentry id="function.ociparse">
   <refnamediv>
    <refname>OCIParse</refname>
    <refpurpose>Analiza una consulta y devuelve una sentencia</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIParse</function></funcdef>
      <paramdef>int <parameter>conn</parameter></paramdef>
      <paramdef>strint <parameter>query</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     <function>OCIParse</function> analiza la <parameter>query</parameter> 
     usando  <parameter>conn</parameter>.  Devuelve el identificador de la sentencia
     si la consulta es válida, y falso si no lo es. La
     <parameter>query</parameter> puede ser cualquier sentencia SQL válida.
    </simpara>
   </refsect1>
  </refentry>
  <refentry id="function.ocierror">
   <refnamediv>
    <refname>OCIError</refname>
    <refpurpose>Devuelve el último error de stmt|conn|global. 
     Si no ocurre ningún error devuelve falso.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>OCIError</function></funcdef>
      <paramdef>int 
       <parameter><optional>stmt|conn|global</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     <function>OCIError</function> devuelve el último error encontrado. Si
      el parámetro opcional <parameter>stmt|conn|global</parameter> no es usado,
      es devuelto el último error encontrado.  Si no se encuentra ningún error,
     <function>OCIError</function> devuelve falso.
     <function>OCIError</function> devuelve el error como un array asociativo.
     En este array, <parameter>code</parameter> consiste en el código de error de Oracle
     y <parameter>message</parameter> en la cadena de descripción del error.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ociinternaldebug">
   <refnamediv>
    <refname>OCIInternalDebug</refname>
    <refpurpose>
     Habilita o deshabilita la salida del depurador interno.  Por defecto este está
     deshabiltado
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>OCIInternalDebug</function></funcdef>
      <paramdef>int <parameter>onoff</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     <function>OCIInternalDebug</function> habilita la salida del depurador interno.
     Asigne 0 a <parameter>onoff</parameter> para deshabilitar la salida y 1 
     para habilitarla.</simpara>
   </refsect1>
  </refentry>
 </reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->

