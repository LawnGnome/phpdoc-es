<?xml version="1.0" encoding="iso-8859-1"?>
 <reference id="ref.regex">
  <title>Funciones para expresiones regulares</title>
  <titleabbrev>Regexps</titleabbrev>
  <partintro>
   <para>
    Las expresiones regulares se usan en PHP para manipular cadenas
	complejas. Las funciones que soportan expresiones regulares son:

    <itemizedlist>
     <listitem>
      <simpara><function>ereg</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>ereg_replace</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>eregi</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>eregi_replace</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>split</function></simpara>
     </listitem>
    </itemizedlist>

	En todas estas funciones, el primer argumento es una expresi&oacute;n
	regular.  PHP utiliza las expresiones regulares extendidas de
	POSIX, definidas en POSIX 1003.2.  Para una descripci&oacute;n completa
	de las expresiones regulares POSIX, ver las p&aacute;ginas de manual de
	regex incluidas en el directorio regex de la distribuci&oacute;n de PHP.
	Est&aacute;n en formato de p&aacute;gina de manual, por lo que se deben leer con
	una orden como <command>man /usr/local/src/regex/regex.7</command>.

   <!-- Should add discussion of PCRE functions here. --></para>

   <para>
    <example>
     <title>Ejemplos de expresiones regulares</title>
     <programlisting>
ereg(&quot;abc&quot;,$string);            
/* Devuelve true si &quot;abc&quot;
   se encuentra en $string. */

ereg(&quot;^abc&quot;,$string);
/* Devuelve true si &quot;abc&quot;
   se encuentra al comienzo de $string. */

ereg("abc$",$string);
/* Devuelve true si &quot;abc&quot;
   se encuentra al final de $string. */

eregi("(ozilla.[23]|MSIE.3)",$HTTP_USER_AGENT);  
/* Devuelve true si el navegador cliente
   es Netscape 2, 3 o MSIE 3. */

ereg("([[:alnum:]]+) ([[:alnum:]]+) ([[:alnum:]]+)",
     $string,$regs); 
/* Pone tres palabras separadas por espacios
   en $regs[1], $regs[2] y $regs[3]. */

$string = ereg_replace("^","&lt;BR&gt;",$string); 
/* Coloca la etiqueta &lt;BR&gt; al comienzo de $string. */
 
$string = ereg_replace("$","&lt;BR&gt;",$string); 
/* Coloca la etiqueta &lt;BR&gt; al final de $string. */

$string = ereg_replace("\n","",$string);
/* Elimina los caracteres fin-de-l&iacute;nea de $string. */
     </programlisting>
    </example></para>

  </partintro>

  <refentry id="function.ereg">
   <refnamediv>
    <refname>ereg</refname>
    <refpurpose>Coincidencia de expresiones regulares</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripci&oacute;n</title>
    <funcsynopsis>
     <funcprototype>
     <funcdef>int <function>ereg</function></funcdef>
     <paramdef>string <parameter>pattern</parameter></paramdef>
     <paramdef>string <parameter>string</parameter></paramdef>
     <paramdef>array <parameter><optional>regs</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
	 Busca en <parameter>string</parameter> las coincidencias con la
	 expresi&oacute;n regular <parameter>pattern</parameter>.</simpara> 

    <simpara>
	 Si se encuentran coincidencias con subcadenas entre par&eacute;ntesis de
	 <parameter>pattern</parameter> y la funci&oacute;n se ha llamado con el
	 tercer argumento <parameter>regs</parameter>, las coincidencias
	 se almacenar&aacute;n en los elementos de <parameter>regs</parameter>.
	 $regs[1] contendr&aacute; la subcadena que empieza en el primer
	 par&eacute;ntesis izquierdo; $regs[2] la que comienza en el segundo,
	 etc. $regs[0] contendr&aacute; una copia de
	 <parameter>string</parameter>.</simpara>

    <para>
	 La b&uacute;squeda diferencia may&uacute;sculas y min&uacute;sculas.</para>

    <para>
	 Devuelve un valor verdadero si se encontr&oacute; alguna coincidencia, o
	 falso in no se encontraron coincidencias u ocurri&oacute; alg&uacute;n
	 error.</para>
    
    <para>
	 El siguiente fragmento de c&oacute;digo toma una fecha en formato ISO
	 (AAAA-MM-DD) y la imprime en formato DD.MM.AAAA:
     <example>
      <title>ereg() example</title>
      <programlisting>
if ( ereg( "([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})", $date, $regs ) ) {
    echo "$regs[3].$regs[2].$regs[1]";
} else {
    echo "Invalid date format: $date";
}
</programlisting></example></para>

    <para>
	 Ver tambi&eacute;n <function>eregi</function>,
	 <function>ereg_replace</function>, y 
	 <function>eregi_replace</function>.</para>

   </refsect1>
  </refentry>


  <refentry id="function.ereg-replace">
   <refnamediv>
    <refname>ereg_replace</refname>
    <refpurpose>reemplaza expresiones regulares</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripci&oacute;n</title>
    <funcsynopsis>
     <funcprototype>
     <funcdef>string <function>ereg_replace</function></funcdef>
     <paramdef>string <parameter>pattern</parameter></paramdef>
     <paramdef>string <parameter>replacement</parameter></paramdef>
     <paramdef>string <parameter>string</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
	 Esta funci&oacute;n examina <parameter>string</parameter> buscando
	 coincidencias de <parameter>pattern</parameter>, y reemplaza el
	 texto encontrado con <parameter>replacement</parameter>.</para>

    <para>
	 Devuelve la cadena modificada. Si no hay coincidencias que
	 reemplazar, devuelve la cadena original.</para>

    <para>
	 Si <parameter>pattern</parameter> contiene subcadenas entre
	 par&eacute;ntesis, <parameter>replacement</parameter> puede contener
	 subcadenas de la forma
	 <literal>\\<replaceable>cifra</replaceable></literal>, que ser&aacute;n
	 reemplazadas por el texto que coincide con la subcadena entre
	 par&eacute;ntesis que ocupa el lugar indicado por la cifra;
	 <literal>\\0</literal> produce el contenido total de la cadena.
	 Se pueden usar hasta nueve subcadenas. Los par&eacute;ntesis pueden
	 anidarse; en este caso se cuentan los par&eacute;ntesis de
	 apertura.</para>

    <para>
	 Si no se encuentran coincidencias en
	 <parameter>string</parameter>, se devuelve
	 <parameter>string</parameter> sin cambios.</para>

    <para>
	 Por ejemplo, el siguiente fragmento de c&oacute;digo imprime "This was a
	 test" tres veces:
     <example>
      <title>ereg_replace() example</title>
      <programlisting>
$string = "This is a test";
echo ereg_replace( " is", " was", $string );
echo ereg_replace( "( )is", "\\1was", $string );
echo ereg_replace( "(( )is)", "\\2was", $string );
      </programlisting>
     </example></para>

    <para>
	 Ver tambi&eacute;n <function>ereg</function>, <function>eregi</function>,
     y <function>eregi_replace</function>.</para>
   </refsect1>
  </refentry>


  <refentry id="function.eregi">
   <refnamediv>
    <refname>eregi</refname>
	<refpurpose>coincidencia de expresiones regulares sin diferenciar
	may&uacute;sculas y min&uacute;sculas</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripci&oacute;n</title>
    <funcsynopsis>
     <funcprototype>
     <funcdef>int <function>eregi</function></funcdef>
     <paramdef>string <parameter>pattern</parameter></paramdef>
     <paramdef>string <parameter>string</parameter></paramdef>
     <paramdef>array <parameter><optional>regs</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
	 Esta funci&oacute;n es id&eacute;ntica a <function>ereg</function>, excepto en
	 que ignora la distinci&oacute;n entre may&uacute;sculas y min&uacute;sculas.</para>

    <para>
	 Ver tambi&eacute;n <function>ereg</function>,
	 <function>ereg_replace</function>, y
	 <function>eregi_replace</function>.</para> 
   </refsect1>
  </refentry>


  <refentry id="function.eregi-replace">
   <refnamediv>
    <refname>eregi_replace</refname>
	<refpurpose>reemplaza expresiones regularse sin diferenciar
	may&uacute;sculas y min&uacute;sculas</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripci&oacute;n</title>
    <funcsynopsis>
     <funcprototype>
     <funcdef>string <function>eregi_replace</function></funcdef>
     <paramdef>string <parameter>pattern</parameter></paramdef>
     <paramdef>string <parameter>replacement</parameter></paramdef>
     <paramdef>string <parameter>string</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
	 Esta funci&oacute;n es id&eacute;ntica a <function>ereg_replace</function>,
	 excepto en que ignora la distinci&oacute;n entre may&uacute;sculas y
	 min&uacute;sculas.</para>

    <para>
	 Ver tambi&eacute;n <function>ereg</function>,
	 <function>eregi</function>, y
	 <function>ereg_replace</function>.</para>

   </refsect1>
  </refentry>


  <refentry id="function.split">
   <refnamediv>
    <refname>split</refname>
	<refpurpose>divide la cadena en elementos de un array seg&uacute;n una
	expresi&oacute;n regular</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripci&oacute;n</title>
    <funcsynopsis>
     <funcprototype>
     <funcdef>array <function>split</function></funcdef>
     <paramdef>string <parameter>pattern</parameter></paramdef>
     <paramdef>string <parameter>string</parameter></paramdef>
     <paramdef>int <parameter><optional>limit</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
	 Devuelve un array de cadenas, cada una de las cuales es una
	 subcadena de <parameter>string</parameter> formada al dividir
	 esta en los l&iacute;mites formados por la expresi&oacute;n regular
	 <parameter>pattern</parameter>. Si ocurre un error, devuelve un
	 valor falso.
	</para>

    <para>
	 Para obtener los cinco primeros campos de una l&iacute;nea de
     <filename>/etc/passwd</filename>:
	 <example>
      <title>split() example</title>
      <programlisting>
$passwd_list = split( ":", $passwd_line, 5 );
	  </programlisting>
	 </example>
	</para>

    <para>
	 Para examinar una fecha que puede estar delimitada por barras,
	 puntos o guiones:
	 <example>
      <title>split() example</title>
      <programlisting>
$date = "04/30/1973";  // Los delimitadores pueden ser barras, puntos o guiones
list( $month, $day, $year ) = split( '[/.-]', $date );
echo "Month: $month; Day: $day; Year: $year&lt;br&gt;\n";
	  </programlisting>
	 </example>
	</para>

    <para>
	 Observar que <parameter>pattern</parameter> distingue entre
	 may&uacute;sculas y min&uacute;sculas.
	</para>

	<para>
	 Observar que si no se necesita la potencia de las expresiones
	 regulares, es m&aacute;s r&aacute;pido utilizar <function>explode</function>,
	 que no carga el motor de expresiones regulares.
	</para>

	<para>
	 Por favor, observar que <parameter>pattern</parameter> es una
	 expresi&oacute;n regular. Si se quiere dividir con alguno de los
	 caracteres especiales de las expresiones regulares, se necesita
	 protegerlo antes. Si pareciera que <function>split</function> (o
	 cualquier otra funci&oacute;n de regex) est&aacute; haciendo algo irregular,
	 l&eacute;ase el archivo <filename>regex.7</filename>, incluido en el
	 subdirectorio <filename>regex</filename> de la distribuci&oacute;n de
	 PHP. Est&aacute; en formato de p&aacute;gina de manual, por lo que para leerlo
	 es necesaria una orden como <command>man
	 /usr/local/src/regex/regex.7</command>.
	</para>

    <para>
	 Ver tambi&eacute;n: <function>explode</function> e
	 <function>implode</function>.
	</para>

   </refsect1>
  </refentry>


  <refentry id="function.sql-regcase">
   <refnamediv>
    <refname>sql_regcase</refname>
	<refpurpose>construye una expresi&oacute;n regular para buscar
	coincidencias sin diferenciar may&uacute;sculas y min&uacute;sculas</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripci&oacute;n</title>
    <funcsynopsis>
     <funcprototype>
     <funcdef>string <function>sql_regcase</function></funcdef>
     <paramdef>string <parameter>string</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
	 Devuelve una expresi&oacute;n regular v&aacute;lida que coincide con
	 <parameter>string</parameter> sin distinguir may&uacute;sculas y
	 min&uacute;sculas. Esta expresi&oacute;n es <parameter>string</parameter> con
	 cada car&aacute;cter convertido a una expresi&oacute;n entre corchetes que
	 contiene el car&aacute;cter en may&uacute;scula y min&uacute;scula, si es posible; en
	 caso contrario, contiene el car&aacute;cter original dos veces.
     <example>
      <title>sql_regcase() example</title>
      <programlisting>
echo sql_regcase( "Foo bar" );
</programlisting></example>

     imprime <screen>[Ff][Oo][Oo][  ][Bb][Aa][Rr]</screen>.</para>

    <para>
	 Se puede utilizar para lograr coincidencias que no diferencien
	 may&uacute;sculas de min&uacute;sculas en productos que s&oacute;lo soportan
	 expresiones regulares que s&iacute; distinguen.</para>
  
   </refsect1>
  </refentry>


 </reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
