 <reference id="ref.regex">
  <title>Funciones para expresiones regulares</title>
  <titleabbrev>Regexps</titleabbrev>
  <partintro>
   <para>
    Las expresiones regulares se usan en PHP para manipular cadenas
	complejas. Las funciones que soportan expresiones regulares son:

    <itemizedlist>
     <listitem>
      <simpara><function>ereg</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>ereg_replace</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>eregi</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>eregi_replace</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>split</function></simpara>
     </listitem>
    </itemizedlist>

	En todas estas funciones, el primer argumento es una expresión
	regular.  PHP utiliza las expresiones regulares extendidas de
	POSIX, definidas en POSIX 1003.2.  Para una descripción completa
	de las expresiones regulares POSIX, ver las páginas de manual de
	regex incluidas en el directorio regex de la distribución de PHP.
	Están en formato de página de manual, por lo que se deben leer con
	una orden como <command>man /usr/local/src/regex/regex.7</command>.

   <!-- Should add discussion of PCRE functions here. --></para>

   <para>
    <example>
     <title>Ejemplos de expresiones regulares</title>
     <programlisting>
ereg(&quot;abc&quot;,$string);            
/* Devuelve true si &quot;abc&quot;
   se encuentra en $string. */

ereg(&quot;^abc&quot;,$string);
/* Devuelve true si &quot;abc&quot;
   se encuentra al comienzo de $string. */

ereg("abc$",$string);
/* Devuelve true si &quot;abc&quot;
   se encuentra al final de $string. */

eregi("(ozilla.[23]|MSIE.3)",$HTTP_USER_AGENT);  
/* Devuelve true si el navegador cliente
   es Netscape 2, 3 o MSIE 3. */

ereg("([[:alnum:]]+) ([[:alnum:]]+) ([[:alnum:]]+)",
     $string,$regs); 
/* Pone tres palabras separadas por espacios
   en $regs[1], $regs[2] y $regs[3]. */

$string = ereg_replace("^","&lt;BR&gt;",$string); 
/* Coloca la etiqueta &lt;BR&gt; al comienzo de $string. */
 
$string = ereg_replace("$","&lt;BR&gt;",$string); 
/* Coloca la etiqueta &lt;BR&gt; al final de $string. */

$string = ereg_replace("\n","",$string);
/* Elimina los caracteres fin-de-línea de $string. */
     </programlisting>
    </example></para>

  </partintro>

  <refentry id="function.ereg">
   <refnamediv>
    <refname>ereg</refname>
    <refpurpose>Coincidencia de expresiones regulares</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcdef>int <function>ereg</function></funcdef>
     <paramdef>string <parameter>pattern</parameter></paramdef>
     <paramdef>string <parameter>string</parameter></paramdef>
     <paramdef>array <parameter><optional>regs</optional></parameter></paramdef>
    </funcsynopsis>
    <simpara>
	 Busca en <parameter>string</parameter> las coincidencias con la
	 expresión regular <parameter>pattern</parameter>.</simpara> 

    <simpara>
	 Si se encuentran coincidencias con subcadenas entre paréntesis de
	 <parameter>pattern</parameter> y la función se ha llamado con el
	 tercer argumento <parameter>regs</parameter>, las coincidencias
	 se almacenarán en los elementos de <parameter>regs</parameter>.
	 $regs[1] contendrá la subcadena que empieza en el primer
	 paréntesis izquierdo; $regs[2] la que comienza en el segundo,
	 etc. $regs[0] contendrá una copia de
	 <parameter>string</parameter>.</simpara>

    <para>
	 La búsqueda diferencia mayúsculas y minúsculas.</para>

    <para>
	 Devuelve un valor verdadero si se encontró alguna coincidencia, o
	 falso in no se encontraron coincidencias u ocurrió algún
	 error.</para>
    
    <para>
	 El siguiente fragmento de código toma una fecha en formato ISO
	 (AAAA-MM-DD) y la imprime en formato DD.MM.AAAA:
     <example>
      <title>ereg() example</title>
      <programlisting>
if ( ereg( "([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})", $date, $regs ) ) {
    echo "$regs[3].$regs[2].$regs[1]";
} else {
    echo "Invalid date format: $date";
}
</programlisting></example></para>

    <para>
	 Ver también <function>eregi</function>,
	 <function>ereg_replace</function>, y 
	 <function>eregi_replace</function>.</para>

   </refsect1>
  </refentry>


  <refentry id="function.ereg-replace">
   <refnamediv>
    <refname>ereg_replace</refname>
    <refpurpose>reemplaza expresiones regulares</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcdef>string <function>ereg_replace</function></funcdef>
     <paramdef>string <parameter>pattern</parameter></paramdef>
     <paramdef>string <parameter>replacement</parameter></paramdef>
     <paramdef>string <parameter>string</parameter></paramdef>
    </funcsynopsis>
    <para>
	 Esta función examina <parameter>string</parameter> buscando
	 coincidencias de <parameter>pattern</parameter>, y reemplaza el
	 texto encontrado con <parameter>replacement</parameter>.</para>

    <para>
	 Devuelve la cadena modificada. Si no hay coincidencias que
	 reemplazar, devuelve la cadena original.</para>

    <para>
	 Si <parameter>pattern</parameter> contiene subcadenas entre
	 paréntesis, <parameter>replacement</parameter> puede contener
	 subcadenas de la forma
	 <literal>\\<replaceable>cifra</replaceable></literal>, que serán
	 reemplazadas por el texto que coincide con la subcadena entre
	 paréntesis que ocupa el lugar indicado por la cifra;
	 <literal>\\0</literal> produce el contenido total de la cadena.
	 Se pueden usar hasta nueve subcadenas. Los paréntesis pueden
	 anidarse; en este caso se cuentan los paréntesis de
	 apertura.</para>

    <para>
	 Si no se encuentran coincidencias en
	 <parameter>string</parameter>, se devuelve
	 <parameter>string</parameter> sin cambios.</para>

    <para>
	 Por ejemplo, el siguiente fragmento de código imprime "This was a
	 test" tres veces:
     <example>
      <title>ereg_replace() example</title>
      <programlisting>
$string = "This is a test";
echo ereg_replace( " is", " was", $string );
echo ereg_replace( "( )is", "\\1was", $string );
echo ereg_replace( "(( )is)", "\\2was", $string );
      </programlisting>
     </example></para>

    <para>
	 Ver también <function>ereg</function>, <function>eregi</function>,
     y <function>eregi_replace</function>.</para>
   </refsect1>
  </refentry>


  <refentry id="function.eregi">
   <refnamediv>
    <refname>eregi</refname>
	<refpurpose>coincidencia de expresiones regulares sin diferenciar
	mayúsculas y minúsculas</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcdef>int <function>eregi</function></funcdef>
     <paramdef>string <parameter>pattern</parameter></paramdef>
     <paramdef>string <parameter>string</parameter></paramdef>
     <paramdef>array <parameter><optional>regs</optional></parameter></paramdef>
    </funcsynopsis>
    <para>
	 Esta función es idéntica a <function>ereg</function>, excepto en
	 que ignora la distinción entre mayúsculas y minúsculas.</para>

    <para>
	 Ver también <function>ereg</function>,
	 <function>ereg_replace</function>, y
	 <function>eregi_replace</function>.</para> 
   </refsect1>
  </refentry>


  <refentry id="function.eregi-replace">
   <refnamediv>
    <refname>eregi_replace</refname>
	<refpurpose>reemplaza expresiones regularse sin diferenciar
	mayúsculas y minúsculas</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcdef>string <function>eregi_replace</function></funcdef>
     <paramdef>string <parameter>pattern</parameter></paramdef>
     <paramdef>string <parameter>replacement</parameter></paramdef>
     <paramdef>string <parameter>string</parameter></paramdef>
    </funcsynopsis>
    <para>
	 Esta función es idéntica a <function>ereg_replace</function>,
	 excepto en que ignora la distinción entre mayúsculas y
	 minúsculas.</para>

    <para>
	 Ver también <function>ereg</function>,
	 <function>eregi</function>, y
	 <function>ereg_replace</function>.</para>

   </refsect1>
  </refentry>


  <refentry id="function.split">
   <refnamediv>
    <refname>split</refname>
	<refpurpose>divide la cadena en elementos de un array según una
	expresión regular</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcdef>array <function>split</function></funcdef>
     <paramdef>string <parameter>pattern</parameter></paramdef>
     <paramdef>string <parameter>string</parameter></paramdef>
     <paramdef>int <parameter><optional>limit</optional></parameter></paramdef>
    </funcsynopsis>
    <para>
	 Devuelve un array de cadenas, cada una de las cuales es una
	 subcadena de <parameter>string</parameter> formada al dividir
	 esta en los límites formados por la expresión regular
	 <parameter>pattern</parameter>. Si ocurre un error, devuelve un
	 valor falso.
	</para>

    <para>
	 Para obtener los cinco primeros campos de una línea de
     <filename>/etc/passwd</filename>:
	 <example>
      <title>split() example</title>
      <programlisting>
$passwd_list = split( ":", $passwd_line, 5 );
	  </programlisting>
	 </example>
	</para>

    <para>
	 Para examinar una fecha que puede estar delimitada por barras,
	 puntos o guiones:
	 <example>
      <title>split() example</title>
      <programlisting>
$date = "04/30/1973";  // Los delimitadores pueden ser barras, puntos o guiones
list( $month, $day, $year ) = split( '[/.-]', $date );
echo "Month: $month; Day: $day; Year: $year&lt;br&gt;\n";
	  </programlisting>
	 </example>
	</para>

    <para>
	 Observar que <parameter>pattern</parameter> distingue entre
	 mayúsculas y minúsculas.
	</para>

	<para>
	 Observar que si no se necesita la potencia de las expresiones
	 regulares, es más rápido utilizar <function>explode</function>,
	 que no carga el motor de expresiones regulares.
	</para>

	<para>
	 Por favor, observar que <parameter>pattern</parameter> es una
	 expresión regular. Si se quiere dividir con alguno de los
	 caracteres especiales de las expresiones regulares, se necesita
	 protegerlo antes. Si pareciera que <function>split</function> (o
	 cualquier otra función de regex) está haciendo algo irregular,
	 léase el archivo <filename>regex.7</filename>, incluido en el
	 subdirectorio <filename>regex</filename> de la distribución de
	 PHP. Está en formato de página de manual, por lo que para leerlo
	 es necesaria una orden como <command>man
	 /usr/local/src/regex/regex.7</command>.
	</para>

    <para>
	 Ver también: <function>explode</function> e
	 <function>implode</function>.
	</para>

   </refsect1>
  </refentry>


  <refentry id="function.sql-regcase">
   <refnamediv>
    <refname>sql_regcase</refname>
	<refpurpose>construye una expresión regular para buscar
	coincidencias sin diferenciar mayúsculas y minúsculas</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcdef>string <function>sql_regcase</function></funcdef>
     <paramdef>string <parameter>string</parameter></paramdef>
    </funcsynopsis>
    <para>
	 Devuelve una expresión regular válida que coincide con
	 <parameter>string</parameter> sin distinguir mayúsculas y
	 minúsculas. Esta expresión es <parameter>string</parameter> con
	 cada carácter convertido a una expresión entre corchetes que
	 contiene el carácter en mayúscula y minúscula, si es posible; en
	 caso contrario, contiene el carácter original dos veces.
     <example>
      <title>sql_regcase() example</title>
      <programlisting>
echo sql_regcase( "Foo bar" );
</programlisting></example>

     imprime <screen>[Ff][Oo][Oo][  ][Bb][Aa][Rr]</screen>.</para>

    <para>
	 Se puede utilizar para lograr coincidencias que no diferencien
	 mayúsculas de minúsculas en productos que sólo soportan
	 expresiones regulares que sí distinguen.</para>
  
   </refsect1>
  </refentry>


 </reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
