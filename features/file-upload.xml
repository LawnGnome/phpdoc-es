<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 303378 Maintainer: jpberdejo Status: ready -->
 <chapter xml:id="features.file-upload" xmlns="http://docbook.org/ns/docbook">
  <title>Manejando la carga de archivos</title>

  <sect1 xml:id="features.file-upload.post-method">
   <title>Carga con el método POST</title>
   <simpara>
    Esta característica permite que los usuarios envien tanto archivos de texto como binarios.
    Con la autenticación de PHP y las funciones de manipulación de archivos,
    se tiene completo control sobre quién está autorizado a cargar y
    que hay que hacer con el archivo una vez que se ha cargado.
   </simpara>
   <simpara>
    PHP es capaz de recibir cargas de archivos de cualquier
    navegador compatible con RFC-1867.
   </simpara>

   <note>
    <title>Configuraciones Relacionadas</title>
    <para>
     Ver también las directivas <link linkend="ini.file-uploads">file_uploads</link>,
     <link linkend="ini.upload-max-filesize">upload_max_filesize</link>,
     <link linkend="ini.upload-tmp-dir">upload_tmp_dir</link>,
     <link linkend="ini.post-max-size">post_max_size</link> y
     <link linkend="ini.max-input-time">max_input_time</link>
     en &php.ini;
    </para>
   </note>

   <para>
    PHP también soporta el método PUT para la carga como lo utilizan los clientes
    <productname>Netscape Composer</productname> y
    <productname>Amaya</productname> del W3C. Ver el <link
    linkend="features.file-upload.put-method">soporte del
    método PUT</link> para más detalles.
   </para>

   <para>
    <example>
     <title>Formulario para la carga de archivos</title>
     <para>
      Una página de carga de archivos puede ser construida mediante la creación de un formulario especial
      el cual se vería algo como esto:
     </para>
     <programlisting role="html">
<![CDATA[
<!-- El tipo de codificación de datos, enctype, se DEBE especificar como a continuación -->
<form enctype="multipart/form-data" action="__URL__" method="POST">
    <!-- MAX_FILE_SIZE debe preceder el campo de entrada de archivo -->
    <input type="hidden" name="MAX_FILE_SIZE" value="30000" />
    <!-- El nombre del elemento de entrada determina el nombre en el array $_FILES -->
    Enviar este archivo: <input name="userfile" type="file" />
    <input type="submit" value="Send File" />
</form>
]]>
     </programlisting>
     <para>
      El <literal>__URL__</literal> en el ejemplo anterior se debe sustituir
      y apuntar a un archivo PHP.
     </para>
     <para>
      El campo oculto <literal>MAX_FILE_SIZE</literal> (medido en bytes) debe
      preceder al campo de entrada de archivo y su valor es el tamaño máximo de archivo aceptado por PHP.
      Este elemento del formulario se debe usar siempre, ya que evita a los usuarios la molestia de
      esperar a que un gran archivo sea transferido sólo para descubrir que era demasiado
      grande y falló la transferencia. Tener en cuenta: engañar a esta configuración en el
      lado del navegador es muy fácil, así que nunca se debe confiar en que archivos con un tamaño mayor
      serán bloqueados por esta característica. Es simplemente una característica de conveniencia para
      los usuarios en el lado cliente de la aplicación. Sin embargo, la configuración de PHP (en el lado del
      servidor) para un máximo de tamaño, no puede ser engañada.
     </para>
    </example>
   </para>

   <note>
    <para>
     Asegúrese de que el formulario de subida de archivos tiene el atributo <literal>enctype="multipart/form-data"</literal>
     de lo contrario la carga de archivos no funcionará.
    </para>
   </note>

   <para>
    El <varname>$_FILES</varname> global
    existe a partir de PHP 4.1.0 (Usar <varname>$HTTP_POST_FILES</varname>
    en su lugar si se utiliza una versión anterior).
    Este array contendrá toda la información sobre el archivo cargado.
   </para>

   <para>
    El contenido de <varname>$_FILES</varname>
    del formulario de ejemplo es el siguiente. Tenga en cuenta que esto asume la utilización del
    nombre del archivo cargado <emphasis>userfile</emphasis>, tal como se utiliza en el script
    de ejemplo anterior. Este puede ser cualquier nombre.
    <variablelist>
     <varlistentry>
      <term><varname>$_FILES['userfile']['name']</varname></term>
      <listitem>
       <para>
        El nombre original del archivo en la máquina cliente.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['type']</varname></term>
      <listitem>
       <para>
        El tipo mime del archivo, si el navegador proporciona esta
        información. Un ejemplo podría ser
        <literal>"image/gif"</literal>. Este tipo mime, sin embargo
        no se verifica en el lado de PHP y por lo tanto no se garantiza
        su valor.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['size']</varname></term>
      <listitem>
       <para>
        El tamaño, en bytes, del archivo subido.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['tmp_name']</varname></term>
      <listitem>
       <para>
        El nombre temporal del archivo en el cual se almacena el archivo
        cargado en el servidor.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['error']</varname></term>
      <listitem>
       <para>
        El <link linkend="features.file-upload.errors">código de error</link>
        asociado a esta carga de archivo. Este elemento fue añadido en PHP 4.2.0
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Los archivos, por defecto se almacenan en el directorio temporal por defecto
    del servidor, a menos que otro lugar haya sido dado con la directiva <link
    linkend="ini.upload-tmp-dir">upload_tmp_dir</link> en
    &php.ini;. El directorio por defecto del servidor puede
    ser cambiado mediante el establecimiento de la variable de entorno
    <envar>TMPDIR</envar> en el entorno en el cual se ejecuta PHP.
    Configurarlo usando <function>putenv</function> desde un script PHP
    no funcionará. Esta variable de entorno también se puede utilizar
    para asegurarse de que las demás operaciones están trabajando sobre los archivos
    cargados.
    <example>
     <title>Validación de la carga de archivos</title>
     <para>
      Ver también las entradas para las funciones <function>is_uploaded_file</function>
      y <function>move_uploaded_file</function> para más información. El
      siguiente ejemplo procesaría la carga de archivo que vendría de un formulario.
     </para>
     <programlisting role="php">
<![CDATA[
<?php
// En versiones de PHP anteriores a 4.1.0, $HTTP_POST_FILES debe utilizarse en lugar
// de $_FILES.

$uploaddir = '/var/www/uploads/';
$uploadfile = $uploaddir . basename($_FILES['userfile']['name']);

echo '<pre>';
if (move_uploaded_file($_FILES['userfile']['tmp_name'], $uploadfile)) {
    echo "El archivo es válido y fue cargado exitosamente.\n";
} else {
    echo "¡Posible ataque de carga de archivos!\n";
}

echo 'Aquí hay más información de depurado:';
print_r($_FILES);

print "</pre>";

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    El script PHP que recibe el archivo cargado, debe implementar
    cualquier lógica que sea necesaria para determinar qué se debe hacer
    con el archivo subido. Se puede, por ejemplo, utilizar la
    variable <varname>$_FILES['userfile']['size']</varname>
    para descartar cualquier archivo que sea demasiado pequeño o demasiado grande. Se
    podría utilizar la
    variable <varname>$_FILES['userfile']['type']</varname>
    para descartar cualquier archivo que no corresponda con un cierto criterio de tipo, pero
    usando esto sólo como la primera de una serie de verificaciones, debido a que este valor
    está completamente bajo el control del cliente y no se comprueba en el lado
    de PHP.
    A partir de PHP 4.2.0, se puede usar <varname>$_FILES['userfile']['error']</varname>
    y el planear la lógica de acuerdo con los <link
    linkend="features.file-upload.errors">códigos de error</link>.
    Cualquiera que sea la lógica, se debe borrar el archivo del
    directorio temporal o moverlo a otra parte.
   </simpara>
   <simpara>
    Si ningún archivo es seleccionado para realizar la carga en el formulario, PHP devolverá
    <varname>$_FILES['userfile']['size']</varname> como 0, y
    <varname>$_FILES['userfile']['tmp_name']</varname> como ninguno.
   </simpara>
   <simpara>
    El archivo será borrado del directorio temporal al final
    de la solicitud si no se ha movido o renombrado.
   </simpara>
    <example>
     <title>Cargando un array de archivos</title>
     <para>
      PHP soporta las <link linkend="faq.html.arrays">funcionalidades array de HTML</link>
      incluso con archivos.
     </para>
     <programlisting role="html">
<![CDATA[
<form action="" method="post" enctype="multipart/form-data">
<p>Pictures:
<input type="file" name="pictures[]" />
<input type="file" name="pictures[]" />
<input type="file" name="pictures[]" />
<input type="submit" value="Send" />
</p>
</form>
]]>
     </programlisting>
     <programlisting role="php">
<![CDATA[
<?php
foreach ($_FILES["pictures"]["error"] as $key => $error) {
    if ($error == UPLOAD_ERR_OK) {
        $tmp_name = $_FILES["pictures"]["tmp_name"][$key];
        $name = $_FILES["pictures"]["name"][$key];
        move_uploaded_file($tmp_name, "data/$name");
    }
}
?>
]]>
     </programlisting>
    </example>
   <para>
    Una barra de progreso de carga de archivos pueden ser implementada mediante <link
    linkend="ini.apc.rfc1867">apc.rfc1867</link>.
   </para>
  </sect1>

  <sect1 xml:id="features.file-upload.errors">
   <title>Explicación de los mensajes de error</title>
   <simpara>
    A partir de PHP 4.2.0, PHP devuelve un código de error apropiado, junto con el
    array del archivo. El código de error se puede encontrar en el
    segmento <literal>error</literal> del array del archivo que PHP crea
    durante la subida del archivo. En otras palabras, el error podría
    encontrarse en <varname>$_FILES['userfile']['error']</varname>.
   </simpara>
   <para>
    <variablelist>
     <varlistentry>
      <term><constant>UPLOAD_ERR_OK</constant></term>
      <listitem>
       <para>
        Valor: 0; No hay error, archivo subido con éxito.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><constant>UPLOAD_ERR_INI_SIZE</constant></term>
      <listitem>
       <para>
        Valor: 1; El archivo subido excede la directiva
        <link linkend="ini.upload-max-filesize">upload_max_filesize</link>
        en &php.ini;.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><constant>UPLOAD_ERR_FORM_SIZE</constant></term>
      <listitem>
       <para>
        Valor: 2; El archivo subido excede la directiva <emphasis>MAX_FILE_SIZE</emphasis>
        que fue especificada en el formulario HTML.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><constant>UPLOAD_ERR_PARTIAL</constant></term>
      <listitem>
       <para>
        Valor: 3; El archivo subido fue sólo parcialmente cargado.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><constant>UPLOAD_ERR_NO_FILE</constant></term>
      <listitem>
       <para>
        Valor: 4; Ningún archivo fue subido.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><constant>UPLOAD_ERR_NO_TMP_DIR</constant></term>
      <listitem>
       <para>
        Valor: 6; Falta la carpeta temporal. Introducido en PHP 4.3.10 y PHP
        5.0.3.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><constant>UPLOAD_ERR_CANT_WRITE</constant></term>
      <listitem>
       <para>
        Valor: 7; No se pudo escribir el archivo en el disco. Introducido en PHP 5.1.0.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
       <term><constant>UPLOAD_ERR_EXTENSION</constant></term>
       <listitem>
         <para>
           Valor: 8; Una extensión de PHP detuvo la carga de archivos. PHP no
           proporciona una forma de determinar cual extensión causó la parada
           de la subida de archivos; el examen de la lista de extensiones cargadas con phpinfo() puede ayudar.
           Introducido en PHP 5.2.0.
         </para>
       </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <note>
    <para>
     Estas se convirtieron en constantes de PHP en PHP 4.3.0.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="features.file-upload.common-pitfalls">
   <title>Dificultades comunes</title>
   <simpara>
    El item <literal>MAX_FILE_SIZE</literal> no puede especificar un tamaño de archivo
    mayor que el que ha sido configurado en el <link
    linkend="ini.upload-max-filesize">upload_max_filesize</link> en
    el archivo &php.ini;. Por defecto es 2 megabytes.
   </simpara>
   <simpara>
    Si hay un límite de memoria activado, un <link
    linkend="ini.memory-limit">memory_limit</link> más grande puede ser necesario.
    Asegurarse de configurar un <link linkend="ini.memory-limit">memory_limit</link>
    lo suficientemente grande.
   </simpara>
   <simpara>
    Si el <link linkend="ini.max-execution-time">max_execution_time</link>
    es demasiado pequeño, la ejecución del script puede excederse de este valor. Asegurarse
    de configurar un <literal>max_execution_time</literal> lo suficientemente grande.
   </simpara>
   <note>
    <simpara>
     <link linkend="ini.max-execution-time">max_execution_time</link> sólo
     afecta al plazo de ejecución del propio script. Todo el tiempo gastado
     en actividades que tengan lugar por fuera de la ejecución del script,
     tales como las llamadas al sistema usando <function>system</function>, la
     función <function>sleep</function>, las consultas a base de datos, el tiempo que tarda
     el proceso de subida de archivos, etc., no se incluye cuando se determina el tiempo
     máximo que el script ha estado funcionando.
    </simpara>
   </note>
   <warning>
    <simpara>
     <link linkend="ini.max-input-time">max_input_time</link> establece el tiempo
     máximo, en segundos, al script se le permite recibir información, esto incluye
     la subida de archivos. Para archivos grandes o múltiples, o usuarios con conexiones más lentas,
     el valor predeterminado de 60 segundos puede ser excedido.
    </simpara>
   </warning>
   <simpara>
    Si <link linkend="ini.post-max-size">post_max_size</link> se establece demasiado
    pequeño, los archivos grandes no pueden ser cargados. Asegurarse de configurar
    <literal>post_max_size</literal> lo suficientemente grande.
   </simpara>
   <simpara>
    A partir de PHP 5.2.12, la
    configuración <link linkend="ini.max-file-uploads">max_file_uploads</link>
    controla el número máximo de archivos que se pueden cargar en una
    petición. Si más archivos que ese límite son subidos, entonces
    <varname>$_FILES</varname> parará de procesar archivos una vez se alcanza
    el límite. Por ejemplo, si
    <link linkend="ini.max-file-uploads">max_file_uploads</link> se establece en
    <literal>10</literal>, entonces <varname>$_FILES</varname> nunca contendrá
    más de 10 elementos.
   </simpara>
   <simpara>
    No validar sobre cual archivo se opera puede significar que los usuarios pueden acceder
    a información sensible en otros directorios.
   </simpara>
   <simpara>
    Por favor tener en cuenta que el <productname>CERN httpd</productname> parece quitar todo
    lo que empieza con primer espacio en blanco en la cabecera de tipo de contenido mime
    que recibe desde el cliente. Mientras este sea el caso, el <productname>CERN httpd</productname>
    no soportará la funcionalidad de carga de archivos.
   </simpara>
   <simpara>
    Debido a la gran cantidad de estilos de lista de directorios, no podemos garantizar
    que los archivos con nombres exóticos (como el que contiene espacios en blanco) se manejen adecuadamente.
   </simpara>
   <simpara>
    Un desarrollador no debe mezclar los campos <literal>input</literal> normales con los de carga de archivos en la misma
    variable de formulario (mediante un nombre de <literal>input</literal> como <literal>foo[]</literal>).
   </simpara>
  </sect1>
  
  <sect1 xml:id="features.file-upload.multiple">
   <title>Subida de múltiples archivos</title>
   <simpara>
    Múltiples archivos pueden ser subidos utilizando diferentes
    <literal>name</literal> para los <literal>input</literal>.
   </simpara>
   <simpara>
    También es posible subir múltiples archivos simultáneamente y
    tener la información organizada automáticamente en arrays. Para
    ello, es necesario utilizar la misma sintaxis de sumisión de array en el
    formulario HTML como se hace con múltiples selects y checkboxes:
   </simpara>
   <para>
    <example>
     <title>Subida de múltiples archivos</title>
     <programlisting role="html">
<![CDATA[
<form action="file-upload.php" method="post" enctype="multipart/form-data">
  Enviar estos archivos:<br />
  <input name="userfile[]" type="file" /><br />
  <input name="userfile[]" type="file" /><br />
  <input type="submit" value="Send files" />
</form>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Cuando el formulario de arriba se remite, los arrays
    <varname>$_FILES['userfile']</varname>,
    <varname>$_FILES['userfile']['name']</varname> y
    <varname>$_FILES['userfile']['size']</varname> serán
    inicializados (así como en <varname>$HTTP_POST_FILES</varname> para las versiones de PHP anteriores
    a 4.1.0).
    Cuando <link linkend="ini.register-globals">register_globals</link> está activado, globales para los archivos subidos
    también se inicializan. Cada uno de estos será un array indexado
    numéricamente de los valores correspondientes a los archivos remitidos.
   </simpara>
   <simpara>
    Por ejemplo, suponga que los nombres de archivo
    <filename>/home/test/review.html</filename> y
    <filename>/home/test/xwp.out</filename> son remitidos. En este
    caso,<varname>$_FILES['userfile']['name'][0]</varname>
    contendría el valor <filename>review.html</filename>, y
    <varname>$_FILES['userfile']['name'][1]</varname> contendría
    el valor <filename>xwp.out</filename>. De manera similar,
    <varname>$_FILES['userfile']['size'][0]</varname> contendría
    el tamaño del archivo <filename>review.html</filename> y así sucesivamente.
   </simpara>
   <simpara>
    <varname>$_FILES['userfile']['name'][0]</varname>,
    <varname>$_FILES['userfile']['tmp_name'][0]</varname>,
    <varname>$_FILES['userfile']['size'][0]</varname>, y
    <varname>$_FILES['userfile']['type'][0]</varname> también
    son establecidos.
   </simpara>
   <warning>
    <simpara>
     A partir de PHP 5.2.12, la
     configuración <link linkend="ini.max-file-uploads">max_file_uploads</link>
     actúa como un límite en el número de archivos que se pueden
     subir en una petición. Se necesita asegurar que el formulario no
     intenta cargar más archivos que este límite en una petición.
    </simpara>
   </warning>
  </sect1>

  <sect1 xml:id="features.file-upload.put-method">
   <title>Soporte del método PUT</title>
   <para>
    PHP ofrece soporte para el método HTTP PUT utilizado por algunos clientes para almacenar
    archivos en un servidor.
    Las peticiones PUT son mucho más simples que una carga de archivos mediante solicitudes POST
    y se ven algo como esto:
    <informalexample>
     <programlisting role="HTTP">
<![CDATA[
PUT /path/filename.html HTTP/1.1
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Esto normalmente significa que el cliente remoto quiere guardar
    el contenido que sigue como: <filename>/path/filename.html</filename>  en el árbol web.
    Obviamente no es una buena idea para Apache o PHP dejar automáticamente
    a todo el mundo que pueda sobrescribir cualquier archivo del árbol web. Para manejar
    esta solicitud se debe primero decir al servidor web que se
    desea que cierto script de PHP maneje la petición. En Apache se hace
    esto con la directiva de <emphasis>Script</emphasis>. Se puede
    colocar casi en cualquier parte del archivo de configuración de Apache. Un
    lugar común es dentro de un bloque <literal>&lt;Directory&gt;</literal> o tal vez dentro
    de un bloque <literal>&lt;VirtualHost&gt;</literal>. Una línea como ésta haría el truco:
    <informalexample>
     <programlisting>
<![CDATA[
Script PUT /put.php
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Esto le dice a Apache que envíe todas peticiones PUT para URIs que coincidan con
    el contexto en el cual se pone esta línea en el script <filename>put.php</filename>. Esto
    asume, por supuesto, que se tiene habilitado PHP para la extensión
    <filename>.php</filename> y que PHP está activo. El recurso de destino para todas las
    solicitudes PUT a este script tiene que ser en propio script, el archivo subido
    no debe tener un nombre de archivo.
   </simpara>
   <simpara>
    Con PHP entonces se haría algo como lo siguiente en
    el put.php. Esto copiaría el contenido del archivo subido al
    archivo <filename>myputfile.ext</filename> en el servidor.
    Es probable que se deseen realizar algunas verificaciones y/o
    autenticar al usuario antes de realizar esta copia de archivo.
   </simpara>
   <para>
    <example>
     <title>Guardando archivos HTTP PUT</title>
     <programlisting role="php">
<![CDATA[
<?php
/* datos PUT vienen en en el flujo de entrada estándar  */
$putdata = fopen("php://input", "r");

/* Abre un archivo para escribir */
$fp = fopen("myputfile.ext", "w");

/* Leer los datos de 1 KB a la vez
   y escribir en el archivo */
while ($data = fread($putdata, 1024))
  fwrite($fp, $data);

/* Cerrar los flujos */
fclose($fp);
fclose($putdata);
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

