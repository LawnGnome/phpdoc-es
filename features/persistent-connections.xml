<?xml version="1.0" encoding="iso-8859-1"?>
 <chapter id="features.persistent-connections">
  <title>Conexiones persistentes a bases de datos</title>

  <simpara>
   Las conexiones persistentes son enlaces SQL que no se cierran
   cuando termina la ejecuci&oacute;n del archivo de comandos.
   Cuando se pide una conexi&oacute;n persistente, PHP comprueba
   si hay ya una conexi&oacute;n persistente id&eacute;ntica (que
   permanec&iacute;a abierta desde antes) - y si existe, la usa.
   Si no existe, crea un enlace. Una conexi&oacute;n 'id&eacute;ntica'
   es una conexi&oacute;n que se abri&oacute; hacia el mismo "host", con
   el mismo nombre de usuario y la misma contrase&ntilde;a (donde sea
   aplicable).
  </simpara>
  <note>
   <para>
    Existen otras extensiones que proporcionan conexiones persistentes, 
    tal como la <link linkend="ref.imap">extensi&oacute;n IMAP</link>
   </para>
  </note>
  <simpara>
   La gente que no est&aacute; familiarizada con el modo como trabajan
   y distribuyen la carga los servidores "web" puede confundir que 
   significa conexiones persistentes.  En particular, 
   <emphasis>no</emphasis> te dan la habilidad de abrir 
   'sesiones de usuario' en el mismo enlace SQL, 
   <emphasis>no</emphasis> dan la habilidad de construir una 
   transacci&oacute;n de forma eficiente, y no hacen un mont&oacute;n de
   otras cosas. De hecho, para ser extremadamente claros sobre el tema
   las conexiones persistentes no te dan <emphasis>ninguna</emphasis>
   functionalidad que no fuera posible con sus hermanas 
   no-persistentes.
  </simpara>

  <simpara>
   &iquest;Por qu&eacute;?
  </simpara> 

  <simpara>
   Esto tiene que ver con el modo como funcionan los servidores "web".
   Hay tres modos en que un servidor "web" puede utilizar PHP para generar
   p&aacute;ginas web.
  </simpara>

  <simpara>
   El primer m&eacute;todo es usar PHP como una capa CGI. Cuando corre
   de este modo, se crea y destruye una instancia del int&eacute;rprete
   PHP por cada p&aacute;gina solicitada (para una p&aacute;gina PHP)
   a tu servidor. Debido a que se destruye despu&eacute;s de cada
   petici&oacute;n, cualquier recurso que adquiera (como un enlace a un
   servidor de base de datos SQL) se cierra cuando es destruido. En
   este caso, no se gana nada si se intentan usar conexiones persistentes,
   ya que simplemente no persisten.
   </simpara>

  <simpara>
   El segundo, y m&aacute;s popular, m&eacute;todo es correr PHP como
   un m&oacute;dulo en un servidor web multiproceso, lo cual actualmente
   s&oacute;lo incluye Apache. Un servidor multiproceso tiene 
   t&iacute;picamente un proceso (el padre) que coordina un conjunto de
   procesos (sus hijos) que realmente hacen el trabajo se servir las
   p&aacute;ginas web. Cuando entra cada petici&oacute;n de un cliente,
   es entregada a uno de los hijos que no est&eacute; ya sirviendo a
   otro cliente. Esto significa que cuando el mismo cliente hace una
   segunda petci&oacute;n al servidor, puede ser atendido por un proceso
   hijo distinto del de la primera vez. Lo que una conexi&oacute;n persistente
   hace por ti en este caso es hacerlo de tal modo que cada proceso hijo
   s&oacute;lo necesita conectar a tu SQL server la primera vez que sirve
   una p&aacute;gina que hace uso de una conexi&oacute;n as&iacute;. Cuando
   otra p&aacute;gina solicita una conexi&oacute;n a SQL server, puede
   reutilizar la conexi&oacute;n que el hijo estableci&oacute; previamente.
   </simpara>

  <simpara>
   El &uacute;ltimo m&eacute;todo es usar PHP como un "plug-in" para un
   servidor web multihilo. En la actualidad es solamente te&oacute;rico --
   PHP no funciona a&uacute;n como "plug-in" para ning&uacute;n servidor
   web multihilo. Actualmente PHP 4 soporta ISAPI, WSAPI y
   NSAPI (en Windows), lo cual permite a PHP ser utilizado como
   "plug-in" para servidores web multihilo como Netscape FastTrack,
   Internet Information Server (IIS) de Microsoft, y O'Reilly's WebSite Pro.
   El comportamiento es exactamente el mismo que para el modelo de 
   multiprocesador descrito anteriormente. Tener en cuanta que el soporte
   para SAPI no est&aacute; disponible en PHP 3.</simpara>

  <simpara>
   Si las conexiones persistentes no aportan ninguna funcionalidad
   a&ntilde;adida, &iquest;para qu&eacute; son buenas?</simpara>

  <simpara>
   La respuesta aqui es extremadamente simple -- eficiencia. Las conexiones
   persistentes son buenas si las cabeceras de control para crear un enlace 
   a tu servidor SQL es alta. Que estas cabeceras sean o no realmente altas
   depende de muchos factores. Como, qu&eacute clase de base de datos es, si
   esta o no situada en el mismo ordenador que el servidor web, c&oacute;mo
   est&aacute; de cargada la m&aacute;quina donde se encuentre el servidor
   SQL, y otras as&iacute;. El hecho fundamental es que si la cabecera de
   conexi&oacute;n es alta, las conexiones persistentes te ayudan 
   considerablemente . Ellas hacen que el proceso hijo simplemente conecte
   solamente una vez durante todo su intervalo de vida, en vez de
   cada vez que procesa una pagina que requiere conectar al servidor SQL.
   Esto significa que por cada hijo que abri&oacute; una conexi&oacute;n
   persistente tendr&aacute; su propia conexi&oacute;n persistente al servidor.
   Por ejemplo, si tienes 20 procesos hijos distintos que corran un
   archivo de comandos que cree una conexi&oacute;n persistente a tu
   servidor SQL, tendr&iacute;as 20 conexiones diferentes a ti servidor
   SQL, una por cada hijo.
  </simpara>

   <simpara>
   No obstante, hay que tener en cuenta que esto puede tener desventajas
   si estais utilizando una base de datos con l&iacute;mites de conexi&oacute;n, por debajo
   del numero de procesos hijo con conexiones persistentes. Si
   tu base de datos tiene un l&iacute;mite de 16 conexiones simultaneas y en
   el curso de una sesi&oacute;n de servidor, 17 procesos hijo intentan conectarse, 
   uno de ellos no podr&aacute; hacerlo. Si existen errores en los scripts, que
   no permitan terminar la conexion (p.ej.bucles infinitos), una base
   de datos con solo 32 conexiones puede ser r&aacute;pidamente hundida. Comprobar
   la documentacion de vuestra base de datos para obtener informaci&oacute;n sobre 
   que hacer con conexiones abandonadas &oacute; libres.
  </simpara>
  <warning>
   <simpara>
    Un par de advertencias m&aacute;s a tener en cuenta cuando utiliceis
    conexiones persistentes. La primera, si utilizais bloqueos
    en una tabla desde una conexi&oacute;n persistente y  por cualquier
    causa el script no puede desbloquear la tabla, todos los scripts
    posteriores que usen esta conexi&oacute;n, quedar&aacute;n bloqueados indefin&iacute;damente
    y se requerir&aacute; que, &oacute; bien el servidor httpd &oacute; la base de datos sean
    arrancados de nuevo.
    La segunda, cuando utiliceis transacciones. Un bloqueo por transacci&oacute;n
    ser&aacute; heredado por el pr&oacute;ximo script usando la conecci&oacute;n, si la ejecuci&oacute;n del
    primer script termina antes que el bloqueo. en anbos caso podeis
    utilizar <function>register_shutdown_function</function> para registrar
    una funcion simple de limpieza que desbloquee las tablas &oacute; deshaga
    la transacci&oacute;n. Lo mejor para evitar problemas es no usar 
    conexiones persistentes en scripts que usen bloqueos de tablas &oacute;
    transacciones (para todolo dem&aacute;s pueden ser usadas sin problemas)
   </simpara>
  </warning>

  <simpara>
   Un resumen importante. Las conexiones persistentes fueron dise&ntilde;adas
   para tener una equivalencia uno-a-uno con las conexiones normales.
   Eso significa que deber&iacute;ais <emphasis>siempre</emphasis> ser capaz
   de reemplazar las conexiones persistentes por conexiones no persistentes
   y no cambiar&aacute, el modo como se comporta el archivo de comandos.
   <emphasis>Puede</emphasis> cambiar la eficiencia del archivo de comandos
   (y probablemete lo har&aacute;), &iexcl;pero no su comportamiento!
   </simpara>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
