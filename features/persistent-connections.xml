 <chapter id="features.persistent-connections">
  <title>Conexiones persistentes a bases de datos</title>

  <simpara>
   Las conexiones persistentes son enlaces SQL que no se cierran
   cuando termina la ejecuci&oacute;n del archivo de comandos.
   Cuando se pide una conexi&oacute;n persistente, PHP comprueba
   si hay ya una conexi&oacute;n persistente id&eacute;ntica (que
   permanec&iacute;a abierta desde antes) - y si existe, la usa.
   Si no existe, crea un enlace. Una conexi&oacute;n 'id&eacute;ntica'
   es una conexi&oacute;n que se abri&oacute; hacia el mismo "host", con
   el mismo nombre de usuario y la misma contrase&ntilde;a (donde sea
   aplicable).</simpara>

  <simpara>
   La gente que no est&aacute; familiarizada con el modo como trabajan
   y distribuyen la carga los servidores "web" puede confundir que 
   persistente significa lo que no es.  En particular, ellas 
   <emphasis>no</emphasis> te dan la habilidad de abrir 
   'sesiones de usuario' en el mismo enlace SQL, 
   <emphasis>no</emphasis> dan la habilidad de construir una 
   transacci&oacute;n de forma eficiente, y no hacen un mont&oacute;n de
   otras cosas. De hecho, para ser extremadamente claros sobre el tema
   las conexiones persistentes no te dan <emphasis>ninguna</emphasis>
   functionalidad que no fuera posible con sus hermanas 
   no-persistentes.</simpara>

  <simpara>
   &iquest;Por qu&eacute;?</simpara> 

  <simpara>
   Esto tiene que ver con el modo como funcionan los servidores "web".
   Hay tres modos en que un servidor "web" puede utilizar PHP para generar
   p&aacute;ginas web.</simpara>

  <simpara>
   El primer m&eacute;todo es usar PHP como una capa CGI. Cuando corre
   de este modo, se crea y destruye una instancia del int&eacute;rprete
   PHP por cada p&aacute;gina solicitada (para una p&aacute;gina PHP)
   a tu servidor. Debido a que se destruye despu&eacute;s de cada
   petici&oacute;n, cualquier recurso que adquiera (como un enlace a un
   servidor de base de datos SQL) se cierra cuando es destruido. En
   este caso, no se gana nada si se intentan usar conexiones persistentes.
   </simpara>

  <simpara>
   El segundo, y m&aacute;s popular, m&eacute;todo es correr PHP como
   un m&oacute;dulo en un servidor web multiproceso, lo cual actualmente
   s&oacute;lo incluye Apache. Un servidor multiproceso tiene 
   t&iacute;picamente un proceso (el padre) que coordina un conjunto de
   procesos (sus hijos) que realmente hacen el trabajo se servir las
   p&aacute;ginas web. Cuando entra cada petici&oacute;n de un cliente,
   es entregada a uno de los hijos que no est&eacute; ya sirviendo a
   otro cliente. Esto significa que cuando el mismo cliente hace una
   segunda petci&oacute;n al servidor, puede ser atendidp por un proceso
   hijo distinto del de la primera vez. Lo que una conexi&oacute;n persistente
   hace por ti en este caso es hacerlo de tal modo que cada proceso hijo
   s&oacute;lo necesita conectar a tu SQL server la primera vez que sirve
   una p&aacute;gina que hace uso de una conexi&oacute;n as&iacute;. Cuando
   otra p&aacute;gina solicita una conexi&oacute;n a SQL server, puede
   reutilizar la conexi&oacute;n que el hijo estableci&oacute; previamente.
   </simpara>

  <simpara>
   El &uacute;ltimo m&eacute;todo es usar PHP como un "plug-in" para un
   servidor web multihilo. En la actualidad es solamente te&oacute;rico --
   PHP no funciona a&uacute;n como "plug-in" para ning&uacute;n servidor
   web multihilo. Hay trabajo en progreso para soportar ISAPI, WSAPI y
   NSAPI (en Windows), lo cual permitir&aacute; a PHP ser utilizado como
   "plug-in" para servidores web multihilo como Netscape FastTrack,
   Internet Information Server (IIS) de Microsoft, y O'Reilly's WebSite Pro.
   Cuando esto ocurra, el comportamiento ser&aacute; exactamente el mismo
   que para el modelo de multiprocesador descrito anteriormente.</simpara>

  <simpara>
   Si las conexiones persistentes no aportan ninguna funcionalidad
   a&ntilde;adida, &iquest;para qu&eacute; son buenas?</simpara>

  <simpara>
   La respuesta aqui es extremadamente simple -- eficiencia. Las conexiones
   persistentes son buenas si las cabeceras de control para crear un enlace 
   a tu servidor SQL es alta. Que estas cabeceras sean o no realmente altas
   depende de muchos factores. Como, qu&eacute clase de base de datos es, si
   esta o no situada en el mismo ordenador que el servidor web, c&oacute;mo
   est&aacute; de cargada la m&aacute;quina donde se encuentre el servidor
   SQL, y otras as&iacute;. El hecho fundamental es que si la cabecera de
   conexi&oacute;n es alta, las conexiones persistentes te ayudan 
   considerablemente . Ellas hacen que el proceso hijo simplemente conecte
   solamente una vez durante todo su intervalo de vida, en vez de
   cada vez que procesa una pagina que requiere conectar al servidor SQL.
   Esto significa que por cada hijo que abri&oacute; una conexi&oacute;n
   persistente tendr&aacute; su propia conexi&oacute;n persistente al servidor.
   Por ejemplo, si tienes 20 procesos hijos distintos que corran un
   archivo de comandos que cree una conexi&oacute;n persistente a tu
   servidor SQL, tendr&iacute;as 20 conexiones diferentes a ti servidor
   SQL, una por cada hijo.</simpara>

  <simpara>
   Un resumen importante. Las conexiones persistentes fueron dise&ntilde;adas
   para tener una equivalencia uno-a-uno con las conexiones normales.
   Eso significa que deber&iacute;s <emphasis>siempre</emphasis> ser capaz
   de reemplazar las conexiones persistentes por conexiones no persistentes
   y no cambiar&aacute, el modo como se comporta el archivo de comandos.
   <emphasis>Puede</emphasis> cambiar la eficiencia del archivo de comandos
   (y probablemete lo har&aacute;), &iexcl;pero no su comportamiento!
   </simpara>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
