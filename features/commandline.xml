<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.4 $ -->
<!-- EN-Revision: 1.20 Maintainer: angela Status: ready -->
<chapter xml:id="features.commandline" xmlns="http://docbook.org/ns/docbook">
 <title>Usando PHP desde la l&iacute;nea de comando</title>
 <!-- NEW DOCUMENTATION STARTS -->
  <para>
  Desde la versi&oacute;n 4.3.0, <literal>PHP</literal> 
  soporta un nuevo tipo de <literal>SAPI</literal> 
  (Interfaz De Programaci&oacute;n De Uso Del Servidor) 
  llamada <literal>CLI</literal> que significa literalmente 
  <emphasis> interfaz de l&iacute;nea de comando 
  (Command Line Interface)</emphasis>. Como el nombre implica, 
  este tipo de <literal>SAPI</literal> se foca en la 
  creaci&oacute;n de aplicaciones que pueden correr desde 
  la l&iacute;nea de comando (o desde el desktop tambi&eacute;n) 
  con <literal>PHP</literal>. Hay algunas diferencias dentro del 
  <literal>CLI SAPI</literal> y otros <literal>SAPI</literal> 
  que son explicadas en este cap&iacute;tulo. Es importante 
  mencionar que <literal>CLI</literal> y <literal>CGI</literal> 
  son diferentes clases de SAPI y comparten algunas 
  caracter&iacute;sticas.  
 </para>
 <para>
 
  
  La interfaz llamada <literal>CLI SAPI</literal> 
  fue introducida con <literal>PHP 4.2.0</literal>, 
  pero es todav&iacute;a en estado experimental y 
  tiene que ser activada expl&iacute;citamente con 
  <literal>--enable-cli</literal> cuando usando 
  <literal>./configure</literal>. Desde 
  <literal>PHP 4.3.0</literal> la interfaz 
  <literal>CLI SAPI</literal> es activada 
  autom&aacute;ticamente. Tu puedes usar 
  <literal>--disable-cli</literal> para de-activarla.
 </para>
 <para>
  
  Desde <literal>PHP 4.3.0</literal>, el nombre, 
  locaci&oacute;n, y existencia de los binarios CLI/CGI 
  ser&aacute;n diferentes dependiendo en como Instales 
  <literal>PHP</literal> en tu sistema.
  Cuando ejecutes <literal>make</literal>, CGI, y CLI son 
  compilados autom&aacute;ticamente, y puestas como 
  <literal>sapi/cgi/php</literal> y <literal>sapi/cli/php</literal> 
  respectivamente, en el directorio "source" de 
  <literal>PHP</literal>. Debes notar, que los dos son 
  llamados <literal>php</literal>. Lo que ocurre durante 
  el proceso <literal>make</literal> depende en tu 
  l&iacute;nea de configuraci&oacute;n (./configure). 
  
  Si el modulo <literal>SAPI</literal> es seleccionado 
  durante tu configuraci&oacute;n, como por ejemplo 
  <literal>apxs</literal>, o la opci&oacute;n 
  <literal>--disable-cgi</literal> es usada, el 
  <literal>CLI</literal> es copiado a 
  <literal>{PREFIX}/bin/php</literal> durante la 
  ejecuci&oacute;n del comando <literal>make install</literal> 
  de otras maneras el CGI es instalado aqu&iacute;. 
  Por ejemplo, si pones <literal>--with-apxs</literal> en tu 
  configuraci&oacute;n, entonces el <literal>CLI</literal> 
  es copiado a <literal>{PREFIX}/bin/php</literal> durante 
  <literal>make install</literal>. Si tu quieres sobrescribir 
  la instalaci&oacute;n del <literal>CGI</literal> binario, 
  utiliza <literal>make install-cli</literal> despu&eacute;s 
  de usar <literal> make install</literal>. Alternativamente 
  puedes especificar <literal>--disable-cgi</literal> en tu 
  l&iacute;nea de configuraci&oacute;n.
 </para>
 <note>
  <para>
   
   Por que ambos <literal>--enable-cli</literal> y 
   <literal>--enable-cgi</literal> son activados 
   autom&aacute;ticamente, simplemente teniendo 
   <literal>--enable-cli</literal> en tu l&iacute;nea 
   de configuraci&oacute;n no necesariamente significa 
   que <literal>CLI</literal> son copiados a 
   <literal>{PREFIX}/bin/php</literal> durante 
   <literal>make install</literal>.
  </para>
 </note>
 <para>
  Los archivos de <literal>PHP 4.2.0</literal> y <literal>
  PHP 4.2.3</literal> distribu&iacute;an el CLI como 
  <filename>php-cli.exe</filename>, y los manten&iacute;a en 
  el mismo directorio que el CGI <filename>php.exe</filename>. 
  Empezando con <literal>PHP 4.3.0</literal> el archivo 
  para windows distribuye el CLI como <filename>php.exe</filename> 
  en un directorio llamado cli; o sea <literal>cli/php.exe</literal>.
 </para>
 <note>
  <title>Que versi&oacute;n de SAPI tengo?</title>
  <para>
   Desde tu l&iacute;nea de comando, ejecutando 
   <literal>php -v</literal> te dejara saber si 
   <literal>php</literal> es <literal>CGI</literal> o 
   <literal>CLI</literal>.
  </para>
 </note>
 <para>
  Diferencias remarcables del <literal>CLI SAPI</literal> 
  comparadas con otros <literal>SAPI</literal>s:
  <literal>SAPI</literal>s:
  <itemizedlist>
   <listitem>
    <para>
     En esta clase de <literal>CGI SAPI</literal> no hay 
     cabeceras ("headers") escritas en el resultado ("output").
    </para>
    <para>
     
     Aunque el <literal>CGI SAPI</literal> provee una manera de 
     suprimir HTTP cabeceras ("headers"), no existe una 
     opci&oacute;n equivalente que los activa en el 
     <literal>CLI SAPI</literal>.
    </para>
    <para>
     <literal>CLI</literal> autom&aacute;ticamente empieza 
     en modo silencioso, la opci&oacute;n <literal>-q</literal> 
     existe por compatibilidad con antiguos programas 
     <literal>CGI</literal>.
    </para>
    <para>
     No cambia el directorio corriente, a ese en el cual el 
     programa vive. La opci&oacute;n <literal>-C</literal> 
     es mantenida por compatibilidad.
    </para>
    <para>
     Errores son reportados en texto, no en el formato HTML.
    </para>
   </listitem>
   <listitem>
    <para>
     Hay ciertas directivas en el &php.ini; que son 
     sobrescrita por el <literal>CLI SAPI</literal> por que 
     estas no hacen mucho sentido en situaciones donde la 
     l&iacute;nea de comando es usada:
     <table>
      <title>Directivas sobrescrita en &php.ini;</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Directivas (directives)</entry>
         <entry><literal>CLI SAPI</literal> evalu&oacute; 
         autom&aacute;tico (default value)</entry>
         <entry>Commentario (comment)</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><link linkend="ini.html-errors">html_errors</link></entry>
         <entry>&false;</entry>
         <entry>
          Cuando los resultados incorrectos aparecen en tu 
          l&iacute;nea de comando, puede ser dif&iacute;cil hacer 
          sentido de ellos con todas esas <literal>HTML</literal> 
          tags, por esta raz&oacute;n, esta directiva es 
          autom&aacute;ticamente &false;.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
         <entry>&true;</entry>
         <entry>
          Es deseoso que los resultados de <function>print 
          (imprimir)</function>, <function>echo (ecco)</function> 
          y otras relacionadas, sean inmediatamente escritas como 
          resultados y no mantenidas en ning&uacute;n buffer. Tu 
          todav&iacute;a puedes usar 
          <link linkend="ref.outcontrol">output buffering</link> 
          si tu quieres manipular los resultados proveidos 
          autom&aacute;ticamente. 
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
         <entry>0 (unlimited)</entry>
         <entry>
          Debido un numero ilimitado de posibilidades de usar 
          <literal>PHP</literal> en la l&iacute;nea de comando, 
          el m&aacute;ximo tiempo de ejecuci&oacute;n es ilimitado. 
          Aunque aplicaciones escritas para el Internet, usualmente 
          requieres una r&aacute;pida ejecuci&oacute;n, la clase de 
          aplicaci&oacute;n que es ejecutada desde la l&iacute;nea 
          de comando, usualmente necesitan mas tiempo para ejecutar 
          correctamente.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
         <entry>&true;</entry>
         <entry>
         <para>
          Por que estas opciones son &true; tu siempre necesitaras 
          acceso al <emphasis>argc</emphasis> (el numero de argumentos 
          pasados a la aplicaci&oacute;n) y <emphasis>argv</emphasis> 
          (el array de argumentos) en el <literal>CLI SAPI</literal>.
         </para>
         <para>
          Desde la versi&oacute;n 4.3.0 de <literal>PHP</literal>, 
          las variables <varname>$argc</varname> y 
          <varname>$argv</varname> son registradas y llenadas con 
          los  resultados apropiados cuando usando 
          <literal>CLI SAPI</literal>. Antes de esta versi&oacute;n, 
          la creaci&oacute;n de estas variables es similar a como en 
          <literal>CGI</literal> y <literal>MODULE</literal> 
          versiones que requiere la PHP directiva 
          <link linkend="ini.register-globals">register_globals</link> 
          estar <emphasis>on (active)</emphasis>. Sin importar 
          la versi&oacute;n o la configuraci&oacute;n de 
          <link linkend="ini.register-globals">register_globals</link> 
          tu siempre puedes trabajar por medio de 
          <link linkend="reserved.variables.server">$_SERVER</link> 
          o <varname>$HTTP_SERVER_VARS</varname>. Por ejemplo:
          <varname>$_SERVER['argv']</varname>
          
         </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <para>
      Estas instrucciones no pueden ser iniciadas con 
      valores que son diferentes a los de la configuraci&oacute;n 
      en &php.ini; o el archivo correspondiente. Esta es una 
      limitaci&oacute;n dada por que esos valores autom&aacute;ticos, 
      son aplicados despu&eacute;s de que todos los archivos 
      conteniendo par&aacute;metros de configuraci&oacute;n an 
      sido ejecutados; PERO, esto valores pueden ser cambiados 
      mientras to programa esta ejecutando (esto no hace sentido 
      para todas las directivas, como por ejemplo 
      <link linkend="ini.register-argc-argv">register_argc_argv</link>).
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     Para facilitar trabajando en la l&iacute;nea de comando, 
     las siguientes constantes son definidas:
     <table>
      <title>constantes especificas de CLI</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Constant (constante)</entry>
         <entry>Description (descripci&oacute;n)</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><constant>STDIN</constant></entry>
         <entry>
         Una stream abierta hacia <literal>stdin</literal>. 
         Esto nos salva de abrirla con          
         <programlisting role="php">
<![CDATA[
$stdin = fopen('php://stdin', 'r');
]]>  
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDOUT</constant></entry>
         <entry>
         Una stream abierta hacia <literal>stdout</literal>. 
         Esto nos salva de abrirla con          
         <programlisting role="php">
<![CDATA[
$stdout = fopen('php://stdout', 'w');
]]>
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDERR</constant></entry>
         <entry>
         Una stream abierta hacia <literal>stderr</literal>. 
         Esto nos salva de abrirla con 
         <programlisting role="php">
<![CDATA[
$stderr = fopen('php://stderr', 'w');
]]>
         </programlisting>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     Dado lo anterior, tu no necesitas abrir, como por ejemplo, 
     una stream hacia <literal>stderr</literal> manualmente, 
     solamente necesitas usar la constante en vez de usar los 
     recursos de la stream:      
     <programlisting role="php">
<![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
     </programlisting>
     No necesitas cerrar estas stream expl&iacute;citamente, 
     desde que son cerradas autom&aacute;ticamente por 
     <literal>PHP</literal> cuando tu programa termina. 
    </para>
   </listitem>
   <listitem>
    <para>
     El <literal>CLI SAPI</literal> <emphasis
     role="strong">no</emphasis> cambia el directorio en el 
     cual to estas corrientemente, al directorio donde el 
     programa ejecutado vive!
    </para>
    <para>
     Ejemplo mostrando la diferencia al <literal>CGI SAPI</literal>:
     <programlisting role="php">
<![CDATA[
<?php
    /* Nuestra aplicaci&oacute;n llamada.php*/
    echo getcwd(), "\n";
?>
]]>
     </programlisting>
    </para>
    <para>
     Cuando usas la versi&oacute;n <literal>CGI</literal> 
     el resultado es:
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -q otro_directorio/test.php
/tmp/otro_directorio
]]>
     </screen>
     Esto claramente muestra que <literal>PHP</literal> 
     cambia su directorio al usado por el programa que ejecutas.
    </para>
    <para>
     Usando el <literal>CLI SAPI</literal> resulta:
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -f otro_directorio/test.php
/tmp
]]>
     </screen>
     Esto no da mas flexibilidad cuando escribiendo 
     utilidades en la l&iacute;nea de comando con 
     <literal>PHP</literal>.
    </para>
    <note>
     <para>
      </para>
    </note>
   </listitem>
  </itemizedlist>
 </para>
 <para>
 
  Puedes obtener acceso a la lista de opciones proveida por 
  <literal>PHP</literal> ejecutando <literal>PHP</literal> 
  con el <literal>-h</literal>switch:
  <screen>
<![CDATA[
Usage: php [options] [-f] <file> [args...]
       php [options] -r <code> [args...]
       php [options] [-- args...]
  -s               Display colour syntax highlighted source.  
  -w               Display source with stripped comments and whitespace.
  -f <file>        Parse <file>.
  -v               Version number
  -c <path>|<file> Look for php.ini file in this directory
  -a               Run interactively
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -z <file>        Load Zend extension <file>.
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -i               PHP information
  -r <code>        Run PHP <code> without using script tags <?..?>
  -h               This help

  args...          Arguments passed to script. Use -- args when first argument 
                   starts with - or script is read from stdin
]]>
  </screen>
  
  Aunque los resultados anteriores siempre ser&aacute;n 
  dados en ingles, a continuaci&oacute;n te dar&eacute; 
  una lista que probablemente sera muy &uacute;til:
    <screen>
  <![CDATA[
  Usage: php [options] [-f] <file> [args...]
         php [options] -r <code> [args...]
         php [options] [-- args...]
    -s               Display colour syntax highlighted source.  
                     (colorear el sintaxis en el c&oacute;digo)
    -w               Display source with stripped comments and whitespace.
                     (remueve los comentarios y espacios del c&oacute;digo) 
    -f <file>        Parse <file>.
                     (analiza <file>)
    -v               Version number
                     (la versi&oacute;n de PHP que estas usando)
    -c <path>|<file> Look for php.ini file in this directory
                     (usa el php.ini archivo localizado aqu&iacute;)
    -a               Run interactively
                     (interactivo)
    -d foo[=bar]     Define INI entry foo with value 'bar'
                     (define foo con el valor 'bar' en php.ini)
    -e               Generate extended information for debugger/profiler
                     (genera mas informaci&oacute;n para el debugger/profiler) 
    -z <file>        Load Zend extension <file>.
                     (inicia las exenciones Zend <archive>)
    -l               Syntax check only (lint)
                     (Mira al sintaxis (lint))
    -m               Show compiled in modules
                     (muestra los m&oacute;dulos compilados)
    -i               PHP information
                     (informaci&oacute;n PHP)
    -r <code>        Run PHP <code> without using script tags <?..?>
                     (ejecuta PHP <code> sin usar las tags <?..?> en el script
    -h               This help
                     (estas opciones)  
    args...          Arguments passed to script. Use -- args when first argument 
                     starts with - or script is read from stdin
                     (Argumentos pasados al programa. Usa -- args cuando el primer 
                     argumento empieza con - o tu programa es le&iacute;do directamente desde stdin)
  ]]>
  </screen>
 </para>
 <para>
  El <literal>CLI SAPI</literal> tiene tres diferentes maneras 
  de obtener el c&oacute;digo <literal>PHP</literal> que tu 
  quieres ejecutar:
    <orderedlist>
   <listitem>
    <para>
     Puedes decir a <literal>PHP</literal> que ejecute ciertos archivos.
    </para>
    <para>
     <screen>
<![CDATA[
php my_script.php

php -f my_script.php
]]>
     </screen>
     En estos dos ejemplos (aunque utilices el switch 
     <literal>-f</literal> o no) ejecutan el archivo 
     <filename>my_script.php</filename>. Tu puedes escoger 
     cualquier archivo para ejecutar - tus programas 
     <literal>PHP</literal> no tienen que terminar con la 
     exenci&oacute;n <filename>.php</filename> y pueden 
     tener cualquier otra exenci&oacute;n tu desees.
    </para>
   </listitem>
   <listitem>
    <para>
     Pasa el c&oacute;digo <literal>PHP</literal> para 
     que sea ejecutado directamente en la l&iacute;nea 
     de comando.
    </para>
    <para>
     <screen>
<![CDATA[
php -r 'print_r(get_defined_constants());'
]]>
     </screen>
     Debes tener cuidado en reguardo a las substituciones 
     variables en tu l&iacute;nea de comando y usando comillas(").
    </para>
    <note>
     <para>
      Deves ponerle atenci&oacute;n al ejemplo, y notaras que 
      no tiene tags ni al principio ni al final, el comando 
      <literal>-r</literal> simplemente no las usa. Usando 
      las tags te dar&aacute; un error cuando trates de ejecutar 
      el programa.
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     Provee el c&oacute;digo <literal>PHP</literal> para 
     ejecutar por medio de <literal>stdin</literal>
    </para>
    <para>
     Esto te da la habilidad de din&aacute;micamente crear 
     c&oacute;digo <literal>PHP</literal> y mandarlo al 
     programa, como por ejemplo a continuaci&oacute;n:    
     <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u >final_output.txt
]]>
     </screen>
    </para>
   </listitem>
  </orderedlist>
  Tu no puedes combinar ninguna de las tres formas de ejecutar el 
  c&oacute;digo.
 </para>
 <para>
  Como cualquier aplicaci&oacute;n ejecutada en la 
  l&iacute;nea de comando, el <literal>PHP</literal> 
  binario acepta un numero de argumentos y tu programa 
  tambi&eacute;n puede recibir argumentos. El numero de 
  argumentos que pueden ser pasados a tu programa no es 
  limitado por <literal>PHP</literal> (la l&iacute;nea 
  de comando tiene limitaciones en el numero de 
  s&iacute;mbolos que pueden ser pasados; usualmente tu 
  nunca alcanzar&iacute;as este limite). Los argumentos 
  pasados a tu programa, est&aacute;n disponibles en tu 
  array global <literal>$argv</literal>. El &iacute;ndex 
  cero ("0") siempre contiene el nombre de tu programa 
  (que es <literal>-</literal> en caso de c&oacute;digo 
  que esta viniendo por medio del input est&aacute;ndar, o 
  del switch en la l&iacute;nea de comando <literal>-r</literal>.
  La segunda variable global registrada es <literal>$argc</literal> 
  y contiene el numero de elementos en el array 
  <literal>$argv</literal> (<emphasis>no</emphasis> 
  el numero de argumentos pasados as programa).

 </para>
 <para>
  Mientras el argumento que tu quieres pasas a tu 
  programa no comienza con <literal>-</literal>, 
  no tienes que esperar por nada especial. Pero si el 
  argumento empieza con <literal>-</literal>, te 
  puede generar problemas, por que <literal>PHP</literal> 
  pensara que tiene que procesarlo. Para prevenir esto, 
  usa la lista separadora de argumentos: <literal>--</literal>. 
  Despu&eacute;s de que el separador a sido procesado, 
  cada siguiente argumento es pasado sin tocar a tu programa. 
 </para>
 <screen>
<![CDATA[
# This will not execute the given code but will show the PHP usage
# Esto no ejecutara el c&oacute;digo pero PHP mostrara el uso
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# This will pass the '-h' argument to your script and prevent PHP from showing it's usage
# passaremos el argumento '-h' a tu programa y prevenira que PHP demuestre su uso 
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
 </screen>
 <para>
  Pero, existe otra manera de usar <literal>PHP</literal> 
  en la l&iacute;nea de comando. Tu puedes escribir un 
  programa donde la primera l&iacute;nea empieza con 
  <literal>#!/usr/bin/php (donde /usr/bin/php es la 
  locaci&oacute;n de php)</literal>. Despu&eacute;s de 
  esto, tu puedes usar <literal>PHP</literal> com&uacute;n y 
  corriente. Una vez que tu le as dado permiso de 
  ejecuci&oacute;n a tu programa (por ejemplo 
  <literal>+x test</literal>) tu programa puede ser 
  ejecutado como si fuera digamos un programa en perl: 

  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
    var_dump($argv);
?>
]]>
  </programlisting>
  Asumiremos que el archivo es llamado 
  <literal>test</literal>, y esta en el mismo 
  directorio en el cual to estas, en ese caso, 
  podemos hacer lo siguiente.
  <screen>
<![CDATA[
$ chmod 755 test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
  </screen>
 Como puedes ver, en este caso no atenci&oacute;n es 
 dada a pasar los par&aacute;metros que comiensen 
 con <literal>-</literal> en tu programa. 
 </para>
 <para>
  <table>
   <title>Opciones en la l&iacute;nea de comando</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Opciones</entry>
      <entry>Descripcion</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-s</entry>
      <entry>
       <para>
        colora el sintaxis de tu c&oacute;digo
       </para>
       <para>
        Esta opci&oacute;n usa un mecanismo interno para 
        ejecutar el archivo, y produce una versi&oacute;n 
        coloreada en <literal>HML</literal> y la escribe como 
        output normal. Nota que todo lo que hace es generar 
        un bloque de <literal>&lt;code&gt; [...] &lt;/code&gt;
        </literal><literal>HTML</literal> tags, no 
        cabecera de<literal>HTML</literal> es creada.
       </para>
       <note>
        <para>
         Esta opci&oacute;n no trabaja en conjunto con 
         <literal>-r</literal>.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-w</entry>
      <entry>
       <para>
        Te mostrara tu c&oacute;digo sin comentarios ni 
        espacios blancos. 
       </para>
       <note>
        <para>
         Esta opci&oacute;n no trabaja en conjunto con 
         <literal>-r</literal>.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>
       <para>
        Ejecuta el archivo indicado en la opci&oacute;n 
        <literal>-f</literal>. Esta opci&oacute;n es 
        opcional y puede ser excluida. Solamente 
        proveiendo el archivo que necesita ser ejecutado 
        es suficiente. 
       </para>
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>
       <para>
        Escribe la version de PHP, PHP SAPI y Zend al output normal, 
        por ejemplo:
        <screen>
<![CDATA[
$ php -v
PHP 4.3.0 (cli), Copyright (c) 1997-2002 The PHP Group
Zend Engine v1.3.0, Copyright (c) 1998-2002 Zend Technologies
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>
       <para>
        Con esta opci&oacute;n uno puede especificar 
        el directorio donde encontraremos el &php.ini; 
        archivo, o tu puedes especificar una versi&oacute;n 
        &uacute;nica del mismo (la cual no tiene que ser 
        llamada &php.ini;), por ejemplo:
        <screen>
<![CDATA[
$ php -c /costumatisado/directorio/ mi_programa.php

$ php -c /customatisado/directorio/customatisado-archivo.ini mi_programa.php
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-a</entry>
      <entry>
       <para>
        Corre PHP interactivamente.
        <!-- 
        mfischer, 20020510: no pudo crear una decente descripci&oacute;n de la implementaci&oacute;n del modo interactivo. 
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>
       <para>
        Esta opci&oacute;n te hayudara a crear el valor de cualquier directiva de configuraci&oacute;n permitidas en el &php.ini; archivo. El sintaxis es:
        <screen>
<![CDATA[
-d directiva__de_configuracion [=valor]
]]>
        </screen>
       </para>
       <para>
        Ejemplos:
        <screen>
<![CDATA[
# Omitting the value part will set the given configuration directive to "1"
# Omitiendo la parte relacionada al valor, le asignara a la directiva de configuracion el valor # "1"
$ php -d max_execution_time -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# Passing an empty value part will set the configuration directive to ""
# Pasando un valor vac&iacute;o, le asignara a la directiva de configuraci&oacute;n el valor ""
php -d max_execution_time= -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# The configuration directive will be set to anything passed after the '=' character
# la directiva de configuraci&oacute;n sera asignada a todo pasada el "=" simbolo
$  php -d max_execution_time=20 -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php -d max_execution_time=doesntmakesense -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-e</entry>
      <entry>
       <para>
        Generando mas informaci&oacute;n para el debugger/profiler.
        <!-- 
        mfischer, 20020510: Anyone who can provide more information what it
        really does (even if it's only for developers) ?
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-z</entry>
      <entry>
       <para>
        Activa las extensiones Zend. Si solamente un archivo es dado,
        <literal>PHP</literal> tratar&aacute; de activar estas
        extensiones directamente desde el directorio predeterminado
        donde est&eacute; la biblioteca en su sistema (Usualmente
        especificado <filename>/etc/ld.so.conf</filename> en
        Linux). Pasando el nombre del archivo con descripci&oacute;n
        absoluta de la ubicaci&oacute;n de sus archivos, no
        usar&aacute; las bibliotecas en su sistema.  Un archivo
        conteniendo la informaci&oacute;n de estos directorios, le
        dira a <literal>PHP</literal> que solamente trate de activar
        las extensiones relativas al directorio donde te encuentras
       </para>
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>
       <para>
        Esta opci&oacute;n proveer&aacute; una forma 
        conveniente para marcar tu sintaxis en tu 
        c&oacute;digo. En caso de suceso, el texto 
        <literal>"No sintax errors detected in &lt;filename&gt;</literal> 
        (no errores de sintaxis fueron detectados) es 
        escrito en tu output normal, y la l&iacute;nea 
        de comando retornara el c&oacute;digo <literal>0</literal>. 
        En caso de problemas, el texto <literal>Errors 
        parsing &lt;filename&gt;</literal>, en adici&oacute;n 
        al la forma interna de detectar errores, mensajes son 
        escritos como output normal y tu l&iacute;nea de 
        comando recibir&aacute; el c&oacute;digo <literal>255</literal> 
       </para>
       <para>
        Esta opci&oacute;n no encontrara errores fatales 
        (como por ejemplo funciones indefinida), usa 
        <literal>-f</literal> si tu quieres probar por esta 
        clase de errores tambi&eacute;n.
       </para>
       <note>
        <para>
         Esta opci&oacute;n no trabaja en conjunci&oacute;n con 
         <literal>-r</literal>
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-m</entry>
      <entry>
       <para>
        Usando esta opci&oacute;n, <literal>PHP</literal> imprime 
        sus m&oacute;dulos internos (y activados) usados por PHP y Zend:
        <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>
       Esta opci&oacute;n llama <literal>phpinfo</literal>, e 
       imprime los resultado. Si <literal>PHP</literal> no esta 
       trabajando correctamente, es recomendable que uses esta 
       opci&oacute;n observes si alg&uacute;n mensaje es imprimido antes 
       de, o en medio de la informaci&oacute;n dada por esta 
       opci&oacute;n. 
       Es un detalle importante que entiendas que el mensaje 
       imprimido es en <literal>HTML</literal> y por esta 
       raz&oacute;n grandecito.
      </entry>
     </row>
     <row>
      <entry>-r</entry>
      <entry>
       <para>
        Esta opci&oacute;n te ayudara a ejecutar 
        <literal>PHP</literal> directamente desde la l&iacute;nea 
        de comando. Las etiquetas que determinas el principio y al 
        final de tu programa (<literal>&lt;?php</literal> y 
        <literal>?&gt;</literal>) <emphasis role="strong">no son 
        necesarias</emphasis> y causaran errores si las pones 
        en tu c&oacute;digo.  
       </para>
       <note>
        <para>
         Debes tener cuidado cuando usando esta forma de 
         <literal>PHP</literal> para que no crees conflicto con 
         la substituci&oacute;n de variables usada por la 
         l&iacute;nea de comando.
        </para>
        <para>
         Ejemplos de errores
         <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
Command line code(1) : Parse error - parse error, unexpected '='
]]>
         </screen>
         El problema aqu&iacute; es que sh/bash esta haciendo 
         una substituci&oacute;n de variables, aunque las comillas 
         (<literal>"</literal>) est&aacute;n presentes. Desde que 
         la variable <literal>$foo</literal> probablemente no esta 
         definida, esta no se inflara en ninguna direcci&oacute;n, 
         el resultado es que el c&oacute;digo pasado a 
         <literal>PHP</literal> para que ejecute realmente lee:
         <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
         </screen>
         La forma correcta de hacer esto, seria usando solamente 
         una comilla (<literal>'</literal>), variables usando 
         solamente una comilla no son infladas por
         sh/bash.
         <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
         </screen>
         Si tu no estas usando sh/bash, tambi&eacute;n puedes 
         encontrar otros problemas. Por favor reporta estos 
         problemas mandando un e-mail a phpdocs@lists.php.net

         Tu tambi&eacute;n puedes tener problemas si tratas de 
         poner variables en tu c&oacute;digo o cuando usas "/" 
         como s&iacute;mbolos de escape. Te hemos advertido <!-- :) -->
        </para>
       </note>
       <note>
        <para>
         <literal>-r</literal> esta listo en <emphasis>CLI</emphasis> 
         SAPI y no en el <emphasis>CGI</emphasis> SAPI.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-h</entry>
      <entry>
       Con esta opci&oacute;n, tu puedes obtener informaci&oacute;n 
       acerca de las opciones describ&iacute;as anteriormente, y una 
       breve descripci&oacute;n acerca de sus funciones. 
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 <!-- NEW DOCUMENTATION ENDS -->

 <!-- OLD DOCUMENTED STARTS
  mfischer, 20020510: I've commented out the start paragraphs of the old
  documentation as it is meant to be replaced by the new one.
 <para>
  The command line options of the PHP executable are useful
  if you would like to debug or test your PHP setup, but they
  can also be handy, if you would like to use PHP for a
  different purpose than web scripting.
 </para>
 <para>
  Note, that you can always direct the output of the PHP
  executable to an external file with the &gt; character,
  so <literal>php -q test.php > test.html</literal> will
  print out the output of <filename>test.php</filename>
  without HTTP headers to the <filename>test.html</filename>
  file in the same directory.
 </para>
 <para>
  You can only use these command line options if you have
  the PHP executable. If you built the server module
  version, and you have no CGI version available on your
  machine, than you have no chance to use these options.
  For Windows users both the PHP executable and the server
  modules are in the binary package, the executable is
  named <filename>php.exe</filename>.
 </para>
 <para>
  This list of command line options is consistent with PHP 4.0.6.
  You can get the actual list and some one line descriptions
  with the <literal>-h</literal> option. The output of
  <literal>php -h</literal> should be something like this:
  <screen>
<![CDATA[
Usage: php [-q] [-h] [-s [-v] [-i] [-f <file>] |  {<file> [args...]}
  -q             Quiet-mode.  Suppress HTTP Header output.
  -s             Display colour syntax highlighted source.
  -f <file>      Parse <file>.  Implies `-q'
  -v             Version number
  -C             Do not chdir to the script's directory
  -c <path>      Look for php.ini file in this directory
  -d foo[=bar]   Define INI entry foo with value 'bar'
  -e             Generate extended information for debugger/profiler
  -z <file>      Load Zend extension <file>.
  -l             Syntax check only (lint)
  -m             Show compiled in modules
  -i             PHP information
  -h             This help
]]>
  </screen>
 </para>
 <para>
  Here we list some of the most important command line options
  with detailed explanations.
 </para>
 <para>
  <table>
   <title>Command line options</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Option</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-q</entry>
      <entry>
       Suppress HTTP headers output. Normally PHP prints out
       HTTP headers for the calling program (ie. webserver)
       to hand on to the browser. When writing command line
       applications these headers are useless.
      </entry>
     </row>
     <row>
      <entry>-s</entry>
      <entry>
       Display the color highlighted source of the file
       given with its name. This is the same as if you were
       printing out the source using the
       <function>highlight_file</function> function in
       a PHP script.
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>
       Parse the file given, and search for syntactical and
       fatal errors. This option implies -q. Use for
       debugging purposes.
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>
       By calling PHP with this option, you can ask
       it to print out its version number, ie: 4.0.6. 
      </entry>
     </row>
     <row>
      <entry>-C</entry>
      <entry>
       Normally PHP changes the working directory to the
       running scripts directory. This makes it possible
       for example, to open files in the same directory,
       with only specifying the name of the file. If you
       would like to disable this directory change, use
       this option.
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>
       Using this option, you can specify an alternative
       &php.ini; path, so PHP will
       search your configurations file in this path
       instead of the default one.
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>
       With this option, you can set individual 
       &php.ini; settings in the
       time of running a script.
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>
       Check the file given for syntax errors. This
       option implies -q. Use for debugging purposes.
       This option won't find fatal errors (like undefined
       functions). Use -f if you would like to test
       for fatal errors too.
      </entry>
     </row>
     <row>
      <entry>-m</entry>
      <entry>
       Using this option, PHP prints out the built in
       (and loaded) PHP and Zend modules, the PHP
       and Zend version numbers, and a short Zend
       copyright notice.
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>
       This command line option calls
       <function>phpinfo</function>, and prints
       out the results. If PHP is not working well,
       it is advisable to make a <literal>php -i</literal>
       and see if any error messages are printed out
       before or in place of the information tables.
      </entry>
     </row>
     <row>
      <entry>-h</entry>
      <entry>
       With this option, you can get information about
       the actual list of command line options and some
       one line descriptions about what they do.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 -->
 <para>
  <literal>PHP</literal> puede ejecutar tus programas 
  absolutamente independiente de tu servidor de p&aacute;ginas 
  de web. Si tu usas Unix, tu puedes a&ntilde;adir una 
  l&iacute;nea especial al principio de tu programa, y 
  hacerlo ejecutable, para que el sistema sepa que programa 
  debe ejecutar tu nueva creaci&oacute;n. Si usas windows, 
  tu puedes asociar tu programa con <literal>php.exe</literal> 
  para que solamente tengas que ejecutarlo como har&iacute;as 
  con otros programas bajo windows, tambi&eacute;n puedes crear 
  un "batch" archivo para ejecutar tu programa por medio de 
  <literal>PHP</literal>. La primera l&iacute;nea que usaste para 
  hacer que tu programa funcione en Unix, no le ara da&ntilde;o a 
  tu programa cuando ejecutad bajo windows, pero de esta manera 
  puedes crear programas que puedes ser usados bajo las dos plataformas. 
  A continuaci&oacute;n te daremos un ejemplo:
 </para>
 <example>
  <title>Programa para correr en la l&iacute;nea do comando (script.php)</title>
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

Este es un programa en php entendido para la l&iacute;nea de 
comando con una opci&oacute;n. 

  Usage:
  <?php echo $argv[0]; ?> <option>

  <option> puede ser cualquier palabra que tu quieras
  imprimir. Con la opci&oacute;n --help, -help -h or -?, tu puedes
  obtener esta informaci&oacute;n

<?php
} else {
    echo $argv[1];
}
?>
]]>
  </programlisting>
 </example>
 <para>
  En el programa anterior, usamos una l&iacute;nea especial 
  como nuestra primera l&iacute;nea, para indicar que archivo 
  deber ser ejecutado por PHP. Nosotros trabajamos con una 
  versi&oacute;n de CLI aqu&iacute;, por eso, no tendremos
  cabeceras de HTTP imprimidas. Hay dos variables que puedes 
  usar cuando escribiendo aplicaciones en la l&iacute;nea de 
  comando en PHP: <varname>$argc</varname> y 
  <varname>$argv</varname>. La primera es el numero de 
  argumentos mas uso (el nombre del programa siendo ejecutado). 
  La segunda es un array conteniendo los argumentos, empezando 
  con el programa nombre, y el numero cero "0" 
  (<varname>$argv[0]</varname>).
 </para>
 <para>
  En el programa anterior chequeamos si hab&iacute;an 
  mas, o menos de dos argumentos. Tambi&eacute;n trata 
  de ver si <literal>--help</literal>, <literal>-help</literal>, 
  <literal>-h</literal> o <literal>-?</literal>,
  son llamados, e imprime el mensaje de ayuda. 
 </para>
 <para> 
  Si tu quieres ejecutar el programa anterior en Unix, 
  tu tienes que hacerlo ejecutable, y simplemente llamado 
  <literal>script.php echo this</literal> o 
  <literal>script.php -h</literal>. En windows,
  tu puedes hacer un batch archivo para alcanzar 
  estos resultados:
 </para>
 <example>
  <title>Archivo batch para ejecutar el programa 
  php (script.bat)</title>
  <programlisting role="winbat">
@c:\php\cli\php.exe script.php %1 %2 %3 %4
  </programlisting>
 </example>
 <para>
  Asumiendo que llamaste el programa 
  descrito anteriormente <filename>script.php
  </filename>, Y que tienes tu CLI 
  <filename>php.exe</filename> en 
  <filename>c:\php\cli\php.ese</filename> este
  archivo batch, lo ejecutara para ti con las 
  funciones a&ntilde;adidas:
   <literal>script.bat echo this</literal> o
  <literal>script.bat -h</literal>.
 </para>
 <para>
  Mira tambi&eacute;n la documentaci&oacute;n de 
  <link linkend="ref.readline">Readline</link> 
  para mas funciones que puedes usar para
  incrementar tus opciones en este sujeto.
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
