 <chapter id="features.http-auth">
  <title>Autentificación HTTP con PHP</title>

  <simpara>
   Las caracteríticas de autentificación HTTP en PHP solo estan
   disponibles cuando se está ejecutando como un módulo en Apache y
   hasta ahora no lo estan en la versión CGI. En un script PHP como
   módulo de Apache, se puede usar la función
   <function>Header</function> para enviar un mensaje de
   "Autentificación requerida" al navegador cliente haciendo que
   muestre una ventana de entrada emergente con nombre de usuario y
   contraseña. Una vez que el usuario ha rellenado el nombre y la
   contraseña, la URL que contiene el script PHP vuelve a ser llamada
   con las variables $PHP_AUTH_USER, $PHP_AUTH_PW y $PHP_AUTH_TYPE
   rellenas con el nombre de usuario, la contraseña y el tipo de
   autentificación respectivamente. Sólo autentificación "Básica"
   esta soportada en este momento. Consulte la función 
   <function>Header</function> para más información.</simpara>       <para>
   Un fragmento de script de ejmplo que fuerce la autentificación del
   cliente en una página sería como el siguiente:
    <example>
    <title>Ejemplo de autentificación HTTP</title>
    <programlisting role="php">
&lt;?php
  if(!isset($PHP_AUTH_USER)) {
    Header(&quot;WWW-Autentificación: Basic realm=\&quot;Mi Reino\&quot;&quot;);
    Header(&quot;HTTP/1.0 401 No autorizado&quot;);     
    echo &quot;Texto a enviar si pulsa el botón Cancelar\n&quot;;   
    exit;
  } else { 
    echo &quot;Hola $PHP_AUTH_USER.&lt;P&gt;&quot;;
    echo &quot;Ha introducido $PHP_AUTH_PW como su contraseña.&lt;P&gt;&quot;;
  } 
  ?>   
  </programlisting>
   </example></para>

  <para>
   En vez de, sencillamente, mostrar $PHP_AUTH_USER y
   $PHP_AUTH_PW, seguramente quiera comprobar la validez del nombre
   de usuario y la contraseña. Tal vez enviando una consulta a una
   base de datos o buscando el usuario en un fichero dbm.</para>

  <para>
   Vigile aquí los navegadores Interner Explorer con bugs. Parecen muy
   quisquillosos con el orden de las cabeceras. Enviar la cabecera
   <emphasis>WWW-Autentificación</emphasis> antes que la cabecera   
   <errorcode>HTTP/1.0 401</errorcode> parece ser el truco por ahora.</para>

  <simpara>
   Para prevenir que alguien escriba un script que revele la
   contraseña de una página que ha sido autentificada a través de
   algún mecanismo externo tradicional, las variables PHP_AUTH no
   serán rellenadas si algún tipo de autentificación externo ha sido
   activado para una página en particular. En este caso, la variable 
   $REMOTE_USER puede ser usada para identificar al usuario
   autentificado externamente.</simpara>

  <simpara>
   Nota, a pesar de todo, lo ya dicho no proteje de que alguien que
   controle una URL no autentificada robe contraseñas de URLs
   autentificadas en el mismo servidor.</simpara>
  
  <simpara>
   Tanto Netscape como Internet Explorer borrarán la caché de la
   ventana de autentificación en el navegador local después de
   recibir una respuesta 401 del servidor. Esto puede usarse, de
   forma efectiva, para "desconectar" a un usuario, forzandole a
   reintroducir su nombre y contraseña. Algunas personas usan esto
   para "hacer caducar" entradas, o para proveer un botón de
   "desconectar".</simpara>

  <simpara></simpara>
   <example>
     <title>Ejemplo de autentificación HTTP forzando una
     reentrada</title>   

     <programlisting role="php">
&lt;?php
  function  authenticate()  {
    Header( &quot;WWW-Autentificación: reino básico='Test Autentificación Sistema '&quot;);
    Header( &quot;HTTP/1.0  401 No autorizado&quot;); 
    echo  &quot;Debe introducir un nombre de usuario y contraseña válidos para acceder a  
    este recurso\n&quot;;
    exit; 
  }

  if(!isset($PHP_AUTH_USER)  ||  ($SeenBefore ==  1  &&  !strcmp($OldAuth,  $PHP_AUTH_USER))  )  {
    authenticate();
  }  
  else  {
    echo  &quot;Bienvenido:  $PHP_AUTH_USER&lt;BR&gt;&quot;;
    echo  &quot;Old:  $OldAuth&quot;;
    echo  &quot;&lt;FORM  ACTION=\&quot;$PHP_SELF\&quot;  METHOD=POST&gt;\n&quot;;
    echo  &quot;&lt;INPUT  TYPE=HIDDEN  NAME=\&quot;SeenBefore\&quot;  VALUE=\&quot;1\&quot;&gt;\n&quot;;
    echo  &quot;&lt;INPUT  TYPE=HIDDEN  NAME=\&quot;OldAuth\&quot;  VALUE=\&quot;$PHP_AUTH_USER\&quot;&gt;\n&quot;;
    echo  &quot;&lt;INPUT  TYPE=Submit  VALUE=\&quot;Re  Authenticate\&quot;&gt;\n&quot;;
    echo  &quot;&lt;/FORM&gt;\n&quot;;

}
?>
   </programlisting>
  </example>
  <simpara>
   Este comportamiento no es requerido por el estándar de autentificación
   básica de HTTP, por lo que nunca debe depender de esto. Pruebas
   con Lynx han demostrado que Lynx no borra las credenciales de 
   autentificación con una respuesta 401 del servidor, por lo que
   pulsando atrás y después adelante abriría el recurso de nuevo 
   (siempre que los requerimientos de contraseña no hayan cambiado). </simpara>
  <simpara>
   Además note que esto no funciona usando el servidor IIS de Microsoft
   y la versión CGI de PHP debido a una limitación del IIS</simpara>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
