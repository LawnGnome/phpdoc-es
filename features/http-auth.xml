 <chapter id="features.http-auth">
  <title>Autentificaci&oacute;n HTTP con PHP</title>

  <simpara>
   Las caracter&iacute;ticas de autentificaci&oacute;n HTTP en PHP solo estan
   disponibles cuando se est&aacute; ejecutando como un m&oacute;dulo en Apache y
   hasta ahora no lo estan en la versi&oacute;n CGI. En un script PHP como
   m&oacute;dulo de Apache, se puede usar la funci&oacute;n
   <function>header</function> para enviar un mensaje de
   "Autentificaci&oacute;n requerida" al navegador cliente haciendo que
   muestre una ventana de entrada emergente con nombre de usuario y
   contrase&ntilde;a. Una vez que el usuario ha rellenado el nombre y la
   contrase&ntilde;a, la URL que contiene el script PHP vuelve a ser llamada
   con las variables $PHP_AUTH_USER, $PHP_AUTH_PW y $PHP_AUTH_TYPE
   rellenas con el nombre de usuario, la contrase&ntilde;a y el tipo de
   autentificaci&oacute;n respectivamente. S&oacute;lo autentificaci&oacute;n "B&aacute;sica"
   esta soportada en este momento. Consulte la funci&oacute;n 
   <function>header</function> para m&aacute;s informaci&oacute;n.</simpara>       <para>
   Un fragmento de script de ejmplo que fuerce la autentificaci&oacute;n del
   cliente en una p&aacute;gina ser&iacute;a como el siguiente:
    <example>
    <title>Ejemplo de autentificaci&oacute;n HTTP</title>
    <programlisting role="php">
&lt;?php
  if(!isset($PHP_AUTH_USER)) {
    Header(&quot;WWW-Autentificaci&oacute;n: Basic realm=\&quot;Mi Reino\&quot;&quot;);
    Header(&quot;HTTP/1.0 401 No autorizado&quot;);     
    echo &quot;Texto a enviar si pulsa el bot&oacute;n Cancelar\n&quot;;   
    exit;
  } else { 
    echo &quot;Hola $PHP_AUTH_USER.&lt;P&gt;&quot;;
    echo &quot;Ha introducido $PHP_AUTH_PW como su contrase&ntilde;a.&lt;P&gt;&quot;;
  } 
  ?>   
  </programlisting>
   </example></para>

  <para>
   En vez de, sencillamente, mostrar $PHP_AUTH_USER y
   $PHP_AUTH_PW, seguramente quiera comprobar la validez del nombre
   de usuario y la contrase&ntilde;a. Tal vez enviando una consulta a una
   base de datos o buscando el usuario en un fichero dbm.</para>

  <para>
   Vigile aqu&iacute; los navegadores Interner Explorer con bugs. Parecen muy
   quisquillosos con el orden de las cabeceras. Enviar la cabecera
   <emphasis>WWW-Autentificaci&oacute;n</emphasis> antes que la cabecera   
   <errorcode>HTTP/1.0 401</errorcode> parece ser el truco por ahora.</para>

  <simpara>
   Para prevenir que alguien escriba un script que revele la
   contrase&ntilde;a de una p&aacute;gina que ha sido autentificada a trav&eacute;s de
   alg&uacute;n mecanismo externo tradicional, las variables PHP_AUTH no
   ser&aacute;n rellenadas si alg&uacute;n tipo de autentificaci&oacute;n externo ha sido
   activado para una p&aacute;gina en particular. En este caso, la variable 
   $REMOTE_USER puede ser usada para identificar al usuario
   autentificado externamente.</simpara>

  <simpara>
   Nota, a pesar de todo, lo ya dicho no proteje de que alguien que
   controle una URL no autentificada robe contrase&ntilde;as de URLs
   autentificadas en el mismo servidor.</simpara>
  
  <simpara>
   Tanto Netscape como Internet Explorer borrar&aacute;n la cach&eacute; de la
   ventana de autentificaci&oacute;n en el navegador local despu&eacute;s de
   recibir una respuesta 401 del servidor. Esto puede usarse, de
   forma efectiva, para "desconectar" a un usuario, forzandole a
   reintroducir su nombre y contrase&ntilde;a. Algunas personas usan esto
   para "hacer caducar" entradas, o para proveer un bot&oacute;n de
   "desconectar".</simpara>

  <simpara></simpara>
   <example>
     <title>Ejemplo de autentificaci&oacute;n HTTP forzando una
     reentrada</title>   

     <programlisting role="php">
&lt;?php
  function authenticate() {
   Header( &quot;WWW-Authenticate: Basic realm=\&quot;Test Autentificaci&oacute;n Sistema\&quot;&quot;);
   Header( &quot;HTTP/1.0 401 No autorizado&quot;);
   echo &quot;Debe introducir un nombre de usuario y contrase&ntilde;a v&aacute;lidos para acceder a 
   este recurso\n&quot;;
   exit; 
  }
 
  if(!isset($PHP_AUTH_USER) || ($SeenBefore == 1 && !strcmp($OldAuth, $PHP_AUTH_USER)) ) {
   authenticate();
  } 
  else {
   echo &quot;Bienvenido: $PHP_AUTH_USER&lt;BR&gt;&quot;;
   echo &quot;Old: $OldAuth&quot;;
   echo &quot;&lt;FORM ACTION=\&quot;$PHP_SELF\&quot; METHOD=POST&gt;\n&quot;;
   echo &quot;&lt;INPUT TYPE=HIDDEN NAME=\&quot;SeenBefore\&quot; VALUE=\&quot;1\&quot;&gt;\n&quot;;
   echo &quot;&lt;INPUT TYPE=HIDDEN NAME=\&quot;OldAuth\&quot; VALUE=\&quot;$PHP_AUTH_USER\&quot;&gt;\n&quot;;
   echo &quot;&lt;INPUT TYPE=Submit VALUE=\&quot;Re Authenticate\&quot;&gt;\n&quot;;
   echo &quot;&lt;/FORM&gt;\n&quot;;
  }
?>
   </programlisting>
  </example>
  <simpara>
   Este comportamiento no es requerido por el est&aacute;ndar de autentificaci&oacute;n
   b&aacute;sica de HTTP, por lo que nunca debe depender de esto. Pruebas
   con Lynx han demostrado que Lynx no borra las credenciales de 
   autentificaci&oacute;n con una respuesta 401 del servidor, por lo que
   pulsando atr&aacute;s y despu&eacute;s adelante abrir&iacute;a el recurso de nuevo 
   (siempre que los requerimientos de contrase&ntilde;a no hayan cambiado). </simpara>
  <simpara>
   Adem&aacute;s note que esto no funciona usando el servidor IIS de Microsoft
   y la versi&oacute;n CGI de PHP debido a una limitaci&oacute;n del IIS</simpara>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
