<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.3 $ -->
<!-- EN-Revision: 1.10 Maintainer: lboshell Status: ready -->
<!-- Author: Wez Furlong <wez@thebrainroom.com>
  Please contact me before making any major amendments to the
  content of this section.  Splitting/Merging are fine if they are
  required for php-doc restructuring purposes - just drop me a line
  if you make a change (so I can update my local copy).
-->

<chapter id="streams">
 <title>API de Secuencia para Autores de Extensiones PHP</title>

 <sect1 id="streams.overview">
  <title>Generalidades</title>
  <para>
   La API de Secuencias de PHP introduce un enfoque unificado a la
   gesti&oacute;n de archivos y sockets en extensiones PHP. Usando una
   API &uacute;nica con funciones est&aacute;ndar para operaciones
   comunes, la API de secuencias le permite a su extensi&oacute;n
   acceder a archivos, sockets, URLs, memoria y objetos definidos
   por-script. Esta es una API extensible de tiempo de
   ejecuci&oacute;n que permite la carga din&aacute;mica de
   m&oacute;dulos (&iexcl;y scripts!) para registrar nuevas
   secuencias.
  </para>
  <para>
   El prop&oacute;sito de la API de secuencias es facilitar la
   apertura de archivos, URLs y otras fuentes de datos secuenciables a
   los desarrolladores, mediante una API unificada que es f&aacute;cil
   de entender. La API se encuentra m&aacute;s o menos basada en la
   familia de funciones ANSI C stdio (con una sem&aacute;ntica
   id&eacute;ntica para la mayor&iacute;a de sus funciones
   principales), as&iacute; que los progamadores de C tendr&aacute;n
   una sensaci&oacute;n de familiaridad con las secuencias.
  </para>
  <para>
   La API de secuencias opera en un par de niveles diferentes: al
   nivel base, la API define objetos php_stream para representar
   fuentes de datos secuenciables. En un nivel ligeramente m&aacute;s
   alto, la API define objetos php_stream_wrapper que "envuelven" la
   API de nivel m&aacute;s bajo para proveer soporte para la
   recuperaci&oacute;n de datos y meta-datos desde URLs. Un
   par&aacute;metro de <literal>contexto</literal> adicional, aceptado
   por la mayor&iacute;a de funciones de creaci&oacute;n de secuencia,
   es pasado al m&eacute;todo <literal>stream_opener</literal> de la
   envoltura para configurar en detalle el comportamiento de la misma.
  </para>
  <para>
   Cualquier secuencia, una vez abierta, puede tener tambi&eacute;n
   cualquier n&uacute;mero de <literal>filtros</literal> aplicados
   sobre ella, los cuales procesan datos en la medida en que
   &eacute;stos son le&iacute;dos desde/escritos hacia la secuencia.
  </para>
  <para>
   Las secuencias pueden ser moldeadas (convertidas) a otros tipos de
   gestores de archivo, de modo que puedan ser usadas con bibliotecas
   externas sin mucho problema. Esto permite que aquellas bibliotecas
   accedan a datos directamente desde fuentes tipo URL. Si su sistema
   tiene la funci&oacute;n <function>fopencookie</function> o
   <function>funopen</function>, &iexcl;puede pasar incluso cualquier
   secuencia PHP a cualquier biblioteca que use stdio ANSI!
  </para>
  <para>
   <note>
    <para>
     Las funciones en este cap&iacute;tulo son para su uso en el
     c&oacute;digo fuente de PHP y no son funciones de PHP. Las
     funciones de secuencias para usuarios pueden encontrarse en la
     <link linkend="ref.stream">Referencia de Secuencias</link>.
    </para>
   </note>
  </para>
 </sect1>

 <sect1 id="streams.basics">
  <title>Conceptos B&aacute;sicos de Secuencias</title>
  <para>
   El uso de secuencias es bastante similar al uso de funciones stdio
   ANSI. La principal diferencia est&aacute; en el modo en que obtiene
   en un principo el gestor de la secuencia. En la mayor&iacute;a de
   casos, usted usar&aacute;
   <function>php_stream_open_wrapper</function> para obtener el gestor
   de secuencia. Esta funci&oacute;n trabaja de forma muy similar a
   fopen, y puede apreciarse en el siguiente ejemplo:
  </para>
  <para>
     <example>
      <title>ejemplo simple de secuencia que despliega la
      p&aacute;gina de inicio de PHP</title>
      <programlisting role="c">
<![CDATA[
php_stream * stream = php_stream_open_wrapper("http://www.php.net", "rb", REPORT_ERRORS, NULL);
if (stream) {
    while(!php_stream_eof(stream)) {
        char buf[1024];
        
        if (php_stream_gets(stream, buf, sizeof(buf))) {
            printf(buf);
        } else {
            break;
        }
    }
    php_stream_close(stream);
}
]]>
      </programlisting>
     </example>
  </para>
  <para>
   La tabla a continuaci&oacute;n muestra los equivalentes de
   Secuencia a las funciones m&aacute;s comunes de stdio ANSI. A menos
   que se note lo contrario, las sem&aacute;nticas de las funciones
   son id&eacute;nticas.
     <table>
      <title>Funciones equivalentes a stdio ANSI en la API de
      Secuencias</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Funci&oacute;n Stdio ANSI</entry>
         <entry>Funci&oacute;n de Secuencias PHP</entry>
         <entry>Notas</entry>
        </row>
       </thead>
       <tbody>

        <row>
         <entry>fopen</entry>
         <entry>php_stream_open_wrapper</entry>
         <entry>Las secuencias incluyen par&aacute;metros
         opcionales</entry>
        </row>

        <row>
         <entry>fclose</entry>
         <entry>php_stream_close</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fgets</entry>
         <entry>php_stream_gets</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fread</entry>
         <entry>php_stream_read</entry>
         <entry>Se asume que el par&aacute;metro nmemb tiene un valor
         de 1, as&iacute; que el prototipo luce m&aacute;s como
         read(2)</entry>
        </row>

        <row>
         <entry>fwrite</entry>
         <entry>php_stream_write</entry>
         <entry>Se asume que el par&aacute;metro nmemb tiene un valor
         de 1, as&iacute; que el prototipo luce m&aacute;s como
         write(2)</entry>
        </row>

        <row>
         <entry>fseek</entry>
         <entry>php_stream_seek</entry>
         <entry></entry>
        </row>

        <row>
         <entry>ftell</entry>
         <entry>php_stream_tell</entry>
         <entry></entry>
        </row>

        <row>
         <entry>rewind</entry>
         <entry>php_stream_rewind</entry>
         <entry></entry>
        </row>

        <row>
         <entry>feof</entry>
         <entry>php_stream_eof</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fgetc</entry>
         <entry>php_stream_getc</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fputc</entry>
         <entry>php_stream_putc</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fflush</entry>
         <entry>php_stream_flush</entry>
         <entry></entry>
        </row>

        <row>
         <entry>puts</entry>
         <entry>php_stream_puts</entry>
         <entry>La misma sem&aacute;ntica que puts, NO fputs</entry>
        </row>

        <row>
         <entry>fstat</entry>
         <entry>php_stream_stat</entry>
         <entry>Las secuencias tienen una estructura stat m&aacute;s
         rica</entry>
        </row>
         
       </tbody>
      </tgroup>
     </table>
   
  </para>
 </sect1>

 <sect1 id="streams.resources">
  <title>Las Secuencias como Recursos</title>
  <para>
   Todas las secuencias son registradas como recursos cuando son
   creadas. Esto asegura que sean limpiadas apropiadamente incluso si
   ocurre un error fatal. Todas las funciones del sistema de archivos
   en PHP operan sobre recursos de secuencia - lo que quiere decir que
   sus extensiones pueden aceptar apuntadores de archivo PHP normales
   como par&aacute;metros tambi&eacute;n, y devolver secuencias desde
   sus funciones. La API de secuencias hace este proceso tan simple
   como es posible:
  </para>
  <para>
     <example>
      <title>C&oacute;mo aceptar una secuencia como
      par&aacute;metro</title>
      <programlisting role="c">
<![CDATA[
PHP_FUNCTION(ejemplo_escribir_hola)
{
    zval *zstream;
    php_stream *stream;
    
    if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &zstream))
        return;
    
    php_stream_from_zval(stream, &zstream);

    /* ahora puede usar la secuencia. Sin embargo, usted no es el
       "duenyo" de la secuencia, lo es el script. Eso quiere decir que
       usted NO DEBE cerrar la secuencia, ya que producira un fallo en
       PHP! */

    php_stream_write(stream, "hola\n");
        
    RETURN_TRUE();
}
]]>
      </programlisting>
     </example>
  </para>
  <para>
     <example>
      <title>C&oacute;mo devolver una secuencia desde una
      funci&oacute;n</title>
      <programlisting role="c">
<![CDATA[
PHP_FUNCTION(ejemplo_abrir_pagina_php)
{
    php_stream *stream;
    
    stream = php_stream_open_wrapper("http://www.php.net", "rb", REPORT_ERRORS, NULL);
    
    php_stream_to_zval(stream, return_value);

    /* despues de este punto, el duenyo de la secuencia es el
       script. Si la cierra ahora, hara que PHP falle! */

}
]]>
      </programlisting>
     </example>
  </para>
  <para>
   Ya que las secuencias son limpiadas autom&aacute;ticamente, es
   tentador pensar que tenemos la oportunidad de ser programadores
   mediocres y no preocuparnos por cerrar las secuencias cuando
   hayamos terminado con ellas. Aunque tal enfoque podr&iacute;a
   funcionar, no es una buena idea por varias razones: las secuencias
   mantienen bloqueos sobre recursos del sistema mientras est&aacute;n
   abiertas, as&iacute; que dejar un archivo abierto despu&eacute;s
   que ha terminado de usarlo puede prevenir que otros procesos tengan
   acceso a los recursos. Si un script maneja un gran n&uacute;mero de
   archivos, el conjunto de los recursos usados, tanto en
   t&eacute;rminos de memoria y el exagerado n&uacute;mero de archivos
   abiertos, puede producir que las peticiones al servidor web
   fallen. Suena mal, &iquest;no es as&iacute;? La API de secuencias
   incluye algo de magia que le ayuda a mantener su c&oacute;digo
   limpio - si una secuencia no es cerrada por su c&oacute;digo cuando
   deber&iacute;a hacerlo, encontrar&aacute; un poco de
   informaci&oacute;n &uacute;til de depuraci&oacute;n en su registro
   de errores del servidor web.
  </para>
  <note>
   <simpara>
    Siempre use una versi&oacute;n de PHP compilada para
    depuraci&oacute;n cuando desarrolle una extensi&oacute;n
    (<option>--enable-debug</option> cuando ejecute configure), ya que
    se ha hecho un gran esfuerzo para advertirle sobre fugas de
    memoria y secuencias.
   </simpara>
  </note>
  <para>
   En algunos casos, es &uacute;til mantener una secuencia abierta
   durante la duraci&oacute;n de una petici&oacute;n, para actuar como
   un registro o rastrear un archivo, por ejemplo. Escribir el
   c&oacute;digo necesario para limpiar de manera segura ese tipo de
   secuencia no es dif&iacute;cil, pero se trata de varias
   l&iacute;neas de c&oacute;digo que no es escrictamente
   necesario. Para evitarse los problemas de escribir aqu&eacute;l
   c&oacute;digo, puede marcar una secuencia para que sea apta para
   una auto-limpieza. Lo que quiere decir esto es que la API de
   secuencias no emitir&aacute; una advertencia cuando sea momento de
   auto-limpiar una secuencia. Para hacer esto, puede usar
   <function>php_stream_auto_cleanup</function>.
  </para>
 </sect1>
</chapter>

&chapters.streams.common;
&chapters.streams.dir;
&chapters.streams.file;
&chapters.streams.socket;
&chapters.streams.structs;
&chapters.streams.constants;

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

